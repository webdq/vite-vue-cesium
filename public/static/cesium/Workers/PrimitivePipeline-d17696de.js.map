{"version":3,"file":"PrimitivePipeline-d17696de.js","sources":["../../../../Source/Core/OffsetGeometryInstanceAttribute.js","../../../../Source/Scene/PrimitivePipeline.js"],"sourcesContent":["import Check from \"./Check.js\";\r\nimport ComponentDatatype from \"./ComponentDatatype.js\";\r\nimport defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\n\r\n/**\r\n * Value and type information for per-instance geometry attribute that determines the geometry instance offset\r\n *\r\n * @alias OffsetGeometryInstanceAttribute\r\n * @constructor\r\n *\r\n * @param {Number} [x=0] The x translation\r\n * @param {Number} [y=0] The y translation\r\n * @param {Number} [z=0] The z translation\r\n *\r\n * @private\r\n *\r\n * @see GeometryInstance\r\n * @see GeometryInstanceAttribute\r\n */\r\nfunction OffsetGeometryInstanceAttribute(x, y, z) {\r\n  x = defaultValue(x, 0);\r\n  y = defaultValue(y, 0);\r\n  z = defaultValue(z, 0);\r\n\r\n  /**\r\n   * The values for the attributes stored in a typed array.\r\n   *\r\n   * @type Float32Array\r\n   */\r\n  this.value = new Float32Array([x, y, z]);\r\n}\r\n\r\nObject.defineProperties(OffsetGeometryInstanceAttribute.prototype, {\r\n  /**\r\n   * The datatype of each component in the attribute, e.g., individual elements in\r\n   * {@link OffsetGeometryInstanceAttribute#value}.\r\n   *\r\n   * @memberof OffsetGeometryInstanceAttribute.prototype\r\n   *\r\n   * @type {ComponentDatatype}\r\n   * @readonly\r\n   *\r\n   * @default {@link ComponentDatatype.FLOAT}\r\n   */\r\n  componentDatatype: {\r\n    get: function () {\r\n      return ComponentDatatype.FLOAT;\r\n    },\r\n  },\r\n\r\n  /**\r\n   * The number of components in the attributes, i.e., {@link OffsetGeometryInstanceAttribute#value}.\r\n   *\r\n   * @memberof OffsetGeometryInstanceAttribute.prototype\r\n   *\r\n   * @type {Number}\r\n   * @readonly\r\n   *\r\n   * @default 3\r\n   */\r\n  componentsPerAttribute: {\r\n    get: function () {\r\n      return 3;\r\n    },\r\n  },\r\n\r\n  /**\r\n   * When <code>true</code> and <code>componentDatatype</code> is an integer format,\r\n   * indicate that the components should be mapped to the range [0, 1] (unsigned)\r\n   * or [-1, 1] (signed) when they are accessed as floating-point for rendering.\r\n   *\r\n   * @memberof OffsetGeometryInstanceAttribute.prototype\r\n   *\r\n   * @type {Boolean}\r\n   * @readonly\r\n   *\r\n   * @default false\r\n   */\r\n  normalize: {\r\n    get: function () {\r\n      return false;\r\n    },\r\n  },\r\n});\r\n\r\n/**\r\n * Creates a new {@link OffsetGeometryInstanceAttribute} instance given the provided an enabled flag and {@link DistanceDisplayCondition}.\r\n *\r\n * @param {Cartesian3} offset The cartesian offset\r\n * @returns {OffsetGeometryInstanceAttribute} The new {@link OffsetGeometryInstanceAttribute} instance.\r\n */\r\nOffsetGeometryInstanceAttribute.fromCartesian3 = function (offset) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"offset\", offset);\r\n  //>>includeEnd('debug');\r\n\r\n  return new OffsetGeometryInstanceAttribute(offset.x, offset.y, offset.z);\r\n};\r\n\r\n/**\r\n * Converts a distance display condition to a typed array that can be used to assign a distance display condition attribute.\r\n *\r\n * @param {Cartesian3} offset The cartesian offset\r\n * @param {Float32Array} [result] The array to store the result in, if undefined a new instance will be created.\r\n * @returns {Float32Array} The modified result parameter or a new instance if result was undefined.\r\n *\r\n * @example\r\n * const attributes = primitive.getGeometryInstanceAttributes('an id');\r\n * attributes.modelMatrix = Cesium.OffsetGeometryInstanceAttribute.toValue(modelMatrix, attributes.modelMatrix);\r\n */\r\nOffsetGeometryInstanceAttribute.toValue = function (offset, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"offset\", offset);\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    result = new Float32Array([offset.x, offset.y, offset.z]);\r\n  }\r\n\r\n  result[0] = offset.x;\r\n  result[1] = offset.y;\r\n  result[2] = offset.z;\r\n  return result;\r\n};\r\nexport default OffsetGeometryInstanceAttribute;\r\n","import BoundingSphere from \"../Core/BoundingSphere.js\";\r\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\r\nimport defaultValue from \"../Core/defaultValue.js\";\r\nimport defined from \"../Core/defined.js\";\r\nimport DeveloperError from \"../Core/DeveloperError.js\";\r\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\r\nimport GeographicProjection from \"../Core/GeographicProjection.js\";\r\nimport Geometry from \"../Core/Geometry.js\";\r\nimport GeometryAttribute from \"../Core/GeometryAttribute.js\";\r\nimport GeometryAttributes from \"../Core/GeometryAttributes.js\";\r\nimport GeometryPipeline from \"../Core/GeometryPipeline.js\";\r\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\r\nimport Matrix4 from \"../Core/Matrix4.js\";\r\nimport OffsetGeometryInstanceAttribute from \"../Core/OffsetGeometryInstanceAttribute.js\";\r\nimport WebMercatorProjection from \"../Core/WebMercatorProjection.js\";\r\n\r\nfunction transformToWorldCoordinates(\r\n  instances,\r\n  primitiveModelMatrix,\r\n  scene3DOnly\r\n) {\r\n  let toWorld = !scene3DOnly;\r\n  const length = instances.length;\r\n  let i;\r\n\r\n  if (!toWorld && length > 1) {\r\n    const modelMatrix = instances[0].modelMatrix;\r\n\r\n    for (i = 1; i < length; ++i) {\r\n      if (!Matrix4.equals(modelMatrix, instances[i].modelMatrix)) {\r\n        toWorld = true;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (toWorld) {\r\n    for (i = 0; i < length; ++i) {\r\n      if (defined(instances[i].geometry)) {\r\n        GeometryPipeline.transformToWorldCoordinates(instances[i]);\r\n      }\r\n    }\r\n  } else {\r\n    // Leave geometry in local coordinate system; auto update model-matrix.\r\n    Matrix4.multiplyTransformation(\r\n      primitiveModelMatrix,\r\n      instances[0].modelMatrix,\r\n      primitiveModelMatrix\r\n    );\r\n  }\r\n}\r\n\r\nfunction addGeometryBatchId(geometry, batchId) {\r\n  const attributes = geometry.attributes;\r\n  const positionAttr = attributes.position;\r\n  const numberOfComponents =\r\n    positionAttr.values.length / positionAttr.componentsPerAttribute;\r\n\r\n  attributes.batchId = new GeometryAttribute({\r\n    componentDatatype: ComponentDatatype.FLOAT,\r\n    componentsPerAttribute: 1,\r\n    values: new Float32Array(numberOfComponents),\r\n  });\r\n\r\n  const values = attributes.batchId.values;\r\n  for (let j = 0; j < numberOfComponents; ++j) {\r\n    values[j] = batchId;\r\n  }\r\n}\r\n\r\nfunction addBatchIds(instances) {\r\n  const length = instances.length;\r\n\r\n  for (let i = 0; i < length; ++i) {\r\n    const instance = instances[i];\r\n    if (defined(instance.geometry)) {\r\n      addGeometryBatchId(instance.geometry, i);\r\n    } else if (\r\n      defined(instance.westHemisphereGeometry) &&\r\n      defined(instance.eastHemisphereGeometry)\r\n    ) {\r\n      addGeometryBatchId(instance.westHemisphereGeometry, i);\r\n      addGeometryBatchId(instance.eastHemisphereGeometry, i);\r\n    }\r\n  }\r\n}\r\n\r\nfunction geometryPipeline(parameters) {\r\n  const instances = parameters.instances;\r\n  const projection = parameters.projection;\r\n  const uintIndexSupport = parameters.elementIndexUintSupported;\r\n  const scene3DOnly = parameters.scene3DOnly;\r\n  const vertexCacheOptimize = parameters.vertexCacheOptimize;\r\n  const compressVertices = parameters.compressVertices;\r\n  const modelMatrix = parameters.modelMatrix;\r\n\r\n  let i;\r\n  let geometry;\r\n  let primitiveType;\r\n  let length = instances.length;\r\n\r\n  for (i = 0; i < length; ++i) {\r\n    if (defined(instances[i].geometry)) {\r\n      primitiveType = instances[i].geometry.primitiveType;\r\n      break;\r\n    }\r\n  }\r\n\r\n  //>>includeStart('debug', pragmas.debug);\r\n  for (i = 1; i < length; ++i) {\r\n    if (\r\n      defined(instances[i].geometry) &&\r\n      instances[i].geometry.primitiveType !== primitiveType\r\n    ) {\r\n      throw new DeveloperError(\r\n        \"All instance geometries must have the same primitiveType.\"\r\n      );\r\n    }\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  // Unify to world coordinates before combining.\r\n  transformToWorldCoordinates(instances, modelMatrix, scene3DOnly);\r\n\r\n  // Clip to IDL\r\n  if (!scene3DOnly) {\r\n    for (i = 0; i < length; ++i) {\r\n      if (defined(instances[i].geometry)) {\r\n        GeometryPipeline.splitLongitude(instances[i]);\r\n      }\r\n    }\r\n  }\r\n\r\n  addBatchIds(instances);\r\n\r\n  // Optimize for vertex shader caches\r\n  if (vertexCacheOptimize) {\r\n    for (i = 0; i < length; ++i) {\r\n      const instance = instances[i];\r\n      if (defined(instance.geometry)) {\r\n        GeometryPipeline.reorderForPostVertexCache(instance.geometry);\r\n        GeometryPipeline.reorderForPreVertexCache(instance.geometry);\r\n      } else if (\r\n        defined(instance.westHemisphereGeometry) &&\r\n        defined(instance.eastHemisphereGeometry)\r\n      ) {\r\n        GeometryPipeline.reorderForPostVertexCache(\r\n          instance.westHemisphereGeometry\r\n        );\r\n        GeometryPipeline.reorderForPreVertexCache(\r\n          instance.westHemisphereGeometry\r\n        );\r\n\r\n        GeometryPipeline.reorderForPostVertexCache(\r\n          instance.eastHemisphereGeometry\r\n        );\r\n        GeometryPipeline.reorderForPreVertexCache(\r\n          instance.eastHemisphereGeometry\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  // Combine into single geometry for better rendering performance.\r\n  let geometries = GeometryPipeline.combineInstances(instances);\r\n\r\n  length = geometries.length;\r\n  for (i = 0; i < length; ++i) {\r\n    geometry = geometries[i];\r\n\r\n    // Split positions for GPU RTE\r\n    const attributes = geometry.attributes;\r\n    if (!scene3DOnly) {\r\n      for (const name in attributes) {\r\n        if (\r\n          attributes.hasOwnProperty(name) &&\r\n          attributes[name].componentDatatype === ComponentDatatype.DOUBLE\r\n        ) {\r\n          const name3D = `${name}3D`;\r\n          const name2D = `${name}2D`;\r\n\r\n          // Compute 2D positions\r\n          GeometryPipeline.projectTo2D(\r\n            geometry,\r\n            name,\r\n            name3D,\r\n            name2D,\r\n            projection\r\n          );\r\n          if (defined(geometry.boundingSphere) && name === \"position\") {\r\n            geometry.boundingSphereCV = BoundingSphere.fromVertices(\r\n              geometry.attributes.position2D.values\r\n            );\r\n          }\r\n\r\n          GeometryPipeline.encodeAttribute(\r\n            geometry,\r\n            name3D,\r\n            `${name3D}High`,\r\n            `${name3D}Low`\r\n          );\r\n          GeometryPipeline.encodeAttribute(\r\n            geometry,\r\n            name2D,\r\n            `${name2D}High`,\r\n            `${name2D}Low`\r\n          );\r\n        }\r\n      }\r\n    } else {\r\n      for (const name in attributes) {\r\n        if (\r\n          attributes.hasOwnProperty(name) &&\r\n          attributes[name].componentDatatype === ComponentDatatype.DOUBLE\r\n        ) {\r\n          GeometryPipeline.encodeAttribute(\r\n            geometry,\r\n            name,\r\n            `${name}3DHigh`,\r\n            `${name}3DLow`\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    // oct encode and pack normals, compress texture coordinates\r\n    if (compressVertices) {\r\n      GeometryPipeline.compressVertices(geometry);\r\n    }\r\n  }\r\n\r\n  if (!uintIndexSupport) {\r\n    // Break into multiple geometries to fit within unsigned short indices if needed\r\n    let splitGeometries = [];\r\n    length = geometries.length;\r\n    for (i = 0; i < length; ++i) {\r\n      geometry = geometries[i];\r\n      splitGeometries = splitGeometries.concat(\r\n        GeometryPipeline.fitToUnsignedShortIndices(geometry)\r\n      );\r\n    }\r\n\r\n    geometries = splitGeometries;\r\n  }\r\n\r\n  return geometries;\r\n}\r\n\r\nfunction createPickOffsets(instances, geometryName, geometries, pickOffsets) {\r\n  let offset;\r\n  let indexCount;\r\n  let geometryIndex;\r\n\r\n  const offsetIndex = pickOffsets.length - 1;\r\n  if (offsetIndex >= 0) {\r\n    const pickOffset = pickOffsets[offsetIndex];\r\n    offset = pickOffset.offset + pickOffset.count;\r\n    geometryIndex = pickOffset.index;\r\n    indexCount = geometries[geometryIndex].indices.length;\r\n  } else {\r\n    offset = 0;\r\n    geometryIndex = 0;\r\n    indexCount = geometries[geometryIndex].indices.length;\r\n  }\r\n\r\n  const length = instances.length;\r\n  for (let i = 0; i < length; ++i) {\r\n    const instance = instances[i];\r\n    const geometry = instance[geometryName];\r\n    if (!defined(geometry)) {\r\n      continue;\r\n    }\r\n\r\n    const count = geometry.indices.length;\r\n\r\n    if (offset + count > indexCount) {\r\n      offset = 0;\r\n      indexCount = geometries[++geometryIndex].indices.length;\r\n    }\r\n\r\n    pickOffsets.push({\r\n      index: geometryIndex,\r\n      offset: offset,\r\n      count: count,\r\n    });\r\n    offset += count;\r\n  }\r\n}\r\n\r\nfunction createInstancePickOffsets(instances, geometries) {\r\n  const pickOffsets = [];\r\n  createPickOffsets(instances, \"geometry\", geometries, pickOffsets);\r\n  createPickOffsets(\r\n    instances,\r\n    \"westHemisphereGeometry\",\r\n    geometries,\r\n    pickOffsets\r\n  );\r\n  createPickOffsets(\r\n    instances,\r\n    \"eastHemisphereGeometry\",\r\n    geometries,\r\n    pickOffsets\r\n  );\r\n  return pickOffsets;\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\nconst PrimitivePipeline = {};\r\n\r\n/**\r\n * @private\r\n */\r\nPrimitivePipeline.combineGeometry = function (parameters) {\r\n  let geometries;\r\n  let attributeLocations;\r\n  const instances = parameters.instances;\r\n  const length = instances.length;\r\n  let pickOffsets;\r\n\r\n  let offsetInstanceExtend;\r\n  let hasOffset = false;\r\n  if (length > 0) {\r\n    geometries = geometryPipeline(parameters);\r\n    if (geometries.length > 0) {\r\n      attributeLocations = GeometryPipeline.createAttributeLocations(\r\n        geometries[0]\r\n      );\r\n      if (parameters.createPickOffsets) {\r\n        pickOffsets = createInstancePickOffsets(instances, geometries);\r\n      }\r\n    }\r\n    if (\r\n      defined(instances[0].attributes) &&\r\n      defined(instances[0].attributes.offset)\r\n    ) {\r\n      offsetInstanceExtend = new Array(length);\r\n      hasOffset = true;\r\n    }\r\n  }\r\n\r\n  const boundingSpheres = new Array(length);\r\n  const boundingSpheresCV = new Array(length);\r\n  for (let i = 0; i < length; ++i) {\r\n    const instance = instances[i];\r\n    const geometry = instance.geometry;\r\n    if (defined(geometry)) {\r\n      boundingSpheres[i] = geometry.boundingSphere;\r\n      boundingSpheresCV[i] = geometry.boundingSphereCV;\r\n      if (hasOffset) {\r\n        offsetInstanceExtend[i] = instance.geometry.offsetAttribute;\r\n      }\r\n    }\r\n\r\n    const eastHemisphereGeometry = instance.eastHemisphereGeometry;\r\n    const westHemisphereGeometry = instance.westHemisphereGeometry;\r\n    if (defined(eastHemisphereGeometry) && defined(westHemisphereGeometry)) {\r\n      if (\r\n        defined(eastHemisphereGeometry.boundingSphere) &&\r\n        defined(westHemisphereGeometry.boundingSphere)\r\n      ) {\r\n        boundingSpheres[i] = BoundingSphere.union(\r\n          eastHemisphereGeometry.boundingSphere,\r\n          westHemisphereGeometry.boundingSphere\r\n        );\r\n      }\r\n      if (\r\n        defined(eastHemisphereGeometry.boundingSphereCV) &&\r\n        defined(westHemisphereGeometry.boundingSphereCV)\r\n      ) {\r\n        boundingSpheresCV[i] = BoundingSphere.union(\r\n          eastHemisphereGeometry.boundingSphereCV,\r\n          westHemisphereGeometry.boundingSphereCV\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  return {\r\n    geometries: geometries,\r\n    modelMatrix: parameters.modelMatrix,\r\n    attributeLocations: attributeLocations,\r\n    pickOffsets: pickOffsets,\r\n    offsetInstanceExtend: offsetInstanceExtend,\r\n    boundingSpheres: boundingSpheres,\r\n    boundingSpheresCV: boundingSpheresCV,\r\n  };\r\n};\r\n\r\nfunction transferGeometry(geometry, transferableObjects) {\r\n  const attributes = geometry.attributes;\r\n  for (const name in attributes) {\r\n    if (attributes.hasOwnProperty(name)) {\r\n      const attribute = attributes[name];\r\n\r\n      if (defined(attribute) && defined(attribute.values)) {\r\n        transferableObjects.push(attribute.values.buffer);\r\n      }\r\n    }\r\n  }\r\n\r\n  if (defined(geometry.indices)) {\r\n    transferableObjects.push(geometry.indices.buffer);\r\n  }\r\n}\r\n\r\nfunction transferGeometries(geometries, transferableObjects) {\r\n  const length = geometries.length;\r\n  for (let i = 0; i < length; ++i) {\r\n    transferGeometry(geometries[i], transferableObjects);\r\n  }\r\n}\r\n\r\n// This function was created by simplifying packCreateGeometryResults into a count-only operation.\r\nfunction countCreateGeometryResults(items) {\r\n  let count = 1;\r\n  const length = items.length;\r\n  for (let i = 0; i < length; i++) {\r\n    const geometry = items[i];\r\n    ++count;\r\n\r\n    if (!defined(geometry)) {\r\n      continue;\r\n    }\r\n\r\n    const attributes = geometry.attributes;\r\n\r\n    count +=\r\n      7 +\r\n      2 * BoundingSphere.packedLength +\r\n      (defined(geometry.indices) ? geometry.indices.length : 0);\r\n\r\n    for (const property in attributes) {\r\n      if (\r\n        attributes.hasOwnProperty(property) &&\r\n        defined(attributes[property])\r\n      ) {\r\n        const attribute = attributes[property];\r\n        count += 5 + attribute.values.length;\r\n      }\r\n    }\r\n  }\r\n\r\n  return count;\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\nPrimitivePipeline.packCreateGeometryResults = function (\r\n  items,\r\n  transferableObjects\r\n) {\r\n  const packedData = new Float64Array(countCreateGeometryResults(items));\r\n  const stringTable = [];\r\n  const stringHash = {};\r\n\r\n  const length = items.length;\r\n  let count = 0;\r\n  packedData[count++] = length;\r\n  for (let i = 0; i < length; i++) {\r\n    const geometry = items[i];\r\n\r\n    const validGeometry = defined(geometry);\r\n    packedData[count++] = validGeometry ? 1.0 : 0.0;\r\n\r\n    if (!validGeometry) {\r\n      continue;\r\n    }\r\n\r\n    packedData[count++] = geometry.primitiveType;\r\n    packedData[count++] = geometry.geometryType;\r\n    packedData[count++] = defaultValue(geometry.offsetAttribute, -1);\r\n\r\n    const validBoundingSphere = defined(geometry.boundingSphere) ? 1.0 : 0.0;\r\n    packedData[count++] = validBoundingSphere;\r\n    if (validBoundingSphere) {\r\n      BoundingSphere.pack(geometry.boundingSphere, packedData, count);\r\n    }\r\n\r\n    count += BoundingSphere.packedLength;\r\n\r\n    const validBoundingSphereCV = defined(geometry.boundingSphereCV)\r\n      ? 1.0\r\n      : 0.0;\r\n    packedData[count++] = validBoundingSphereCV;\r\n    if (validBoundingSphereCV) {\r\n      BoundingSphere.pack(geometry.boundingSphereCV, packedData, count);\r\n    }\r\n\r\n    count += BoundingSphere.packedLength;\r\n\r\n    const attributes = geometry.attributes;\r\n    const attributesToWrite = [];\r\n    for (const property in attributes) {\r\n      if (\r\n        attributes.hasOwnProperty(property) &&\r\n        defined(attributes[property])\r\n      ) {\r\n        attributesToWrite.push(property);\r\n        if (!defined(stringHash[property])) {\r\n          stringHash[property] = stringTable.length;\r\n          stringTable.push(property);\r\n        }\r\n      }\r\n    }\r\n\r\n    packedData[count++] = attributesToWrite.length;\r\n    for (let q = 0; q < attributesToWrite.length; q++) {\r\n      const name = attributesToWrite[q];\r\n      const attribute = attributes[name];\r\n      packedData[count++] = stringHash[name];\r\n      packedData[count++] = attribute.componentDatatype;\r\n      packedData[count++] = attribute.componentsPerAttribute;\r\n      packedData[count++] = attribute.normalize ? 1 : 0;\r\n      packedData[count++] = attribute.values.length;\r\n      packedData.set(attribute.values, count);\r\n      count += attribute.values.length;\r\n    }\r\n\r\n    const indicesLength = defined(geometry.indices)\r\n      ? geometry.indices.length\r\n      : 0;\r\n    packedData[count++] = indicesLength;\r\n\r\n    if (indicesLength > 0) {\r\n      packedData.set(geometry.indices, count);\r\n      count += indicesLength;\r\n    }\r\n  }\r\n\r\n  transferableObjects.push(packedData.buffer);\r\n\r\n  return {\r\n    stringTable: stringTable,\r\n    packedData: packedData,\r\n  };\r\n};\r\n\r\n/**\r\n * @private\r\n */\r\nPrimitivePipeline.unpackCreateGeometryResults = function (\r\n  createGeometryResult\r\n) {\r\n  const stringTable = createGeometryResult.stringTable;\r\n  const packedGeometry = createGeometryResult.packedData;\r\n\r\n  let i;\r\n  const result = new Array(packedGeometry[0]);\r\n  let resultIndex = 0;\r\n\r\n  let packedGeometryIndex = 1;\r\n  while (packedGeometryIndex < packedGeometry.length) {\r\n    const valid = packedGeometry[packedGeometryIndex++] === 1.0;\r\n    if (!valid) {\r\n      result[resultIndex++] = undefined;\r\n      continue;\r\n    }\r\n\r\n    const primitiveType = packedGeometry[packedGeometryIndex++];\r\n    const geometryType = packedGeometry[packedGeometryIndex++];\r\n    let offsetAttribute = packedGeometry[packedGeometryIndex++];\r\n    if (offsetAttribute === -1) {\r\n      offsetAttribute = undefined;\r\n    }\r\n\r\n    let boundingSphere;\r\n    let boundingSphereCV;\r\n\r\n    const validBoundingSphere = packedGeometry[packedGeometryIndex++] === 1.0;\r\n    if (validBoundingSphere) {\r\n      boundingSphere = BoundingSphere.unpack(\r\n        packedGeometry,\r\n        packedGeometryIndex\r\n      );\r\n    }\r\n\r\n    packedGeometryIndex += BoundingSphere.packedLength;\r\n\r\n    const validBoundingSphereCV = packedGeometry[packedGeometryIndex++] === 1.0;\r\n    if (validBoundingSphereCV) {\r\n      boundingSphereCV = BoundingSphere.unpack(\r\n        packedGeometry,\r\n        packedGeometryIndex\r\n      );\r\n    }\r\n\r\n    packedGeometryIndex += BoundingSphere.packedLength;\r\n\r\n    let length;\r\n    let values;\r\n    let componentsPerAttribute;\r\n    const attributes = new GeometryAttributes();\r\n    const numAttributes = packedGeometry[packedGeometryIndex++];\r\n    for (i = 0; i < numAttributes; i++) {\r\n      const name = stringTable[packedGeometry[packedGeometryIndex++]];\r\n      const componentDatatype = packedGeometry[packedGeometryIndex++];\r\n      componentsPerAttribute = packedGeometry[packedGeometryIndex++];\r\n      const normalize = packedGeometry[packedGeometryIndex++] !== 0;\r\n\r\n      length = packedGeometry[packedGeometryIndex++];\r\n      values = ComponentDatatype.createTypedArray(componentDatatype, length);\r\n      for (let valuesIndex = 0; valuesIndex < length; valuesIndex++) {\r\n        values[valuesIndex] = packedGeometry[packedGeometryIndex++];\r\n      }\r\n\r\n      attributes[name] = new GeometryAttribute({\r\n        componentDatatype: componentDatatype,\r\n        componentsPerAttribute: componentsPerAttribute,\r\n        normalize: normalize,\r\n        values: values,\r\n      });\r\n    }\r\n\r\n    let indices;\r\n    length = packedGeometry[packedGeometryIndex++];\r\n\r\n    if (length > 0) {\r\n      const numberOfVertices = values.length / componentsPerAttribute;\r\n      indices = IndexDatatype.createTypedArray(numberOfVertices, length);\r\n      for (i = 0; i < length; i++) {\r\n        indices[i] = packedGeometry[packedGeometryIndex++];\r\n      }\r\n    }\r\n\r\n    result[resultIndex++] = new Geometry({\r\n      primitiveType: primitiveType,\r\n      geometryType: geometryType,\r\n      boundingSphere: boundingSphere,\r\n      boundingSphereCV: boundingSphereCV,\r\n      indices: indices,\r\n      attributes: attributes,\r\n      offsetAttribute: offsetAttribute,\r\n    });\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\nfunction packInstancesForCombine(instances, transferableObjects) {\r\n  const length = instances.length;\r\n  const packedData = new Float64Array(1 + length * 19);\r\n  let count = 0;\r\n  packedData[count++] = length;\r\n  for (let i = 0; i < length; i++) {\r\n    const instance = instances[i];\r\n    Matrix4.pack(instance.modelMatrix, packedData, count);\r\n    count += Matrix4.packedLength;\r\n    if (defined(instance.attributes) && defined(instance.attributes.offset)) {\r\n      const values = instance.attributes.offset.value;\r\n      packedData[count] = values[0];\r\n      packedData[count + 1] = values[1];\r\n      packedData[count + 2] = values[2];\r\n    }\r\n    count += 3;\r\n  }\r\n  transferableObjects.push(packedData.buffer);\r\n\r\n  return packedData;\r\n}\r\n\r\nfunction unpackInstancesForCombine(data) {\r\n  const packedInstances = data;\r\n  const result = new Array(packedInstances[0]);\r\n  let count = 0;\r\n\r\n  let i = 1;\r\n  while (i < packedInstances.length) {\r\n    const modelMatrix = Matrix4.unpack(packedInstances, i);\r\n    let attributes;\r\n    i += Matrix4.packedLength;\r\n    if (defined(packedInstances[i])) {\r\n      attributes = {\r\n        offset: new OffsetGeometryInstanceAttribute(\r\n          packedInstances[i],\r\n          packedInstances[i + 1],\r\n          packedInstances[i + 2]\r\n        ),\r\n      };\r\n    }\r\n    i += 3;\r\n\r\n    result[count++] = {\r\n      modelMatrix: modelMatrix,\r\n      attributes: attributes,\r\n    };\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\nPrimitivePipeline.packCombineGeometryParameters = function (\r\n  parameters,\r\n  transferableObjects\r\n) {\r\n  const createGeometryResults = parameters.createGeometryResults;\r\n  const length = createGeometryResults.length;\r\n\r\n  for (let i = 0; i < length; i++) {\r\n    transferableObjects.push(createGeometryResults[i].packedData.buffer);\r\n  }\r\n\r\n  return {\r\n    createGeometryResults: parameters.createGeometryResults,\r\n    packedInstances: packInstancesForCombine(\r\n      parameters.instances,\r\n      transferableObjects\r\n    ),\r\n    ellipsoid: parameters.ellipsoid,\r\n    isGeographic: parameters.projection instanceof GeographicProjection,\r\n    elementIndexUintSupported: parameters.elementIndexUintSupported,\r\n    scene3DOnly: parameters.scene3DOnly,\r\n    vertexCacheOptimize: parameters.vertexCacheOptimize,\r\n    compressVertices: parameters.compressVertices,\r\n    modelMatrix: parameters.modelMatrix,\r\n    createPickOffsets: parameters.createPickOffsets,\r\n  };\r\n};\r\n\r\n/**\r\n * @private\r\n */\r\nPrimitivePipeline.unpackCombineGeometryParameters = function (\r\n  packedParameters\r\n) {\r\n  const instances = unpackInstancesForCombine(packedParameters.packedInstances);\r\n  const createGeometryResults = packedParameters.createGeometryResults;\r\n  const length = createGeometryResults.length;\r\n  let instanceIndex = 0;\r\n\r\n  for (let resultIndex = 0; resultIndex < length; resultIndex++) {\r\n    const geometries = PrimitivePipeline.unpackCreateGeometryResults(\r\n      createGeometryResults[resultIndex]\r\n    );\r\n    const geometriesLength = geometries.length;\r\n    for (\r\n      let geometryIndex = 0;\r\n      geometryIndex < geometriesLength;\r\n      geometryIndex++\r\n    ) {\r\n      const geometry = geometries[geometryIndex];\r\n      const instance = instances[instanceIndex];\r\n      instance.geometry = geometry;\r\n      ++instanceIndex;\r\n    }\r\n  }\r\n\r\n  const ellipsoid = Ellipsoid.clone(packedParameters.ellipsoid);\r\n  const projection = packedParameters.isGeographic\r\n    ? new GeographicProjection(ellipsoid)\r\n    : new WebMercatorProjection(ellipsoid);\r\n\r\n  return {\r\n    instances: instances,\r\n    ellipsoid: ellipsoid,\r\n    projection: projection,\r\n    elementIndexUintSupported: packedParameters.elementIndexUintSupported,\r\n    scene3DOnly: packedParameters.scene3DOnly,\r\n    vertexCacheOptimize: packedParameters.vertexCacheOptimize,\r\n    compressVertices: packedParameters.compressVertices,\r\n    modelMatrix: Matrix4.clone(packedParameters.modelMatrix),\r\n    createPickOffsets: packedParameters.createPickOffsets,\r\n  };\r\n};\r\n\r\nfunction packBoundingSpheres(boundingSpheres) {\r\n  const length = boundingSpheres.length;\r\n  const bufferLength = 1 + (BoundingSphere.packedLength + 1) * length;\r\n  const buffer = new Float32Array(bufferLength);\r\n\r\n  let bufferIndex = 0;\r\n  buffer[bufferIndex++] = length;\r\n\r\n  for (let i = 0; i < length; ++i) {\r\n    const bs = boundingSpheres[i];\r\n    if (!defined(bs)) {\r\n      buffer[bufferIndex++] = 0.0;\r\n    } else {\r\n      buffer[bufferIndex++] = 1.0;\r\n      BoundingSphere.pack(boundingSpheres[i], buffer, bufferIndex);\r\n    }\r\n    bufferIndex += BoundingSphere.packedLength;\r\n  }\r\n\r\n  return buffer;\r\n}\r\n\r\nfunction unpackBoundingSpheres(buffer) {\r\n  const result = new Array(buffer[0]);\r\n  let count = 0;\r\n\r\n  let i = 1;\r\n  while (i < buffer.length) {\r\n    if (buffer[i++] === 1.0) {\r\n      result[count] = BoundingSphere.unpack(buffer, i);\r\n    }\r\n    ++count;\r\n    i += BoundingSphere.packedLength;\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\nPrimitivePipeline.packCombineGeometryResults = function (\r\n  results,\r\n  transferableObjects\r\n) {\r\n  if (defined(results.geometries)) {\r\n    transferGeometries(results.geometries, transferableObjects);\r\n  }\r\n\r\n  const packedBoundingSpheres = packBoundingSpheres(results.boundingSpheres);\r\n  const packedBoundingSpheresCV = packBoundingSpheres(\r\n    results.boundingSpheresCV\r\n  );\r\n  transferableObjects.push(\r\n    packedBoundingSpheres.buffer,\r\n    packedBoundingSpheresCV.buffer\r\n  );\r\n\r\n  return {\r\n    geometries: results.geometries,\r\n    attributeLocations: results.attributeLocations,\r\n    modelMatrix: results.modelMatrix,\r\n    pickOffsets: results.pickOffsets,\r\n    offsetInstanceExtend: results.offsetInstanceExtend,\r\n    boundingSpheres: packedBoundingSpheres,\r\n    boundingSpheresCV: packedBoundingSpheresCV,\r\n  };\r\n};\r\n\r\n/**\r\n * @private\r\n */\r\nPrimitivePipeline.unpackCombineGeometryResults = function (packedResult) {\r\n  return {\r\n    geometries: packedResult.geometries,\r\n    attributeLocations: packedResult.attributeLocations,\r\n    modelMatrix: packedResult.modelMatrix,\r\n    pickOffsets: packedResult.pickOffsets,\r\n    offsetInstanceExtend: packedResult.offsetInstanceExtend,\r\n    boundingSpheres: unpackBoundingSpheres(packedResult.boundingSpheres),\r\n    boundingSpheresCV: unpackBoundingSpheres(packedResult.boundingSpheresCV),\r\n  };\r\n};\r\nexport default PrimitivePipeline;\r\n"],"names":["OffsetGeometryInstanceAttribute","x","y","z","defaultValue","this","value","Float32Array","addGeometryBatchId","geometry","batchId","attributes","positionAttr","position","numberOfComponents","values","length","componentsPerAttribute","GeometryAttribute","componentDatatype","ComponentDatatype","FLOAT","j","geometryPipeline","parameters","instances","projection","uintIndexSupport","elementIndexUintSupported","scene3DOnly","vertexCacheOptimize","compressVertices","modelMatrix","i","primitiveType","defined","DeveloperError","primitiveModelMatrix","toWorld","Matrix4","equals","GeometryPipeline","transformToWorldCoordinates","multiplyTransformation","splitLongitude","instance","westHemisphereGeometry","eastHemisphereGeometry","addBatchIds","reorderForPostVertexCache","reorderForPreVertexCache","geometries","combineInstances","name","hasOwnProperty","DOUBLE","encodeAttribute","name3D","name2D","projectTo2D","boundingSphere","boundingSphereCV","BoundingSphere","fromVertices","position2D","splitGeometries","concat","fitToUnsignedShortIndices","createPickOffsets","geometryName","pickOffsets","offset","indexCount","geometryIndex","offsetIndex","pickOffset","count","index","indices","push","Object","defineProperties","prototype","get","normalize","fromCartesian3","Check","toValue","result","PrimitivePipeline","transferGeometry","transferableObjects","attribute","buffer","packInstancesForCombine","packedData","Float64Array","pack","packedLength","packBoundingSpheres","boundingSpheres","bufferLength","bufferIndex","bs","unpackBoundingSpheres","Array","unpack","combineGeometry","attributeLocations","offsetInstanceExtend","hasOffset","createAttributeLocations","createInstancePickOffsets","boundingSpheresCV","offsetAttribute","union","packCreateGeometryResults","items","property","countCreateGeometryResults","stringTable","stringHash","validGeometry","geometryType","validBoundingSphere","validBoundingSphereCV","attributesToWrite","q","set","indicesLength","unpackCreateGeometryResults","createGeometryResult","packedGeometry","resultIndex","packedGeometryIndex","undefined","GeometryAttributes","numAttributes","createTypedArray","valuesIndex","numberOfVertices","IndexDatatype","Geometry","packCombineGeometryParameters","createGeometryResults","packedInstances","ellipsoid","isGeographic","GeographicProjection","unpackCombineGeometryParameters","packedParameters","data","unpackInstancesForCombine","instanceIndex","geometriesLength","Ellipsoid","clone","WebMercatorProjection","packCombineGeometryResults","results","transferGeometries","packedBoundingSpheres","packedBoundingSpheresCV","unpackCombineGeometryResults","packedResult"],"mappings":"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"}