{"version":3,"file":"WallGeometryLibrary-2476b7eb.js","sources":["../../../../Source/Core/WallGeometryLibrary.js"],"sourcesContent":["import arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\r\nimport Cartesian3 from \"./Cartesian3.js\";\r\nimport Cartographic from \"./Cartographic.js\";\r\nimport defined from \"./defined.js\";\r\nimport CesiumMath from \"./Math.js\";\r\nimport PolylinePipeline from \"./PolylinePipeline.js\";\r\n\r\n/**\r\n * @private\r\n */\r\nconst WallGeometryLibrary = {};\r\n\r\nfunction latLonEquals(c0, c1) {\r\n  return (\r\n    CesiumMath.equalsEpsilon(c0.latitude, c1.latitude, CesiumMath.EPSILON10) &&\r\n    CesiumMath.equalsEpsilon(c0.longitude, c1.longitude, CesiumMath.EPSILON10)\r\n  );\r\n}\r\n\r\nconst scratchCartographic1 = new Cartographic();\r\nconst scratchCartographic2 = new Cartographic();\r\nfunction removeDuplicates(ellipsoid, positions, topHeights, bottomHeights) {\r\n  positions = arrayRemoveDuplicates(positions, Cartesian3.equalsEpsilon);\r\n\r\n  const length = positions.length;\r\n  if (length < 2) {\r\n    return;\r\n  }\r\n\r\n  const hasBottomHeights = defined(bottomHeights);\r\n  const hasTopHeights = defined(topHeights);\r\n\r\n  const cleanedPositions = new Array(length);\r\n  const cleanedTopHeights = new Array(length);\r\n  const cleanedBottomHeights = new Array(length);\r\n\r\n  const v0 = positions[0];\r\n  cleanedPositions[0] = v0;\r\n\r\n  const c0 = ellipsoid.cartesianToCartographic(v0, scratchCartographic1);\r\n  if (hasTopHeights) {\r\n    c0.height = topHeights[0];\r\n  }\r\n\r\n  cleanedTopHeights[0] = c0.height;\r\n\r\n  if (hasBottomHeights) {\r\n    cleanedBottomHeights[0] = bottomHeights[0];\r\n  } else {\r\n    cleanedBottomHeights[0] = 0.0;\r\n  }\r\n\r\n  const startTopHeight = cleanedTopHeights[0];\r\n  const startBottomHeight = cleanedBottomHeights[0];\r\n  let hasAllSameHeights = startTopHeight === startBottomHeight;\r\n\r\n  let index = 1;\r\n  for (let i = 1; i < length; ++i) {\r\n    const v1 = positions[i];\r\n    const c1 = ellipsoid.cartesianToCartographic(v1, scratchCartographic2);\r\n    if (hasTopHeights) {\r\n      c1.height = topHeights[i];\r\n    }\r\n    hasAllSameHeights = hasAllSameHeights && c1.height === 0;\r\n\r\n    if (!latLonEquals(c0, c1)) {\r\n      cleanedPositions[index] = v1; // Shallow copy!\r\n      cleanedTopHeights[index] = c1.height;\r\n\r\n      if (hasBottomHeights) {\r\n        cleanedBottomHeights[index] = bottomHeights[i];\r\n      } else {\r\n        cleanedBottomHeights[index] = 0.0;\r\n      }\r\n      hasAllSameHeights =\r\n        hasAllSameHeights &&\r\n        cleanedTopHeights[index] === cleanedBottomHeights[index];\r\n\r\n      Cartographic.clone(c1, c0);\r\n      ++index;\r\n    } else if (c0.height < c1.height) {\r\n      // two adjacent positions are the same, so use whichever has the greater height\r\n      cleanedTopHeights[index - 1] = c1.height;\r\n    }\r\n  }\r\n\r\n  if (hasAllSameHeights || index < 2) {\r\n    return;\r\n  }\r\n\r\n  cleanedPositions.length = index;\r\n  cleanedTopHeights.length = index;\r\n  cleanedBottomHeights.length = index;\r\n\r\n  return {\r\n    positions: cleanedPositions,\r\n    topHeights: cleanedTopHeights,\r\n    bottomHeights: cleanedBottomHeights,\r\n  };\r\n}\r\n\r\nconst positionsArrayScratch = new Array(2);\r\nconst heightsArrayScratch = new Array(2);\r\nconst generateArcOptionsScratch = {\r\n  positions: undefined,\r\n  height: undefined,\r\n  granularity: undefined,\r\n  ellipsoid: undefined,\r\n};\r\n\r\n/**\r\n * @private\r\n */\r\nWallGeometryLibrary.computePositions = function (\r\n  ellipsoid,\r\n  wallPositions,\r\n  maximumHeights,\r\n  minimumHeights,\r\n  granularity,\r\n  duplicateCorners\r\n) {\r\n  const o = removeDuplicates(\r\n    ellipsoid,\r\n    wallPositions,\r\n    maximumHeights,\r\n    minimumHeights\r\n  );\r\n\r\n  if (!defined(o)) {\r\n    return;\r\n  }\r\n\r\n  wallPositions = o.positions;\r\n  maximumHeights = o.topHeights;\r\n  minimumHeights = o.bottomHeights;\r\n\r\n  const length = wallPositions.length;\r\n  const numCorners = length - 2;\r\n  let topPositions;\r\n  let bottomPositions;\r\n\r\n  const minDistance = CesiumMath.chordLength(\r\n    granularity,\r\n    ellipsoid.maximumRadius\r\n  );\r\n\r\n  const generateArcOptions = generateArcOptionsScratch;\r\n  generateArcOptions.minDistance = minDistance;\r\n  generateArcOptions.ellipsoid = ellipsoid;\r\n\r\n  if (duplicateCorners) {\r\n    let count = 0;\r\n    let i;\r\n\r\n    for (i = 0; i < length - 1; i++) {\r\n      count +=\r\n        PolylinePipeline.numberOfPoints(\r\n          wallPositions[i],\r\n          wallPositions[i + 1],\r\n          minDistance\r\n        ) + 1;\r\n    }\r\n\r\n    topPositions = new Float64Array(count * 3);\r\n    bottomPositions = new Float64Array(count * 3);\r\n\r\n    const generateArcPositions = positionsArrayScratch;\r\n    const generateArcHeights = heightsArrayScratch;\r\n    generateArcOptions.positions = generateArcPositions;\r\n    generateArcOptions.height = generateArcHeights;\r\n\r\n    let offset = 0;\r\n    for (i = 0; i < length - 1; i++) {\r\n      generateArcPositions[0] = wallPositions[i];\r\n      generateArcPositions[1] = wallPositions[i + 1];\r\n\r\n      generateArcHeights[0] = maximumHeights[i];\r\n      generateArcHeights[1] = maximumHeights[i + 1];\r\n\r\n      const pos = PolylinePipeline.generateArc(generateArcOptions);\r\n      topPositions.set(pos, offset);\r\n\r\n      generateArcHeights[0] = minimumHeights[i];\r\n      generateArcHeights[1] = minimumHeights[i + 1];\r\n\r\n      bottomPositions.set(\r\n        PolylinePipeline.generateArc(generateArcOptions),\r\n        offset\r\n      );\r\n\r\n      offset += pos.length;\r\n    }\r\n  } else {\r\n    generateArcOptions.positions = wallPositions;\r\n    generateArcOptions.height = maximumHeights;\r\n    topPositions = new Float64Array(\r\n      PolylinePipeline.generateArc(generateArcOptions)\r\n    );\r\n\r\n    generateArcOptions.height = minimumHeights;\r\n    bottomPositions = new Float64Array(\r\n      PolylinePipeline.generateArc(generateArcOptions)\r\n    );\r\n  }\r\n\r\n  return {\r\n    bottomPositions: bottomPositions,\r\n    topPositions: topPositions,\r\n    numCorners: numCorners,\r\n  };\r\n};\r\nexport default WallGeometryLibrary;\r\n"],"names":["WallGeometryLibrary","latLonEquals","c0","c1","CesiumMath","equalsEpsilon","latitude","EPSILON10","longitude","scratchCartographic1","Cartographic","scratchCartographic2","positionsArrayScratch","Array","heightsArrayScratch","generateArcOptionsScratch","positions","undefined","height","granularity","ellipsoid","computePositions","wallPositions","maximumHeights","minimumHeights","duplicateCorners","o","topHeights","bottomHeights","length","arrayRemoveDuplicates","Cartesian3","hasBottomHeights","defined","hasTopHeights","cleanedPositions","cleanedTopHeights","cleanedBottomHeights","v0","cartesianToCartographic","hasAllSameHeights","index","i","v1","clone","removeDuplicates","numCorners","topPositions","bottomPositions","minDistance","chordLength","maximumRadius","generateArcOptions","count","PolylinePipeline","numberOfPoints","Float64Array","generateArcPositions","generateArcHeights","offset","pos","generateArc","set"],"mappings":"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"}