{"version":3,"file":"createRectangleGeometry.js","sources":["../../../../Source/Core/RectangleGeometry.js","../../../../Source/WorkersES6/createRectangleGeometry.js"],"sourcesContent":["import arrayFill from \"./arrayFill.js\";\r\nimport BoundingSphere from \"./BoundingSphere.js\";\r\nimport Cartesian2 from \"./Cartesian2.js\";\r\nimport Cartesian3 from \"./Cartesian3.js\";\r\nimport Cartographic from \"./Cartographic.js\";\r\nimport Check from \"./Check.js\";\r\nimport ComponentDatatype from \"./ComponentDatatype.js\";\r\nimport defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\nimport DeveloperError from \"./DeveloperError.js\";\r\nimport Ellipsoid from \"./Ellipsoid.js\";\r\nimport Geometry from \"./Geometry.js\";\r\nimport GeometryAttribute from \"./GeometryAttribute.js\";\r\nimport GeometryAttributes from \"./GeometryAttributes.js\";\r\nimport GeometryInstance from \"./GeometryInstance.js\";\r\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\r\nimport GeometryPipeline from \"./GeometryPipeline.js\";\r\nimport IndexDatatype from \"./IndexDatatype.js\";\r\nimport CesiumMath from \"./Math.js\";\r\nimport Matrix2 from \"./Matrix2.js\";\r\nimport Matrix3 from \"./Matrix3.js\";\r\nimport PolygonPipeline from \"./PolygonPipeline.js\";\r\nimport PrimitiveType from \"./PrimitiveType.js\";\r\nimport Quaternion from \"./Quaternion.js\";\r\nimport Rectangle from \"./Rectangle.js\";\r\nimport RectangleGeometryLibrary from \"./RectangleGeometryLibrary.js\";\r\nimport VertexFormat from \"./VertexFormat.js\";\r\n\r\nconst positionScratch = new Cartesian3();\r\nconst normalScratch = new Cartesian3();\r\nconst tangentScratch = new Cartesian3();\r\nconst bitangentScratch = new Cartesian3();\r\nconst rectangleScratch = new Rectangle();\r\nconst stScratch = new Cartesian2();\r\nconst bottomBoundingSphere = new BoundingSphere();\r\nconst topBoundingSphere = new BoundingSphere();\r\n\r\nfunction createAttributes(vertexFormat, attributes) {\r\n  const geo = new Geometry({\r\n    attributes: new GeometryAttributes(),\r\n    primitiveType: PrimitiveType.TRIANGLES,\r\n  });\r\n\r\n  geo.attributes.position = new GeometryAttribute({\r\n    componentDatatype: ComponentDatatype.DOUBLE,\r\n    componentsPerAttribute: 3,\r\n    values: attributes.positions,\r\n  });\r\n  if (vertexFormat.normal) {\r\n    geo.attributes.normal = new GeometryAttribute({\r\n      componentDatatype: ComponentDatatype.FLOAT,\r\n      componentsPerAttribute: 3,\r\n      values: attributes.normals,\r\n    });\r\n  }\r\n  if (vertexFormat.tangent) {\r\n    geo.attributes.tangent = new GeometryAttribute({\r\n      componentDatatype: ComponentDatatype.FLOAT,\r\n      componentsPerAttribute: 3,\r\n      values: attributes.tangents,\r\n    });\r\n  }\r\n  if (vertexFormat.bitangent) {\r\n    geo.attributes.bitangent = new GeometryAttribute({\r\n      componentDatatype: ComponentDatatype.FLOAT,\r\n      componentsPerAttribute: 3,\r\n      values: attributes.bitangents,\r\n    });\r\n  }\r\n  return geo;\r\n}\r\n\r\nfunction calculateAttributes(\r\n  positions,\r\n  vertexFormat,\r\n  ellipsoid,\r\n  tangentRotationMatrix\r\n) {\r\n  const length = positions.length;\r\n\r\n  const normals = vertexFormat.normal ? new Float32Array(length) : undefined;\r\n  const tangents = vertexFormat.tangent ? new Float32Array(length) : undefined;\r\n  const bitangents = vertexFormat.bitangent\r\n    ? new Float32Array(length)\r\n    : undefined;\r\n\r\n  let attrIndex = 0;\r\n  const bitangent = bitangentScratch;\r\n  const tangent = tangentScratch;\r\n  let normal = normalScratch;\r\n  if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {\r\n    for (let i = 0; i < length; i += 3) {\r\n      const p = Cartesian3.fromArray(positions, i, positionScratch);\r\n      const attrIndex1 = attrIndex + 1;\r\n      const attrIndex2 = attrIndex + 2;\r\n\r\n      normal = ellipsoid.geodeticSurfaceNormal(p, normal);\r\n      if (vertexFormat.tangent || vertexFormat.bitangent) {\r\n        Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent);\r\n        Matrix3.multiplyByVector(tangentRotationMatrix, tangent, tangent);\r\n        Cartesian3.normalize(tangent, tangent);\r\n\r\n        if (vertexFormat.bitangent) {\r\n          Cartesian3.normalize(\r\n            Cartesian3.cross(normal, tangent, bitangent),\r\n            bitangent\r\n          );\r\n        }\r\n      }\r\n\r\n      if (vertexFormat.normal) {\r\n        normals[attrIndex] = normal.x;\r\n        normals[attrIndex1] = normal.y;\r\n        normals[attrIndex2] = normal.z;\r\n      }\r\n      if (vertexFormat.tangent) {\r\n        tangents[attrIndex] = tangent.x;\r\n        tangents[attrIndex1] = tangent.y;\r\n        tangents[attrIndex2] = tangent.z;\r\n      }\r\n      if (vertexFormat.bitangent) {\r\n        bitangents[attrIndex] = bitangent.x;\r\n        bitangents[attrIndex1] = bitangent.y;\r\n        bitangents[attrIndex2] = bitangent.z;\r\n      }\r\n      attrIndex += 3;\r\n    }\r\n  }\r\n  return createAttributes(vertexFormat, {\r\n    positions: positions,\r\n    normals: normals,\r\n    tangents: tangents,\r\n    bitangents: bitangents,\r\n  });\r\n}\r\n\r\nconst v1Scratch = new Cartesian3();\r\nconst v2Scratch = new Cartesian3();\r\n\r\nfunction calculateAttributesWall(positions, vertexFormat, ellipsoid) {\r\n  const length = positions.length;\r\n\r\n  const normals = vertexFormat.normal ? new Float32Array(length) : undefined;\r\n  const tangents = vertexFormat.tangent ? new Float32Array(length) : undefined;\r\n  const bitangents = vertexFormat.bitangent\r\n    ? new Float32Array(length)\r\n    : undefined;\r\n\r\n  let normalIndex = 0;\r\n  let tangentIndex = 0;\r\n  let bitangentIndex = 0;\r\n  let recomputeNormal = true;\r\n\r\n  let bitangent = bitangentScratch;\r\n  let tangent = tangentScratch;\r\n  let normal = normalScratch;\r\n  if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {\r\n    for (let i = 0; i < length; i += 6) {\r\n      const p = Cartesian3.fromArray(positions, i, positionScratch);\r\n      const p1 = Cartesian3.fromArray(positions, (i + 6) % length, v1Scratch);\r\n      if (recomputeNormal) {\r\n        const p2 = Cartesian3.fromArray(positions, (i + 3) % length, v2Scratch);\r\n        Cartesian3.subtract(p1, p, p1);\r\n        Cartesian3.subtract(p2, p, p2);\r\n        normal = Cartesian3.normalize(Cartesian3.cross(p2, p1, normal), normal);\r\n        recomputeNormal = false;\r\n      }\r\n\r\n      if (Cartesian3.equalsEpsilon(p1, p, CesiumMath.EPSILON10)) {\r\n        // if we've reached a corner\r\n        recomputeNormal = true;\r\n      }\r\n\r\n      if (vertexFormat.tangent || vertexFormat.bitangent) {\r\n        bitangent = ellipsoid.geodeticSurfaceNormal(p, bitangent);\r\n        if (vertexFormat.tangent) {\r\n          tangent = Cartesian3.normalize(\r\n            Cartesian3.cross(bitangent, normal, tangent),\r\n            tangent\r\n          );\r\n        }\r\n      }\r\n\r\n      if (vertexFormat.normal) {\r\n        normals[normalIndex++] = normal.x;\r\n        normals[normalIndex++] = normal.y;\r\n        normals[normalIndex++] = normal.z;\r\n        normals[normalIndex++] = normal.x;\r\n        normals[normalIndex++] = normal.y;\r\n        normals[normalIndex++] = normal.z;\r\n      }\r\n\r\n      if (vertexFormat.tangent) {\r\n        tangents[tangentIndex++] = tangent.x;\r\n        tangents[tangentIndex++] = tangent.y;\r\n        tangents[tangentIndex++] = tangent.z;\r\n        tangents[tangentIndex++] = tangent.x;\r\n        tangents[tangentIndex++] = tangent.y;\r\n        tangents[tangentIndex++] = tangent.z;\r\n      }\r\n\r\n      if (vertexFormat.bitangent) {\r\n        bitangents[bitangentIndex++] = bitangent.x;\r\n        bitangents[bitangentIndex++] = bitangent.y;\r\n        bitangents[bitangentIndex++] = bitangent.z;\r\n        bitangents[bitangentIndex++] = bitangent.x;\r\n        bitangents[bitangentIndex++] = bitangent.y;\r\n        bitangents[bitangentIndex++] = bitangent.z;\r\n      }\r\n    }\r\n  }\r\n\r\n  return createAttributes(vertexFormat, {\r\n    positions: positions,\r\n    normals: normals,\r\n    tangents: tangents,\r\n    bitangents: bitangents,\r\n  });\r\n}\r\n\r\nfunction constructRectangle(rectangleGeometry, computedOptions) {\r\n  const vertexFormat = rectangleGeometry._vertexFormat;\r\n  const ellipsoid = rectangleGeometry._ellipsoid;\r\n  const height = computedOptions.height;\r\n  const width = computedOptions.width;\r\n  const northCap = computedOptions.northCap;\r\n  const southCap = computedOptions.southCap;\r\n\r\n  let rowStart = 0;\r\n  let rowEnd = height;\r\n  let rowHeight = height;\r\n  let size = 0;\r\n  if (northCap) {\r\n    rowStart = 1;\r\n    rowHeight -= 1;\r\n    size += 1;\r\n  }\r\n  if (southCap) {\r\n    rowEnd -= 1;\r\n    rowHeight -= 1;\r\n    size += 1;\r\n  }\r\n  size += width * rowHeight;\r\n\r\n  const positions = vertexFormat.position\r\n    ? new Float64Array(size * 3)\r\n    : undefined;\r\n  const textureCoordinates = vertexFormat.st\r\n    ? new Float32Array(size * 2)\r\n    : undefined;\r\n\r\n  let posIndex = 0;\r\n  let stIndex = 0;\r\n\r\n  const position = positionScratch;\r\n  const st = stScratch;\r\n\r\n  let minX = Number.MAX_VALUE;\r\n  let minY = Number.MAX_VALUE;\r\n  let maxX = -Number.MAX_VALUE;\r\n  let maxY = -Number.MAX_VALUE;\r\n\r\n  for (let row = rowStart; row < rowEnd; ++row) {\r\n    for (let col = 0; col < width; ++col) {\r\n      RectangleGeometryLibrary.computePosition(\r\n        computedOptions,\r\n        ellipsoid,\r\n        vertexFormat.st,\r\n        row,\r\n        col,\r\n        position,\r\n        st\r\n      );\r\n\r\n      positions[posIndex++] = position.x;\r\n      positions[posIndex++] = position.y;\r\n      positions[posIndex++] = position.z;\r\n\r\n      if (vertexFormat.st) {\r\n        textureCoordinates[stIndex++] = st.x;\r\n        textureCoordinates[stIndex++] = st.y;\r\n\r\n        minX = Math.min(minX, st.x);\r\n        minY = Math.min(minY, st.y);\r\n        maxX = Math.max(maxX, st.x);\r\n        maxY = Math.max(maxY, st.y);\r\n      }\r\n    }\r\n  }\r\n  if (northCap) {\r\n    RectangleGeometryLibrary.computePosition(\r\n      computedOptions,\r\n      ellipsoid,\r\n      vertexFormat.st,\r\n      0,\r\n      0,\r\n      position,\r\n      st\r\n    );\r\n\r\n    positions[posIndex++] = position.x;\r\n    positions[posIndex++] = position.y;\r\n    positions[posIndex++] = position.z;\r\n\r\n    if (vertexFormat.st) {\r\n      textureCoordinates[stIndex++] = st.x;\r\n      textureCoordinates[stIndex++] = st.y;\r\n\r\n      minX = st.x;\r\n      minY = st.y;\r\n      maxX = st.x;\r\n      maxY = st.y;\r\n    }\r\n  }\r\n  if (southCap) {\r\n    RectangleGeometryLibrary.computePosition(\r\n      computedOptions,\r\n      ellipsoid,\r\n      vertexFormat.st,\r\n      height - 1,\r\n      0,\r\n      position,\r\n      st\r\n    );\r\n\r\n    positions[posIndex++] = position.x;\r\n    positions[posIndex++] = position.y;\r\n    positions[posIndex] = position.z;\r\n\r\n    if (vertexFormat.st) {\r\n      textureCoordinates[stIndex++] = st.x;\r\n      textureCoordinates[stIndex] = st.y;\r\n\r\n      minX = Math.min(minX, st.x);\r\n      minY = Math.min(minY, st.y);\r\n      maxX = Math.max(maxX, st.x);\r\n      maxY = Math.max(maxY, st.y);\r\n    }\r\n  }\r\n\r\n  if (\r\n    vertexFormat.st &&\r\n    (minX < 0.0 || minY < 0.0 || maxX > 1.0 || maxY > 1.0)\r\n  ) {\r\n    for (let k = 0; k < textureCoordinates.length; k += 2) {\r\n      textureCoordinates[k] = (textureCoordinates[k] - minX) / (maxX - minX);\r\n      textureCoordinates[k + 1] =\r\n        (textureCoordinates[k + 1] - minY) / (maxY - minY);\r\n    }\r\n  }\r\n\r\n  const geo = calculateAttributes(\r\n    positions,\r\n    vertexFormat,\r\n    ellipsoid,\r\n    computedOptions.tangentRotationMatrix\r\n  );\r\n\r\n  let indicesSize = 6 * (width - 1) * (rowHeight - 1);\r\n  if (northCap) {\r\n    indicesSize += 3 * (width - 1);\r\n  }\r\n  if (southCap) {\r\n    indicesSize += 3 * (width - 1);\r\n  }\r\n  const indices = IndexDatatype.createTypedArray(size, indicesSize);\r\n  let index = 0;\r\n  let indicesIndex = 0;\r\n  let i;\r\n  for (i = 0; i < rowHeight - 1; ++i) {\r\n    for (let j = 0; j < width - 1; ++j) {\r\n      const upperLeft = index;\r\n      const lowerLeft = upperLeft + width;\r\n      const lowerRight = lowerLeft + 1;\r\n      const upperRight = upperLeft + 1;\r\n      indices[indicesIndex++] = upperLeft;\r\n      indices[indicesIndex++] = lowerLeft;\r\n      indices[indicesIndex++] = upperRight;\r\n      indices[indicesIndex++] = upperRight;\r\n      indices[indicesIndex++] = lowerLeft;\r\n      indices[indicesIndex++] = lowerRight;\r\n      ++index;\r\n    }\r\n    ++index;\r\n  }\r\n  if (northCap || southCap) {\r\n    let northIndex = size - 1;\r\n    const southIndex = size - 1;\r\n    if (northCap && southCap) {\r\n      northIndex = size - 2;\r\n    }\r\n\r\n    let p1;\r\n    let p2;\r\n    index = 0;\r\n\r\n    if (northCap) {\r\n      for (i = 0; i < width - 1; i++) {\r\n        p1 = index;\r\n        p2 = p1 + 1;\r\n        indices[indicesIndex++] = northIndex;\r\n        indices[indicesIndex++] = p1;\r\n        indices[indicesIndex++] = p2;\r\n        ++index;\r\n      }\r\n    }\r\n    if (southCap) {\r\n      index = (rowHeight - 1) * width;\r\n      for (i = 0; i < width - 1; i++) {\r\n        p1 = index;\r\n        p2 = p1 + 1;\r\n        indices[indicesIndex++] = p1;\r\n        indices[indicesIndex++] = southIndex;\r\n        indices[indicesIndex++] = p2;\r\n        ++index;\r\n      }\r\n    }\r\n  }\r\n\r\n  geo.indices = indices;\r\n  if (vertexFormat.st) {\r\n    geo.attributes.st = new GeometryAttribute({\r\n      componentDatatype: ComponentDatatype.FLOAT,\r\n      componentsPerAttribute: 2,\r\n      values: textureCoordinates,\r\n    });\r\n  }\r\n\r\n  return geo;\r\n}\r\n\r\nfunction addWallPositions(\r\n  wallPositions,\r\n  posIndex,\r\n  i,\r\n  topPositions,\r\n  bottomPositions\r\n) {\r\n  wallPositions[posIndex++] = topPositions[i];\r\n  wallPositions[posIndex++] = topPositions[i + 1];\r\n  wallPositions[posIndex++] = topPositions[i + 2];\r\n  wallPositions[posIndex++] = bottomPositions[i];\r\n  wallPositions[posIndex++] = bottomPositions[i + 1];\r\n  wallPositions[posIndex] = bottomPositions[i + 2];\r\n  return wallPositions;\r\n}\r\n\r\nfunction addWallTextureCoordinates(wallTextures, stIndex, i, st) {\r\n  wallTextures[stIndex++] = st[i];\r\n  wallTextures[stIndex++] = st[i + 1];\r\n  wallTextures[stIndex++] = st[i];\r\n  wallTextures[stIndex] = st[i + 1];\r\n  return wallTextures;\r\n}\r\n\r\nconst scratchVertexFormat = new VertexFormat();\r\n\r\nfunction constructExtrudedRectangle(rectangleGeometry, computedOptions) {\r\n  const shadowVolume = rectangleGeometry._shadowVolume;\r\n  const offsetAttributeValue = rectangleGeometry._offsetAttribute;\r\n  const vertexFormat = rectangleGeometry._vertexFormat;\r\n  const minHeight = rectangleGeometry._extrudedHeight;\r\n  const maxHeight = rectangleGeometry._surfaceHeight;\r\n  const ellipsoid = rectangleGeometry._ellipsoid;\r\n\r\n  const height = computedOptions.height;\r\n  const width = computedOptions.width;\r\n\r\n  let i;\r\n\r\n  if (shadowVolume) {\r\n    const newVertexFormat = VertexFormat.clone(\r\n      vertexFormat,\r\n      scratchVertexFormat\r\n    );\r\n    newVertexFormat.normal = true;\r\n    rectangleGeometry._vertexFormat = newVertexFormat;\r\n  }\r\n\r\n  const topBottomGeo = constructRectangle(rectangleGeometry, computedOptions);\r\n\r\n  if (shadowVolume) {\r\n    rectangleGeometry._vertexFormat = vertexFormat;\r\n  }\r\n\r\n  let topPositions = PolygonPipeline.scaleToGeodeticHeight(\r\n    topBottomGeo.attributes.position.values,\r\n    maxHeight,\r\n    ellipsoid,\r\n    false\r\n  );\r\n  topPositions = new Float64Array(topPositions);\r\n  let length = topPositions.length;\r\n  const newLength = length * 2;\r\n  const positions = new Float64Array(newLength);\r\n  positions.set(topPositions);\r\n  const bottomPositions = PolygonPipeline.scaleToGeodeticHeight(\r\n    topBottomGeo.attributes.position.values,\r\n    minHeight,\r\n    ellipsoid\r\n  );\r\n  positions.set(bottomPositions, length);\r\n  topBottomGeo.attributes.position.values = positions;\r\n\r\n  const normals = vertexFormat.normal ? new Float32Array(newLength) : undefined;\r\n  const tangents = vertexFormat.tangent\r\n    ? new Float32Array(newLength)\r\n    : undefined;\r\n  const bitangents = vertexFormat.bitangent\r\n    ? new Float32Array(newLength)\r\n    : undefined;\r\n  const textures = vertexFormat.st\r\n    ? new Float32Array((newLength / 3) * 2)\r\n    : undefined;\r\n  let topSt;\r\n  let topNormals;\r\n  if (vertexFormat.normal) {\r\n    topNormals = topBottomGeo.attributes.normal.values;\r\n    normals.set(topNormals);\r\n    for (i = 0; i < length; i++) {\r\n      topNormals[i] = -topNormals[i];\r\n    }\r\n    normals.set(topNormals, length);\r\n    topBottomGeo.attributes.normal.values = normals;\r\n  }\r\n  if (shadowVolume) {\r\n    topNormals = topBottomGeo.attributes.normal.values;\r\n    if (!vertexFormat.normal) {\r\n      topBottomGeo.attributes.normal = undefined;\r\n    }\r\n    const extrudeNormals = new Float32Array(newLength);\r\n    for (i = 0; i < length; i++) {\r\n      topNormals[i] = -topNormals[i];\r\n    }\r\n    extrudeNormals.set(topNormals, length); //only get normals for bottom layer that's going to be pushed down\r\n    topBottomGeo.attributes.extrudeDirection = new GeometryAttribute({\r\n      componentDatatype: ComponentDatatype.FLOAT,\r\n      componentsPerAttribute: 3,\r\n      values: extrudeNormals,\r\n    });\r\n  }\r\n\r\n  let offsetValue;\r\n  const hasOffsets = defined(offsetAttributeValue);\r\n  if (hasOffsets) {\r\n    const size = (length / 3) * 2;\r\n    let offsetAttribute = new Uint8Array(size);\r\n    if (offsetAttributeValue === GeometryOffsetAttribute.TOP) {\r\n      offsetAttribute = arrayFill(offsetAttribute, 1, 0, size / 2);\r\n    } else {\r\n      offsetValue =\r\n        offsetAttributeValue === GeometryOffsetAttribute.NONE ? 0 : 1;\r\n      offsetAttribute = arrayFill(offsetAttribute, offsetValue);\r\n    }\r\n\r\n    topBottomGeo.attributes.applyOffset = new GeometryAttribute({\r\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\r\n      componentsPerAttribute: 1,\r\n      values: offsetAttribute,\r\n    });\r\n  }\r\n\r\n  if (vertexFormat.tangent) {\r\n    const topTangents = topBottomGeo.attributes.tangent.values;\r\n    tangents.set(topTangents);\r\n    for (i = 0; i < length; i++) {\r\n      topTangents[i] = -topTangents[i];\r\n    }\r\n    tangents.set(topTangents, length);\r\n    topBottomGeo.attributes.tangent.values = tangents;\r\n  }\r\n  if (vertexFormat.bitangent) {\r\n    const topBitangents = topBottomGeo.attributes.bitangent.values;\r\n    bitangents.set(topBitangents);\r\n    bitangents.set(topBitangents, length);\r\n    topBottomGeo.attributes.bitangent.values = bitangents;\r\n  }\r\n  if (vertexFormat.st) {\r\n    topSt = topBottomGeo.attributes.st.values;\r\n    textures.set(topSt);\r\n    textures.set(topSt, (length / 3) * 2);\r\n    topBottomGeo.attributes.st.values = textures;\r\n  }\r\n\r\n  const indices = topBottomGeo.indices;\r\n  const indicesLength = indices.length;\r\n  const posLength = length / 3;\r\n  const newIndices = IndexDatatype.createTypedArray(\r\n    newLength / 3,\r\n    indicesLength * 2\r\n  );\r\n  newIndices.set(indices);\r\n  for (i = 0; i < indicesLength; i += 3) {\r\n    newIndices[i + indicesLength] = indices[i + 2] + posLength;\r\n    newIndices[i + 1 + indicesLength] = indices[i + 1] + posLength;\r\n    newIndices[i + 2 + indicesLength] = indices[i] + posLength;\r\n  }\r\n  topBottomGeo.indices = newIndices;\r\n\r\n  const northCap = computedOptions.northCap;\r\n  const southCap = computedOptions.southCap;\r\n\r\n  let rowHeight = height;\r\n  let widthMultiplier = 2;\r\n  let perimeterPositions = 0;\r\n  let corners = 4;\r\n  let dupliateCorners = 4;\r\n  if (northCap) {\r\n    widthMultiplier -= 1;\r\n    rowHeight -= 1;\r\n    perimeterPositions += 1;\r\n    corners -= 2;\r\n    dupliateCorners -= 1;\r\n  }\r\n  if (southCap) {\r\n    widthMultiplier -= 1;\r\n    rowHeight -= 1;\r\n    perimeterPositions += 1;\r\n    corners -= 2;\r\n    dupliateCorners -= 1;\r\n  }\r\n  perimeterPositions += widthMultiplier * width + 2 * rowHeight - corners;\r\n\r\n  const wallCount = (perimeterPositions + dupliateCorners) * 2;\r\n\r\n  let wallPositions = new Float64Array(wallCount * 3);\r\n  const wallExtrudeNormals = shadowVolume\r\n    ? new Float32Array(wallCount * 3)\r\n    : undefined;\r\n  let wallOffsetAttribute = hasOffsets ? new Uint8Array(wallCount) : undefined;\r\n  let wallTextures = vertexFormat.st\r\n    ? new Float32Array(wallCount * 2)\r\n    : undefined;\r\n\r\n  const computeTopOffsets =\r\n    offsetAttributeValue === GeometryOffsetAttribute.TOP;\r\n  if (hasOffsets && !computeTopOffsets) {\r\n    offsetValue = offsetAttributeValue === GeometryOffsetAttribute.ALL ? 1 : 0;\r\n    wallOffsetAttribute = arrayFill(wallOffsetAttribute, offsetValue);\r\n  }\r\n\r\n  let posIndex = 0;\r\n  let stIndex = 0;\r\n  let extrudeNormalIndex = 0;\r\n  let wallOffsetIndex = 0;\r\n  const area = width * rowHeight;\r\n  let threeI;\r\n  for (i = 0; i < area; i += width) {\r\n    threeI = i * 3;\r\n    wallPositions = addWallPositions(\r\n      wallPositions,\r\n      posIndex,\r\n      threeI,\r\n      topPositions,\r\n      bottomPositions\r\n    );\r\n    posIndex += 6;\r\n    if (vertexFormat.st) {\r\n      wallTextures = addWallTextureCoordinates(\r\n        wallTextures,\r\n        stIndex,\r\n        i * 2,\r\n        topSt\r\n      );\r\n      stIndex += 4;\r\n    }\r\n    if (shadowVolume) {\r\n      extrudeNormalIndex += 3;\r\n      wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\r\n      wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\r\n      wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\r\n    }\r\n    if (computeTopOffsets) {\r\n      wallOffsetAttribute[wallOffsetIndex++] = 1;\r\n      wallOffsetIndex += 1;\r\n    }\r\n  }\r\n\r\n  if (!southCap) {\r\n    for (i = area - width; i < area; i++) {\r\n      threeI = i * 3;\r\n      wallPositions = addWallPositions(\r\n        wallPositions,\r\n        posIndex,\r\n        threeI,\r\n        topPositions,\r\n        bottomPositions\r\n      );\r\n      posIndex += 6;\r\n      if (vertexFormat.st) {\r\n        wallTextures = addWallTextureCoordinates(\r\n          wallTextures,\r\n          stIndex,\r\n          i * 2,\r\n          topSt\r\n        );\r\n        stIndex += 4;\r\n      }\r\n      if (shadowVolume) {\r\n        extrudeNormalIndex += 3;\r\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\r\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\r\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\r\n      }\r\n      if (computeTopOffsets) {\r\n        wallOffsetAttribute[wallOffsetIndex++] = 1;\r\n        wallOffsetIndex += 1;\r\n      }\r\n    }\r\n  } else {\r\n    const southIndex = northCap ? area + 1 : area;\r\n    threeI = southIndex * 3;\r\n\r\n    for (i = 0; i < 2; i++) {\r\n      // duplicate corner points\r\n      wallPositions = addWallPositions(\r\n        wallPositions,\r\n        posIndex,\r\n        threeI,\r\n        topPositions,\r\n        bottomPositions\r\n      );\r\n      posIndex += 6;\r\n      if (vertexFormat.st) {\r\n        wallTextures = addWallTextureCoordinates(\r\n          wallTextures,\r\n          stIndex,\r\n          southIndex * 2,\r\n          topSt\r\n        );\r\n        stIndex += 4;\r\n      }\r\n      if (shadowVolume) {\r\n        extrudeNormalIndex += 3;\r\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\r\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\r\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\r\n      }\r\n      if (computeTopOffsets) {\r\n        wallOffsetAttribute[wallOffsetIndex++] = 1;\r\n        wallOffsetIndex += 1;\r\n      }\r\n    }\r\n  }\r\n\r\n  for (i = area - 1; i > 0; i -= width) {\r\n    threeI = i * 3;\r\n    wallPositions = addWallPositions(\r\n      wallPositions,\r\n      posIndex,\r\n      threeI,\r\n      topPositions,\r\n      bottomPositions\r\n    );\r\n    posIndex += 6;\r\n    if (vertexFormat.st) {\r\n      wallTextures = addWallTextureCoordinates(\r\n        wallTextures,\r\n        stIndex,\r\n        i * 2,\r\n        topSt\r\n      );\r\n      stIndex += 4;\r\n    }\r\n    if (shadowVolume) {\r\n      extrudeNormalIndex += 3;\r\n      wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\r\n      wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\r\n      wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\r\n    }\r\n    if (computeTopOffsets) {\r\n      wallOffsetAttribute[wallOffsetIndex++] = 1;\r\n      wallOffsetIndex += 1;\r\n    }\r\n  }\r\n\r\n  if (!northCap) {\r\n    for (i = width - 1; i >= 0; i--) {\r\n      threeI = i * 3;\r\n      wallPositions = addWallPositions(\r\n        wallPositions,\r\n        posIndex,\r\n        threeI,\r\n        topPositions,\r\n        bottomPositions\r\n      );\r\n      posIndex += 6;\r\n      if (vertexFormat.st) {\r\n        wallTextures = addWallTextureCoordinates(\r\n          wallTextures,\r\n          stIndex,\r\n          i * 2,\r\n          topSt\r\n        );\r\n        stIndex += 4;\r\n      }\r\n      if (shadowVolume) {\r\n        extrudeNormalIndex += 3;\r\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\r\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\r\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\r\n      }\r\n      if (computeTopOffsets) {\r\n        wallOffsetAttribute[wallOffsetIndex++] = 1;\r\n        wallOffsetIndex += 1;\r\n      }\r\n    }\r\n  } else {\r\n    const northIndex = area;\r\n    threeI = northIndex * 3;\r\n\r\n    for (i = 0; i < 2; i++) {\r\n      // duplicate corner points\r\n      wallPositions = addWallPositions(\r\n        wallPositions,\r\n        posIndex,\r\n        threeI,\r\n        topPositions,\r\n        bottomPositions\r\n      );\r\n      posIndex += 6;\r\n      if (vertexFormat.st) {\r\n        wallTextures = addWallTextureCoordinates(\r\n          wallTextures,\r\n          stIndex,\r\n          northIndex * 2,\r\n          topSt\r\n        );\r\n        stIndex += 4;\r\n      }\r\n      if (shadowVolume) {\r\n        extrudeNormalIndex += 3;\r\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\r\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\r\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\r\n      }\r\n      if (computeTopOffsets) {\r\n        wallOffsetAttribute[wallOffsetIndex++] = 1;\r\n        wallOffsetIndex += 1;\r\n      }\r\n    }\r\n  }\r\n\r\n  let geo = calculateAttributesWall(wallPositions, vertexFormat, ellipsoid);\r\n\r\n  if (vertexFormat.st) {\r\n    geo.attributes.st = new GeometryAttribute({\r\n      componentDatatype: ComponentDatatype.FLOAT,\r\n      componentsPerAttribute: 2,\r\n      values: wallTextures,\r\n    });\r\n  }\r\n  if (shadowVolume) {\r\n    geo.attributes.extrudeDirection = new GeometryAttribute({\r\n      componentDatatype: ComponentDatatype.FLOAT,\r\n      componentsPerAttribute: 3,\r\n      values: wallExtrudeNormals,\r\n    });\r\n  }\r\n  if (hasOffsets) {\r\n    geo.attributes.applyOffset = new GeometryAttribute({\r\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\r\n      componentsPerAttribute: 1,\r\n      values: wallOffsetAttribute,\r\n    });\r\n  }\r\n\r\n  const wallIndices = IndexDatatype.createTypedArray(\r\n    wallCount,\r\n    perimeterPositions * 6\r\n  );\r\n\r\n  let upperLeft;\r\n  let lowerLeft;\r\n  let lowerRight;\r\n  let upperRight;\r\n  length = wallPositions.length / 3;\r\n  let index = 0;\r\n  for (i = 0; i < length - 1; i += 2) {\r\n    upperLeft = i;\r\n    upperRight = (upperLeft + 2) % length;\r\n    const p1 = Cartesian3.fromArray(wallPositions, upperLeft * 3, v1Scratch);\r\n    const p2 = Cartesian3.fromArray(wallPositions, upperRight * 3, v2Scratch);\r\n    if (Cartesian3.equalsEpsilon(p1, p2, CesiumMath.EPSILON10)) {\r\n      continue;\r\n    }\r\n    lowerLeft = (upperLeft + 1) % length;\r\n    lowerRight = (lowerLeft + 2) % length;\r\n    wallIndices[index++] = upperLeft;\r\n    wallIndices[index++] = lowerLeft;\r\n    wallIndices[index++] = upperRight;\r\n    wallIndices[index++] = upperRight;\r\n    wallIndices[index++] = lowerLeft;\r\n    wallIndices[index++] = lowerRight;\r\n  }\r\n\r\n  geo.indices = wallIndices;\r\n\r\n  geo = GeometryPipeline.combineInstances([\r\n    new GeometryInstance({\r\n      geometry: topBottomGeo,\r\n    }),\r\n    new GeometryInstance({\r\n      geometry: geo,\r\n    }),\r\n  ]);\r\n\r\n  return geo[0];\r\n}\r\n\r\nconst scratchRectanglePoints = [\r\n  new Cartesian3(),\r\n  new Cartesian3(),\r\n  new Cartesian3(),\r\n  new Cartesian3(),\r\n];\r\nconst nwScratch = new Cartographic();\r\nconst stNwScratch = new Cartographic();\r\nfunction computeRectangle(rectangle, granularity, rotation, ellipsoid, result) {\r\n  if (rotation === 0.0) {\r\n    return Rectangle.clone(rectangle, result);\r\n  }\r\n\r\n  const computedOptions = RectangleGeometryLibrary.computeOptions(\r\n    rectangle,\r\n    granularity,\r\n    rotation,\r\n    0,\r\n    rectangleScratch,\r\n    nwScratch\r\n  );\r\n\r\n  const height = computedOptions.height;\r\n  const width = computedOptions.width;\r\n\r\n  const positions = scratchRectanglePoints;\r\n  RectangleGeometryLibrary.computePosition(\r\n    computedOptions,\r\n    ellipsoid,\r\n    false,\r\n    0,\r\n    0,\r\n    positions[0]\r\n  );\r\n  RectangleGeometryLibrary.computePosition(\r\n    computedOptions,\r\n    ellipsoid,\r\n    false,\r\n    0,\r\n    width - 1,\r\n    positions[1]\r\n  );\r\n  RectangleGeometryLibrary.computePosition(\r\n    computedOptions,\r\n    ellipsoid,\r\n    false,\r\n    height - 1,\r\n    0,\r\n    positions[2]\r\n  );\r\n  RectangleGeometryLibrary.computePosition(\r\n    computedOptions,\r\n    ellipsoid,\r\n    false,\r\n    height - 1,\r\n    width - 1,\r\n    positions[3]\r\n  );\r\n\r\n  return Rectangle.fromCartesianArray(positions, ellipsoid, result);\r\n}\r\n\r\n/**\r\n * A description of a cartographic rectangle on an ellipsoid centered at the origin. Rectangle geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\r\n *\r\n * @alias RectangleGeometry\r\n * @constructor\r\n *\r\n * @param {Object} options Object with the following properties:\r\n * @param {Rectangle} options.rectangle A cartographic rectangle with north, south, east and west properties in radians.\r\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\r\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the rectangle lies.\r\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\r\n * @param {Number} [options.height=0.0] The distance in meters between the rectangle and the ellipsoid surface.\r\n * @param {Number} [options.rotation=0.0] The rotation of the rectangle, in radians. A positive rotation is counter-clockwise.\r\n * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\r\n * @param {Number} [options.extrudedHeight] The distance in meters between the rectangle's extruded face and the ellipsoid surface.\r\n *\r\n * @exception {DeveloperError} <code>options.rectangle.north</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\r\n * @exception {DeveloperError} <code>options.rectangle.south</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\r\n * @exception {DeveloperError} <code>options.rectangle.east</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\r\n * @exception {DeveloperError} <code>options.rectangle.west</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\r\n * @exception {DeveloperError} <code>options.rectangle.north</code> must be greater than <code>options.rectangle.south</code>.\r\n *\r\n * @see RectangleGeometry#createGeometry\r\n *\r\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Rectangle.html|Cesium Sandcastle Rectangle Demo}\r\n *\r\n * @example\r\n * // 1. create a rectangle\r\n * const rectangle = new Cesium.RectangleGeometry({\r\n *   ellipsoid : Cesium.Ellipsoid.WGS84,\r\n *   rectangle : Cesium.Rectangle.fromDegrees(-80.0, 39.0, -74.0, 42.0),\r\n *   height : 10000.0\r\n * });\r\n * const geometry = Cesium.RectangleGeometry.createGeometry(rectangle);\r\n *\r\n * // 2. create an extruded rectangle without a top\r\n * const rectangle = new Cesium.RectangleGeometry({\r\n *   ellipsoid : Cesium.Ellipsoid.WGS84,\r\n *   rectangle : Cesium.Rectangle.fromDegrees(-80.0, 39.0, -74.0, 42.0),\r\n *   height : 10000.0,\r\n *   extrudedHeight: 300000\r\n * });\r\n * const geometry = Cesium.RectangleGeometry.createGeometry(rectangle);\r\n */\r\nfunction RectangleGeometry(options) {\r\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n\r\n  const rectangle = options.rectangle;\r\n\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"rectangle\", rectangle);\r\n  Rectangle.validate(rectangle);\r\n  if (rectangle.north < rectangle.south) {\r\n    throw new DeveloperError(\r\n      \"options.rectangle.north must be greater than or equal to options.rectangle.south\"\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const height = defaultValue(options.height, 0.0);\r\n  const extrudedHeight = defaultValue(options.extrudedHeight, height);\r\n\r\n  this._rectangle = Rectangle.clone(rectangle);\r\n  this._granularity = defaultValue(\r\n    options.granularity,\r\n    CesiumMath.RADIANS_PER_DEGREE\r\n  );\r\n  this._ellipsoid = Ellipsoid.clone(\r\n    defaultValue(options.ellipsoid, Ellipsoid.WGS84)\r\n  );\r\n  this._surfaceHeight = Math.max(height, extrudedHeight);\r\n  this._rotation = defaultValue(options.rotation, 0.0);\r\n  this._stRotation = defaultValue(options.stRotation, 0.0);\r\n  this._vertexFormat = VertexFormat.clone(\r\n    defaultValue(options.vertexFormat, VertexFormat.DEFAULT)\r\n  );\r\n  this._extrudedHeight = Math.min(height, extrudedHeight);\r\n  this._shadowVolume = defaultValue(options.shadowVolume, false);\r\n  this._workerName = \"createRectangleGeometry\";\r\n  this._offsetAttribute = options.offsetAttribute;\r\n  this._rotatedRectangle = undefined;\r\n\r\n  this._textureCoordinateRotationPoints = undefined;\r\n}\r\n\r\n/**\r\n * The number of elements used to pack the object into an array.\r\n * @type {Number}\r\n */\r\nRectangleGeometry.packedLength =\r\n  Rectangle.packedLength +\r\n  Ellipsoid.packedLength +\r\n  VertexFormat.packedLength +\r\n  7;\r\n\r\n/**\r\n * Stores the provided instance into the provided array.\r\n *\r\n * @param {RectangleGeometry} value The value to pack.\r\n * @param {Number[]} array The array to pack into.\r\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n *\r\n * @returns {Number[]} The array that was packed into\r\n */\r\nRectangleGeometry.pack = function (value, array, startingIndex) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"value\", value);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  Rectangle.pack(value._rectangle, array, startingIndex);\r\n  startingIndex += Rectangle.packedLength;\r\n\r\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\r\n  startingIndex += Ellipsoid.packedLength;\r\n\r\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\r\n  startingIndex += VertexFormat.packedLength;\r\n\r\n  array[startingIndex++] = value._granularity;\r\n  array[startingIndex++] = value._surfaceHeight;\r\n  array[startingIndex++] = value._rotation;\r\n  array[startingIndex++] = value._stRotation;\r\n  array[startingIndex++] = value._extrudedHeight;\r\n  array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;\r\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\r\n\r\n  return array;\r\n};\r\n\r\nconst scratchRectangle = new Rectangle();\r\nconst scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\r\nconst scratchOptions = {\r\n  rectangle: scratchRectangle,\r\n  ellipsoid: scratchEllipsoid,\r\n  vertexFormat: scratchVertexFormat,\r\n  granularity: undefined,\r\n  height: undefined,\r\n  rotation: undefined,\r\n  stRotation: undefined,\r\n  extrudedHeight: undefined,\r\n  shadowVolume: undefined,\r\n  offsetAttribute: undefined,\r\n};\r\n\r\n/**\r\n * Retrieves an instance from a packed array.\r\n *\r\n * @param {Number[]} array The packed array.\r\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n * @param {RectangleGeometry} [result] The object into which to store the result.\r\n * @returns {RectangleGeometry} The modified result parameter or a new RectangleGeometry instance if one was not provided.\r\n */\r\nRectangleGeometry.unpack = function (array, startingIndex, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  const rectangle = Rectangle.unpack(array, startingIndex, scratchRectangle);\r\n  startingIndex += Rectangle.packedLength;\r\n\r\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\r\n  startingIndex += Ellipsoid.packedLength;\r\n\r\n  const vertexFormat = VertexFormat.unpack(\r\n    array,\r\n    startingIndex,\r\n    scratchVertexFormat\r\n  );\r\n  startingIndex += VertexFormat.packedLength;\r\n\r\n  const granularity = array[startingIndex++];\r\n  const surfaceHeight = array[startingIndex++];\r\n  const rotation = array[startingIndex++];\r\n  const stRotation = array[startingIndex++];\r\n  const extrudedHeight = array[startingIndex++];\r\n  const shadowVolume = array[startingIndex++] === 1.0;\r\n  const offsetAttribute = array[startingIndex];\r\n\r\n  if (!defined(result)) {\r\n    scratchOptions.granularity = granularity;\r\n    scratchOptions.height = surfaceHeight;\r\n    scratchOptions.rotation = rotation;\r\n    scratchOptions.stRotation = stRotation;\r\n    scratchOptions.extrudedHeight = extrudedHeight;\r\n    scratchOptions.shadowVolume = shadowVolume;\r\n    scratchOptions.offsetAttribute =\r\n      offsetAttribute === -1 ? undefined : offsetAttribute;\r\n\r\n    return new RectangleGeometry(scratchOptions);\r\n  }\r\n\r\n  result._rectangle = Rectangle.clone(rectangle, result._rectangle);\r\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\r\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\r\n  result._granularity = granularity;\r\n  result._surfaceHeight = surfaceHeight;\r\n  result._rotation = rotation;\r\n  result._stRotation = stRotation;\r\n  result._extrudedHeight = extrudedHeight;\r\n  result._shadowVolume = shadowVolume;\r\n  result._offsetAttribute =\r\n    offsetAttribute === -1 ? undefined : offsetAttribute;\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the bounding rectangle based on the provided options\r\n *\r\n * @param {Object} options Object with the following properties:\r\n * @param {Rectangle} options.rectangle A cartographic rectangle with north, south, east and west properties in radians.\r\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the rectangle lies.\r\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\r\n * @param {Number} [options.rotation=0.0] The rotation of the rectangle, in radians. A positive rotation is counter-clockwise.\r\n * @param {Rectangle} [result] An object in which to store the result.\r\n *\r\n * @returns {Rectangle} The result rectangle\r\n */\r\nRectangleGeometry.computeRectangle = function (options, result) {\r\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n\r\n  const rectangle = options.rectangle;\r\n\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"rectangle\", rectangle);\r\n  Rectangle.validate(rectangle);\r\n  if (rectangle.north < rectangle.south) {\r\n    throw new DeveloperError(\r\n      \"options.rectangle.north must be greater than or equal to options.rectangle.south\"\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const granularity = defaultValue(\r\n    options.granularity,\r\n    CesiumMath.RADIANS_PER_DEGREE\r\n  );\r\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\r\n  const rotation = defaultValue(options.rotation, 0.0);\r\n\r\n  return computeRectangle(rectangle, granularity, rotation, ellipsoid, result);\r\n};\r\n\r\nconst tangentRotationMatrixScratch = new Matrix3();\r\nconst quaternionScratch = new Quaternion();\r\nconst centerScratch = new Cartographic();\r\n/**\r\n * Computes the geometric representation of a rectangle, including its vertices, indices, and a bounding sphere.\r\n *\r\n * @param {RectangleGeometry} rectangleGeometry A description of the rectangle.\r\n * @returns {Geometry|undefined} The computed vertices and indices.\r\n *\r\n * @exception {DeveloperError} Rotated rectangle is invalid.\r\n */\r\nRectangleGeometry.createGeometry = function (rectangleGeometry) {\r\n  if (\r\n    CesiumMath.equalsEpsilon(\r\n      rectangleGeometry._rectangle.north,\r\n      rectangleGeometry._rectangle.south,\r\n      CesiumMath.EPSILON10\r\n    ) ||\r\n    CesiumMath.equalsEpsilon(\r\n      rectangleGeometry._rectangle.east,\r\n      rectangleGeometry._rectangle.west,\r\n      CesiumMath.EPSILON10\r\n    )\r\n  ) {\r\n    return undefined;\r\n  }\r\n\r\n  let rectangle = rectangleGeometry._rectangle;\r\n  const ellipsoid = rectangleGeometry._ellipsoid;\r\n  const rotation = rectangleGeometry._rotation;\r\n  const stRotation = rectangleGeometry._stRotation;\r\n  const vertexFormat = rectangleGeometry._vertexFormat;\r\n\r\n  const computedOptions = RectangleGeometryLibrary.computeOptions(\r\n    rectangle,\r\n    rectangleGeometry._granularity,\r\n    rotation,\r\n    stRotation,\r\n    rectangleScratch,\r\n    nwScratch,\r\n    stNwScratch\r\n  );\r\n\r\n  const tangentRotationMatrix = tangentRotationMatrixScratch;\r\n  if (stRotation !== 0 || rotation !== 0) {\r\n    const center = Rectangle.center(rectangle, centerScratch);\r\n    const axis = ellipsoid.geodeticSurfaceNormalCartographic(center, v1Scratch);\r\n    Quaternion.fromAxisAngle(axis, -stRotation, quaternionScratch);\r\n    Matrix3.fromQuaternion(quaternionScratch, tangentRotationMatrix);\r\n  } else {\r\n    Matrix3.clone(Matrix3.IDENTITY, tangentRotationMatrix);\r\n  }\r\n\r\n  const surfaceHeight = rectangleGeometry._surfaceHeight;\r\n  const extrudedHeight = rectangleGeometry._extrudedHeight;\r\n  const extrude = !CesiumMath.equalsEpsilon(\r\n    surfaceHeight,\r\n    extrudedHeight,\r\n    0,\r\n    CesiumMath.EPSILON2\r\n  );\r\n\r\n  computedOptions.lonScalar = 1.0 / rectangleGeometry._rectangle.width;\r\n  computedOptions.latScalar = 1.0 / rectangleGeometry._rectangle.height;\r\n  computedOptions.tangentRotationMatrix = tangentRotationMatrix;\r\n\r\n  let geometry;\r\n  let boundingSphere;\r\n  rectangle = rectangleGeometry._rectangle;\r\n  if (extrude) {\r\n    geometry = constructExtrudedRectangle(rectangleGeometry, computedOptions);\r\n    const topBS = BoundingSphere.fromRectangle3D(\r\n      rectangle,\r\n      ellipsoid,\r\n      surfaceHeight,\r\n      topBoundingSphere\r\n    );\r\n    const bottomBS = BoundingSphere.fromRectangle3D(\r\n      rectangle,\r\n      ellipsoid,\r\n      extrudedHeight,\r\n      bottomBoundingSphere\r\n    );\r\n    boundingSphere = BoundingSphere.union(topBS, bottomBS);\r\n  } else {\r\n    geometry = constructRectangle(rectangleGeometry, computedOptions);\r\n    geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(\r\n      geometry.attributes.position.values,\r\n      surfaceHeight,\r\n      ellipsoid,\r\n      false\r\n    );\r\n\r\n    if (defined(rectangleGeometry._offsetAttribute)) {\r\n      const length = geometry.attributes.position.values.length;\r\n      const applyOffset = new Uint8Array(length / 3);\r\n      const offsetValue =\r\n        rectangleGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\r\n          ? 0\r\n          : 1;\r\n      arrayFill(applyOffset, offsetValue);\r\n      geometry.attributes.applyOffset = new GeometryAttribute({\r\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\r\n        componentsPerAttribute: 1,\r\n        values: applyOffset,\r\n      });\r\n    }\r\n\r\n    boundingSphere = BoundingSphere.fromRectangle3D(\r\n      rectangle,\r\n      ellipsoid,\r\n      surfaceHeight\r\n    );\r\n  }\r\n\r\n  if (!vertexFormat.position) {\r\n    delete geometry.attributes.position;\r\n  }\r\n\r\n  return new Geometry({\r\n    attributes: geometry.attributes,\r\n    indices: geometry.indices,\r\n    primitiveType: geometry.primitiveType,\r\n    boundingSphere: boundingSphere,\r\n    offsetAttribute: rectangleGeometry._offsetAttribute,\r\n  });\r\n};\r\n\r\n/**\r\n * @private\r\n */\r\nRectangleGeometry.createShadowVolume = function (\r\n  rectangleGeometry,\r\n  minHeightFunc,\r\n  maxHeightFunc\r\n) {\r\n  const granularity = rectangleGeometry._granularity;\r\n  const ellipsoid = rectangleGeometry._ellipsoid;\r\n\r\n  const minHeight = minHeightFunc(granularity, ellipsoid);\r\n  const maxHeight = maxHeightFunc(granularity, ellipsoid);\r\n\r\n  return new RectangleGeometry({\r\n    rectangle: rectangleGeometry._rectangle,\r\n    rotation: rectangleGeometry._rotation,\r\n    ellipsoid: ellipsoid,\r\n    stRotation: rectangleGeometry._stRotation,\r\n    granularity: granularity,\r\n    extrudedHeight: maxHeight,\r\n    height: minHeight,\r\n    vertexFormat: VertexFormat.POSITION_ONLY,\r\n    shadowVolume: true,\r\n  });\r\n};\r\n\r\nconst unrotatedTextureRectangleScratch = new Rectangle();\r\nconst points2DScratch = [new Cartesian2(), new Cartesian2(), new Cartesian2()];\r\nconst rotation2DScratch = new Matrix2();\r\nconst rectangleCenterScratch = new Cartographic();\r\n\r\nfunction textureCoordinateRotationPoints(rectangleGeometry) {\r\n  if (rectangleGeometry._stRotation === 0.0) {\r\n    return [0, 0, 0, 1, 1, 0];\r\n  }\r\n\r\n  const rectangle = Rectangle.clone(\r\n    rectangleGeometry._rectangle,\r\n    unrotatedTextureRectangleScratch\r\n  );\r\n  const granularity = rectangleGeometry._granularity;\r\n  const ellipsoid = rectangleGeometry._ellipsoid;\r\n\r\n  // Rotate to align the texture coordinates with ENU\r\n  const rotation = rectangleGeometry._rotation - rectangleGeometry._stRotation;\r\n\r\n  const unrotatedTextureRectangle = computeRectangle(\r\n    rectangle,\r\n    granularity,\r\n    rotation,\r\n    ellipsoid,\r\n    unrotatedTextureRectangleScratch\r\n  );\r\n\r\n  // Assume a computed \"east-north\" texture coordinate system based on spherical or planar tricks, bounded by `boundingRectangle`.\r\n  // The \"desired\" texture coordinate system forms an oriented rectangle (un-oriented computed) around the geometry that completely and tightly bounds it.\r\n  // We want to map from the \"east-north\" texture coordinate system into the \"desired\" system using a pair of lines (analagous planes in 2D)\r\n  // Compute 3 corners of the \"desired\" texture coordinate system in \"east-north\" texture space by the following in cartographic space:\r\n  // - rotate 3 of the corners in unrotatedTextureRectangle by stRotation around the center of the bounding rectangle\r\n  // - apply the \"east-north\" system's normalization formula to the rotated cartographics, even though this is likely to produce values outside [0-1].\r\n  // This gives us a set of points in the \"east-north\" texture coordinate system that can be used to map \"east-north\" texture coordinates to \"desired.\"\r\n\r\n  const points2D = points2DScratch;\r\n  points2D[0].x = unrotatedTextureRectangle.west;\r\n  points2D[0].y = unrotatedTextureRectangle.south;\r\n\r\n  points2D[1].x = unrotatedTextureRectangle.west;\r\n  points2D[1].y = unrotatedTextureRectangle.north;\r\n\r\n  points2D[2].x = unrotatedTextureRectangle.east;\r\n  points2D[2].y = unrotatedTextureRectangle.south;\r\n\r\n  const boundingRectangle = rectangleGeometry.rectangle;\r\n  const toDesiredInComputed = Matrix2.fromRotation(\r\n    rectangleGeometry._stRotation,\r\n    rotation2DScratch\r\n  );\r\n  const boundingRectangleCenter = Rectangle.center(\r\n    boundingRectangle,\r\n    rectangleCenterScratch\r\n  );\r\n\r\n  for (let i = 0; i < 3; ++i) {\r\n    const point2D = points2D[i];\r\n    point2D.x -= boundingRectangleCenter.longitude;\r\n    point2D.y -= boundingRectangleCenter.latitude;\r\n    Matrix2.multiplyByVector(toDesiredInComputed, point2D, point2D);\r\n    point2D.x += boundingRectangleCenter.longitude;\r\n    point2D.y += boundingRectangleCenter.latitude;\r\n\r\n    // Convert point into east-north texture coordinate space\r\n    point2D.x = (point2D.x - boundingRectangle.west) / boundingRectangle.width;\r\n    point2D.y =\r\n      (point2D.y - boundingRectangle.south) / boundingRectangle.height;\r\n  }\r\n\r\n  const minXYCorner = points2D[0];\r\n  const maxYCorner = points2D[1];\r\n  const maxXCorner = points2D[2];\r\n  const result = new Array(6);\r\n  Cartesian2.pack(minXYCorner, result);\r\n  Cartesian2.pack(maxYCorner, result, 2);\r\n  Cartesian2.pack(maxXCorner, result, 4);\r\n  return result;\r\n}\r\n\r\nObject.defineProperties(RectangleGeometry.prototype, {\r\n  /**\r\n   * @private\r\n   */\r\n  rectangle: {\r\n    get: function () {\r\n      if (!defined(this._rotatedRectangle)) {\r\n        this._rotatedRectangle = computeRectangle(\r\n          this._rectangle,\r\n          this._granularity,\r\n          this._rotation,\r\n          this._ellipsoid\r\n        );\r\n      }\r\n      return this._rotatedRectangle;\r\n    },\r\n  },\r\n  /**\r\n   * For remapping texture coordinates when rendering RectangleGeometries as GroundPrimitives.\r\n   * This version permits skew in textures by computing offsets directly in cartographic space and\r\n   * more accurately approximates rendering RectangleGeometries with height as standard Primitives.\r\n   * @see Geometry#_textureCoordinateRotationPoints\r\n   * @private\r\n   */\r\n  textureCoordinateRotationPoints: {\r\n    get: function () {\r\n      if (!defined(this._textureCoordinateRotationPoints)) {\r\n        this._textureCoordinateRotationPoints = textureCoordinateRotationPoints(\r\n          this\r\n        );\r\n      }\r\n      return this._textureCoordinateRotationPoints;\r\n    },\r\n  },\r\n});\r\nexport default RectangleGeometry;\r\n","import defined from \"../Core/defined.js\";\r\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\r\nimport Rectangle from \"../Core/Rectangle.js\";\r\nimport RectangleGeometry from \"../Core/RectangleGeometry.js\";\r\n\r\nfunction createRectangleGeometry(rectangleGeometry, offset) {\r\n  if (defined(offset)) {\r\n    rectangleGeometry = RectangleGeometry.unpack(rectangleGeometry, offset);\r\n  }\r\n  rectangleGeometry._ellipsoid = Ellipsoid.clone(rectangleGeometry._ellipsoid);\r\n  rectangleGeometry._rectangle = Rectangle.clone(rectangleGeometry._rectangle);\r\n  return RectangleGeometry.createGeometry(rectangleGeometry);\r\n}\r\nexport default createRectangleGeometry;\r\n"],"names":["positionScratch","Cartesian3","normalScratch","tangentScratch","bitangentScratch","rectangleScratch","Rectangle","stScratch","Cartesian2","bottomBoundingSphere","BoundingSphere","topBoundingSphere","createAttributes","vertexFormat","attributes","geo","Geometry","GeometryAttributes","primitiveType","PrimitiveType","TRIANGLES","position","GeometryAttribute","componentDatatype","ComponentDatatype","DOUBLE","componentsPerAttribute","values","positions","normal","FLOAT","normals","tangent","tangents","bitangent","bitangents","v1Scratch","v2Scratch","constructRectangle","rectangleGeometry","computedOptions","_vertexFormat","ellipsoid","_ellipsoid","height","width","northCap","southCap","rowStart","rowEnd","rowHeight","size","Float64Array","undefined","textureCoordinates","st","Float32Array","posIndex","stIndex","minX","Number","MAX_VALUE","minY","maxX","maxY","row","col","RectangleGeometryLibrary","computePosition","x","y","z","Math","min","max","k","length","tangentRotationMatrix","attrIndex","i","p","fromArray","attrIndex1","attrIndex2","geodeticSurfaceNormal","cross","UNIT_Z","Matrix3","multiplyByVector","normalize","calculateAttributes","indicesSize","indices","IndexDatatype","createTypedArray","index","indicesIndex","j","upperLeft","lowerLeft","lowerRight","upperRight","northIndex","southIndex","p1","p2","addWallPositions","wallPositions","topPositions","bottomPositions","addWallTextureCoordinates","wallTextures","scratchVertexFormat","VertexFormat","constructExtrudedRectangle","shadowVolume","_shadowVolume","offsetAttributeValue","_offsetAttribute","minHeight","_extrudedHeight","maxHeight","_surfaceHeight","newVertexFormat","clone","topBottomGeo","PolygonPipeline","scaleToGeodeticHeight","newLength","set","textures","topSt","topNormals","offsetValue","extrudeNormals","extrudeDirection","hasOffsets","defined","offsetAttribute","Uint8Array","GeometryOffsetAttribute","TOP","arrayFill","NONE","applyOffset","UNSIGNED_BYTE","topTangents","topBitangents","indicesLength","posLength","newIndices","widthMultiplier","perimeterPositions","corners","dupliateCorners","wallCount","wallExtrudeNormals","wallOffsetAttribute","computeTopOffsets","ALL","extrudeNormalIndex","wallOffsetIndex","area","threeI","normalIndex","tangentIndex","bitangentIndex","recomputeNormal","subtract","equalsEpsilon","CesiumMath","EPSILON10","calculateAttributesWall","wallIndices","GeometryPipeline","combineInstances","GeometryInstance","geometry","scratchRectanglePoints","nwScratch","Cartographic","stNwScratch","computeRectangle","rectangle","granularity","rotation","result","computeOptions","fromCartesianArray","RectangleGeometry","options","defaultValue","EMPTY_OBJECT","Check","typeOf","object","validate","north","south","DeveloperError","extrudedHeight","this","_rectangle","_granularity","RADIANS_PER_DEGREE","Ellipsoid","WGS84","_rotation","_stRotation","stRotation","DEFAULT","_workerName","_rotatedRectangle","_textureCoordinateRotationPoints","packedLength","pack","value","array","startingIndex","scratchRectangle","scratchEllipsoid","UNIT_SPHERE","scratchOptions","unpack","surfaceHeight","tangentRotationMatrixScratch","quaternionScratch","Quaternion","centerScratch","createGeometry","east","west","center","axis","geodeticSurfaceNormalCartographic","fromAxisAngle","fromQuaternion","IDENTITY","extrude","EPSILON2","boundingSphere","lonScalar","latScalar","topBS","fromRectangle3D","bottomBS","union","createShadowVolume","minHeightFunc","maxHeightFunc","POSITION_ONLY","unrotatedTextureRectangleScratch","points2DScratch","rotation2DScratch","Matrix2","rectangleCenterScratch","Object","defineProperties","prototype","get","textureCoordinateRotationPoints","unrotatedTextureRectangle","points2D","boundingRectangle","toDesiredInComputed","fromRotation","boundingRectangleCenter","point2D","longitude","latitude","minXYCorner","maxYCorner","maxXCorner","Array","offset"],"mappings":"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"}