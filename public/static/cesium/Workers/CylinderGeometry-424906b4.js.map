{"version":3,"file":"CylinderGeometry-424906b4.js","sources":["../../../../Source/Core/CylinderGeometry.js"],"sourcesContent":["import arrayFill from \"./arrayFill.js\";\r\nimport BoundingSphere from \"./BoundingSphere.js\";\r\nimport Cartesian2 from \"./Cartesian2.js\";\r\nimport Cartesian3 from \"./Cartesian3.js\";\r\nimport ComponentDatatype from \"./ComponentDatatype.js\";\r\nimport CylinderGeometryLibrary from \"./CylinderGeometryLibrary.js\";\r\nimport defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\nimport DeveloperError from \"./DeveloperError.js\";\r\nimport Geometry from \"./Geometry.js\";\r\nimport GeometryAttribute from \"./GeometryAttribute.js\";\r\nimport GeometryAttributes from \"./GeometryAttributes.js\";\r\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\r\nimport IndexDatatype from \"./IndexDatatype.js\";\r\nimport CesiumMath from \"./Math.js\";\r\nimport PrimitiveType from \"./PrimitiveType.js\";\r\nimport VertexFormat from \"./VertexFormat.js\";\r\n\r\nconst radiusScratch = new Cartesian2();\r\nconst normalScratch = new Cartesian3();\r\nconst bitangentScratch = new Cartesian3();\r\nconst tangentScratch = new Cartesian3();\r\nconst positionScratch = new Cartesian3();\r\n\r\n/**\r\n * A description of a cylinder.\r\n *\r\n * @alias CylinderGeometry\r\n * @constructor\r\n *\r\n * @param {Object} options Object with the following properties:\r\n * @param {Number} options.length The length of the cylinder.\r\n * @param {Number} options.topRadius The radius of the top of the cylinder.\r\n * @param {Number} options.bottomRadius The radius of the bottom of the cylinder.\r\n * @param {Number} [options.slices=128] The number of edges around the perimeter of the cylinder.\r\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\r\n *\r\n * @exception {DeveloperError} options.slices must be greater than or equal to 3.\r\n *\r\n * @see CylinderGeometry.createGeometry\r\n *\r\n * @example\r\n * // create cylinder geometry\r\n * const cylinder = new Cesium.CylinderGeometry({\r\n *     length: 200000,\r\n *     topRadius: 80000,\r\n *     bottomRadius: 200000,\r\n * });\r\n * const geometry = Cesium.CylinderGeometry.createGeometry(cylinder);\r\n */\r\nfunction CylinderGeometry(options) {\r\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n\r\n  const length = options.length;\r\n  const topRadius = options.topRadius;\r\n  const bottomRadius = options.bottomRadius;\r\n  const vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\r\n  const slices = defaultValue(options.slices, 128);\r\n\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(length)) {\r\n    throw new DeveloperError(\"options.length must be defined.\");\r\n  }\r\n  if (!defined(topRadius)) {\r\n    throw new DeveloperError(\"options.topRadius must be defined.\");\r\n  }\r\n  if (!defined(bottomRadius)) {\r\n    throw new DeveloperError(\"options.bottomRadius must be defined.\");\r\n  }\r\n  if (slices < 3) {\r\n    throw new DeveloperError(\r\n      \"options.slices must be greater than or equal to 3.\"\r\n    );\r\n  }\r\n  if (\r\n    defined(options.offsetAttribute) &&\r\n    options.offsetAttribute === GeometryOffsetAttribute.TOP\r\n  ) {\r\n    throw new DeveloperError(\r\n      \"GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.\"\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  this._length = length;\r\n  this._topRadius = topRadius;\r\n  this._bottomRadius = bottomRadius;\r\n  this._vertexFormat = VertexFormat.clone(vertexFormat);\r\n  this._slices = slices;\r\n  this._offsetAttribute = options.offsetAttribute;\r\n  this._workerName = \"createCylinderGeometry\";\r\n}\r\n\r\n/**\r\n * The number of elements used to pack the object into an array.\r\n * @type {Number}\r\n */\r\nCylinderGeometry.packedLength = VertexFormat.packedLength + 5;\r\n\r\n/**\r\n * Stores the provided instance into the provided array.\r\n *\r\n * @param {CylinderGeometry} value The value to pack.\r\n * @param {Number[]} array The array to pack into.\r\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n *\r\n * @returns {Number[]} The array that was packed into\r\n */\r\nCylinderGeometry.pack = function (value, array, startingIndex) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(value)) {\r\n    throw new DeveloperError(\"value is required\");\r\n  }\r\n  if (!defined(array)) {\r\n    throw new DeveloperError(\"array is required\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\r\n  startingIndex += VertexFormat.packedLength;\r\n\r\n  array[startingIndex++] = value._length;\r\n  array[startingIndex++] = value._topRadius;\r\n  array[startingIndex++] = value._bottomRadius;\r\n  array[startingIndex++] = value._slices;\r\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\r\n\r\n  return array;\r\n};\r\n\r\nconst scratchVertexFormat = new VertexFormat();\r\nconst scratchOptions = {\r\n  vertexFormat: scratchVertexFormat,\r\n  length: undefined,\r\n  topRadius: undefined,\r\n  bottomRadius: undefined,\r\n  slices: undefined,\r\n  offsetAttribute: undefined,\r\n};\r\n\r\n/**\r\n * Retrieves an instance from a packed array.\r\n *\r\n * @param {Number[]} array The packed array.\r\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n * @param {CylinderGeometry} [result] The object into which to store the result.\r\n * @returns {CylinderGeometry} The modified result parameter or a new CylinderGeometry instance if one was not provided.\r\n */\r\nCylinderGeometry.unpack = function (array, startingIndex, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(array)) {\r\n    throw new DeveloperError(\"array is required\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  const vertexFormat = VertexFormat.unpack(\r\n    array,\r\n    startingIndex,\r\n    scratchVertexFormat\r\n  );\r\n  startingIndex += VertexFormat.packedLength;\r\n\r\n  const length = array[startingIndex++];\r\n  const topRadius = array[startingIndex++];\r\n  const bottomRadius = array[startingIndex++];\r\n  const slices = array[startingIndex++];\r\n  const offsetAttribute = array[startingIndex];\r\n\r\n  if (!defined(result)) {\r\n    scratchOptions.length = length;\r\n    scratchOptions.topRadius = topRadius;\r\n    scratchOptions.bottomRadius = bottomRadius;\r\n    scratchOptions.slices = slices;\r\n    scratchOptions.offsetAttribute =\r\n      offsetAttribute === -1 ? undefined : offsetAttribute;\r\n    return new CylinderGeometry(scratchOptions);\r\n  }\r\n\r\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\r\n  result._length = length;\r\n  result._topRadius = topRadius;\r\n  result._bottomRadius = bottomRadius;\r\n  result._slices = slices;\r\n  result._offsetAttribute =\r\n    offsetAttribute === -1 ? undefined : offsetAttribute;\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the geometric representation of a cylinder, including its vertices, indices, and a bounding sphere.\r\n *\r\n * @param {CylinderGeometry} cylinderGeometry A description of the cylinder.\r\n * @returns {Geometry|undefined} The computed vertices and indices.\r\n */\r\nCylinderGeometry.createGeometry = function (cylinderGeometry) {\r\n  let length = cylinderGeometry._length;\r\n  const topRadius = cylinderGeometry._topRadius;\r\n  const bottomRadius = cylinderGeometry._bottomRadius;\r\n  const vertexFormat = cylinderGeometry._vertexFormat;\r\n  const slices = cylinderGeometry._slices;\r\n\r\n  if (\r\n    length <= 0 ||\r\n    topRadius < 0 ||\r\n    bottomRadius < 0 ||\r\n    (topRadius === 0 && bottomRadius === 0)\r\n  ) {\r\n    return;\r\n  }\r\n\r\n  const twoSlices = slices + slices;\r\n  const threeSlices = slices + twoSlices;\r\n  const numVertices = twoSlices + twoSlices;\r\n\r\n  const positions = CylinderGeometryLibrary.computePositions(\r\n    length,\r\n    topRadius,\r\n    bottomRadius,\r\n    slices,\r\n    true\r\n  );\r\n\r\n  const st = vertexFormat.st ? new Float32Array(numVertices * 2) : undefined;\r\n  const normals = vertexFormat.normal\r\n    ? new Float32Array(numVertices * 3)\r\n    : undefined;\r\n  const tangents = vertexFormat.tangent\r\n    ? new Float32Array(numVertices * 3)\r\n    : undefined;\r\n  const bitangents = vertexFormat.bitangent\r\n    ? new Float32Array(numVertices * 3)\r\n    : undefined;\r\n\r\n  let i;\r\n  const computeNormal =\r\n    vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent;\r\n\r\n  if (computeNormal) {\r\n    const computeTangent = vertexFormat.tangent || vertexFormat.bitangent;\r\n\r\n    let normalIndex = 0;\r\n    let tangentIndex = 0;\r\n    let bitangentIndex = 0;\r\n\r\n    const theta = Math.atan2(bottomRadius - topRadius, length);\r\n    const normal = normalScratch;\r\n    normal.z = Math.sin(theta);\r\n    const normalScale = Math.cos(theta);\r\n    let tangent = tangentScratch;\r\n    let bitangent = bitangentScratch;\r\n\r\n    for (i = 0; i < slices; i++) {\r\n      const angle = (i / slices) * CesiumMath.TWO_PI;\r\n      const x = normalScale * Math.cos(angle);\r\n      const y = normalScale * Math.sin(angle);\r\n      if (computeNormal) {\r\n        normal.x = x;\r\n        normal.y = y;\r\n\r\n        if (computeTangent) {\r\n          tangent = Cartesian3.normalize(\r\n            Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent),\r\n            tangent\r\n          );\r\n        }\r\n\r\n        if (vertexFormat.normal) {\r\n          normals[normalIndex++] = normal.x;\r\n          normals[normalIndex++] = normal.y;\r\n          normals[normalIndex++] = normal.z;\r\n          normals[normalIndex++] = normal.x;\r\n          normals[normalIndex++] = normal.y;\r\n          normals[normalIndex++] = normal.z;\r\n        }\r\n\r\n        if (vertexFormat.tangent) {\r\n          tangents[tangentIndex++] = tangent.x;\r\n          tangents[tangentIndex++] = tangent.y;\r\n          tangents[tangentIndex++] = tangent.z;\r\n          tangents[tangentIndex++] = tangent.x;\r\n          tangents[tangentIndex++] = tangent.y;\r\n          tangents[tangentIndex++] = tangent.z;\r\n        }\r\n\r\n        if (vertexFormat.bitangent) {\r\n          bitangent = Cartesian3.normalize(\r\n            Cartesian3.cross(normal, tangent, bitangent),\r\n            bitangent\r\n          );\r\n          bitangents[bitangentIndex++] = bitangent.x;\r\n          bitangents[bitangentIndex++] = bitangent.y;\r\n          bitangents[bitangentIndex++] = bitangent.z;\r\n          bitangents[bitangentIndex++] = bitangent.x;\r\n          bitangents[bitangentIndex++] = bitangent.y;\r\n          bitangents[bitangentIndex++] = bitangent.z;\r\n        }\r\n      }\r\n    }\r\n\r\n    for (i = 0; i < slices; i++) {\r\n      if (vertexFormat.normal) {\r\n        normals[normalIndex++] = 0;\r\n        normals[normalIndex++] = 0;\r\n        normals[normalIndex++] = -1;\r\n      }\r\n      if (vertexFormat.tangent) {\r\n        tangents[tangentIndex++] = 1;\r\n        tangents[tangentIndex++] = 0;\r\n        tangents[tangentIndex++] = 0;\r\n      }\r\n      if (vertexFormat.bitangent) {\r\n        bitangents[bitangentIndex++] = 0;\r\n        bitangents[bitangentIndex++] = -1;\r\n        bitangents[bitangentIndex++] = 0;\r\n      }\r\n    }\r\n\r\n    for (i = 0; i < slices; i++) {\r\n      if (vertexFormat.normal) {\r\n        normals[normalIndex++] = 0;\r\n        normals[normalIndex++] = 0;\r\n        normals[normalIndex++] = 1;\r\n      }\r\n      if (vertexFormat.tangent) {\r\n        tangents[tangentIndex++] = 1;\r\n        tangents[tangentIndex++] = 0;\r\n        tangents[tangentIndex++] = 0;\r\n      }\r\n      if (vertexFormat.bitangent) {\r\n        bitangents[bitangentIndex++] = 0;\r\n        bitangents[bitangentIndex++] = 1;\r\n        bitangents[bitangentIndex++] = 0;\r\n      }\r\n    }\r\n  }\r\n\r\n  const numIndices = 12 * slices - 12;\r\n  const indices = IndexDatatype.createTypedArray(numVertices, numIndices);\r\n  let index = 0;\r\n  let j = 0;\r\n  for (i = 0; i < slices - 1; i++) {\r\n    indices[index++] = j;\r\n    indices[index++] = j + 2;\r\n    indices[index++] = j + 3;\r\n\r\n    indices[index++] = j;\r\n    indices[index++] = j + 3;\r\n    indices[index++] = j + 1;\r\n\r\n    j += 2;\r\n  }\r\n\r\n  indices[index++] = twoSlices - 2;\r\n  indices[index++] = 0;\r\n  indices[index++] = 1;\r\n  indices[index++] = twoSlices - 2;\r\n  indices[index++] = 1;\r\n  indices[index++] = twoSlices - 1;\r\n\r\n  for (i = 1; i < slices - 1; i++) {\r\n    indices[index++] = twoSlices + i + 1;\r\n    indices[index++] = twoSlices + i;\r\n    indices[index++] = twoSlices;\r\n  }\r\n\r\n  for (i = 1; i < slices - 1; i++) {\r\n    indices[index++] = threeSlices;\r\n    indices[index++] = threeSlices + i;\r\n    indices[index++] = threeSlices + i + 1;\r\n  }\r\n\r\n  let textureCoordIndex = 0;\r\n  if (vertexFormat.st) {\r\n    const rad = Math.max(topRadius, bottomRadius);\r\n    for (i = 0; i < numVertices; i++) {\r\n      const position = Cartesian3.fromArray(positions, i * 3, positionScratch);\r\n      st[textureCoordIndex++] = (position.x + rad) / (2.0 * rad);\r\n      st[textureCoordIndex++] = (position.y + rad) / (2.0 * rad);\r\n    }\r\n  }\r\n\r\n  const attributes = new GeometryAttributes();\r\n  if (vertexFormat.position) {\r\n    attributes.position = new GeometryAttribute({\r\n      componentDatatype: ComponentDatatype.DOUBLE,\r\n      componentsPerAttribute: 3,\r\n      values: positions,\r\n    });\r\n  }\r\n\r\n  if (vertexFormat.normal) {\r\n    attributes.normal = new GeometryAttribute({\r\n      componentDatatype: ComponentDatatype.FLOAT,\r\n      componentsPerAttribute: 3,\r\n      values: normals,\r\n    });\r\n  }\r\n\r\n  if (vertexFormat.tangent) {\r\n    attributes.tangent = new GeometryAttribute({\r\n      componentDatatype: ComponentDatatype.FLOAT,\r\n      componentsPerAttribute: 3,\r\n      values: tangents,\r\n    });\r\n  }\r\n\r\n  if (vertexFormat.bitangent) {\r\n    attributes.bitangent = new GeometryAttribute({\r\n      componentDatatype: ComponentDatatype.FLOAT,\r\n      componentsPerAttribute: 3,\r\n      values: bitangents,\r\n    });\r\n  }\r\n\r\n  if (vertexFormat.st) {\r\n    attributes.st = new GeometryAttribute({\r\n      componentDatatype: ComponentDatatype.FLOAT,\r\n      componentsPerAttribute: 2,\r\n      values: st,\r\n    });\r\n  }\r\n\r\n  radiusScratch.x = length * 0.5;\r\n  radiusScratch.y = Math.max(bottomRadius, topRadius);\r\n\r\n  const boundingSphere = new BoundingSphere(\r\n    Cartesian3.ZERO,\r\n    Cartesian2.magnitude(radiusScratch)\r\n  );\r\n\r\n  if (defined(cylinderGeometry._offsetAttribute)) {\r\n    length = positions.length;\r\n    const applyOffset = new Uint8Array(length / 3);\r\n    const offsetValue =\r\n      cylinderGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\r\n        ? 0\r\n        : 1;\r\n    arrayFill(applyOffset, offsetValue);\r\n    attributes.applyOffset = new GeometryAttribute({\r\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\r\n      componentsPerAttribute: 1,\r\n      values: applyOffset,\r\n    });\r\n  }\r\n\r\n  return new Geometry({\r\n    attributes: attributes,\r\n    indices: indices,\r\n    primitiveType: PrimitiveType.TRIANGLES,\r\n    boundingSphere: boundingSphere,\r\n    offsetAttribute: cylinderGeometry._offsetAttribute,\r\n  });\r\n};\r\n\r\nlet unitCylinderGeometry;\r\n\r\n/**\r\n * Returns the geometric representation of a unit cylinder, including its vertices, indices, and a bounding sphere.\r\n * @returns {Geometry} The computed vertices and indices.\r\n *\r\n * @private\r\n */\r\nCylinderGeometry.getUnitCylinder = function () {\r\n  if (!defined(unitCylinderGeometry)) {\r\n    unitCylinderGeometry = CylinderGeometry.createGeometry(\r\n      new CylinderGeometry({\r\n        topRadius: 1.0,\r\n        bottomRadius: 1.0,\r\n        length: 1.0,\r\n        vertexFormat: VertexFormat.POSITION_ONLY,\r\n      })\r\n    );\r\n  }\r\n  return unitCylinderGeometry;\r\n};\r\nexport default CylinderGeometry;\r\n"],"names":["radiusScratch","Cartesian2","normalScratch","Cartesian3","bitangentScratch","tangentScratch","positionScratch","CylinderGeometry","options","length","defaultValue","EMPTY_OBJECT","topRadius","bottomRadius","vertexFormat","VertexFormat","DEFAULT","slices","defined","DeveloperError","offsetAttribute","GeometryOffsetAttribute","TOP","this","_length","_topRadius","_bottomRadius","_vertexFormat","clone","_slices","_offsetAttribute","_workerName","packedLength","pack","value","array","startingIndex","scratchVertexFormat","scratchOptions","undefined","unitCylinderGeometry","unpack","result","createGeometry","cylinderGeometry","twoSlices","threeSlices","numVertices","positions","CylinderGeometryLibrary","computePositions","st","Float32Array","normals","normal","tangents","tangent","bitangents","bitangent","i","computeNormal","computeTangent","normalIndex","tangentIndex","bitangentIndex","theta","Math","atan2","z","sin","normalScale","cos","angle","CesiumMath","TWO_PI","x","y","normalize","cross","UNIT_Z","numIndices","indices","IndexDatatype","createTypedArray","index","j","textureCoordIndex","rad","max","position","fromArray","attributes","GeometryAttributes","GeometryAttribute","componentDatatype","ComponentDatatype","DOUBLE","componentsPerAttribute","values","FLOAT","boundingSphere","BoundingSphere","ZERO","magnitude","applyOffset","Uint8Array","offsetValue","NONE","arrayFill","UNSIGNED_BYTE","Geometry","primitiveType","PrimitiveType","TRIANGLES","getUnitCylinder","POSITION_ONLY"],"mappings":"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"}