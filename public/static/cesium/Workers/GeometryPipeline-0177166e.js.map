{"version":3,"file":"GeometryPipeline-0177166e.js","sources":["../../../../Source/Core/barycentricCoordinates.js","../../../../Source/Core/Tipsify.js","../../../../Source/Core/GeometryPipeline.js"],"sourcesContent":["import Cartesian2 from \"./Cartesian2.js\";\r\nimport Cartesian3 from \"./Cartesian3.js\";\r\nimport Check from \"./Check.js\";\r\nimport defined from \"./defined.js\";\r\nimport CesiumMath from \"./Math.js\";\r\n\r\nconst scratchCartesian1 = new Cartesian3();\r\nconst scratchCartesian2 = new Cartesian3();\r\nconst scratchCartesian3 = new Cartesian3();\r\n\r\n/**\r\n * Computes the barycentric coordinates for a point with respect to a triangle.\r\n *\r\n * @function\r\n *\r\n * @param {Cartesian2|Cartesian3} point The point to test.\r\n * @param {Cartesian2|Cartesian3} p0 The first point of the triangle, corresponding to the barycentric x-axis.\r\n * @param {Cartesian2|Cartesian3} p1 The second point of the triangle, corresponding to the barycentric y-axis.\r\n * @param {Cartesian2|Cartesian3} p2 The third point of the triangle, corresponding to the barycentric z-axis.\r\n * @param {Cartesian3} [result] The object onto which to store the result.\r\n * @returns {Cartesian3|undefined} The modified result parameter or a new Cartesian3 instance if one was not provided. If the triangle is degenerate the function will return undefined.\r\n *\r\n * @example\r\n * // Returns Cartesian3.UNIT_X\r\n * const p = new Cesium.Cartesian3(-1.0, 0.0, 0.0);\r\n * const b = Cesium.barycentricCoordinates(p,\r\n *   new Cesium.Cartesian3(-1.0, 0.0, 0.0),\r\n *   new Cesium.Cartesian3( 1.0, 0.0, 0.0),\r\n *   new Cesium.Cartesian3( 0.0, 1.0, 1.0));\r\n */\r\nfunction barycentricCoordinates(point, p0, p1, p2, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"point\", point);\r\n  Check.defined(\"p0\", p0);\r\n  Check.defined(\"p1\", p1);\r\n  Check.defined(\"p2\", p2);\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    result = new Cartesian3();\r\n  }\r\n\r\n  // Implementation based on http://www.blackpawn.com/texts/pointinpoly/default.html.\r\n  let v0;\r\n  let v1;\r\n  let v2;\r\n  let dot00;\r\n  let dot01;\r\n  let dot02;\r\n  let dot11;\r\n  let dot12;\r\n\r\n  if (!defined(p0.z)) {\r\n    if (Cartesian2.equalsEpsilon(point, p0, CesiumMath.EPSILON14)) {\r\n      return Cartesian3.clone(Cartesian3.UNIT_X, result);\r\n    }\r\n    if (Cartesian2.equalsEpsilon(point, p1, CesiumMath.EPSILON14)) {\r\n      return Cartesian3.clone(Cartesian3.UNIT_Y, result);\r\n    }\r\n    if (Cartesian2.equalsEpsilon(point, p2, CesiumMath.EPSILON14)) {\r\n      return Cartesian3.clone(Cartesian3.UNIT_Z, result);\r\n    }\r\n\r\n    v0 = Cartesian2.subtract(p1, p0, scratchCartesian1);\r\n    v1 = Cartesian2.subtract(p2, p0, scratchCartesian2);\r\n    v2 = Cartesian2.subtract(point, p0, scratchCartesian3);\r\n\r\n    dot00 = Cartesian2.dot(v0, v0);\r\n    dot01 = Cartesian2.dot(v0, v1);\r\n    dot02 = Cartesian2.dot(v0, v2);\r\n    dot11 = Cartesian2.dot(v1, v1);\r\n    dot12 = Cartesian2.dot(v1, v2);\r\n  } else {\r\n    if (Cartesian3.equalsEpsilon(point, p0, CesiumMath.EPSILON14)) {\r\n      return Cartesian3.clone(Cartesian3.UNIT_X, result);\r\n    }\r\n    if (Cartesian3.equalsEpsilon(point, p1, CesiumMath.EPSILON14)) {\r\n      return Cartesian3.clone(Cartesian3.UNIT_Y, result);\r\n    }\r\n    if (Cartesian3.equalsEpsilon(point, p2, CesiumMath.EPSILON14)) {\r\n      return Cartesian3.clone(Cartesian3.UNIT_Z, result);\r\n    }\r\n\r\n    v0 = Cartesian3.subtract(p1, p0, scratchCartesian1);\r\n    v1 = Cartesian3.subtract(p2, p0, scratchCartesian2);\r\n    v2 = Cartesian3.subtract(point, p0, scratchCartesian3);\r\n\r\n    dot00 = Cartesian3.dot(v0, v0);\r\n    dot01 = Cartesian3.dot(v0, v1);\r\n    dot02 = Cartesian3.dot(v0, v2);\r\n    dot11 = Cartesian3.dot(v1, v1);\r\n    dot12 = Cartesian3.dot(v1, v2);\r\n  }\r\n\r\n  result.y = dot11 * dot02 - dot01 * dot12;\r\n  result.z = dot00 * dot12 - dot01 * dot02;\r\n  const q = dot00 * dot11 - dot01 * dot01;\r\n\r\n  // Triangle is degenerate\r\n  if (q === 0) {\r\n    return undefined;\r\n  }\r\n\r\n  result.y /= q;\r\n  result.z /= q;\r\n  result.x = 1.0 - result.y - result.z;\r\n  return result;\r\n}\r\nexport default barycentricCoordinates;\r\n","import defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\nimport DeveloperError from \"./DeveloperError.js\";\r\n\r\n/**\r\n * Encapsulates an algorithm to optimize triangles for the post\r\n * vertex-shader cache.  This is based on the 2007 SIGGRAPH paper\r\n * 'Fast Triangle Reordering for Vertex Locality and Reduced Overdraw.'\r\n * The runtime is linear but several passes are made.\r\n *\r\n * @namespace Tipsify\r\n *\r\n * @see <a href='http://gfx.cs.princeton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf'>\r\n * Fast Triangle Reordering for Vertex Locality and Reduced Overdraw</a>\r\n * by Sander, Nehab, and Barczak\r\n *\r\n * @private\r\n */\r\nconst Tipsify = {};\r\n\r\n/**\r\n * Calculates the average cache miss ratio (ACMR) for a given set of indices.\r\n *\r\n * @param {Object} options Object with the following properties:\r\n * @param {Number[]} options.indices Lists triads of numbers corresponding to the indices of the vertices\r\n *                        in the vertex buffer that define the geometry's triangles.\r\n * @param {Number} [options.maximumIndex] The maximum value of the elements in <code>args.indices</code>.\r\n *                                     If not supplied, this value will be computed.\r\n * @param {Number} [options.cacheSize=24] The number of vertices that can be stored in the cache at any one time.\r\n * @returns {Number} The average cache miss ratio (ACMR).\r\n *\r\n * @exception {DeveloperError} indices length must be a multiple of three.\r\n * @exception {DeveloperError} cacheSize must be greater than two.\r\n *\r\n * @example\r\n * const indices = [0, 1, 2, 3, 4, 5];\r\n * const maxIndex = 5;\r\n * const cacheSize = 3;\r\n * const acmr = Cesium.Tipsify.calculateACMR({indices : indices, maxIndex : maxIndex, cacheSize : cacheSize});\r\n */\r\nTipsify.calculateACMR = function (options) {\r\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n  const indices = options.indices;\r\n  let maximumIndex = options.maximumIndex;\r\n  const cacheSize = defaultValue(options.cacheSize, 24);\r\n\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(indices)) {\r\n    throw new DeveloperError(\"indices is required.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const numIndices = indices.length;\r\n\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (numIndices < 3 || numIndices % 3 !== 0) {\r\n    throw new DeveloperError(\"indices length must be a multiple of three.\");\r\n  }\r\n  if (maximumIndex <= 0) {\r\n    throw new DeveloperError(\"maximumIndex must be greater than zero.\");\r\n  }\r\n  if (cacheSize < 3) {\r\n    throw new DeveloperError(\"cacheSize must be greater than two.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  // Compute the maximumIndex if not given\r\n  if (!defined(maximumIndex)) {\r\n    maximumIndex = 0;\r\n    let currentIndex = 0;\r\n    let intoIndices = indices[currentIndex];\r\n    while (currentIndex < numIndices) {\r\n      if (intoIndices > maximumIndex) {\r\n        maximumIndex = intoIndices;\r\n      }\r\n      ++currentIndex;\r\n      intoIndices = indices[currentIndex];\r\n    }\r\n  }\r\n\r\n  // Vertex time stamps\r\n  const vertexTimeStamps = [];\r\n  for (let i = 0; i < maximumIndex + 1; i++) {\r\n    vertexTimeStamps[i] = 0;\r\n  }\r\n\r\n  // Cache processing\r\n  let s = cacheSize + 1;\r\n  for (let j = 0; j < numIndices; ++j) {\r\n    if (s - vertexTimeStamps[indices[j]] > cacheSize) {\r\n      vertexTimeStamps[indices[j]] = s;\r\n      ++s;\r\n    }\r\n  }\r\n\r\n  return (s - cacheSize + 1) / (numIndices / 3);\r\n};\r\n\r\n/**\r\n * Optimizes triangles for the post-vertex shader cache.\r\n *\r\n * @param {Object} options Object with the following properties:\r\n * @param {Number[]} options.indices Lists triads of numbers corresponding to the indices of the vertices\r\n *                        in the vertex buffer that define the geometry's triangles.\r\n * @param {Number} [options.maximumIndex] The maximum value of the elements in <code>args.indices</code>.\r\n *                                     If not supplied, this value will be computed.\r\n * @param {Number} [options.cacheSize=24] The number of vertices that can be stored in the cache at any one time.\r\n * @returns {Number[]} A list of the input indices in an optimized order.\r\n *\r\n * @exception {DeveloperError} indices length must be a multiple of three.\r\n * @exception {DeveloperError} cacheSize must be greater than two.\r\n *\r\n * @example\r\n * const indices = [0, 1, 2, 3, 4, 5];\r\n * const maxIndex = 5;\r\n * const cacheSize = 3;\r\n * const reorderedIndices = Cesium.Tipsify.tipsify({indices : indices, maxIndex : maxIndex, cacheSize : cacheSize});\r\n */\r\nTipsify.tipsify = function (options) {\r\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n  const indices = options.indices;\r\n  const maximumIndex = options.maximumIndex;\r\n  const cacheSize = defaultValue(options.cacheSize, 24);\r\n\r\n  let cursor;\r\n\r\n  function skipDeadEnd(vertices, deadEnd, indices, maximumIndexPlusOne) {\r\n    while (deadEnd.length >= 1) {\r\n      // while the stack is not empty\r\n      const d = deadEnd[deadEnd.length - 1]; // top of the stack\r\n      deadEnd.splice(deadEnd.length - 1, 1); // pop the stack\r\n\r\n      if (vertices[d].numLiveTriangles > 0) {\r\n        return d;\r\n      }\r\n    }\r\n\r\n    while (cursor < maximumIndexPlusOne) {\r\n      if (vertices[cursor].numLiveTriangles > 0) {\r\n        ++cursor;\r\n        return cursor - 1;\r\n      }\r\n      ++cursor;\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  function getNextVertex(\r\n    indices,\r\n    cacheSize,\r\n    oneRing,\r\n    vertices,\r\n    s,\r\n    deadEnd,\r\n    maximumIndexPlusOne\r\n  ) {\r\n    let n = -1;\r\n    let p;\r\n    let m = -1;\r\n    let itOneRing = 0;\r\n    while (itOneRing < oneRing.length) {\r\n      const index = oneRing[itOneRing];\r\n      if (vertices[index].numLiveTriangles) {\r\n        p = 0;\r\n        if (\r\n          s -\r\n            vertices[index].timeStamp +\r\n            2 * vertices[index].numLiveTriangles <=\r\n          cacheSize\r\n        ) {\r\n          p = s - vertices[index].timeStamp;\r\n        }\r\n        if (p > m || m === -1) {\r\n          m = p;\r\n          n = index;\r\n        }\r\n      }\r\n      ++itOneRing;\r\n    }\r\n    if (n === -1) {\r\n      return skipDeadEnd(vertices, deadEnd, indices, maximumIndexPlusOne);\r\n    }\r\n    return n;\r\n  }\r\n\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(indices)) {\r\n    throw new DeveloperError(\"indices is required.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const numIndices = indices.length;\r\n\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (numIndices < 3 || numIndices % 3 !== 0) {\r\n    throw new DeveloperError(\"indices length must be a multiple of three.\");\r\n  }\r\n  if (maximumIndex <= 0) {\r\n    throw new DeveloperError(\"maximumIndex must be greater than zero.\");\r\n  }\r\n  if (cacheSize < 3) {\r\n    throw new DeveloperError(\"cacheSize must be greater than two.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  // Determine maximum index\r\n  let maximumIndexPlusOne = 0;\r\n  let currentIndex = 0;\r\n  let intoIndices = indices[currentIndex];\r\n  const endIndex = numIndices;\r\n  if (defined(maximumIndex)) {\r\n    maximumIndexPlusOne = maximumIndex + 1;\r\n  } else {\r\n    while (currentIndex < endIndex) {\r\n      if (intoIndices > maximumIndexPlusOne) {\r\n        maximumIndexPlusOne = intoIndices;\r\n      }\r\n      ++currentIndex;\r\n      intoIndices = indices[currentIndex];\r\n    }\r\n    if (maximumIndexPlusOne === -1) {\r\n      return 0;\r\n    }\r\n    ++maximumIndexPlusOne;\r\n  }\r\n\r\n  // Vertices\r\n  const vertices = [];\r\n  let i;\r\n  for (i = 0; i < maximumIndexPlusOne; i++) {\r\n    vertices[i] = {\r\n      numLiveTriangles: 0,\r\n      timeStamp: 0,\r\n      vertexTriangles: [],\r\n    };\r\n  }\r\n  currentIndex = 0;\r\n  let triangle = 0;\r\n  while (currentIndex < endIndex) {\r\n    vertices[indices[currentIndex]].vertexTriangles.push(triangle);\r\n    ++vertices[indices[currentIndex]].numLiveTriangles;\r\n    vertices[indices[currentIndex + 1]].vertexTriangles.push(triangle);\r\n    ++vertices[indices[currentIndex + 1]].numLiveTriangles;\r\n    vertices[indices[currentIndex + 2]].vertexTriangles.push(triangle);\r\n    ++vertices[indices[currentIndex + 2]].numLiveTriangles;\r\n    ++triangle;\r\n    currentIndex += 3;\r\n  }\r\n\r\n  // Starting index\r\n  let f = 0;\r\n\r\n  // Time Stamp\r\n  let s = cacheSize + 1;\r\n  cursor = 1;\r\n\r\n  // Process\r\n  let oneRing = [];\r\n  const deadEnd = []; //Stack\r\n  let vertex;\r\n  let intoVertices;\r\n  let currentOutputIndex = 0;\r\n  const outputIndices = [];\r\n  const numTriangles = numIndices / 3;\r\n  const triangleEmitted = [];\r\n  for (i = 0; i < numTriangles; i++) {\r\n    triangleEmitted[i] = false;\r\n  }\r\n  let index;\r\n  let limit;\r\n  while (f !== -1) {\r\n    oneRing = [];\r\n    intoVertices = vertices[f];\r\n    limit = intoVertices.vertexTriangles.length;\r\n    for (let k = 0; k < limit; ++k) {\r\n      triangle = intoVertices.vertexTriangles[k];\r\n      if (!triangleEmitted[triangle]) {\r\n        triangleEmitted[triangle] = true;\r\n        currentIndex = triangle + triangle + triangle;\r\n        for (let j = 0; j < 3; ++j) {\r\n          // Set this index as a possible next index\r\n          index = indices[currentIndex];\r\n          oneRing.push(index);\r\n          deadEnd.push(index);\r\n\r\n          // Output index\r\n          outputIndices[currentOutputIndex] = index;\r\n          ++currentOutputIndex;\r\n\r\n          // Cache processing\r\n          vertex = vertices[index];\r\n          --vertex.numLiveTriangles;\r\n          if (s - vertex.timeStamp > cacheSize) {\r\n            vertex.timeStamp = s;\r\n            ++s;\r\n          }\r\n          ++currentIndex;\r\n        }\r\n      }\r\n    }\r\n    f = getNextVertex(\r\n      indices,\r\n      cacheSize,\r\n      oneRing,\r\n      vertices,\r\n      s,\r\n      deadEnd,\r\n      maximumIndexPlusOne\r\n    );\r\n  }\r\n\r\n  return outputIndices;\r\n};\r\nexport default Tipsify;\r\n","import AttributeCompression from \"./AttributeCompression.js\";\r\nimport barycentricCoordinates from \"./barycentricCoordinates.js\";\r\nimport BoundingSphere from \"./BoundingSphere.js\";\r\nimport Cartesian2 from \"./Cartesian2.js\";\r\nimport Cartesian3 from \"./Cartesian3.js\";\r\nimport Cartesian4 from \"./Cartesian4.js\";\r\nimport Cartographic from \"./Cartographic.js\";\r\nimport ComponentDatatype from \"./ComponentDatatype.js\";\r\nimport defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\nimport DeveloperError from \"./DeveloperError.js\";\r\nimport EncodedCartesian3 from \"./EncodedCartesian3.js\";\r\nimport GeographicProjection from \"./GeographicProjection.js\";\r\nimport Geometry from \"./Geometry.js\";\r\nimport GeometryAttribute from \"./GeometryAttribute.js\";\r\nimport GeometryType from \"./GeometryType.js\";\r\nimport IndexDatatype from \"./IndexDatatype.js\";\r\nimport Intersect from \"./Intersect.js\";\r\nimport IntersectionTests from \"./IntersectionTests.js\";\r\nimport CesiumMath from \"./Math.js\";\r\nimport Matrix3 from \"./Matrix3.js\";\r\nimport Matrix4 from \"./Matrix4.js\";\r\nimport Plane from \"./Plane.js\";\r\nimport PrimitiveType from \"./PrimitiveType.js\";\r\nimport Tipsify from \"./Tipsify.js\";\r\n\r\n/**\r\n * Content pipeline functions for geometries.\r\n *\r\n * @namespace GeometryPipeline\r\n *\r\n * @see Geometry\r\n */\r\nconst GeometryPipeline = {};\r\n\r\nfunction addTriangle(lines, index, i0, i1, i2) {\r\n  lines[index++] = i0;\r\n  lines[index++] = i1;\r\n\r\n  lines[index++] = i1;\r\n  lines[index++] = i2;\r\n\r\n  lines[index++] = i2;\r\n  lines[index] = i0;\r\n}\r\n\r\nfunction trianglesToLines(triangles) {\r\n  const count = triangles.length;\r\n  const size = (count / 3) * 6;\r\n  const lines = IndexDatatype.createTypedArray(count, size);\r\n\r\n  let index = 0;\r\n  for (let i = 0; i < count; i += 3, index += 6) {\r\n    addTriangle(lines, index, triangles[i], triangles[i + 1], triangles[i + 2]);\r\n  }\r\n\r\n  return lines;\r\n}\r\n\r\nfunction triangleStripToLines(triangles) {\r\n  const count = triangles.length;\r\n  if (count >= 3) {\r\n    const size = (count - 2) * 6;\r\n    const lines = IndexDatatype.createTypedArray(count, size);\r\n\r\n    addTriangle(lines, 0, triangles[0], triangles[1], triangles[2]);\r\n    let index = 6;\r\n\r\n    for (let i = 3; i < count; ++i, index += 6) {\r\n      addTriangle(\r\n        lines,\r\n        index,\r\n        triangles[i - 1],\r\n        triangles[i],\r\n        triangles[i - 2]\r\n      );\r\n    }\r\n\r\n    return lines;\r\n  }\r\n\r\n  return new Uint16Array();\r\n}\r\n\r\nfunction triangleFanToLines(triangles) {\r\n  if (triangles.length > 0) {\r\n    const count = triangles.length - 1;\r\n    const size = (count - 1) * 6;\r\n    const lines = IndexDatatype.createTypedArray(count, size);\r\n\r\n    const base = triangles[0];\r\n    let index = 0;\r\n    for (let i = 1; i < count; ++i, index += 6) {\r\n      addTriangle(lines, index, base, triangles[i], triangles[i + 1]);\r\n    }\r\n\r\n    return lines;\r\n  }\r\n\r\n  return new Uint16Array();\r\n}\r\n\r\n/**\r\n * Converts a geometry's triangle indices to line indices.  If the geometry has an <code>indices</code>\r\n * and its <code>primitiveType</code> is <code>TRIANGLES</code>, <code>TRIANGLE_STRIP</code>,\r\n * <code>TRIANGLE_FAN</code>, it is converted to <code>LINES</code>; otherwise, the geometry is not changed.\r\n * <p>\r\n * This is commonly used to create a wireframe geometry for visual debugging.\r\n * </p>\r\n *\r\n * @param {Geometry} geometry The geometry to modify.\r\n * @returns {Geometry} The modified <code>geometry</code> argument, with its triangle indices converted to lines.\r\n *\r\n * @exception {DeveloperError} geometry.primitiveType must be TRIANGLES, TRIANGLE_STRIP, or TRIANGLE_FAN.\r\n *\r\n * @example\r\n * geometry = Cesium.GeometryPipeline.toWireframe(geometry);\r\n */\r\nGeometryPipeline.toWireframe = function (geometry) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(geometry)) {\r\n    throw new DeveloperError(\"geometry is required.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const indices = geometry.indices;\r\n  if (defined(indices)) {\r\n    switch (geometry.primitiveType) {\r\n      case PrimitiveType.TRIANGLES:\r\n        geometry.indices = trianglesToLines(indices);\r\n        break;\r\n      case PrimitiveType.TRIANGLE_STRIP:\r\n        geometry.indices = triangleStripToLines(indices);\r\n        break;\r\n      case PrimitiveType.TRIANGLE_FAN:\r\n        geometry.indices = triangleFanToLines(indices);\r\n        break;\r\n      //>>includeStart('debug', pragmas.debug);\r\n      default:\r\n        throw new DeveloperError(\r\n          \"geometry.primitiveType must be TRIANGLES, TRIANGLE_STRIP, or TRIANGLE_FAN.\"\r\n        );\r\n      //>>includeEnd('debug');\r\n    }\r\n\r\n    geometry.primitiveType = PrimitiveType.LINES;\r\n  }\r\n\r\n  return geometry;\r\n};\r\n\r\n/**\r\n * Creates a new {@link Geometry} with <code>LINES</code> representing the provided\r\n * attribute (<code>attributeName</code>) for the provided geometry.  This is used to\r\n * visualize vector attributes like normals, tangents, and bitangents.\r\n *\r\n * @param {Geometry} geometry The <code>Geometry</code> instance with the attribute.\r\n * @param {String} [attributeName='normal'] The name of the attribute.\r\n * @param {Number} [length=10000.0] The length of each line segment in meters.  This can be negative to point the vector in the opposite direction.\r\n * @returns {Geometry} A new <code>Geometry</code> instance with line segments for the vector.\r\n *\r\n * @exception {DeveloperError} geometry.attributes must have an attribute with the same name as the attributeName parameter.\r\n *\r\n * @example\r\n * const geometry = Cesium.GeometryPipeline.createLineSegmentsForVectors(instance.geometry, 'bitangent', 100000.0);\r\n */\r\nGeometryPipeline.createLineSegmentsForVectors = function (\r\n  geometry,\r\n  attributeName,\r\n  length\r\n) {\r\n  attributeName = defaultValue(attributeName, \"normal\");\r\n\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(geometry)) {\r\n    throw new DeveloperError(\"geometry is required.\");\r\n  }\r\n  if (!defined(geometry.attributes.position)) {\r\n    throw new DeveloperError(\"geometry.attributes.position is required.\");\r\n  }\r\n  if (!defined(geometry.attributes[attributeName])) {\r\n    throw new DeveloperError(\r\n      `geometry.attributes must have an attribute with the same name as the attributeName parameter, ${attributeName}.`\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  length = defaultValue(length, 10000.0);\r\n\r\n  const positions = geometry.attributes.position.values;\r\n  const vectors = geometry.attributes[attributeName].values;\r\n  const positionsLength = positions.length;\r\n\r\n  const newPositions = new Float64Array(2 * positionsLength);\r\n\r\n  let j = 0;\r\n  for (let i = 0; i < positionsLength; i += 3) {\r\n    newPositions[j++] = positions[i];\r\n    newPositions[j++] = positions[i + 1];\r\n    newPositions[j++] = positions[i + 2];\r\n\r\n    newPositions[j++] = positions[i] + vectors[i] * length;\r\n    newPositions[j++] = positions[i + 1] + vectors[i + 1] * length;\r\n    newPositions[j++] = positions[i + 2] + vectors[i + 2] * length;\r\n  }\r\n\r\n  let newBoundingSphere;\r\n  const bs = geometry.boundingSphere;\r\n  if (defined(bs)) {\r\n    newBoundingSphere = new BoundingSphere(bs.center, bs.radius + length);\r\n  }\r\n\r\n  return new Geometry({\r\n    attributes: {\r\n      position: new GeometryAttribute({\r\n        componentDatatype: ComponentDatatype.DOUBLE,\r\n        componentsPerAttribute: 3,\r\n        values: newPositions,\r\n      }),\r\n    },\r\n    primitiveType: PrimitiveType.LINES,\r\n    boundingSphere: newBoundingSphere,\r\n  });\r\n};\r\n\r\n/**\r\n * Creates an object that maps attribute names to unique locations (indices)\r\n * for matching vertex attributes and shader programs.\r\n *\r\n * @param {Geometry} geometry The geometry, which is not modified, to create the object for.\r\n * @returns {Object} An object with attribute name / index pairs.\r\n *\r\n * @example\r\n * const attributeLocations = Cesium.GeometryPipeline.createAttributeLocations(geometry);\r\n * // Example output\r\n * // {\r\n * //   'position' : 0,\r\n * //   'normal' : 1\r\n * // }\r\n */\r\nGeometryPipeline.createAttributeLocations = function (geometry) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(geometry)) {\r\n    throw new DeveloperError(\"geometry is required.\");\r\n  }\r\n  //>>includeEnd('debug')\r\n\r\n  // There can be a WebGL performance hit when attribute 0 is disabled, so\r\n  // assign attribute locations to well-known attributes.\r\n  const semantics = [\r\n    \"position\",\r\n    \"positionHigh\",\r\n    \"positionLow\",\r\n\r\n    // From VertexFormat.position - after 2D projection and high-precision encoding\r\n    \"position3DHigh\",\r\n    \"position3DLow\",\r\n    \"position2DHigh\",\r\n    \"position2DLow\",\r\n\r\n    // From Primitive\r\n    \"pickColor\",\r\n\r\n    // From VertexFormat\r\n    \"normal\",\r\n    \"st\",\r\n    \"tangent\",\r\n    \"bitangent\",\r\n\r\n    // For shadow volumes\r\n    \"extrudeDirection\",\r\n\r\n    // From compressing texture coordinates and normals\r\n    \"compressedAttributes\",\r\n  ];\r\n\r\n  const attributes = geometry.attributes;\r\n  const indices = {};\r\n  let j = 0;\r\n  let i;\r\n  const len = semantics.length;\r\n\r\n  // Attribute locations for well-known attributes\r\n  for (i = 0; i < len; ++i) {\r\n    const semantic = semantics[i];\r\n\r\n    if (defined(attributes[semantic])) {\r\n      indices[semantic] = j++;\r\n    }\r\n  }\r\n\r\n  // Locations for custom attributes\r\n  for (const name in attributes) {\r\n    if (attributes.hasOwnProperty(name) && !defined(indices[name])) {\r\n      indices[name] = j++;\r\n    }\r\n  }\r\n\r\n  return indices;\r\n};\r\n\r\n/**\r\n * Reorders a geometry's attributes and <code>indices</code> to achieve better performance from the GPU's pre-vertex-shader cache.\r\n *\r\n * @param {Geometry} geometry The geometry to modify.\r\n * @returns {Geometry} The modified <code>geometry</code> argument, with its attributes and indices reordered for the GPU's pre-vertex-shader cache.\r\n *\r\n * @exception {DeveloperError} Each attribute array in geometry.attributes must have the same number of attributes.\r\n *\r\n *\r\n * @example\r\n * geometry = Cesium.GeometryPipeline.reorderForPreVertexCache(geometry);\r\n *\r\n * @see GeometryPipeline.reorderForPostVertexCache\r\n */\r\nGeometryPipeline.reorderForPreVertexCache = function (geometry) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(geometry)) {\r\n    throw new DeveloperError(\"geometry is required.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const numVertices = Geometry.computeNumberOfVertices(geometry);\r\n\r\n  const indices = geometry.indices;\r\n  if (defined(indices)) {\r\n    const indexCrossReferenceOldToNew = new Int32Array(numVertices);\r\n    for (let i = 0; i < numVertices; i++) {\r\n      indexCrossReferenceOldToNew[i] = -1;\r\n    }\r\n\r\n    // Construct cross reference and reorder indices\r\n    const indicesIn = indices;\r\n    const numIndices = indicesIn.length;\r\n    const indicesOut = IndexDatatype.createTypedArray(numVertices, numIndices);\r\n\r\n    let intoIndicesIn = 0;\r\n    let intoIndicesOut = 0;\r\n    let nextIndex = 0;\r\n    let tempIndex;\r\n    while (intoIndicesIn < numIndices) {\r\n      tempIndex = indexCrossReferenceOldToNew[indicesIn[intoIndicesIn]];\r\n      if (tempIndex !== -1) {\r\n        indicesOut[intoIndicesOut] = tempIndex;\r\n      } else {\r\n        tempIndex = indicesIn[intoIndicesIn];\r\n        indexCrossReferenceOldToNew[tempIndex] = nextIndex;\r\n\r\n        indicesOut[intoIndicesOut] = nextIndex;\r\n        ++nextIndex;\r\n      }\r\n      ++intoIndicesIn;\r\n      ++intoIndicesOut;\r\n    }\r\n    geometry.indices = indicesOut;\r\n\r\n    // Reorder attributes\r\n    const attributes = geometry.attributes;\r\n    for (const property in attributes) {\r\n      if (\r\n        attributes.hasOwnProperty(property) &&\r\n        defined(attributes[property]) &&\r\n        defined(attributes[property].values)\r\n      ) {\r\n        const attribute = attributes[property];\r\n        const elementsIn = attribute.values;\r\n        let intoElementsIn = 0;\r\n        const numComponents = attribute.componentsPerAttribute;\r\n        const elementsOut = ComponentDatatype.createTypedArray(\r\n          attribute.componentDatatype,\r\n          nextIndex * numComponents\r\n        );\r\n        while (intoElementsIn < numVertices) {\r\n          const temp = indexCrossReferenceOldToNew[intoElementsIn];\r\n          if (temp !== -1) {\r\n            for (let j = 0; j < numComponents; j++) {\r\n              elementsOut[numComponents * temp + j] =\r\n                elementsIn[numComponents * intoElementsIn + j];\r\n            }\r\n          }\r\n          ++intoElementsIn;\r\n        }\r\n        attribute.values = elementsOut;\r\n      }\r\n    }\r\n  }\r\n\r\n  return geometry;\r\n};\r\n\r\n/**\r\n * Reorders a geometry's <code>indices</code> to achieve better performance from the GPU's\r\n * post vertex-shader cache by using the Tipsify algorithm.  If the geometry <code>primitiveType</code>\r\n * is not <code>TRIANGLES</code> or the geometry does not have an <code>indices</code>, this function has no effect.\r\n *\r\n * @param {Geometry} geometry The geometry to modify.\r\n * @param {Number} [cacheCapacity=24] The number of vertices that can be held in the GPU's vertex cache.\r\n * @returns {Geometry} The modified <code>geometry</code> argument, with its indices reordered for the post-vertex-shader cache.\r\n *\r\n * @exception {DeveloperError} cacheCapacity must be greater than two.\r\n *\r\n *\r\n * @example\r\n * geometry = Cesium.GeometryPipeline.reorderForPostVertexCache(geometry);\r\n *\r\n * @see GeometryPipeline.reorderForPreVertexCache\r\n * @see {@link http://gfx.cs.princ0eton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf|Fast Triangle Reordering for Vertex Locality and Reduced Overdraw}\r\n * by Sander, Nehab, and Barczak\r\n */\r\nGeometryPipeline.reorderForPostVertexCache = function (\r\n  geometry,\r\n  cacheCapacity\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(geometry)) {\r\n    throw new DeveloperError(\"geometry is required.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const indices = geometry.indices;\r\n  if (geometry.primitiveType === PrimitiveType.TRIANGLES && defined(indices)) {\r\n    const numIndices = indices.length;\r\n    let maximumIndex = 0;\r\n    for (let j = 0; j < numIndices; j++) {\r\n      if (indices[j] > maximumIndex) {\r\n        maximumIndex = indices[j];\r\n      }\r\n    }\r\n    geometry.indices = Tipsify.tipsify({\r\n      indices: indices,\r\n      maximumIndex: maximumIndex,\r\n      cacheSize: cacheCapacity,\r\n    });\r\n  }\r\n\r\n  return geometry;\r\n};\r\n\r\nfunction copyAttributesDescriptions(attributes) {\r\n  const newAttributes = {};\r\n\r\n  for (const attribute in attributes) {\r\n    if (\r\n      attributes.hasOwnProperty(attribute) &&\r\n      defined(attributes[attribute]) &&\r\n      defined(attributes[attribute].values)\r\n    ) {\r\n      const attr = attributes[attribute];\r\n      newAttributes[attribute] = new GeometryAttribute({\r\n        componentDatatype: attr.componentDatatype,\r\n        componentsPerAttribute: attr.componentsPerAttribute,\r\n        normalize: attr.normalize,\r\n        values: [],\r\n      });\r\n    }\r\n  }\r\n\r\n  return newAttributes;\r\n}\r\n\r\nfunction copyVertex(destinationAttributes, sourceAttributes, index) {\r\n  for (const attribute in sourceAttributes) {\r\n    if (\r\n      sourceAttributes.hasOwnProperty(attribute) &&\r\n      defined(sourceAttributes[attribute]) &&\r\n      defined(sourceAttributes[attribute].values)\r\n    ) {\r\n      const attr = sourceAttributes[attribute];\r\n\r\n      for (let k = 0; k < attr.componentsPerAttribute; ++k) {\r\n        destinationAttributes[attribute].values.push(\r\n          attr.values[index * attr.componentsPerAttribute + k]\r\n        );\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Splits a geometry into multiple geometries, if necessary, to ensure that indices in the\r\n * <code>indices</code> fit into unsigned shorts.  This is used to meet the WebGL requirements\r\n * when unsigned int indices are not supported.\r\n * <p>\r\n * If the geometry does not have any <code>indices</code>, this function has no effect.\r\n * </p>\r\n *\r\n * @param {Geometry} geometry The geometry to be split into multiple geometries.\r\n * @returns {Geometry[]} An array of geometries, each with indices that fit into unsigned shorts.\r\n *\r\n * @exception {DeveloperError} geometry.primitiveType must equal to PrimitiveType.TRIANGLES, PrimitiveType.LINES, or PrimitiveType.POINTS\r\n * @exception {DeveloperError} All geometry attribute lists must have the same number of attributes.\r\n *\r\n * @example\r\n * const geometries = Cesium.GeometryPipeline.fitToUnsignedShortIndices(geometry);\r\n */\r\nGeometryPipeline.fitToUnsignedShortIndices = function (geometry) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(geometry)) {\r\n    throw new DeveloperError(\"geometry is required.\");\r\n  }\r\n  if (\r\n    defined(geometry.indices) &&\r\n    geometry.primitiveType !== PrimitiveType.TRIANGLES &&\r\n    geometry.primitiveType !== PrimitiveType.LINES &&\r\n    geometry.primitiveType !== PrimitiveType.POINTS\r\n  ) {\r\n    throw new DeveloperError(\r\n      \"geometry.primitiveType must equal to PrimitiveType.TRIANGLES, PrimitiveType.LINES, or PrimitiveType.POINTS.\"\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const geometries = [];\r\n\r\n  // If there's an index list and more than 64K attributes, it is possible that\r\n  // some indices are outside the range of unsigned short [0, 64K - 1]\r\n  const numberOfVertices = Geometry.computeNumberOfVertices(geometry);\r\n  if (\r\n    defined(geometry.indices) &&\r\n    numberOfVertices >= CesiumMath.SIXTY_FOUR_KILOBYTES\r\n  ) {\r\n    let oldToNewIndex = [];\r\n    let newIndices = [];\r\n    let currentIndex = 0;\r\n    let newAttributes = copyAttributesDescriptions(geometry.attributes);\r\n\r\n    const originalIndices = geometry.indices;\r\n    const numberOfIndices = originalIndices.length;\r\n\r\n    let indicesPerPrimitive;\r\n\r\n    if (geometry.primitiveType === PrimitiveType.TRIANGLES) {\r\n      indicesPerPrimitive = 3;\r\n    } else if (geometry.primitiveType === PrimitiveType.LINES) {\r\n      indicesPerPrimitive = 2;\r\n    } else if (geometry.primitiveType === PrimitiveType.POINTS) {\r\n      indicesPerPrimitive = 1;\r\n    }\r\n\r\n    for (let j = 0; j < numberOfIndices; j += indicesPerPrimitive) {\r\n      for (let k = 0; k < indicesPerPrimitive; ++k) {\r\n        const x = originalIndices[j + k];\r\n        let i = oldToNewIndex[x];\r\n        if (!defined(i)) {\r\n          i = currentIndex++;\r\n          oldToNewIndex[x] = i;\r\n          copyVertex(newAttributes, geometry.attributes, x);\r\n        }\r\n        newIndices.push(i);\r\n      }\r\n\r\n      if (\r\n        currentIndex + indicesPerPrimitive >=\r\n        CesiumMath.SIXTY_FOUR_KILOBYTES\r\n      ) {\r\n        geometries.push(\r\n          new Geometry({\r\n            attributes: newAttributes,\r\n            indices: newIndices,\r\n            primitiveType: geometry.primitiveType,\r\n            boundingSphere: geometry.boundingSphere,\r\n            boundingSphereCV: geometry.boundingSphereCV,\r\n          })\r\n        );\r\n\r\n        // Reset for next vertex-array\r\n        oldToNewIndex = [];\r\n        newIndices = [];\r\n        currentIndex = 0;\r\n        newAttributes = copyAttributesDescriptions(geometry.attributes);\r\n      }\r\n    }\r\n\r\n    if (newIndices.length !== 0) {\r\n      geometries.push(\r\n        new Geometry({\r\n          attributes: newAttributes,\r\n          indices: newIndices,\r\n          primitiveType: geometry.primitiveType,\r\n          boundingSphere: geometry.boundingSphere,\r\n          boundingSphereCV: geometry.boundingSphereCV,\r\n        })\r\n      );\r\n    }\r\n  } else {\r\n    // No need to split into multiple geometries\r\n    geometries.push(geometry);\r\n  }\r\n\r\n  return geometries;\r\n};\r\n\r\nconst scratchProjectTo2DCartesian3 = new Cartesian3();\r\nconst scratchProjectTo2DCartographic = new Cartographic();\r\n\r\n/**\r\n * Projects a geometry's 3D <code>position</code> attribute to 2D, replacing the <code>position</code>\r\n * attribute with separate <code>position3D</code> and <code>position2D</code> attributes.\r\n * <p>\r\n * If the geometry does not have a <code>position</code>, this function has no effect.\r\n * </p>\r\n *\r\n * @param {Geometry} geometry The geometry to modify.\r\n * @param {String} attributeName The name of the attribute.\r\n * @param {String} attributeName3D The name of the attribute in 3D.\r\n * @param {String} attributeName2D The name of the attribute in 2D.\r\n * @param {Object} [projection=new GeographicProjection()] The projection to use.\r\n * @returns {Geometry} The modified <code>geometry</code> argument with <code>position3D</code> and <code>position2D</code> attributes.\r\n *\r\n * @exception {DeveloperError} geometry must have attribute matching the attributeName argument.\r\n * @exception {DeveloperError} The attribute componentDatatype must be ComponentDatatype.DOUBLE.\r\n * @exception {DeveloperError} Could not project a point to 2D.\r\n *\r\n * @example\r\n * geometry = Cesium.GeometryPipeline.projectTo2D(geometry, 'position', 'position3D', 'position2D');\r\n */\r\nGeometryPipeline.projectTo2D = function (\r\n  geometry,\r\n  attributeName,\r\n  attributeName3D,\r\n  attributeName2D,\r\n  projection\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(geometry)) {\r\n    throw new DeveloperError(\"geometry is required.\");\r\n  }\r\n  if (!defined(attributeName)) {\r\n    throw new DeveloperError(\"attributeName is required.\");\r\n  }\r\n  if (!defined(attributeName3D)) {\r\n    throw new DeveloperError(\"attributeName3D is required.\");\r\n  }\r\n  if (!defined(attributeName2D)) {\r\n    throw new DeveloperError(\"attributeName2D is required.\");\r\n  }\r\n  if (!defined(geometry.attributes[attributeName])) {\r\n    throw new DeveloperError(\r\n      `geometry must have attribute matching the attributeName argument: ${attributeName}.`\r\n    );\r\n  }\r\n  if (\r\n    geometry.attributes[attributeName].componentDatatype !==\r\n    ComponentDatatype.DOUBLE\r\n  ) {\r\n    throw new DeveloperError(\r\n      \"The attribute componentDatatype must be ComponentDatatype.DOUBLE.\"\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const attribute = geometry.attributes[attributeName];\r\n  projection = defined(projection) ? projection : new GeographicProjection();\r\n  const ellipsoid = projection.ellipsoid;\r\n\r\n  // Project original values to 2D.\r\n  const values3D = attribute.values;\r\n  const projectedValues = new Float64Array(values3D.length);\r\n  let index = 0;\r\n\r\n  for (let i = 0; i < values3D.length; i += 3) {\r\n    const value = Cartesian3.fromArray(\r\n      values3D,\r\n      i,\r\n      scratchProjectTo2DCartesian3\r\n    );\r\n\r\n    const lonLat = ellipsoid.cartesianToCartographic(\r\n      value,\r\n      scratchProjectTo2DCartographic\r\n    );\r\n    //>>includeStart('debug', pragmas.debug);\r\n    if (!defined(lonLat)) {\r\n      throw new DeveloperError(\r\n        `Could not project point (${value.x}, ${value.y}, ${value.z}) to 2D.`\r\n      );\r\n    }\r\n    //>>includeEnd('debug');\r\n\r\n    const projectedLonLat = projection.project(\r\n      lonLat,\r\n      scratchProjectTo2DCartesian3\r\n    );\r\n\r\n    projectedValues[index++] = projectedLonLat.x;\r\n    projectedValues[index++] = projectedLonLat.y;\r\n    projectedValues[index++] = projectedLonLat.z;\r\n  }\r\n\r\n  // Rename original cartesians to WGS84 cartesians.\r\n  geometry.attributes[attributeName3D] = attribute;\r\n\r\n  // Replace original cartesians with 2D projected cartesians\r\n  geometry.attributes[attributeName2D] = new GeometryAttribute({\r\n    componentDatatype: ComponentDatatype.DOUBLE,\r\n    componentsPerAttribute: 3,\r\n    values: projectedValues,\r\n  });\r\n  delete geometry.attributes[attributeName];\r\n\r\n  return geometry;\r\n};\r\n\r\nconst encodedResult = {\r\n  high: 0.0,\r\n  low: 0.0,\r\n};\r\n\r\n/**\r\n * Encodes floating-point geometry attribute values as two separate attributes to improve\r\n * rendering precision.\r\n * <p>\r\n * This is commonly used to create high-precision position vertex attributes.\r\n * </p>\r\n *\r\n * @param {Geometry} geometry The geometry to modify.\r\n * @param {String} attributeName The name of the attribute.\r\n * @param {String} attributeHighName The name of the attribute for the encoded high bits.\r\n * @param {String} attributeLowName The name of the attribute for the encoded low bits.\r\n * @returns {Geometry} The modified <code>geometry</code> argument, with its encoded attribute.\r\n *\r\n * @exception {DeveloperError} geometry must have attribute matching the attributeName argument.\r\n * @exception {DeveloperError} The attribute componentDatatype must be ComponentDatatype.DOUBLE.\r\n *\r\n * @example\r\n * geometry = Cesium.GeometryPipeline.encodeAttribute(geometry, 'position3D', 'position3DHigh', 'position3DLow');\r\n */\r\nGeometryPipeline.encodeAttribute = function (\r\n  geometry,\r\n  attributeName,\r\n  attributeHighName,\r\n  attributeLowName\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(geometry)) {\r\n    throw new DeveloperError(\"geometry is required.\");\r\n  }\r\n  if (!defined(attributeName)) {\r\n    throw new DeveloperError(\"attributeName is required.\");\r\n  }\r\n  if (!defined(attributeHighName)) {\r\n    throw new DeveloperError(\"attributeHighName is required.\");\r\n  }\r\n  if (!defined(attributeLowName)) {\r\n    throw new DeveloperError(\"attributeLowName is required.\");\r\n  }\r\n  if (!defined(geometry.attributes[attributeName])) {\r\n    throw new DeveloperError(\r\n      `geometry must have attribute matching the attributeName argument: ${attributeName}.`\r\n    );\r\n  }\r\n  if (\r\n    geometry.attributes[attributeName].componentDatatype !==\r\n    ComponentDatatype.DOUBLE\r\n  ) {\r\n    throw new DeveloperError(\r\n      \"The attribute componentDatatype must be ComponentDatatype.DOUBLE.\"\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const attribute = geometry.attributes[attributeName];\r\n  const values = attribute.values;\r\n  const length = values.length;\r\n  const highValues = new Float32Array(length);\r\n  const lowValues = new Float32Array(length);\r\n\r\n  for (let i = 0; i < length; ++i) {\r\n    EncodedCartesian3.encode(values[i], encodedResult);\r\n    highValues[i] = encodedResult.high;\r\n    lowValues[i] = encodedResult.low;\r\n  }\r\n\r\n  const componentsPerAttribute = attribute.componentsPerAttribute;\r\n\r\n  geometry.attributes[attributeHighName] = new GeometryAttribute({\r\n    componentDatatype: ComponentDatatype.FLOAT,\r\n    componentsPerAttribute: componentsPerAttribute,\r\n    values: highValues,\r\n  });\r\n  geometry.attributes[attributeLowName] = new GeometryAttribute({\r\n    componentDatatype: ComponentDatatype.FLOAT,\r\n    componentsPerAttribute: componentsPerAttribute,\r\n    values: lowValues,\r\n  });\r\n  delete geometry.attributes[attributeName];\r\n\r\n  return geometry;\r\n};\r\n\r\nlet scratchCartesian3 = new Cartesian3();\r\n\r\nfunction transformPoint(matrix, attribute) {\r\n  if (defined(attribute)) {\r\n    const values = attribute.values;\r\n    const length = values.length;\r\n    for (let i = 0; i < length; i += 3) {\r\n      Cartesian3.unpack(values, i, scratchCartesian3);\r\n      Matrix4.multiplyByPoint(matrix, scratchCartesian3, scratchCartesian3);\r\n      Cartesian3.pack(scratchCartesian3, values, i);\r\n    }\r\n  }\r\n}\r\n\r\nfunction transformVector(matrix, attribute) {\r\n  if (defined(attribute)) {\r\n    const values = attribute.values;\r\n    const length = values.length;\r\n    for (let i = 0; i < length; i += 3) {\r\n      Cartesian3.unpack(values, i, scratchCartesian3);\r\n      Matrix3.multiplyByVector(matrix, scratchCartesian3, scratchCartesian3);\r\n      scratchCartesian3 = Cartesian3.normalize(\r\n        scratchCartesian3,\r\n        scratchCartesian3\r\n      );\r\n      Cartesian3.pack(scratchCartesian3, values, i);\r\n    }\r\n  }\r\n}\r\n\r\nconst inverseTranspose = new Matrix4();\r\nconst normalMatrix = new Matrix3();\r\n\r\n/**\r\n * Transforms a geometry instance to world coordinates.  This changes\r\n * the instance's <code>modelMatrix</code> to {@link Matrix4.IDENTITY} and transforms the\r\n * following attributes if they are present: <code>position</code>, <code>normal</code>,\r\n * <code>tangent</code>, and <code>bitangent</code>.\r\n *\r\n * @param {GeometryInstance} instance The geometry instance to modify.\r\n * @returns {GeometryInstance} The modified <code>instance</code> argument, with its attributes transforms to world coordinates.\r\n *\r\n * @example\r\n * Cesium.GeometryPipeline.transformToWorldCoordinates(instance);\r\n */\r\nGeometryPipeline.transformToWorldCoordinates = function (instance) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(instance)) {\r\n    throw new DeveloperError(\"instance is required.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const modelMatrix = instance.modelMatrix;\r\n\r\n  if (Matrix4.equals(modelMatrix, Matrix4.IDENTITY)) {\r\n    // Already in world coordinates\r\n    return instance;\r\n  }\r\n\r\n  const attributes = instance.geometry.attributes;\r\n\r\n  // Transform attributes in known vertex formats\r\n  transformPoint(modelMatrix, attributes.position);\r\n  transformPoint(modelMatrix, attributes.prevPosition);\r\n  transformPoint(modelMatrix, attributes.nextPosition);\r\n\r\n  if (\r\n    defined(attributes.normal) ||\r\n    defined(attributes.tangent) ||\r\n    defined(attributes.bitangent)\r\n  ) {\r\n    Matrix4.inverse(modelMatrix, inverseTranspose);\r\n    Matrix4.transpose(inverseTranspose, inverseTranspose);\r\n    Matrix4.getMatrix3(inverseTranspose, normalMatrix);\r\n\r\n    transformVector(normalMatrix, attributes.normal);\r\n    transformVector(normalMatrix, attributes.tangent);\r\n    transformVector(normalMatrix, attributes.bitangent);\r\n  }\r\n\r\n  const boundingSphere = instance.geometry.boundingSphere;\r\n  if (defined(boundingSphere)) {\r\n    instance.geometry.boundingSphere = BoundingSphere.transform(\r\n      boundingSphere,\r\n      modelMatrix,\r\n      boundingSphere\r\n    );\r\n  }\r\n\r\n  instance.modelMatrix = Matrix4.clone(Matrix4.IDENTITY);\r\n\r\n  return instance;\r\n};\r\n\r\nfunction findAttributesInAllGeometries(instances, propertyName) {\r\n  const length = instances.length;\r\n\r\n  const attributesInAllGeometries = {};\r\n\r\n  const attributes0 = instances[0][propertyName].attributes;\r\n  let name;\r\n\r\n  for (name in attributes0) {\r\n    if (\r\n      attributes0.hasOwnProperty(name) &&\r\n      defined(attributes0[name]) &&\r\n      defined(attributes0[name].values)\r\n    ) {\r\n      const attribute = attributes0[name];\r\n      let numberOfComponents = attribute.values.length;\r\n      let inAllGeometries = true;\r\n\r\n      // Does this same attribute exist in all geometries?\r\n      for (let i = 1; i < length; ++i) {\r\n        const otherAttribute = instances[i][propertyName].attributes[name];\r\n\r\n        if (\r\n          !defined(otherAttribute) ||\r\n          attribute.componentDatatype !== otherAttribute.componentDatatype ||\r\n          attribute.componentsPerAttribute !==\r\n            otherAttribute.componentsPerAttribute ||\r\n          attribute.normalize !== otherAttribute.normalize\r\n        ) {\r\n          inAllGeometries = false;\r\n          break;\r\n        }\r\n\r\n        numberOfComponents += otherAttribute.values.length;\r\n      }\r\n\r\n      if (inAllGeometries) {\r\n        attributesInAllGeometries[name] = new GeometryAttribute({\r\n          componentDatatype: attribute.componentDatatype,\r\n          componentsPerAttribute: attribute.componentsPerAttribute,\r\n          normalize: attribute.normalize,\r\n          values: ComponentDatatype.createTypedArray(\r\n            attribute.componentDatatype,\r\n            numberOfComponents\r\n          ),\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  return attributesInAllGeometries;\r\n}\r\n\r\nconst tempScratch = new Cartesian3();\r\n\r\nfunction combineGeometries(instances, propertyName) {\r\n  const length = instances.length;\r\n\r\n  let name;\r\n  let i;\r\n  let j;\r\n  let k;\r\n\r\n  const m = instances[0].modelMatrix;\r\n  const haveIndices = defined(instances[0][propertyName].indices);\r\n  const primitiveType = instances[0][propertyName].primitiveType;\r\n\r\n  //>>includeStart('debug', pragmas.debug);\r\n  for (i = 1; i < length; ++i) {\r\n    if (!Matrix4.equals(instances[i].modelMatrix, m)) {\r\n      throw new DeveloperError(\"All instances must have the same modelMatrix.\");\r\n    }\r\n    if (defined(instances[i][propertyName].indices) !== haveIndices) {\r\n      throw new DeveloperError(\r\n        \"All instance geometries must have an indices or not have one.\"\r\n      );\r\n    }\r\n    if (instances[i][propertyName].primitiveType !== primitiveType) {\r\n      throw new DeveloperError(\r\n        \"All instance geometries must have the same primitiveType.\"\r\n      );\r\n    }\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  // Find subset of attributes in all geometries\r\n  const attributes = findAttributesInAllGeometries(instances, propertyName);\r\n  let values;\r\n  let sourceValues;\r\n  let sourceValuesLength;\r\n\r\n  // Combine attributes from each geometry into a single typed array\r\n  for (name in attributes) {\r\n    if (attributes.hasOwnProperty(name)) {\r\n      values = attributes[name].values;\r\n\r\n      k = 0;\r\n      for (i = 0; i < length; ++i) {\r\n        sourceValues = instances[i][propertyName].attributes[name].values;\r\n        sourceValuesLength = sourceValues.length;\r\n\r\n        for (j = 0; j < sourceValuesLength; ++j) {\r\n          values[k++] = sourceValues[j];\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Combine index lists\r\n  let indices;\r\n\r\n  if (haveIndices) {\r\n    let numberOfIndices = 0;\r\n    for (i = 0; i < length; ++i) {\r\n      numberOfIndices += instances[i][propertyName].indices.length;\r\n    }\r\n\r\n    const numberOfVertices = Geometry.computeNumberOfVertices(\r\n      new Geometry({\r\n        attributes: attributes,\r\n        primitiveType: PrimitiveType.POINTS,\r\n      })\r\n    );\r\n    const destIndices = IndexDatatype.createTypedArray(\r\n      numberOfVertices,\r\n      numberOfIndices\r\n    );\r\n\r\n    let destOffset = 0;\r\n    let offset = 0;\r\n\r\n    for (i = 0; i < length; ++i) {\r\n      const sourceIndices = instances[i][propertyName].indices;\r\n      const sourceIndicesLen = sourceIndices.length;\r\n\r\n      for (k = 0; k < sourceIndicesLen; ++k) {\r\n        destIndices[destOffset++] = offset + sourceIndices[k];\r\n      }\r\n\r\n      offset += Geometry.computeNumberOfVertices(instances[i][propertyName]);\r\n    }\r\n\r\n    indices = destIndices;\r\n  }\r\n\r\n  // Create bounding sphere that includes all instances\r\n  let center = new Cartesian3();\r\n  let radius = 0.0;\r\n  let bs;\r\n\r\n  for (i = 0; i < length; ++i) {\r\n    bs = instances[i][propertyName].boundingSphere;\r\n    if (!defined(bs)) {\r\n      // If any geometries have an undefined bounding sphere, then so does the combined geometry\r\n      center = undefined;\r\n      break;\r\n    }\r\n\r\n    Cartesian3.add(bs.center, center, center);\r\n  }\r\n\r\n  if (defined(center)) {\r\n    Cartesian3.divideByScalar(center, length, center);\r\n\r\n    for (i = 0; i < length; ++i) {\r\n      bs = instances[i][propertyName].boundingSphere;\r\n      const tempRadius =\r\n        Cartesian3.magnitude(\r\n          Cartesian3.subtract(bs.center, center, tempScratch)\r\n        ) + bs.radius;\r\n\r\n      if (tempRadius > radius) {\r\n        radius = tempRadius;\r\n      }\r\n    }\r\n  }\r\n\r\n  return new Geometry({\r\n    attributes: attributes,\r\n    indices: indices,\r\n    primitiveType: primitiveType,\r\n    boundingSphere: defined(center)\r\n      ? new BoundingSphere(center, radius)\r\n      : undefined,\r\n  });\r\n}\r\n\r\n/**\r\n * Combines geometry from several {@link GeometryInstance} objects into one geometry.\r\n * This concatenates the attributes, concatenates and adjusts the indices, and creates\r\n * a bounding sphere encompassing all instances.\r\n * <p>\r\n * If the instances do not have the same attributes, a subset of attributes common\r\n * to all instances is used, and the others are ignored.\r\n * </p>\r\n * <p>\r\n * This is used by {@link Primitive} to efficiently render a large amount of static data.\r\n * </p>\r\n *\r\n * @private\r\n *\r\n * @param {GeometryInstance[]} [instances] The array of {@link GeometryInstance} objects whose geometry will be combined.\r\n * @returns {Geometry} A single geometry created from the provided geometry instances.\r\n *\r\n * @exception {DeveloperError} All instances must have the same modelMatrix.\r\n * @exception {DeveloperError} All instance geometries must have an indices or not have one.\r\n * @exception {DeveloperError} All instance geometries must have the same primitiveType.\r\n *\r\n *\r\n * @example\r\n * for (let i = 0; i < instances.length; ++i) {\r\n *   Cesium.GeometryPipeline.transformToWorldCoordinates(instances[i]);\r\n * }\r\n * const geometries = Cesium.GeometryPipeline.combineInstances(instances);\r\n *\r\n * @see GeometryPipeline.transformToWorldCoordinates\r\n */\r\nGeometryPipeline.combineInstances = function (instances) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(instances) || instances.length < 1) {\r\n    throw new DeveloperError(\r\n      \"instances is required and must have length greater than zero.\"\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const instanceGeometry = [];\r\n  const instanceSplitGeometry = [];\r\n  const length = instances.length;\r\n  for (let i = 0; i < length; ++i) {\r\n    const instance = instances[i];\r\n\r\n    if (defined(instance.geometry)) {\r\n      instanceGeometry.push(instance);\r\n    } else if (\r\n      defined(instance.westHemisphereGeometry) &&\r\n      defined(instance.eastHemisphereGeometry)\r\n    ) {\r\n      instanceSplitGeometry.push(instance);\r\n    }\r\n  }\r\n\r\n  const geometries = [];\r\n  if (instanceGeometry.length > 0) {\r\n    geometries.push(combineGeometries(instanceGeometry, \"geometry\"));\r\n  }\r\n\r\n  if (instanceSplitGeometry.length > 0) {\r\n    geometries.push(\r\n      combineGeometries(instanceSplitGeometry, \"westHemisphereGeometry\")\r\n    );\r\n    geometries.push(\r\n      combineGeometries(instanceSplitGeometry, \"eastHemisphereGeometry\")\r\n    );\r\n  }\r\n\r\n  return geometries;\r\n};\r\n\r\nconst normal = new Cartesian3();\r\nconst v0 = new Cartesian3();\r\nconst v1 = new Cartesian3();\r\nconst v2 = new Cartesian3();\r\n\r\n/**\r\n * Computes per-vertex normals for a geometry containing <code>TRIANGLES</code> by averaging the normals of\r\n * all triangles incident to the vertex.  The result is a new <code>normal</code> attribute added to the geometry.\r\n * This assumes a counter-clockwise winding order.\r\n *\r\n * @param {Geometry} geometry The geometry to modify.\r\n * @returns {Geometry} The modified <code>geometry</code> argument with the computed <code>normal</code> attribute.\r\n *\r\n * @exception {DeveloperError} geometry.indices length must be greater than 0 and be a multiple of 3.\r\n * @exception {DeveloperError} geometry.primitiveType must be {@link PrimitiveType.TRIANGLES}.\r\n *\r\n * @example\r\n * Cesium.GeometryPipeline.computeNormal(geometry);\r\n */\r\nGeometryPipeline.computeNormal = function (geometry) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(geometry)) {\r\n    throw new DeveloperError(\"geometry is required.\");\r\n  }\r\n  if (\r\n    !defined(geometry.attributes.position) ||\r\n    !defined(geometry.attributes.position.values)\r\n  ) {\r\n    throw new DeveloperError(\r\n      \"geometry.attributes.position.values is required.\"\r\n    );\r\n  }\r\n  if (!defined(geometry.indices)) {\r\n    throw new DeveloperError(\"geometry.indices is required.\");\r\n  }\r\n  if (geometry.indices.length < 2 || geometry.indices.length % 3 !== 0) {\r\n    throw new DeveloperError(\r\n      \"geometry.indices length must be greater than 0 and be a multiple of 3.\"\r\n    );\r\n  }\r\n  if (geometry.primitiveType !== PrimitiveType.TRIANGLES) {\r\n    throw new DeveloperError(\r\n      \"geometry.primitiveType must be PrimitiveType.TRIANGLES.\"\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const indices = geometry.indices;\r\n  const attributes = geometry.attributes;\r\n  const vertices = attributes.position.values;\r\n  const numVertices = attributes.position.values.length / 3;\r\n  const numIndices = indices.length;\r\n  const normalsPerVertex = new Array(numVertices);\r\n  const normalsPerTriangle = new Array(numIndices / 3);\r\n  const normalIndices = new Array(numIndices);\r\n  let i;\r\n  for (i = 0; i < numVertices; i++) {\r\n    normalsPerVertex[i] = {\r\n      indexOffset: 0,\r\n      count: 0,\r\n      currentCount: 0,\r\n    };\r\n  }\r\n\r\n  let j = 0;\r\n  for (i = 0; i < numIndices; i += 3) {\r\n    const i0 = indices[i];\r\n    const i1 = indices[i + 1];\r\n    const i2 = indices[i + 2];\r\n    const i03 = i0 * 3;\r\n    const i13 = i1 * 3;\r\n    const i23 = i2 * 3;\r\n\r\n    v0.x = vertices[i03];\r\n    v0.y = vertices[i03 + 1];\r\n    v0.z = vertices[i03 + 2];\r\n    v1.x = vertices[i13];\r\n    v1.y = vertices[i13 + 1];\r\n    v1.z = vertices[i13 + 2];\r\n    v2.x = vertices[i23];\r\n    v2.y = vertices[i23 + 1];\r\n    v2.z = vertices[i23 + 2];\r\n\r\n    normalsPerVertex[i0].count++;\r\n    normalsPerVertex[i1].count++;\r\n    normalsPerVertex[i2].count++;\r\n\r\n    Cartesian3.subtract(v1, v0, v1);\r\n    Cartesian3.subtract(v2, v0, v2);\r\n    normalsPerTriangle[j] = Cartesian3.cross(v1, v2, new Cartesian3());\r\n    j++;\r\n  }\r\n\r\n  let indexOffset = 0;\r\n  for (i = 0; i < numVertices; i++) {\r\n    normalsPerVertex[i].indexOffset += indexOffset;\r\n    indexOffset += normalsPerVertex[i].count;\r\n  }\r\n\r\n  j = 0;\r\n  let vertexNormalData;\r\n  for (i = 0; i < numIndices; i += 3) {\r\n    vertexNormalData = normalsPerVertex[indices[i]];\r\n    let index = vertexNormalData.indexOffset + vertexNormalData.currentCount;\r\n    normalIndices[index] = j;\r\n    vertexNormalData.currentCount++;\r\n\r\n    vertexNormalData = normalsPerVertex[indices[i + 1]];\r\n    index = vertexNormalData.indexOffset + vertexNormalData.currentCount;\r\n    normalIndices[index] = j;\r\n    vertexNormalData.currentCount++;\r\n\r\n    vertexNormalData = normalsPerVertex[indices[i + 2]];\r\n    index = vertexNormalData.indexOffset + vertexNormalData.currentCount;\r\n    normalIndices[index] = j;\r\n    vertexNormalData.currentCount++;\r\n\r\n    j++;\r\n  }\r\n\r\n  const normalValues = new Float32Array(numVertices * 3);\r\n  for (i = 0; i < numVertices; i++) {\r\n    const i3 = i * 3;\r\n    vertexNormalData = normalsPerVertex[i];\r\n    Cartesian3.clone(Cartesian3.ZERO, normal);\r\n    if (vertexNormalData.count > 0) {\r\n      for (j = 0; j < vertexNormalData.count; j++) {\r\n        Cartesian3.add(\r\n          normal,\r\n          normalsPerTriangle[normalIndices[vertexNormalData.indexOffset + j]],\r\n          normal\r\n        );\r\n      }\r\n\r\n      // We can run into an issue where a vertex is used with 2 primitives that have opposite winding order.\r\n      if (\r\n        Cartesian3.equalsEpsilon(Cartesian3.ZERO, normal, CesiumMath.EPSILON10)\r\n      ) {\r\n        Cartesian3.clone(\r\n          normalsPerTriangle[normalIndices[vertexNormalData.indexOffset]],\r\n          normal\r\n        );\r\n      }\r\n    }\r\n\r\n    // We end up with a zero vector probably because of a degenerate triangle\r\n    if (\r\n      Cartesian3.equalsEpsilon(Cartesian3.ZERO, normal, CesiumMath.EPSILON10)\r\n    ) {\r\n      // Default to (0,0,1)\r\n      normal.z = 1.0;\r\n    }\r\n\r\n    Cartesian3.normalize(normal, normal);\r\n    normalValues[i3] = normal.x;\r\n    normalValues[i3 + 1] = normal.y;\r\n    normalValues[i3 + 2] = normal.z;\r\n  }\r\n\r\n  geometry.attributes.normal = new GeometryAttribute({\r\n    componentDatatype: ComponentDatatype.FLOAT,\r\n    componentsPerAttribute: 3,\r\n    values: normalValues,\r\n  });\r\n\r\n  return geometry;\r\n};\r\n\r\nconst normalScratch = new Cartesian3();\r\nconst normalScale = new Cartesian3();\r\nconst tScratch = new Cartesian3();\r\n\r\n/**\r\n * Computes per-vertex tangents and bitangents for a geometry containing <code>TRIANGLES</code>.\r\n * The result is new <code>tangent</code> and <code>bitangent</code> attributes added to the geometry.\r\n * This assumes a counter-clockwise winding order.\r\n * <p>\r\n * Based on <a href=\"http://www.terathon.com/code/tangent.html\">Computing Tangent Space Basis Vectors\r\n * for an Arbitrary Mesh</a> by Eric Lengyel.\r\n * </p>\r\n *\r\n * @param {Geometry} geometry The geometry to modify.\r\n * @returns {Geometry} The modified <code>geometry</code> argument with the computed <code>tangent</code> and <code>bitangent</code> attributes.\r\n *\r\n * @exception {DeveloperError} geometry.indices length must be greater than 0 and be a multiple of 3.\r\n * @exception {DeveloperError} geometry.primitiveType must be {@link PrimitiveType.TRIANGLES}.\r\n *\r\n * @example\r\n * Cesium.GeometryPipeline.computeTangentAndBiTangent(geometry);\r\n */\r\nGeometryPipeline.computeTangentAndBitangent = function (geometry) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(geometry)) {\r\n    throw new DeveloperError(\"geometry is required.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const attributes = geometry.attributes;\r\n  const indices = geometry.indices;\r\n\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(attributes.position) || !defined(attributes.position.values)) {\r\n    throw new DeveloperError(\r\n      \"geometry.attributes.position.values is required.\"\r\n    );\r\n  }\r\n  if (!defined(attributes.normal) || !defined(attributes.normal.values)) {\r\n    throw new DeveloperError(\"geometry.attributes.normal.values is required.\");\r\n  }\r\n  if (!defined(attributes.st) || !defined(attributes.st.values)) {\r\n    throw new DeveloperError(\"geometry.attributes.st.values is required.\");\r\n  }\r\n  if (!defined(indices)) {\r\n    throw new DeveloperError(\"geometry.indices is required.\");\r\n  }\r\n  if (indices.length < 2 || indices.length % 3 !== 0) {\r\n    throw new DeveloperError(\r\n      \"geometry.indices length must be greater than 0 and be a multiple of 3.\"\r\n    );\r\n  }\r\n  if (geometry.primitiveType !== PrimitiveType.TRIANGLES) {\r\n    throw new DeveloperError(\r\n      \"geometry.primitiveType must be PrimitiveType.TRIANGLES.\"\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const vertices = geometry.attributes.position.values;\r\n  const normals = geometry.attributes.normal.values;\r\n  const st = geometry.attributes.st.values;\r\n\r\n  const numVertices = geometry.attributes.position.values.length / 3;\r\n  const numIndices = indices.length;\r\n  const tan1 = new Array(numVertices * 3);\r\n\r\n  let i;\r\n  for (i = 0; i < tan1.length; i++) {\r\n    tan1[i] = 0;\r\n  }\r\n\r\n  let i03;\r\n  let i13;\r\n  let i23;\r\n  for (i = 0; i < numIndices; i += 3) {\r\n    const i0 = indices[i];\r\n    const i1 = indices[i + 1];\r\n    const i2 = indices[i + 2];\r\n    i03 = i0 * 3;\r\n    i13 = i1 * 3;\r\n    i23 = i2 * 3;\r\n    const i02 = i0 * 2;\r\n    const i12 = i1 * 2;\r\n    const i22 = i2 * 2;\r\n\r\n    const ux = vertices[i03];\r\n    const uy = vertices[i03 + 1];\r\n    const uz = vertices[i03 + 2];\r\n\r\n    const wx = st[i02];\r\n    const wy = st[i02 + 1];\r\n    const t1 = st[i12 + 1] - wy;\r\n    const t2 = st[i22 + 1] - wy;\r\n\r\n    const r = 1.0 / ((st[i12] - wx) * t2 - (st[i22] - wx) * t1);\r\n    const sdirx = (t2 * (vertices[i13] - ux) - t1 * (vertices[i23] - ux)) * r;\r\n    const sdiry =\r\n      (t2 * (vertices[i13 + 1] - uy) - t1 * (vertices[i23 + 1] - uy)) * r;\r\n    const sdirz =\r\n      (t2 * (vertices[i13 + 2] - uz) - t1 * (vertices[i23 + 2] - uz)) * r;\r\n\r\n    tan1[i03] += sdirx;\r\n    tan1[i03 + 1] += sdiry;\r\n    tan1[i03 + 2] += sdirz;\r\n\r\n    tan1[i13] += sdirx;\r\n    tan1[i13 + 1] += sdiry;\r\n    tan1[i13 + 2] += sdirz;\r\n\r\n    tan1[i23] += sdirx;\r\n    tan1[i23 + 1] += sdiry;\r\n    tan1[i23 + 2] += sdirz;\r\n  }\r\n\r\n  const tangentValues = new Float32Array(numVertices * 3);\r\n  const bitangentValues = new Float32Array(numVertices * 3);\r\n\r\n  for (i = 0; i < numVertices; i++) {\r\n    i03 = i * 3;\r\n    i13 = i03 + 1;\r\n    i23 = i03 + 2;\r\n\r\n    const n = Cartesian3.fromArray(normals, i03, normalScratch);\r\n    const t = Cartesian3.fromArray(tan1, i03, tScratch);\r\n    const scalar = Cartesian3.dot(n, t);\r\n    Cartesian3.multiplyByScalar(n, scalar, normalScale);\r\n    Cartesian3.normalize(Cartesian3.subtract(t, normalScale, t), t);\r\n\r\n    tangentValues[i03] = t.x;\r\n    tangentValues[i13] = t.y;\r\n    tangentValues[i23] = t.z;\r\n\r\n    Cartesian3.normalize(Cartesian3.cross(n, t, t), t);\r\n\r\n    bitangentValues[i03] = t.x;\r\n    bitangentValues[i13] = t.y;\r\n    bitangentValues[i23] = t.z;\r\n  }\r\n\r\n  geometry.attributes.tangent = new GeometryAttribute({\r\n    componentDatatype: ComponentDatatype.FLOAT,\r\n    componentsPerAttribute: 3,\r\n    values: tangentValues,\r\n  });\r\n\r\n  geometry.attributes.bitangent = new GeometryAttribute({\r\n    componentDatatype: ComponentDatatype.FLOAT,\r\n    componentsPerAttribute: 3,\r\n    values: bitangentValues,\r\n  });\r\n\r\n  return geometry;\r\n};\r\n\r\nconst scratchCartesian2 = new Cartesian2();\r\nconst toEncode1 = new Cartesian3();\r\nconst toEncode2 = new Cartesian3();\r\nconst toEncode3 = new Cartesian3();\r\nlet encodeResult2 = new Cartesian2();\r\n/**\r\n * Compresses and packs geometry normal attribute values to save memory.\r\n *\r\n * @param {Geometry} geometry The geometry to modify.\r\n * @returns {Geometry} The modified <code>geometry</code> argument, with its normals compressed and packed.\r\n *\r\n * @example\r\n * geometry = Cesium.GeometryPipeline.compressVertices(geometry);\r\n */\r\nGeometryPipeline.compressVertices = function (geometry) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(geometry)) {\r\n    throw new DeveloperError(\"geometry is required.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const extrudeAttribute = geometry.attributes.extrudeDirection;\r\n  let i;\r\n  let numVertices;\r\n  if (defined(extrudeAttribute)) {\r\n    //only shadow volumes use extrudeDirection, and shadow volumes use vertexFormat: POSITION_ONLY so we don't need to check other attributes\r\n    const extrudeDirections = extrudeAttribute.values;\r\n    numVertices = extrudeDirections.length / 3.0;\r\n    const compressedDirections = new Float32Array(numVertices * 2);\r\n\r\n    let i2 = 0;\r\n    for (i = 0; i < numVertices; ++i) {\r\n      Cartesian3.fromArray(extrudeDirections, i * 3.0, toEncode1);\r\n      if (Cartesian3.equals(toEncode1, Cartesian3.ZERO)) {\r\n        i2 += 2;\r\n        continue;\r\n      }\r\n      encodeResult2 = AttributeCompression.octEncodeInRange(\r\n        toEncode1,\r\n        65535,\r\n        encodeResult2\r\n      );\r\n      compressedDirections[i2++] = encodeResult2.x;\r\n      compressedDirections[i2++] = encodeResult2.y;\r\n    }\r\n\r\n    geometry.attributes.compressedAttributes = new GeometryAttribute({\r\n      componentDatatype: ComponentDatatype.FLOAT,\r\n      componentsPerAttribute: 2,\r\n      values: compressedDirections,\r\n    });\r\n    delete geometry.attributes.extrudeDirection;\r\n    return geometry;\r\n  }\r\n\r\n  const normalAttribute = geometry.attributes.normal;\r\n  const stAttribute = geometry.attributes.st;\r\n\r\n  const hasNormal = defined(normalAttribute);\r\n  const hasSt = defined(stAttribute);\r\n  if (!hasNormal && !hasSt) {\r\n    return geometry;\r\n  }\r\n\r\n  const tangentAttribute = geometry.attributes.tangent;\r\n  const bitangentAttribute = geometry.attributes.bitangent;\r\n\r\n  const hasTangent = defined(tangentAttribute);\r\n  const hasBitangent = defined(bitangentAttribute);\r\n\r\n  let normals;\r\n  let st;\r\n  let tangents;\r\n  let bitangents;\r\n\r\n  if (hasNormal) {\r\n    normals = normalAttribute.values;\r\n  }\r\n  if (hasSt) {\r\n    st = stAttribute.values;\r\n  }\r\n  if (hasTangent) {\r\n    tangents = tangentAttribute.values;\r\n  }\r\n  if (hasBitangent) {\r\n    bitangents = bitangentAttribute.values;\r\n  }\r\n\r\n  const length = hasNormal ? normals.length : st.length;\r\n  const numComponents = hasNormal ? 3.0 : 2.0;\r\n  numVertices = length / numComponents;\r\n\r\n  let compressedLength = numVertices;\r\n  let numCompressedComponents = hasSt && hasNormal ? 2.0 : 1.0;\r\n  numCompressedComponents += hasTangent || hasBitangent ? 1.0 : 0.0;\r\n  compressedLength *= numCompressedComponents;\r\n\r\n  const compressedAttributes = new Float32Array(compressedLength);\r\n\r\n  let normalIndex = 0;\r\n  for (i = 0; i < numVertices; ++i) {\r\n    if (hasSt) {\r\n      Cartesian2.fromArray(st, i * 2.0, scratchCartesian2);\r\n      compressedAttributes[\r\n        normalIndex++\r\n      ] = AttributeCompression.compressTextureCoordinates(scratchCartesian2);\r\n    }\r\n\r\n    const index = i * 3.0;\r\n    if (hasNormal && defined(tangents) && defined(bitangents)) {\r\n      Cartesian3.fromArray(normals, index, toEncode1);\r\n      Cartesian3.fromArray(tangents, index, toEncode2);\r\n      Cartesian3.fromArray(bitangents, index, toEncode3);\r\n\r\n      AttributeCompression.octPack(\r\n        toEncode1,\r\n        toEncode2,\r\n        toEncode3,\r\n        scratchCartesian2\r\n      );\r\n      compressedAttributes[normalIndex++] = scratchCartesian2.x;\r\n      compressedAttributes[normalIndex++] = scratchCartesian2.y;\r\n    } else {\r\n      if (hasNormal) {\r\n        Cartesian3.fromArray(normals, index, toEncode1);\r\n        compressedAttributes[\r\n          normalIndex++\r\n        ] = AttributeCompression.octEncodeFloat(toEncode1);\r\n      }\r\n\r\n      if (hasTangent) {\r\n        Cartesian3.fromArray(tangents, index, toEncode1);\r\n        compressedAttributes[\r\n          normalIndex++\r\n        ] = AttributeCompression.octEncodeFloat(toEncode1);\r\n      }\r\n\r\n      if (hasBitangent) {\r\n        Cartesian3.fromArray(bitangents, index, toEncode1);\r\n        compressedAttributes[\r\n          normalIndex++\r\n        ] = AttributeCompression.octEncodeFloat(toEncode1);\r\n      }\r\n    }\r\n  }\r\n\r\n  geometry.attributes.compressedAttributes = new GeometryAttribute({\r\n    componentDatatype: ComponentDatatype.FLOAT,\r\n    componentsPerAttribute: numCompressedComponents,\r\n    values: compressedAttributes,\r\n  });\r\n\r\n  if (hasNormal) {\r\n    delete geometry.attributes.normal;\r\n  }\r\n  if (hasSt) {\r\n    delete geometry.attributes.st;\r\n  }\r\n  if (hasBitangent) {\r\n    delete geometry.attributes.bitangent;\r\n  }\r\n  if (hasTangent) {\r\n    delete geometry.attributes.tangent;\r\n  }\r\n\r\n  return geometry;\r\n};\r\n\r\nfunction indexTriangles(geometry) {\r\n  if (defined(geometry.indices)) {\r\n    return geometry;\r\n  }\r\n  const numberOfVertices = Geometry.computeNumberOfVertices(geometry);\r\n\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (numberOfVertices < 3) {\r\n    throw new DeveloperError(\"The number of vertices must be at least three.\");\r\n  }\r\n  if (numberOfVertices % 3 !== 0) {\r\n    throw new DeveloperError(\r\n      \"The number of vertices must be a multiple of three.\"\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const indices = IndexDatatype.createTypedArray(\r\n    numberOfVertices,\r\n    numberOfVertices\r\n  );\r\n  for (let i = 0; i < numberOfVertices; ++i) {\r\n    indices[i] = i;\r\n  }\r\n\r\n  geometry.indices = indices;\r\n  return geometry;\r\n}\r\n\r\nfunction indexTriangleFan(geometry) {\r\n  const numberOfVertices = Geometry.computeNumberOfVertices(geometry);\r\n\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (numberOfVertices < 3) {\r\n    throw new DeveloperError(\"The number of vertices must be at least three.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const indices = IndexDatatype.createTypedArray(\r\n    numberOfVertices,\r\n    (numberOfVertices - 2) * 3\r\n  );\r\n  indices[0] = 1;\r\n  indices[1] = 0;\r\n  indices[2] = 2;\r\n\r\n  let indicesIndex = 3;\r\n  for (let i = 3; i < numberOfVertices; ++i) {\r\n    indices[indicesIndex++] = i - 1;\r\n    indices[indicesIndex++] = 0;\r\n    indices[indicesIndex++] = i;\r\n  }\r\n\r\n  geometry.indices = indices;\r\n  geometry.primitiveType = PrimitiveType.TRIANGLES;\r\n  return geometry;\r\n}\r\n\r\nfunction indexTriangleStrip(geometry) {\r\n  const numberOfVertices = Geometry.computeNumberOfVertices(geometry);\r\n\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (numberOfVertices < 3) {\r\n    throw new DeveloperError(\"The number of vertices must be at least 3.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const indices = IndexDatatype.createTypedArray(\r\n    numberOfVertices,\r\n    (numberOfVertices - 2) * 3\r\n  );\r\n  indices[0] = 0;\r\n  indices[1] = 1;\r\n  indices[2] = 2;\r\n\r\n  if (numberOfVertices > 3) {\r\n    indices[3] = 0;\r\n    indices[4] = 2;\r\n    indices[5] = 3;\r\n  }\r\n\r\n  let indicesIndex = 6;\r\n  for (let i = 3; i < numberOfVertices - 1; i += 2) {\r\n    indices[indicesIndex++] = i;\r\n    indices[indicesIndex++] = i - 1;\r\n    indices[indicesIndex++] = i + 1;\r\n\r\n    if (i + 2 < numberOfVertices) {\r\n      indices[indicesIndex++] = i;\r\n      indices[indicesIndex++] = i + 1;\r\n      indices[indicesIndex++] = i + 2;\r\n    }\r\n  }\r\n\r\n  geometry.indices = indices;\r\n  geometry.primitiveType = PrimitiveType.TRIANGLES;\r\n  return geometry;\r\n}\r\n\r\nfunction indexLines(geometry) {\r\n  if (defined(geometry.indices)) {\r\n    return geometry;\r\n  }\r\n  const numberOfVertices = Geometry.computeNumberOfVertices(geometry);\r\n\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (numberOfVertices < 2) {\r\n    throw new DeveloperError(\"The number of vertices must be at least two.\");\r\n  }\r\n  if (numberOfVertices % 2 !== 0) {\r\n    throw new DeveloperError(\"The number of vertices must be a multiple of 2.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const indices = IndexDatatype.createTypedArray(\r\n    numberOfVertices,\r\n    numberOfVertices\r\n  );\r\n  for (let i = 0; i < numberOfVertices; ++i) {\r\n    indices[i] = i;\r\n  }\r\n\r\n  geometry.indices = indices;\r\n  return geometry;\r\n}\r\n\r\nfunction indexLineStrip(geometry) {\r\n  const numberOfVertices = Geometry.computeNumberOfVertices(geometry);\r\n\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (numberOfVertices < 2) {\r\n    throw new DeveloperError(\"The number of vertices must be at least two.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const indices = IndexDatatype.createTypedArray(\r\n    numberOfVertices,\r\n    (numberOfVertices - 1) * 2\r\n  );\r\n  indices[0] = 0;\r\n  indices[1] = 1;\r\n  let indicesIndex = 2;\r\n  for (let i = 2; i < numberOfVertices; ++i) {\r\n    indices[indicesIndex++] = i - 1;\r\n    indices[indicesIndex++] = i;\r\n  }\r\n\r\n  geometry.indices = indices;\r\n  geometry.primitiveType = PrimitiveType.LINES;\r\n  return geometry;\r\n}\r\n\r\nfunction indexLineLoop(geometry) {\r\n  const numberOfVertices = Geometry.computeNumberOfVertices(geometry);\r\n\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (numberOfVertices < 2) {\r\n    throw new DeveloperError(\"The number of vertices must be at least two.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const indices = IndexDatatype.createTypedArray(\r\n    numberOfVertices,\r\n    numberOfVertices * 2\r\n  );\r\n\r\n  indices[0] = 0;\r\n  indices[1] = 1;\r\n\r\n  let indicesIndex = 2;\r\n  for (let i = 2; i < numberOfVertices; ++i) {\r\n    indices[indicesIndex++] = i - 1;\r\n    indices[indicesIndex++] = i;\r\n  }\r\n\r\n  indices[indicesIndex++] = numberOfVertices - 1;\r\n  indices[indicesIndex] = 0;\r\n\r\n  geometry.indices = indices;\r\n  geometry.primitiveType = PrimitiveType.LINES;\r\n  return geometry;\r\n}\r\n\r\nfunction indexPrimitive(geometry) {\r\n  switch (geometry.primitiveType) {\r\n    case PrimitiveType.TRIANGLE_FAN:\r\n      return indexTriangleFan(geometry);\r\n    case PrimitiveType.TRIANGLE_STRIP:\r\n      return indexTriangleStrip(geometry);\r\n    case PrimitiveType.TRIANGLES:\r\n      return indexTriangles(geometry);\r\n    case PrimitiveType.LINE_STRIP:\r\n      return indexLineStrip(geometry);\r\n    case PrimitiveType.LINE_LOOP:\r\n      return indexLineLoop(geometry);\r\n    case PrimitiveType.LINES:\r\n      return indexLines(geometry);\r\n  }\r\n\r\n  return geometry;\r\n}\r\n\r\nfunction offsetPointFromXZPlane(p, isBehind) {\r\n  if (Math.abs(p.y) < CesiumMath.EPSILON6) {\r\n    if (isBehind) {\r\n      p.y = -CesiumMath.EPSILON6;\r\n    } else {\r\n      p.y = CesiumMath.EPSILON6;\r\n    }\r\n  }\r\n}\r\n\r\nfunction offsetTriangleFromXZPlane(p0, p1, p2) {\r\n  if (p0.y !== 0.0 && p1.y !== 0.0 && p2.y !== 0.0) {\r\n    offsetPointFromXZPlane(p0, p0.y < 0.0);\r\n    offsetPointFromXZPlane(p1, p1.y < 0.0);\r\n    offsetPointFromXZPlane(p2, p2.y < 0.0);\r\n    return;\r\n  }\r\n\r\n  const p0y = Math.abs(p0.y);\r\n  const p1y = Math.abs(p1.y);\r\n  const p2y = Math.abs(p2.y);\r\n\r\n  let sign;\r\n  if (p0y > p1y) {\r\n    if (p0y > p2y) {\r\n      sign = CesiumMath.sign(p0.y);\r\n    } else {\r\n      sign = CesiumMath.sign(p2.y);\r\n    }\r\n  } else if (p1y > p2y) {\r\n    sign = CesiumMath.sign(p1.y);\r\n  } else {\r\n    sign = CesiumMath.sign(p2.y);\r\n  }\r\n\r\n  const isBehind = sign < 0.0;\r\n  offsetPointFromXZPlane(p0, isBehind);\r\n  offsetPointFromXZPlane(p1, isBehind);\r\n  offsetPointFromXZPlane(p2, isBehind);\r\n}\r\n\r\nconst c3 = new Cartesian3();\r\nfunction getXZIntersectionOffsetPoints(p, p1, u1, v1) {\r\n  Cartesian3.add(\r\n    p,\r\n    Cartesian3.multiplyByScalar(\r\n      Cartesian3.subtract(p1, p, c3),\r\n      p.y / (p.y - p1.y),\r\n      c3\r\n    ),\r\n    u1\r\n  );\r\n  Cartesian3.clone(u1, v1);\r\n  offsetPointFromXZPlane(u1, true);\r\n  offsetPointFromXZPlane(v1, false);\r\n}\r\n\r\nconst u1 = new Cartesian3();\r\nconst u2 = new Cartesian3();\r\nconst q1 = new Cartesian3();\r\nconst q2 = new Cartesian3();\r\n\r\nconst splitTriangleResult = {\r\n  positions: new Array(7),\r\n  indices: new Array(3 * 3),\r\n};\r\n\r\nfunction splitTriangle(p0, p1, p2) {\r\n  // In WGS84 coordinates, for a triangle approximately on the\r\n  // ellipsoid to cross the IDL, first it needs to be on the\r\n  // negative side of the plane x = 0.\r\n  if (p0.x >= 0.0 || p1.x >= 0.0 || p2.x >= 0.0) {\r\n    return undefined;\r\n  }\r\n\r\n  offsetTriangleFromXZPlane(p0, p1, p2);\r\n\r\n  const p0Behind = p0.y < 0.0;\r\n  const p1Behind = p1.y < 0.0;\r\n  const p2Behind = p2.y < 0.0;\r\n\r\n  let numBehind = 0;\r\n  numBehind += p0Behind ? 1 : 0;\r\n  numBehind += p1Behind ? 1 : 0;\r\n  numBehind += p2Behind ? 1 : 0;\r\n\r\n  const indices = splitTriangleResult.indices;\r\n\r\n  if (numBehind === 1) {\r\n    indices[1] = 3;\r\n    indices[2] = 4;\r\n    indices[5] = 6;\r\n    indices[7] = 6;\r\n    indices[8] = 5;\r\n\r\n    if (p0Behind) {\r\n      getXZIntersectionOffsetPoints(p0, p1, u1, q1);\r\n      getXZIntersectionOffsetPoints(p0, p2, u2, q2);\r\n\r\n      indices[0] = 0;\r\n      indices[3] = 1;\r\n      indices[4] = 2;\r\n      indices[6] = 1;\r\n    } else if (p1Behind) {\r\n      getXZIntersectionOffsetPoints(p1, p2, u1, q1);\r\n      getXZIntersectionOffsetPoints(p1, p0, u2, q2);\r\n\r\n      indices[0] = 1;\r\n      indices[3] = 2;\r\n      indices[4] = 0;\r\n      indices[6] = 2;\r\n    } else if (p2Behind) {\r\n      getXZIntersectionOffsetPoints(p2, p0, u1, q1);\r\n      getXZIntersectionOffsetPoints(p2, p1, u2, q2);\r\n\r\n      indices[0] = 2;\r\n      indices[3] = 0;\r\n      indices[4] = 1;\r\n      indices[6] = 0;\r\n    }\r\n  } else if (numBehind === 2) {\r\n    indices[2] = 4;\r\n    indices[4] = 4;\r\n    indices[5] = 3;\r\n    indices[7] = 5;\r\n    indices[8] = 6;\r\n\r\n    if (!p0Behind) {\r\n      getXZIntersectionOffsetPoints(p0, p1, u1, q1);\r\n      getXZIntersectionOffsetPoints(p0, p2, u2, q2);\r\n\r\n      indices[0] = 1;\r\n      indices[1] = 2;\r\n      indices[3] = 1;\r\n      indices[6] = 0;\r\n    } else if (!p1Behind) {\r\n      getXZIntersectionOffsetPoints(p1, p2, u1, q1);\r\n      getXZIntersectionOffsetPoints(p1, p0, u2, q2);\r\n\r\n      indices[0] = 2;\r\n      indices[1] = 0;\r\n      indices[3] = 2;\r\n      indices[6] = 1;\r\n    } else if (!p2Behind) {\r\n      getXZIntersectionOffsetPoints(p2, p0, u1, q1);\r\n      getXZIntersectionOffsetPoints(p2, p1, u2, q2);\r\n\r\n      indices[0] = 0;\r\n      indices[1] = 1;\r\n      indices[3] = 0;\r\n      indices[6] = 2;\r\n    }\r\n  }\r\n\r\n  const positions = splitTriangleResult.positions;\r\n  positions[0] = p0;\r\n  positions[1] = p1;\r\n  positions[2] = p2;\r\n  positions.length = 3;\r\n\r\n  if (numBehind === 1 || numBehind === 2) {\r\n    positions[3] = u1;\r\n    positions[4] = u2;\r\n    positions[5] = q1;\r\n    positions[6] = q2;\r\n    positions.length = 7;\r\n  }\r\n\r\n  return splitTriangleResult;\r\n}\r\n\r\nfunction updateGeometryAfterSplit(geometry, computeBoundingSphere) {\r\n  const attributes = geometry.attributes;\r\n\r\n  if (attributes.position.values.length === 0) {\r\n    return undefined;\r\n  }\r\n\r\n  for (const property in attributes) {\r\n    if (\r\n      attributes.hasOwnProperty(property) &&\r\n      defined(attributes[property]) &&\r\n      defined(attributes[property].values)\r\n    ) {\r\n      const attribute = attributes[property];\r\n      attribute.values = ComponentDatatype.createTypedArray(\r\n        attribute.componentDatatype,\r\n        attribute.values\r\n      );\r\n    }\r\n  }\r\n\r\n  const numberOfVertices = Geometry.computeNumberOfVertices(geometry);\r\n  geometry.indices = IndexDatatype.createTypedArray(\r\n    numberOfVertices,\r\n    geometry.indices\r\n  );\r\n\r\n  if (computeBoundingSphere) {\r\n    geometry.boundingSphere = BoundingSphere.fromVertices(\r\n      attributes.position.values\r\n    );\r\n  }\r\n\r\n  return geometry;\r\n}\r\n\r\nfunction copyGeometryForSplit(geometry) {\r\n  const attributes = geometry.attributes;\r\n  const copiedAttributes = {};\r\n\r\n  for (const property in attributes) {\r\n    if (\r\n      attributes.hasOwnProperty(property) &&\r\n      defined(attributes[property]) &&\r\n      defined(attributes[property].values)\r\n    ) {\r\n      const attribute = attributes[property];\r\n      copiedAttributes[property] = new GeometryAttribute({\r\n        componentDatatype: attribute.componentDatatype,\r\n        componentsPerAttribute: attribute.componentsPerAttribute,\r\n        normalize: attribute.normalize,\r\n        values: [],\r\n      });\r\n    }\r\n  }\r\n\r\n  return new Geometry({\r\n    attributes: copiedAttributes,\r\n    indices: [],\r\n    primitiveType: geometry.primitiveType,\r\n  });\r\n}\r\n\r\nfunction updateInstanceAfterSplit(instance, westGeometry, eastGeometry) {\r\n  const computeBoundingSphere = defined(instance.geometry.boundingSphere);\r\n\r\n  westGeometry = updateGeometryAfterSplit(westGeometry, computeBoundingSphere);\r\n  eastGeometry = updateGeometryAfterSplit(eastGeometry, computeBoundingSphere);\r\n\r\n  if (defined(eastGeometry) && !defined(westGeometry)) {\r\n    instance.geometry = eastGeometry;\r\n  } else if (!defined(eastGeometry) && defined(westGeometry)) {\r\n    instance.geometry = westGeometry;\r\n  } else {\r\n    instance.westHemisphereGeometry = westGeometry;\r\n    instance.eastHemisphereGeometry = eastGeometry;\r\n    instance.geometry = undefined;\r\n  }\r\n}\r\n\r\nfunction generateBarycentricInterpolateFunction(\r\n  CartesianType,\r\n  numberOfComponents\r\n) {\r\n  const v0Scratch = new CartesianType();\r\n  const v1Scratch = new CartesianType();\r\n  const v2Scratch = new CartesianType();\r\n\r\n  return function (\r\n    i0,\r\n    i1,\r\n    i2,\r\n    coords,\r\n    sourceValues,\r\n    currentValues,\r\n    insertedIndex,\r\n    normalize\r\n  ) {\r\n    const v0 = CartesianType.fromArray(\r\n      sourceValues,\r\n      i0 * numberOfComponents,\r\n      v0Scratch\r\n    );\r\n    const v1 = CartesianType.fromArray(\r\n      sourceValues,\r\n      i1 * numberOfComponents,\r\n      v1Scratch\r\n    );\r\n    const v2 = CartesianType.fromArray(\r\n      sourceValues,\r\n      i2 * numberOfComponents,\r\n      v2Scratch\r\n    );\r\n\r\n    CartesianType.multiplyByScalar(v0, coords.x, v0);\r\n    CartesianType.multiplyByScalar(v1, coords.y, v1);\r\n    CartesianType.multiplyByScalar(v2, coords.z, v2);\r\n\r\n    const value = CartesianType.add(v0, v1, v0);\r\n    CartesianType.add(value, v2, value);\r\n\r\n    if (normalize) {\r\n      CartesianType.normalize(value, value);\r\n    }\r\n\r\n    CartesianType.pack(\r\n      value,\r\n      currentValues,\r\n      insertedIndex * numberOfComponents\r\n    );\r\n  };\r\n}\r\n\r\nconst interpolateAndPackCartesian4 = generateBarycentricInterpolateFunction(\r\n  Cartesian4,\r\n  4\r\n);\r\nconst interpolateAndPackCartesian3 = generateBarycentricInterpolateFunction(\r\n  Cartesian3,\r\n  3\r\n);\r\nconst interpolateAndPackCartesian2 = generateBarycentricInterpolateFunction(\r\n  Cartesian2,\r\n  2\r\n);\r\nconst interpolateAndPackBoolean = function (\r\n  i0,\r\n  i1,\r\n  i2,\r\n  coords,\r\n  sourceValues,\r\n  currentValues,\r\n  insertedIndex\r\n) {\r\n  const v1 = sourceValues[i0] * coords.x;\r\n  const v2 = sourceValues[i1] * coords.y;\r\n  const v3 = sourceValues[i2] * coords.z;\r\n  currentValues[insertedIndex] = v1 + v2 + v3 > CesiumMath.EPSILON6 ? 1 : 0;\r\n};\r\n\r\nconst p0Scratch = new Cartesian3();\r\nconst p1Scratch = new Cartesian3();\r\nconst p2Scratch = new Cartesian3();\r\nconst barycentricScratch = new Cartesian3();\r\n\r\nfunction computeTriangleAttributes(\r\n  i0,\r\n  i1,\r\n  i2,\r\n  point,\r\n  positions,\r\n  normals,\r\n  tangents,\r\n  bitangents,\r\n  texCoords,\r\n  extrudeDirections,\r\n  applyOffset,\r\n  currentAttributes,\r\n  customAttributeNames,\r\n  customAttributesLength,\r\n  allAttributes,\r\n  insertedIndex\r\n) {\r\n  if (\r\n    !defined(normals) &&\r\n    !defined(tangents) &&\r\n    !defined(bitangents) &&\r\n    !defined(texCoords) &&\r\n    !defined(extrudeDirections) &&\r\n    customAttributesLength === 0\r\n  ) {\r\n    return;\r\n  }\r\n\r\n  const p0 = Cartesian3.fromArray(positions, i0 * 3, p0Scratch);\r\n  const p1 = Cartesian3.fromArray(positions, i1 * 3, p1Scratch);\r\n  const p2 = Cartesian3.fromArray(positions, i2 * 3, p2Scratch);\r\n  const coords = barycentricCoordinates(point, p0, p1, p2, barycentricScratch);\r\n  if (!defined(coords)) {\r\n    return;\r\n  }\r\n\r\n  if (defined(normals)) {\r\n    interpolateAndPackCartesian3(\r\n      i0,\r\n      i1,\r\n      i2,\r\n      coords,\r\n      normals,\r\n      currentAttributes.normal.values,\r\n      insertedIndex,\r\n      true\r\n    );\r\n  }\r\n\r\n  if (defined(extrudeDirections)) {\r\n    const d0 = Cartesian3.fromArray(extrudeDirections, i0 * 3, p0Scratch);\r\n    const d1 = Cartesian3.fromArray(extrudeDirections, i1 * 3, p1Scratch);\r\n    const d2 = Cartesian3.fromArray(extrudeDirections, i2 * 3, p2Scratch);\r\n\r\n    Cartesian3.multiplyByScalar(d0, coords.x, d0);\r\n    Cartesian3.multiplyByScalar(d1, coords.y, d1);\r\n    Cartesian3.multiplyByScalar(d2, coords.z, d2);\r\n\r\n    let direction;\r\n    if (\r\n      !Cartesian3.equals(d0, Cartesian3.ZERO) ||\r\n      !Cartesian3.equals(d1, Cartesian3.ZERO) ||\r\n      !Cartesian3.equals(d2, Cartesian3.ZERO)\r\n    ) {\r\n      direction = Cartesian3.add(d0, d1, d0);\r\n      Cartesian3.add(direction, d2, direction);\r\n      Cartesian3.normalize(direction, direction);\r\n    } else {\r\n      direction = p0Scratch;\r\n      direction.x = 0;\r\n      direction.y = 0;\r\n      direction.z = 0;\r\n    }\r\n    Cartesian3.pack(\r\n      direction,\r\n      currentAttributes.extrudeDirection.values,\r\n      insertedIndex * 3\r\n    );\r\n  }\r\n\r\n  if (defined(applyOffset)) {\r\n    interpolateAndPackBoolean(\r\n      i0,\r\n      i1,\r\n      i2,\r\n      coords,\r\n      applyOffset,\r\n      currentAttributes.applyOffset.values,\r\n      insertedIndex\r\n    );\r\n  }\r\n\r\n  if (defined(tangents)) {\r\n    interpolateAndPackCartesian3(\r\n      i0,\r\n      i1,\r\n      i2,\r\n      coords,\r\n      tangents,\r\n      currentAttributes.tangent.values,\r\n      insertedIndex,\r\n      true\r\n    );\r\n  }\r\n\r\n  if (defined(bitangents)) {\r\n    interpolateAndPackCartesian3(\r\n      i0,\r\n      i1,\r\n      i2,\r\n      coords,\r\n      bitangents,\r\n      currentAttributes.bitangent.values,\r\n      insertedIndex,\r\n      true\r\n    );\r\n  }\r\n\r\n  if (defined(texCoords)) {\r\n    interpolateAndPackCartesian2(\r\n      i0,\r\n      i1,\r\n      i2,\r\n      coords,\r\n      texCoords,\r\n      currentAttributes.st.values,\r\n      insertedIndex\r\n    );\r\n  }\r\n\r\n  if (customAttributesLength > 0) {\r\n    for (let i = 0; i < customAttributesLength; i++) {\r\n      const attributeName = customAttributeNames[i];\r\n      genericInterpolate(\r\n        i0,\r\n        i1,\r\n        i2,\r\n        coords,\r\n        insertedIndex,\r\n        allAttributes[attributeName],\r\n        currentAttributes[attributeName]\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction genericInterpolate(\r\n  i0,\r\n  i1,\r\n  i2,\r\n  coords,\r\n  insertedIndex,\r\n  sourceAttribute,\r\n  currentAttribute\r\n) {\r\n  const componentsPerAttribute = sourceAttribute.componentsPerAttribute;\r\n  const sourceValues = sourceAttribute.values;\r\n  const currentValues = currentAttribute.values;\r\n  switch (componentsPerAttribute) {\r\n    case 4:\r\n      interpolateAndPackCartesian4(\r\n        i0,\r\n        i1,\r\n        i2,\r\n        coords,\r\n        sourceValues,\r\n        currentValues,\r\n        insertedIndex,\r\n        false\r\n      );\r\n      break;\r\n    case 3:\r\n      interpolateAndPackCartesian3(\r\n        i0,\r\n        i1,\r\n        i2,\r\n        coords,\r\n        sourceValues,\r\n        currentValues,\r\n        insertedIndex,\r\n        false\r\n      );\r\n      break;\r\n    case 2:\r\n      interpolateAndPackCartesian2(\r\n        i0,\r\n        i1,\r\n        i2,\r\n        coords,\r\n        sourceValues,\r\n        currentValues,\r\n        insertedIndex,\r\n        false\r\n      );\r\n      break;\r\n    default:\r\n      currentValues[insertedIndex] =\r\n        sourceValues[i0] * coords.x +\r\n        sourceValues[i1] * coords.y +\r\n        sourceValues[i2] * coords.z;\r\n  }\r\n}\r\n\r\nfunction insertSplitPoint(\r\n  currentAttributes,\r\n  currentIndices,\r\n  currentIndexMap,\r\n  indices,\r\n  currentIndex,\r\n  point\r\n) {\r\n  const insertIndex = currentAttributes.position.values.length / 3;\r\n\r\n  if (currentIndex !== -1) {\r\n    const prevIndex = indices[currentIndex];\r\n    const newIndex = currentIndexMap[prevIndex];\r\n\r\n    if (newIndex === -1) {\r\n      currentIndexMap[prevIndex] = insertIndex;\r\n      currentAttributes.position.values.push(point.x, point.y, point.z);\r\n      currentIndices.push(insertIndex);\r\n      return insertIndex;\r\n    }\r\n\r\n    currentIndices.push(newIndex);\r\n    return newIndex;\r\n  }\r\n\r\n  currentAttributes.position.values.push(point.x, point.y, point.z);\r\n  currentIndices.push(insertIndex);\r\n  return insertIndex;\r\n}\r\n\r\nconst NAMED_ATTRIBUTES = {\r\n  position: true,\r\n  normal: true,\r\n  bitangent: true,\r\n  tangent: true,\r\n  st: true,\r\n  extrudeDirection: true,\r\n  applyOffset: true,\r\n};\r\nfunction splitLongitudeTriangles(instance) {\r\n  const geometry = instance.geometry;\r\n  const attributes = geometry.attributes;\r\n  const positions = attributes.position.values;\r\n  const normals = defined(attributes.normal)\r\n    ? attributes.normal.values\r\n    : undefined;\r\n  const bitangents = defined(attributes.bitangent)\r\n    ? attributes.bitangent.values\r\n    : undefined;\r\n  const tangents = defined(attributes.tangent)\r\n    ? attributes.tangent.values\r\n    : undefined;\r\n  const texCoords = defined(attributes.st) ? attributes.st.values : undefined;\r\n  const extrudeDirections = defined(attributes.extrudeDirection)\r\n    ? attributes.extrudeDirection.values\r\n    : undefined;\r\n  const applyOffset = defined(attributes.applyOffset)\r\n    ? attributes.applyOffset.values\r\n    : undefined;\r\n  const indices = geometry.indices;\r\n\r\n  const customAttributeNames = [];\r\n  for (const attributeName in attributes) {\r\n    if (\r\n      attributes.hasOwnProperty(attributeName) &&\r\n      !NAMED_ATTRIBUTES[attributeName] &&\r\n      defined(attributes[attributeName])\r\n    ) {\r\n      customAttributeNames.push(attributeName);\r\n    }\r\n  }\r\n  const customAttributesLength = customAttributeNames.length;\r\n\r\n  const eastGeometry = copyGeometryForSplit(geometry);\r\n  const westGeometry = copyGeometryForSplit(geometry);\r\n\r\n  let currentAttributes;\r\n  let currentIndices;\r\n  let currentIndexMap;\r\n  let insertedIndex;\r\n  let i;\r\n\r\n  const westGeometryIndexMap = [];\r\n  westGeometryIndexMap.length = positions.length / 3;\r\n\r\n  const eastGeometryIndexMap = [];\r\n  eastGeometryIndexMap.length = positions.length / 3;\r\n\r\n  for (i = 0; i < westGeometryIndexMap.length; ++i) {\r\n    westGeometryIndexMap[i] = -1;\r\n    eastGeometryIndexMap[i] = -1;\r\n  }\r\n\r\n  const len = indices.length;\r\n  for (i = 0; i < len; i += 3) {\r\n    const i0 = indices[i];\r\n    const i1 = indices[i + 1];\r\n    const i2 = indices[i + 2];\r\n\r\n    let p0 = Cartesian3.fromArray(positions, i0 * 3);\r\n    let p1 = Cartesian3.fromArray(positions, i1 * 3);\r\n    let p2 = Cartesian3.fromArray(positions, i2 * 3);\r\n\r\n    const result = splitTriangle(p0, p1, p2);\r\n    if (defined(result) && result.positions.length > 3) {\r\n      const resultPositions = result.positions;\r\n      const resultIndices = result.indices;\r\n      const resultLength = resultIndices.length;\r\n\r\n      for (let j = 0; j < resultLength; ++j) {\r\n        const resultIndex = resultIndices[j];\r\n        const point = resultPositions[resultIndex];\r\n\r\n        if (point.y < 0.0) {\r\n          currentAttributes = westGeometry.attributes;\r\n          currentIndices = westGeometry.indices;\r\n          currentIndexMap = westGeometryIndexMap;\r\n        } else {\r\n          currentAttributes = eastGeometry.attributes;\r\n          currentIndices = eastGeometry.indices;\r\n          currentIndexMap = eastGeometryIndexMap;\r\n        }\r\n\r\n        insertedIndex = insertSplitPoint(\r\n          currentAttributes,\r\n          currentIndices,\r\n          currentIndexMap,\r\n          indices,\r\n          resultIndex < 3 ? i + resultIndex : -1,\r\n          point\r\n        );\r\n        computeTriangleAttributes(\r\n          i0,\r\n          i1,\r\n          i2,\r\n          point,\r\n          positions,\r\n          normals,\r\n          tangents,\r\n          bitangents,\r\n          texCoords,\r\n          extrudeDirections,\r\n          applyOffset,\r\n          currentAttributes,\r\n          customAttributeNames,\r\n          customAttributesLength,\r\n          attributes,\r\n          insertedIndex\r\n        );\r\n      }\r\n    } else {\r\n      if (defined(result)) {\r\n        p0 = result.positions[0];\r\n        p1 = result.positions[1];\r\n        p2 = result.positions[2];\r\n      }\r\n\r\n      if (p0.y < 0.0) {\r\n        currentAttributes = westGeometry.attributes;\r\n        currentIndices = westGeometry.indices;\r\n        currentIndexMap = westGeometryIndexMap;\r\n      } else {\r\n        currentAttributes = eastGeometry.attributes;\r\n        currentIndices = eastGeometry.indices;\r\n        currentIndexMap = eastGeometryIndexMap;\r\n      }\r\n\r\n      insertedIndex = insertSplitPoint(\r\n        currentAttributes,\r\n        currentIndices,\r\n        currentIndexMap,\r\n        indices,\r\n        i,\r\n        p0\r\n      );\r\n      computeTriangleAttributes(\r\n        i0,\r\n        i1,\r\n        i2,\r\n        p0,\r\n        positions,\r\n        normals,\r\n        tangents,\r\n        bitangents,\r\n        texCoords,\r\n        extrudeDirections,\r\n        applyOffset,\r\n        currentAttributes,\r\n        customAttributeNames,\r\n        customAttributesLength,\r\n        attributes,\r\n        insertedIndex\r\n      );\r\n\r\n      insertedIndex = insertSplitPoint(\r\n        currentAttributes,\r\n        currentIndices,\r\n        currentIndexMap,\r\n        indices,\r\n        i + 1,\r\n        p1\r\n      );\r\n      computeTriangleAttributes(\r\n        i0,\r\n        i1,\r\n        i2,\r\n        p1,\r\n        positions,\r\n        normals,\r\n        tangents,\r\n        bitangents,\r\n        texCoords,\r\n        extrudeDirections,\r\n        applyOffset,\r\n        currentAttributes,\r\n        customAttributeNames,\r\n        customAttributesLength,\r\n        attributes,\r\n        insertedIndex\r\n      );\r\n\r\n      insertedIndex = insertSplitPoint(\r\n        currentAttributes,\r\n        currentIndices,\r\n        currentIndexMap,\r\n        indices,\r\n        i + 2,\r\n        p2\r\n      );\r\n      computeTriangleAttributes(\r\n        i0,\r\n        i1,\r\n        i2,\r\n        p2,\r\n        positions,\r\n        normals,\r\n        tangents,\r\n        bitangents,\r\n        texCoords,\r\n        extrudeDirections,\r\n        applyOffset,\r\n        currentAttributes,\r\n        customAttributeNames,\r\n        customAttributesLength,\r\n        attributes,\r\n        insertedIndex\r\n      );\r\n    }\r\n  }\r\n\r\n  updateInstanceAfterSplit(instance, westGeometry, eastGeometry);\r\n}\r\n\r\nconst xzPlane = Plane.fromPointNormal(Cartesian3.ZERO, Cartesian3.UNIT_Y);\r\n\r\nconst offsetScratch = new Cartesian3();\r\nconst offsetPointScratch = new Cartesian3();\r\n\r\nfunction computeLineAttributes(\r\n  i0,\r\n  i1,\r\n  point,\r\n  positions,\r\n  insertIndex,\r\n  currentAttributes,\r\n  applyOffset\r\n) {\r\n  if (!defined(applyOffset)) {\r\n    return;\r\n  }\r\n\r\n  const p0 = Cartesian3.fromArray(positions, i0 * 3, p0Scratch);\r\n  if (Cartesian3.equalsEpsilon(p0, point, CesiumMath.EPSILON10)) {\r\n    currentAttributes.applyOffset.values[insertIndex] = applyOffset[i0];\r\n  } else {\r\n    currentAttributes.applyOffset.values[insertIndex] = applyOffset[i1];\r\n  }\r\n}\r\n\r\nfunction splitLongitudeLines(instance) {\r\n  const geometry = instance.geometry;\r\n  const attributes = geometry.attributes;\r\n  const positions = attributes.position.values;\r\n  const applyOffset = defined(attributes.applyOffset)\r\n    ? attributes.applyOffset.values\r\n    : undefined;\r\n  const indices = geometry.indices;\r\n\r\n  const eastGeometry = copyGeometryForSplit(geometry);\r\n  const westGeometry = copyGeometryForSplit(geometry);\r\n\r\n  let i;\r\n  const length = indices.length;\r\n\r\n  const westGeometryIndexMap = [];\r\n  westGeometryIndexMap.length = positions.length / 3;\r\n\r\n  const eastGeometryIndexMap = [];\r\n  eastGeometryIndexMap.length = positions.length / 3;\r\n\r\n  for (i = 0; i < westGeometryIndexMap.length; ++i) {\r\n    westGeometryIndexMap[i] = -1;\r\n    eastGeometryIndexMap[i] = -1;\r\n  }\r\n\r\n  for (i = 0; i < length; i += 2) {\r\n    const i0 = indices[i];\r\n    const i1 = indices[i + 1];\r\n\r\n    const p0 = Cartesian3.fromArray(positions, i0 * 3, p0Scratch);\r\n    const p1 = Cartesian3.fromArray(positions, i1 * 3, p1Scratch);\r\n    let insertIndex;\r\n\r\n    if (Math.abs(p0.y) < CesiumMath.EPSILON6) {\r\n      if (p0.y < 0.0) {\r\n        p0.y = -CesiumMath.EPSILON6;\r\n      } else {\r\n        p0.y = CesiumMath.EPSILON6;\r\n      }\r\n    }\r\n\r\n    if (Math.abs(p1.y) < CesiumMath.EPSILON6) {\r\n      if (p1.y < 0.0) {\r\n        p1.y = -CesiumMath.EPSILON6;\r\n      } else {\r\n        p1.y = CesiumMath.EPSILON6;\r\n      }\r\n    }\r\n\r\n    let p0Attributes = eastGeometry.attributes;\r\n    let p0Indices = eastGeometry.indices;\r\n    let p0IndexMap = eastGeometryIndexMap;\r\n    let p1Attributes = westGeometry.attributes;\r\n    let p1Indices = westGeometry.indices;\r\n    let p1IndexMap = westGeometryIndexMap;\r\n\r\n    const intersection = IntersectionTests.lineSegmentPlane(\r\n      p0,\r\n      p1,\r\n      xzPlane,\r\n      p2Scratch\r\n    );\r\n    if (defined(intersection)) {\r\n      // move point on the xz-plane slightly away from the plane\r\n      const offset = Cartesian3.multiplyByScalar(\r\n        Cartesian3.UNIT_Y,\r\n        5.0 * CesiumMath.EPSILON9,\r\n        offsetScratch\r\n      );\r\n      if (p0.y < 0.0) {\r\n        Cartesian3.negate(offset, offset);\r\n\r\n        p0Attributes = westGeometry.attributes;\r\n        p0Indices = westGeometry.indices;\r\n        p0IndexMap = westGeometryIndexMap;\r\n        p1Attributes = eastGeometry.attributes;\r\n        p1Indices = eastGeometry.indices;\r\n        p1IndexMap = eastGeometryIndexMap;\r\n      }\r\n\r\n      const offsetPoint = Cartesian3.add(\r\n        intersection,\r\n        offset,\r\n        offsetPointScratch\r\n      );\r\n\r\n      insertIndex = insertSplitPoint(\r\n        p0Attributes,\r\n        p0Indices,\r\n        p0IndexMap,\r\n        indices,\r\n        i,\r\n        p0\r\n      );\r\n      computeLineAttributes(\r\n        i0,\r\n        i1,\r\n        p0,\r\n        positions,\r\n        insertIndex,\r\n        p0Attributes,\r\n        applyOffset\r\n      );\r\n\r\n      insertIndex = insertSplitPoint(\r\n        p0Attributes,\r\n        p0Indices,\r\n        p0IndexMap,\r\n        indices,\r\n        -1,\r\n        offsetPoint\r\n      );\r\n      computeLineAttributes(\r\n        i0,\r\n        i1,\r\n        offsetPoint,\r\n        positions,\r\n        insertIndex,\r\n        p0Attributes,\r\n        applyOffset\r\n      );\r\n\r\n      Cartesian3.negate(offset, offset);\r\n      Cartesian3.add(intersection, offset, offsetPoint);\r\n      insertIndex = insertSplitPoint(\r\n        p1Attributes,\r\n        p1Indices,\r\n        p1IndexMap,\r\n        indices,\r\n        -1,\r\n        offsetPoint\r\n      );\r\n      computeLineAttributes(\r\n        i0,\r\n        i1,\r\n        offsetPoint,\r\n        positions,\r\n        insertIndex,\r\n        p1Attributes,\r\n        applyOffset\r\n      );\r\n\r\n      insertIndex = insertSplitPoint(\r\n        p1Attributes,\r\n        p1Indices,\r\n        p1IndexMap,\r\n        indices,\r\n        i + 1,\r\n        p1\r\n      );\r\n      computeLineAttributes(\r\n        i0,\r\n        i1,\r\n        p1,\r\n        positions,\r\n        insertIndex,\r\n        p1Attributes,\r\n        applyOffset\r\n      );\r\n    } else {\r\n      let currentAttributes;\r\n      let currentIndices;\r\n      let currentIndexMap;\r\n\r\n      if (p0.y < 0.0) {\r\n        currentAttributes = westGeometry.attributes;\r\n        currentIndices = westGeometry.indices;\r\n        currentIndexMap = westGeometryIndexMap;\r\n      } else {\r\n        currentAttributes = eastGeometry.attributes;\r\n        currentIndices = eastGeometry.indices;\r\n        currentIndexMap = eastGeometryIndexMap;\r\n      }\r\n\r\n      insertIndex = insertSplitPoint(\r\n        currentAttributes,\r\n        currentIndices,\r\n        currentIndexMap,\r\n        indices,\r\n        i,\r\n        p0\r\n      );\r\n      computeLineAttributes(\r\n        i0,\r\n        i1,\r\n        p0,\r\n        positions,\r\n        insertIndex,\r\n        currentAttributes,\r\n        applyOffset\r\n      );\r\n\r\n      insertIndex = insertSplitPoint(\r\n        currentAttributes,\r\n        currentIndices,\r\n        currentIndexMap,\r\n        indices,\r\n        i + 1,\r\n        p1\r\n      );\r\n      computeLineAttributes(\r\n        i0,\r\n        i1,\r\n        p1,\r\n        positions,\r\n        insertIndex,\r\n        currentAttributes,\r\n        applyOffset\r\n      );\r\n    }\r\n  }\r\n\r\n  updateInstanceAfterSplit(instance, westGeometry, eastGeometry);\r\n}\r\n\r\nconst cartesian2Scratch0 = new Cartesian2();\r\nconst cartesian2Scratch1 = new Cartesian2();\r\n\r\nconst cartesian3Scratch0 = new Cartesian3();\r\nconst cartesian3Scratch2 = new Cartesian3();\r\nconst cartesian3Scratch3 = new Cartesian3();\r\nconst cartesian3Scratch4 = new Cartesian3();\r\nconst cartesian3Scratch5 = new Cartesian3();\r\nconst cartesian3Scratch6 = new Cartesian3();\r\n\r\nconst cartesian4Scratch0 = new Cartesian4();\r\n\r\nfunction updateAdjacencyAfterSplit(geometry) {\r\n  const attributes = geometry.attributes;\r\n  const positions = attributes.position.values;\r\n  const prevPositions = attributes.prevPosition.values;\r\n  const nextPositions = attributes.nextPosition.values;\r\n\r\n  const length = positions.length;\r\n  for (let j = 0; j < length; j += 3) {\r\n    const position = Cartesian3.unpack(positions, j, cartesian3Scratch0);\r\n    if (position.x > 0.0) {\r\n      continue;\r\n    }\r\n\r\n    const prevPosition = Cartesian3.unpack(\r\n      prevPositions,\r\n      j,\r\n      cartesian3Scratch2\r\n    );\r\n    if (\r\n      (position.y < 0.0 && prevPosition.y > 0.0) ||\r\n      (position.y > 0.0 && prevPosition.y < 0.0)\r\n    ) {\r\n      if (j - 3 > 0) {\r\n        prevPositions[j] = positions[j - 3];\r\n        prevPositions[j + 1] = positions[j - 2];\r\n        prevPositions[j + 2] = positions[j - 1];\r\n      } else {\r\n        Cartesian3.pack(position, prevPositions, j);\r\n      }\r\n    }\r\n\r\n    const nextPosition = Cartesian3.unpack(\r\n      nextPositions,\r\n      j,\r\n      cartesian3Scratch3\r\n    );\r\n    if (\r\n      (position.y < 0.0 && nextPosition.y > 0.0) ||\r\n      (position.y > 0.0 && nextPosition.y < 0.0)\r\n    ) {\r\n      if (j + 3 < length) {\r\n        nextPositions[j] = positions[j + 3];\r\n        nextPositions[j + 1] = positions[j + 4];\r\n        nextPositions[j + 2] = positions[j + 5];\r\n      } else {\r\n        Cartesian3.pack(position, nextPositions, j);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nconst offsetScalar = 5.0 * CesiumMath.EPSILON9;\r\nconst coplanarOffset = CesiumMath.EPSILON6;\r\n\r\nfunction splitLongitudePolyline(instance) {\r\n  const geometry = instance.geometry;\r\n  const attributes = geometry.attributes;\r\n  const positions = attributes.position.values;\r\n  const prevPositions = attributes.prevPosition.values;\r\n  const nextPositions = attributes.nextPosition.values;\r\n  const expandAndWidths = attributes.expandAndWidth.values;\r\n\r\n  const texCoords = defined(attributes.st) ? attributes.st.values : undefined;\r\n  const colors = defined(attributes.color)\r\n    ? attributes.color.values\r\n    : undefined;\r\n\r\n  const eastGeometry = copyGeometryForSplit(geometry);\r\n  const westGeometry = copyGeometryForSplit(geometry);\r\n\r\n  let i;\r\n  let j;\r\n  let index;\r\n\r\n  let intersectionFound = false;\r\n\r\n  const length = positions.length / 3;\r\n  for (i = 0; i < length; i += 4) {\r\n    const i0 = i;\r\n    const i2 = i + 2;\r\n\r\n    const p0 = Cartesian3.fromArray(positions, i0 * 3, cartesian3Scratch0);\r\n    const p2 = Cartesian3.fromArray(positions, i2 * 3, cartesian3Scratch2);\r\n\r\n    // Offset points that are close to the 180 longitude and change the previous/next point\r\n    // to be the same offset point so it can be projected to 2D. There is special handling in the\r\n    // shader for when position == prevPosition || position == nextPosition.\r\n    if (Math.abs(p0.y) < coplanarOffset) {\r\n      p0.y = coplanarOffset * (p2.y < 0.0 ? -1.0 : 1.0);\r\n      positions[i * 3 + 1] = p0.y;\r\n      positions[(i + 1) * 3 + 1] = p0.y;\r\n\r\n      for (j = i0 * 3; j < i0 * 3 + 4 * 3; j += 3) {\r\n        prevPositions[j] = positions[i * 3];\r\n        prevPositions[j + 1] = positions[i * 3 + 1];\r\n        prevPositions[j + 2] = positions[i * 3 + 2];\r\n      }\r\n    }\r\n\r\n    // Do the same but for when the line crosses 180 longitude in the opposite direction.\r\n    if (Math.abs(p2.y) < coplanarOffset) {\r\n      p2.y = coplanarOffset * (p0.y < 0.0 ? -1.0 : 1.0);\r\n      positions[(i + 2) * 3 + 1] = p2.y;\r\n      positions[(i + 3) * 3 + 1] = p2.y;\r\n\r\n      for (j = i0 * 3; j < i0 * 3 + 4 * 3; j += 3) {\r\n        nextPositions[j] = positions[(i + 2) * 3];\r\n        nextPositions[j + 1] = positions[(i + 2) * 3 + 1];\r\n        nextPositions[j + 2] = positions[(i + 2) * 3 + 2];\r\n      }\r\n    }\r\n\r\n    let p0Attributes = eastGeometry.attributes;\r\n    let p0Indices = eastGeometry.indices;\r\n    let p2Attributes = westGeometry.attributes;\r\n    let p2Indices = westGeometry.indices;\r\n\r\n    const intersection = IntersectionTests.lineSegmentPlane(\r\n      p0,\r\n      p2,\r\n      xzPlane,\r\n      cartesian3Scratch4\r\n    );\r\n    if (defined(intersection)) {\r\n      intersectionFound = true;\r\n\r\n      // move point on the xz-plane slightly away from the plane\r\n      const offset = Cartesian3.multiplyByScalar(\r\n        Cartesian3.UNIT_Y,\r\n        offsetScalar,\r\n        cartesian3Scratch5\r\n      );\r\n      if (p0.y < 0.0) {\r\n        Cartesian3.negate(offset, offset);\r\n        p0Attributes = westGeometry.attributes;\r\n        p0Indices = westGeometry.indices;\r\n        p2Attributes = eastGeometry.attributes;\r\n        p2Indices = eastGeometry.indices;\r\n      }\r\n\r\n      const offsetPoint = Cartesian3.add(\r\n        intersection,\r\n        offset,\r\n        cartesian3Scratch6\r\n      );\r\n      p0Attributes.position.values.push(p0.x, p0.y, p0.z, p0.x, p0.y, p0.z);\r\n      p0Attributes.position.values.push(\r\n        offsetPoint.x,\r\n        offsetPoint.y,\r\n        offsetPoint.z\r\n      );\r\n      p0Attributes.position.values.push(\r\n        offsetPoint.x,\r\n        offsetPoint.y,\r\n        offsetPoint.z\r\n      );\r\n\r\n      p0Attributes.prevPosition.values.push(\r\n        prevPositions[i0 * 3],\r\n        prevPositions[i0 * 3 + 1],\r\n        prevPositions[i0 * 3 + 2]\r\n      );\r\n      p0Attributes.prevPosition.values.push(\r\n        prevPositions[i0 * 3 + 3],\r\n        prevPositions[i0 * 3 + 4],\r\n        prevPositions[i0 * 3 + 5]\r\n      );\r\n      p0Attributes.prevPosition.values.push(p0.x, p0.y, p0.z, p0.x, p0.y, p0.z);\r\n\r\n      p0Attributes.nextPosition.values.push(\r\n        offsetPoint.x,\r\n        offsetPoint.y,\r\n        offsetPoint.z\r\n      );\r\n      p0Attributes.nextPosition.values.push(\r\n        offsetPoint.x,\r\n        offsetPoint.y,\r\n        offsetPoint.z\r\n      );\r\n      p0Attributes.nextPosition.values.push(\r\n        offsetPoint.x,\r\n        offsetPoint.y,\r\n        offsetPoint.z\r\n      );\r\n      p0Attributes.nextPosition.values.push(\r\n        offsetPoint.x,\r\n        offsetPoint.y,\r\n        offsetPoint.z\r\n      );\r\n\r\n      Cartesian3.negate(offset, offset);\r\n      Cartesian3.add(intersection, offset, offsetPoint);\r\n      p2Attributes.position.values.push(\r\n        offsetPoint.x,\r\n        offsetPoint.y,\r\n        offsetPoint.z\r\n      );\r\n      p2Attributes.position.values.push(\r\n        offsetPoint.x,\r\n        offsetPoint.y,\r\n        offsetPoint.z\r\n      );\r\n      p2Attributes.position.values.push(p2.x, p2.y, p2.z, p2.x, p2.y, p2.z);\r\n\r\n      p2Attributes.prevPosition.values.push(\r\n        offsetPoint.x,\r\n        offsetPoint.y,\r\n        offsetPoint.z\r\n      );\r\n      p2Attributes.prevPosition.values.push(\r\n        offsetPoint.x,\r\n        offsetPoint.y,\r\n        offsetPoint.z\r\n      );\r\n      p2Attributes.prevPosition.values.push(\r\n        offsetPoint.x,\r\n        offsetPoint.y,\r\n        offsetPoint.z\r\n      );\r\n      p2Attributes.prevPosition.values.push(\r\n        offsetPoint.x,\r\n        offsetPoint.y,\r\n        offsetPoint.z\r\n      );\r\n\r\n      p2Attributes.nextPosition.values.push(p2.x, p2.y, p2.z, p2.x, p2.y, p2.z);\r\n      p2Attributes.nextPosition.values.push(\r\n        nextPositions[i2 * 3],\r\n        nextPositions[i2 * 3 + 1],\r\n        nextPositions[i2 * 3 + 2]\r\n      );\r\n      p2Attributes.nextPosition.values.push(\r\n        nextPositions[i2 * 3 + 3],\r\n        nextPositions[i2 * 3 + 4],\r\n        nextPositions[i2 * 3 + 5]\r\n      );\r\n\r\n      const ew0 = Cartesian2.fromArray(\r\n        expandAndWidths,\r\n        i0 * 2,\r\n        cartesian2Scratch0\r\n      );\r\n      const width = Math.abs(ew0.y);\r\n\r\n      p0Attributes.expandAndWidth.values.push(-1, width, 1, width);\r\n      p0Attributes.expandAndWidth.values.push(-1, -width, 1, -width);\r\n      p2Attributes.expandAndWidth.values.push(-1, width, 1, width);\r\n      p2Attributes.expandAndWidth.values.push(-1, -width, 1, -width);\r\n\r\n      let t = Cartesian3.magnitudeSquared(\r\n        Cartesian3.subtract(intersection, p0, cartesian3Scratch3)\r\n      );\r\n      t /= Cartesian3.magnitudeSquared(\r\n        Cartesian3.subtract(p2, p0, cartesian3Scratch3)\r\n      );\r\n\r\n      if (defined(colors)) {\r\n        const c0 = Cartesian4.fromArray(colors, i0 * 4, cartesian4Scratch0);\r\n        const c2 = Cartesian4.fromArray(colors, i2 * 4, cartesian4Scratch0);\r\n\r\n        const r = CesiumMath.lerp(c0.x, c2.x, t);\r\n        const g = CesiumMath.lerp(c0.y, c2.y, t);\r\n        const b = CesiumMath.lerp(c0.z, c2.z, t);\r\n        const a = CesiumMath.lerp(c0.w, c2.w, t);\r\n\r\n        for (j = i0 * 4; j < i0 * 4 + 2 * 4; ++j) {\r\n          p0Attributes.color.values.push(colors[j]);\r\n        }\r\n        p0Attributes.color.values.push(r, g, b, a);\r\n        p0Attributes.color.values.push(r, g, b, a);\r\n        p2Attributes.color.values.push(r, g, b, a);\r\n        p2Attributes.color.values.push(r, g, b, a);\r\n        for (j = i2 * 4; j < i2 * 4 + 2 * 4; ++j) {\r\n          p2Attributes.color.values.push(colors[j]);\r\n        }\r\n      }\r\n\r\n      if (defined(texCoords)) {\r\n        const s0 = Cartesian2.fromArray(texCoords, i0 * 2, cartesian2Scratch0);\r\n        const s3 = Cartesian2.fromArray(\r\n          texCoords,\r\n          (i + 3) * 2,\r\n          cartesian2Scratch1\r\n        );\r\n\r\n        const sx = CesiumMath.lerp(s0.x, s3.x, t);\r\n\r\n        for (j = i0 * 2; j < i0 * 2 + 2 * 2; ++j) {\r\n          p0Attributes.st.values.push(texCoords[j]);\r\n        }\r\n        p0Attributes.st.values.push(sx, s0.y);\r\n        p0Attributes.st.values.push(sx, s3.y);\r\n        p2Attributes.st.values.push(sx, s0.y);\r\n        p2Attributes.st.values.push(sx, s3.y);\r\n        for (j = i2 * 2; j < i2 * 2 + 2 * 2; ++j) {\r\n          p2Attributes.st.values.push(texCoords[j]);\r\n        }\r\n      }\r\n\r\n      index = p0Attributes.position.values.length / 3 - 4;\r\n      p0Indices.push(index, index + 2, index + 1);\r\n      p0Indices.push(index + 1, index + 2, index + 3);\r\n\r\n      index = p2Attributes.position.values.length / 3 - 4;\r\n      p2Indices.push(index, index + 2, index + 1);\r\n      p2Indices.push(index + 1, index + 2, index + 3);\r\n    } else {\r\n      let currentAttributes;\r\n      let currentIndices;\r\n\r\n      if (p0.y < 0.0) {\r\n        currentAttributes = westGeometry.attributes;\r\n        currentIndices = westGeometry.indices;\r\n      } else {\r\n        currentAttributes = eastGeometry.attributes;\r\n        currentIndices = eastGeometry.indices;\r\n      }\r\n\r\n      currentAttributes.position.values.push(p0.x, p0.y, p0.z);\r\n      currentAttributes.position.values.push(p0.x, p0.y, p0.z);\r\n      currentAttributes.position.values.push(p2.x, p2.y, p2.z);\r\n      currentAttributes.position.values.push(p2.x, p2.y, p2.z);\r\n\r\n      for (j = i * 3; j < i * 3 + 4 * 3; ++j) {\r\n        currentAttributes.prevPosition.values.push(prevPositions[j]);\r\n        currentAttributes.nextPosition.values.push(nextPositions[j]);\r\n      }\r\n\r\n      for (j = i * 2; j < i * 2 + 4 * 2; ++j) {\r\n        currentAttributes.expandAndWidth.values.push(expandAndWidths[j]);\r\n        if (defined(texCoords)) {\r\n          currentAttributes.st.values.push(texCoords[j]);\r\n        }\r\n      }\r\n\r\n      if (defined(colors)) {\r\n        for (j = i * 4; j < i * 4 + 4 * 4; ++j) {\r\n          currentAttributes.color.values.push(colors[j]);\r\n        }\r\n      }\r\n\r\n      index = currentAttributes.position.values.length / 3 - 4;\r\n      currentIndices.push(index, index + 2, index + 1);\r\n      currentIndices.push(index + 1, index + 2, index + 3);\r\n    }\r\n  }\r\n\r\n  if (intersectionFound) {\r\n    updateAdjacencyAfterSplit(westGeometry);\r\n    updateAdjacencyAfterSplit(eastGeometry);\r\n  }\r\n\r\n  updateInstanceAfterSplit(instance, westGeometry, eastGeometry);\r\n}\r\n\r\n/**\r\n * Splits the instances's geometry, by introducing new vertices and indices,that\r\n * intersect the International Date Line and Prime Meridian so that no primitives cross longitude\r\n * -180/180 degrees.  This is not required for 3D drawing, but is required for\r\n * correcting drawing in 2D and Columbus view.\r\n *\r\n * @private\r\n *\r\n * @param {GeometryInstance} instance The instance to modify.\r\n * @returns {GeometryInstance} The modified <code>instance</code> argument, with it's geometry split at the International Date Line.\r\n *\r\n * @example\r\n * instance = Cesium.GeometryPipeline.splitLongitude(instance);\r\n */\r\nGeometryPipeline.splitLongitude = function (instance) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(instance)) {\r\n    throw new DeveloperError(\"instance is required.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const geometry = instance.geometry;\r\n  const boundingSphere = geometry.boundingSphere;\r\n  if (defined(boundingSphere)) {\r\n    const minX = boundingSphere.center.x - boundingSphere.radius;\r\n    if (\r\n      minX > 0 ||\r\n      BoundingSphere.intersectPlane(boundingSphere, Plane.ORIGIN_ZX_PLANE) !==\r\n        Intersect.INTERSECTING\r\n    ) {\r\n      return instance;\r\n    }\r\n  }\r\n\r\n  if (geometry.geometryType !== GeometryType.NONE) {\r\n    switch (geometry.geometryType) {\r\n      case GeometryType.POLYLINES:\r\n        splitLongitudePolyline(instance);\r\n        break;\r\n      case GeometryType.TRIANGLES:\r\n        splitLongitudeTriangles(instance);\r\n        break;\r\n      case GeometryType.LINES:\r\n        splitLongitudeLines(instance);\r\n        break;\r\n    }\r\n  } else {\r\n    indexPrimitive(geometry);\r\n    if (geometry.primitiveType === PrimitiveType.TRIANGLES) {\r\n      splitLongitudeTriangles(instance);\r\n    } else if (geometry.primitiveType === PrimitiveType.LINES) {\r\n      splitLongitudeLines(instance);\r\n    }\r\n  }\r\n\r\n  return instance;\r\n};\r\nexport default GeometryPipeline;\r\n"],"names":["scratchCartesian1","Cartesian3","scratchCartesian2","scratchCartesian3","Tipsify","options","indices","defaultValue","EMPTY_OBJECT","maximumIndex","cacheSize","defined","DeveloperError","numIndices","length","currentIndex","intoIndices","vertexTimeStamps","i","s","j","tipsify","cursor","getNextVertex","oneRing","vertices","deadEnd","maximumIndexPlusOne","p","n","m","itOneRing","index","numLiveTriangles","timeStamp","d","splice","skipDeadEnd","endIndex","vertexTriangles","triangle","push","f","vertex","intoVertices","currentOutputIndex","outputIndices","numTriangles","triangleEmitted","limit","k","GeometryPipeline","addTriangle","lines","i0","i1","i2","copyAttributesDescriptions","attributes","newAttributes","attribute","hasOwnProperty","values","attr","GeometryAttribute","componentDatatype","componentsPerAttribute","normalize","copyVertex","destinationAttributes","sourceAttributes","toWireframe","geometry","primitiveType","PrimitiveType","TRIANGLES","triangles","count","size","IndexDatatype","createTypedArray","trianglesToLines","TRIANGLE_STRIP","Uint16Array","triangleStripToLines","TRIANGLE_FAN","base","triangleFanToLines","LINES","createLineSegmentsForVectors","attributeName","position","positions","vectors","positionsLength","newPositions","Float64Array","newBoundingSphere","bs","boundingSphere","BoundingSphere","center","radius","Geometry","ComponentDatatype","DOUBLE","createAttributeLocations","semantics","len","semantic","name","reorderForPreVertexCache","numVertices","computeNumberOfVertices","indexCrossReferenceOldToNew","Int32Array","indicesIn","indicesOut","tempIndex","intoIndicesIn","intoIndicesOut","nextIndex","property","elementsIn","intoElementsIn","numComponents","elementsOut","temp","reorderForPostVertexCache","cacheCapacity","fitToUnsignedShortIndices","POINTS","geometries","numberOfVertices","CesiumMath","SIXTY_FOUR_KILOBYTES","oldToNewIndex","newIndices","originalIndices","numberOfIndices","indicesPerPrimitive","x","boundingSphereCV","scratchProjectTo2DCartesian3","scratchProjectTo2DCartographic","Cartographic","projectTo2D","attributeName3D","attributeName2D","projection","ellipsoid","GeographicProjection","values3D","projectedValues","value","fromArray","lonLat","cartesianToCartographic","y","z","projectedLonLat","project","encodedResult","high","low","encodeAttribute","attributeHighName","attributeLowName","highValues","Float32Array","lowValues","EncodedCartesian3","encode","FLOAT","transformPoint","matrix","unpack","Matrix4","multiplyByPoint","pack","transformVector","Matrix3","multiplyByVector","inverseTranspose","normalMatrix","transformToWorldCoordinates","instance","modelMatrix","equals","IDENTITY","prevPosition","nextPosition","normal","tangent","bitangent","inverse","transpose","getMatrix3","transform","clone","tempScratch","combineGeometries","instances","propertyName","haveIndices","attributesInAllGeometries","attributes0","numberOfComponents","inAllGeometries","otherAttribute","findAttributesInAllGeometries","sourceValues","sourceValuesLength","destIndices","destOffset","offset","sourceIndices","sourceIndicesLen","undefined","add","divideByScalar","tempRadius","magnitude","subtract","combineInstances","instanceGeometry","instanceSplitGeometry","westHemisphereGeometry","eastHemisphereGeometry","v0","v1","v2","computeNormal","normalsPerVertex","Array","normalsPerTriangle","normalIndices","indexOffset","currentCount","i03","i13","i23","cross","vertexNormalData","normalValues","i3","ZERO","equalsEpsilon","EPSILON10","normalScratch","normalScale","tScratch","computeTangentAndBitangent","st","normals","tan1","i02","i12","i22","ux","uy","uz","wx","wy","t1","t2","r","sdirx","sdiry","sdirz","tangentValues","bitangentValues","t","scalar","dot","multiplyByScalar","Cartesian2","toEncode1","toEncode2","toEncode3","encodeResult2","indexPrimitive","indicesIndex","indexTriangleFan","indexTriangleStrip","indexTriangles","LINE_STRIP","indexLineStrip","LINE_LOOP","indexLineLoop","indexLines","offsetPointFromXZPlane","isBehind","Math","abs","EPSILON6","compressVertices","extrudeAttribute","extrudeDirection","extrudeDirections","compressedDirections","AttributeCompression","octEncodeInRange","compressedAttributes","normalAttribute","stAttribute","hasNormal","hasSt","tangentAttribute","bitangentAttribute","hasTangent","hasBitangent","tangents","bitangents","compressedLength","numCompressedComponents","normalIndex","compressTextureCoordinates","octPack","octEncodeFloat","c3","getXZIntersectionOffsetPoints","p1","u1","u2","q1","q2","splitTriangleResult","splitTriangle","p0","p2","p0y","p1y","p2y","sign","offsetTriangleFromXZPlane","p0Behind","p1Behind","p2Behind","numBehind","updateGeometryAfterSplit","computeBoundingSphere","fromVertices","copyGeometryForSplit","copiedAttributes","updateInstanceAfterSplit","westGeometry","eastGeometry","generateBarycentricInterpolateFunction","CartesianType","v0Scratch","v1Scratch","v2Scratch","coords","currentValues","insertedIndex","interpolateAndPackCartesian4","Cartesian4","interpolateAndPackCartesian3","interpolateAndPackCartesian2","p0Scratch","p1Scratch","p2Scratch","barycentricScratch","computeTriangleAttributes","point","texCoords","applyOffset","currentAttributes","customAttributeNames","customAttributesLength","allAttributes","result","dot00","dot01","dot02","dot11","dot12","Check","EPSILON14","UNIT_X","UNIT_Y","UNIT_Z","q","barycentricCoordinates","d0","d1","d2","direction","v3","interpolateAndPackBoolean","genericInterpolate","sourceAttribute","currentAttribute","insertSplitPoint","currentIndices","currentIndexMap","insertIndex","prevIndex","newIndex","NAMED_ATTRIBUTES","splitLongitudeTriangles","westGeometryIndexMap","eastGeometryIndexMap","resultPositions","resultIndices","resultLength","resultIndex","xzPlane","Plane","fromPointNormal","offsetScratch","offsetPointScratch","computeLineAttributes","splitLongitudeLines","p0Attributes","p0Indices","p0IndexMap","p1Attributes","p1Indices","p1IndexMap","intersection","IntersectionTests","lineSegmentPlane","EPSILON9","negate","offsetPoint","cartesian2Scratch0","cartesian2Scratch1","cartesian3Scratch0","cartesian3Scratch2","cartesian3Scratch3","cartesian3Scratch4","cartesian3Scratch5","cartesian3Scratch6","cartesian4Scratch0","updateAdjacencyAfterSplit","prevPositions","nextPositions","offsetScalar","coplanarOffset","splitLongitude","intersectPlane","ORIGIN_ZX_PLANE","Intersect","INTERSECTING","geometryType","GeometryType","NONE","POLYLINES","expandAndWidths","expandAndWidth","colors","color","intersectionFound","p2Attributes","p2Indices","ew0","width","magnitudeSquared","c0","c2","lerp","g","b","a","w","s0","s3","sx","splitLongitudePolyline"],"mappings":"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"}