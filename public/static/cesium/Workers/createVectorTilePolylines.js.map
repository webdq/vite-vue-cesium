{"version":3,"file":"createVectorTilePolylines.js","sources":["../../../../Source/Core/decodeVectorPolylinePositions.js","../../../../Source/WorkersES6/createVectorTilePolylines.js"],"sourcesContent":["import AttributeCompression from \"./AttributeCompression.js\";\r\nimport Cartesian3 from \"./Cartesian3.js\";\r\nimport Cartographic from \"./Cartographic.js\";\r\nimport CesiumMath from \"./Math.js\";\r\n\r\nconst maxShort = 32767;\r\n\r\nconst scratchBVCartographic = new Cartographic();\r\nconst scratchEncodedPosition = new Cartesian3();\r\n\r\nfunction decodeVectorPolylinePositions(\r\n  positions,\r\n  rectangle,\r\n  minimumHeight,\r\n  maximumHeight,\r\n  ellipsoid\r\n) {\r\n  const positionsLength = positions.length / 3;\r\n  const uBuffer = positions.subarray(0, positionsLength);\r\n  const vBuffer = positions.subarray(positionsLength, 2 * positionsLength);\r\n  const heightBuffer = positions.subarray(\r\n    2 * positionsLength,\r\n    3 * positionsLength\r\n  );\r\n  AttributeCompression.zigZagDeltaDecode(uBuffer, vBuffer, heightBuffer);\r\n\r\n  const decoded = new Float64Array(positions.length);\r\n  for (let i = 0; i < positionsLength; ++i) {\r\n    const u = uBuffer[i];\r\n    const v = vBuffer[i];\r\n    const h = heightBuffer[i];\r\n\r\n    const lon = CesiumMath.lerp(rectangle.west, rectangle.east, u / maxShort);\r\n    const lat = CesiumMath.lerp(rectangle.south, rectangle.north, v / maxShort);\r\n    const alt = CesiumMath.lerp(minimumHeight, maximumHeight, h / maxShort);\r\n\r\n    const cartographic = Cartographic.fromRadians(\r\n      lon,\r\n      lat,\r\n      alt,\r\n      scratchBVCartographic\r\n    );\r\n    const decodedPosition = ellipsoid.cartographicToCartesian(\r\n      cartographic,\r\n      scratchEncodedPosition\r\n    );\r\n    Cartesian3.pack(decodedPosition, decoded, i * 3);\r\n  }\r\n  return decoded;\r\n}\r\nexport default decodeVectorPolylinePositions;\r\n","import Cartesian3 from \"../Core/Cartesian3.js\";\r\nimport combine from \"../Core/combine.js\";\r\nimport decodeVectorPolylinePositions from \"../Core/decodeVectorPolylinePositions.js\";\r\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\r\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\r\nimport Rectangle from \"../Core/Rectangle.js\";\r\nimport createTaskProcessorWorker from \"./createTaskProcessorWorker.js\";\r\n\r\nconst scratchRectangle = new Rectangle();\r\nconst scratchEllipsoid = new Ellipsoid();\r\nconst scratchCenter = new Cartesian3();\r\nconst scratchMinMaxHeights = {\r\n  min: undefined,\r\n  max: undefined,\r\n};\r\n\r\nfunction unpackBuffer(packedBuffer) {\r\n  packedBuffer = new Float64Array(packedBuffer);\r\n\r\n  let offset = 0;\r\n  scratchMinMaxHeights.min = packedBuffer[offset++];\r\n  scratchMinMaxHeights.max = packedBuffer[offset++];\r\n\r\n  Rectangle.unpack(packedBuffer, offset, scratchRectangle);\r\n  offset += Rectangle.packedLength;\r\n\r\n  Ellipsoid.unpack(packedBuffer, offset, scratchEllipsoid);\r\n  offset += Ellipsoid.packedLength;\r\n\r\n  Cartesian3.unpack(packedBuffer, offset, scratchCenter);\r\n}\r\n\r\nfunction getPositionOffsets(counts) {\r\n  const countsLength = counts.length;\r\n  const positionOffsets = new Uint32Array(countsLength + 1);\r\n  let offset = 0;\r\n  for (let i = 0; i < countsLength; ++i) {\r\n    positionOffsets[i] = offset;\r\n    offset += counts[i];\r\n  }\r\n  positionOffsets[countsLength] = offset;\r\n  return positionOffsets;\r\n}\r\n\r\nconst scratchP0 = new Cartesian3();\r\nconst scratchP1 = new Cartesian3();\r\nconst scratchPrev = new Cartesian3();\r\nconst scratchCur = new Cartesian3();\r\nconst scratchNext = new Cartesian3();\r\n\r\nfunction createVectorTilePolylines(parameters, transferableObjects) {\r\n  const encodedPositions = new Uint16Array(parameters.positions);\r\n  const widths = new Uint16Array(parameters.widths);\r\n  const counts = new Uint32Array(parameters.counts);\r\n  const batchIds = new Uint16Array(parameters.batchIds);\r\n\r\n  unpackBuffer(parameters.packedBuffer);\r\n  const rectangle = scratchRectangle;\r\n  const ellipsoid = scratchEllipsoid;\r\n  const center = scratchCenter;\r\n  const minimumHeight = scratchMinMaxHeights.min;\r\n  const maximumHeight = scratchMinMaxHeights.max;\r\n\r\n  const positions = decodeVectorPolylinePositions(\r\n    encodedPositions,\r\n    rectangle,\r\n    minimumHeight,\r\n    maximumHeight,\r\n    ellipsoid\r\n  );\r\n\r\n  const positionsLength = positions.length / 3;\r\n  const size = positionsLength * 4 - 4;\r\n\r\n  const curPositions = new Float32Array(size * 3);\r\n  const prevPositions = new Float32Array(size * 3);\r\n  const nextPositions = new Float32Array(size * 3);\r\n  const expandAndWidth = new Float32Array(size * 2);\r\n  const vertexBatchIds = new Uint16Array(size);\r\n\r\n  let positionIndex = 0;\r\n  let expandAndWidthIndex = 0;\r\n  let batchIdIndex = 0;\r\n\r\n  let i;\r\n  let offset = 0;\r\n  let length = counts.length;\r\n\r\n  for (i = 0; i < length; ++i) {\r\n    const count = counts[i];\r\n    const width = widths[i];\r\n    const batchId = batchIds[i];\r\n\r\n    for (let j = 0; j < count; ++j) {\r\n      let previous;\r\n      if (j === 0) {\r\n        const p0 = Cartesian3.unpack(positions, offset * 3, scratchP0);\r\n        const p1 = Cartesian3.unpack(positions, (offset + 1) * 3, scratchP1);\r\n\r\n        previous = Cartesian3.subtract(p0, p1, scratchPrev);\r\n        Cartesian3.add(p0, previous, previous);\r\n      } else {\r\n        previous = Cartesian3.unpack(\r\n          positions,\r\n          (offset + j - 1) * 3,\r\n          scratchPrev\r\n        );\r\n      }\r\n\r\n      const current = Cartesian3.unpack(\r\n        positions,\r\n        (offset + j) * 3,\r\n        scratchCur\r\n      );\r\n\r\n      let next;\r\n      if (j === count - 1) {\r\n        const p2 = Cartesian3.unpack(\r\n          positions,\r\n          (offset + count - 1) * 3,\r\n          scratchP0\r\n        );\r\n        const p3 = Cartesian3.unpack(\r\n          positions,\r\n          (offset + count - 2) * 3,\r\n          scratchP1\r\n        );\r\n\r\n        next = Cartesian3.subtract(p2, p3, scratchNext);\r\n        Cartesian3.add(p2, next, next);\r\n      } else {\r\n        next = Cartesian3.unpack(positions, (offset + j + 1) * 3, scratchNext);\r\n      }\r\n\r\n      Cartesian3.subtract(previous, center, previous);\r\n      Cartesian3.subtract(current, center, current);\r\n      Cartesian3.subtract(next, center, next);\r\n\r\n      const startK = j === 0 ? 2 : 0;\r\n      const endK = j === count - 1 ? 2 : 4;\r\n\r\n      for (let k = startK; k < endK; ++k) {\r\n        Cartesian3.pack(current, curPositions, positionIndex);\r\n        Cartesian3.pack(previous, prevPositions, positionIndex);\r\n        Cartesian3.pack(next, nextPositions, positionIndex);\r\n        positionIndex += 3;\r\n\r\n        const direction = k - 2 < 0 ? -1.0 : 1.0;\r\n        expandAndWidth[expandAndWidthIndex++] = 2 * (k % 2) - 1;\r\n        expandAndWidth[expandAndWidthIndex++] = direction * width;\r\n\r\n        vertexBatchIds[batchIdIndex++] = batchId;\r\n      }\r\n    }\r\n\r\n    offset += count;\r\n  }\r\n\r\n  const indices = IndexDatatype.createTypedArray(size, positionsLength * 6 - 6);\r\n  let index = 0;\r\n  let indicesIndex = 0;\r\n  length = positionsLength - 1;\r\n  for (i = 0; i < length; ++i) {\r\n    indices[indicesIndex++] = index;\r\n    indices[indicesIndex++] = index + 2;\r\n    indices[indicesIndex++] = index + 1;\r\n\r\n    indices[indicesIndex++] = index + 1;\r\n    indices[indicesIndex++] = index + 2;\r\n    indices[indicesIndex++] = index + 3;\r\n\r\n    index += 4;\r\n  }\r\n\r\n  transferableObjects.push(\r\n    curPositions.buffer,\r\n    prevPositions.buffer,\r\n    nextPositions.buffer\r\n  );\r\n  transferableObjects.push(\r\n    expandAndWidth.buffer,\r\n    vertexBatchIds.buffer,\r\n    indices.buffer\r\n  );\r\n\r\n  let results = {\r\n    indexDatatype:\r\n      indices.BYTES_PER_ELEMENT === 2\r\n        ? IndexDatatype.UNSIGNED_SHORT\r\n        : IndexDatatype.UNSIGNED_INT,\r\n    currentPositions: curPositions.buffer,\r\n    previousPositions: prevPositions.buffer,\r\n    nextPositions: nextPositions.buffer,\r\n    expandAndWidth: expandAndWidth.buffer,\r\n    batchIds: vertexBatchIds.buffer,\r\n    indices: indices.buffer,\r\n  };\r\n\r\n  if (parameters.keepDecodedPositions) {\r\n    const positionOffsets = getPositionOffsets(counts);\r\n    transferableObjects.push(positions.buffer, positionOffsets.buffer);\r\n    results = combine(results, {\r\n      decodedPositions: positions.buffer,\r\n      decodedPositionOffsets: positionOffsets.buffer,\r\n    });\r\n  }\r\n\r\n  return results;\r\n}\r\nexport default createTaskProcessorWorker(createVectorTilePolylines);\r\n"],"names":["maxShort","scratchBVCartographic","Cartographic","scratchEncodedPosition","Cartesian3","scratchRectangle","Rectangle","scratchEllipsoid","Ellipsoid","scratchCenter","scratchMinMaxHeights","min","undefined","max","scratchP0","scratchP1","scratchPrev","scratchCur","scratchNext","createTaskProcessorWorker","parameters","transferableObjects","encodedPositions","Uint16Array","positions","widths","counts","Uint32Array","batchIds","packedBuffer","Float64Array","offset","unpack","packedLength","unpackBuffer","ellipsoid","center","rectangle","minimumHeight","maximumHeight","positionsLength","length","uBuffer","subarray","vBuffer","heightBuffer","AttributeCompression","zigZagDeltaDecode","decoded","i","u","v","h","lon","CesiumMath","lerp","west","east","lat","south","north","alt","cartographic","fromRadians","decodedPosition","cartographicToCartesian","pack","decodeVectorPolylinePositions","size","curPositions","Float32Array","prevPositions","nextPositions","expandAndWidth","vertexBatchIds","positionIndex","expandAndWidthIndex","batchIdIndex","count","width","batchId","j","previous","p0","p1","subtract","add","current","next","p2","p3","endK","k","direction","indices","IndexDatatype","createTypedArray","index","indicesIndex","push","buffer","results","indexDatatype","BYTES_PER_ELEMENT","UNSIGNED_SHORT","UNSIGNED_INT","currentPositions","previousPositions","keepDecodedPositions","positionOffsets","countsLength","getPositionOffsets","combine","decodedPositions","decodedPositionOffsets"],"mappings":"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"}