{"version":3,"file":"decodeDraco.js","sources":["../../../../Source/WorkersES6/decodeDraco.js"],"sourcesContent":["/* global require */\r\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\r\nimport defined from \"../Core/defined.js\";\r\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\r\nimport RuntimeError from \"../Core/RuntimeError.js\";\r\nimport createTaskProcessorWorker from \"./createTaskProcessorWorker.js\";\r\n\r\nlet draco;\r\n\r\nfunction decodeIndexArray(dracoGeometry, dracoDecoder) {\r\n  const numPoints = dracoGeometry.num_points();\r\n  const numFaces = dracoGeometry.num_faces();\r\n  const faceIndices = new draco.DracoInt32Array();\r\n  const numIndices = numFaces * 3;\r\n  const indexArray = IndexDatatype.createTypedArray(numPoints, numIndices);\r\n\r\n  let offset = 0;\r\n  for (let i = 0; i < numFaces; ++i) {\r\n    dracoDecoder.GetFaceFromMesh(dracoGeometry, i, faceIndices);\r\n\r\n    indexArray[offset + 0] = faceIndices.GetValue(0);\r\n    indexArray[offset + 1] = faceIndices.GetValue(1);\r\n    indexArray[offset + 2] = faceIndices.GetValue(2);\r\n    offset += 3;\r\n  }\r\n\r\n  draco.destroy(faceIndices);\r\n\r\n  return {\r\n    typedArray: indexArray,\r\n    numberOfIndices: numIndices,\r\n  };\r\n}\r\n\r\nfunction decodeQuantizedDracoTypedArray(\r\n  dracoGeometry,\r\n  dracoDecoder,\r\n  dracoAttribute,\r\n  quantization,\r\n  vertexArrayLength\r\n) {\r\n  let vertexArray;\r\n  let attributeData;\r\n  if (quantization.quantizationBits <= 8) {\r\n    attributeData = new draco.DracoUInt8Array();\r\n    vertexArray = new Uint8Array(vertexArrayLength);\r\n    dracoDecoder.GetAttributeUInt8ForAllPoints(\r\n      dracoGeometry,\r\n      dracoAttribute,\r\n      attributeData\r\n    );\r\n  } else {\r\n    attributeData = new draco.DracoUInt16Array();\r\n    vertexArray = new Uint16Array(vertexArrayLength);\r\n    dracoDecoder.GetAttributeUInt16ForAllPoints(\r\n      dracoGeometry,\r\n      dracoAttribute,\r\n      attributeData\r\n    );\r\n  }\r\n\r\n  for (let i = 0; i < vertexArrayLength; ++i) {\r\n    vertexArray[i] = attributeData.GetValue(i);\r\n  }\r\n\r\n  draco.destroy(attributeData);\r\n  return vertexArray;\r\n}\r\n\r\nfunction decodeDracoTypedArray(\r\n  dracoGeometry,\r\n  dracoDecoder,\r\n  dracoAttribute,\r\n  vertexArrayLength\r\n) {\r\n  let vertexArray;\r\n  let attributeData;\r\n\r\n  // Some attribute types are casted down to 32 bit since Draco only returns 32 bit values\r\n  switch (dracoAttribute.data_type()) {\r\n    case 1:\r\n    case 11: // DT_INT8 or DT_BOOL\r\n      attributeData = new draco.DracoInt8Array();\r\n      vertexArray = new Int8Array(vertexArrayLength);\r\n      dracoDecoder.GetAttributeInt8ForAllPoints(\r\n        dracoGeometry,\r\n        dracoAttribute,\r\n        attributeData\r\n      );\r\n      break;\r\n    case 2: // DT_UINT8\r\n      attributeData = new draco.DracoUInt8Array();\r\n      vertexArray = new Uint8Array(vertexArrayLength);\r\n      dracoDecoder.GetAttributeUInt8ForAllPoints(\r\n        dracoGeometry,\r\n        dracoAttribute,\r\n        attributeData\r\n      );\r\n      break;\r\n    case 3: // DT_INT16\r\n      attributeData = new draco.DracoInt16Array();\r\n      vertexArray = new Int16Array(vertexArrayLength);\r\n      dracoDecoder.GetAttributeInt16ForAllPoints(\r\n        dracoGeometry,\r\n        dracoAttribute,\r\n        attributeData\r\n      );\r\n      break;\r\n    case 4: // DT_UINT16\r\n      attributeData = new draco.DracoUInt16Array();\r\n      vertexArray = new Uint16Array(vertexArrayLength);\r\n      dracoDecoder.GetAttributeUInt16ForAllPoints(\r\n        dracoGeometry,\r\n        dracoAttribute,\r\n        attributeData\r\n      );\r\n      break;\r\n    case 5:\r\n    case 7: // DT_INT32 or DT_INT64\r\n      attributeData = new draco.DracoInt32Array();\r\n      vertexArray = new Int32Array(vertexArrayLength);\r\n      dracoDecoder.GetAttributeInt32ForAllPoints(\r\n        dracoGeometry,\r\n        dracoAttribute,\r\n        attributeData\r\n      );\r\n      break;\r\n    case 6:\r\n    case 8: // DT_UINT32 or DT_UINT64\r\n      attributeData = new draco.DracoUInt32Array();\r\n      vertexArray = new Uint32Array(vertexArrayLength);\r\n      dracoDecoder.GetAttributeUInt32ForAllPoints(\r\n        dracoGeometry,\r\n        dracoAttribute,\r\n        attributeData\r\n      );\r\n      break;\r\n    case 9:\r\n    case 10: // DT_FLOAT32 or DT_FLOAT64\r\n      attributeData = new draco.DracoFloat32Array();\r\n      vertexArray = new Float32Array(vertexArrayLength);\r\n      dracoDecoder.GetAttributeFloatForAllPoints(\r\n        dracoGeometry,\r\n        dracoAttribute,\r\n        attributeData\r\n      );\r\n      break;\r\n  }\r\n\r\n  for (let i = 0; i < vertexArrayLength; ++i) {\r\n    vertexArray[i] = attributeData.GetValue(i);\r\n  }\r\n\r\n  draco.destroy(attributeData);\r\n  return vertexArray;\r\n}\r\n\r\nfunction decodeAttribute(dracoGeometry, dracoDecoder, dracoAttribute) {\r\n  const numPoints = dracoGeometry.num_points();\r\n  const numComponents = dracoAttribute.num_components();\r\n\r\n  let quantization;\r\n  let transform = new draco.AttributeQuantizationTransform();\r\n  if (transform.InitFromAttribute(dracoAttribute)) {\r\n    const minValues = new Array(numComponents);\r\n    for (let i = 0; i < numComponents; ++i) {\r\n      minValues[i] = transform.min_value(i);\r\n    }\r\n    quantization = {\r\n      quantizationBits: transform.quantization_bits(),\r\n      minValues: minValues,\r\n      range: transform.range(),\r\n      octEncoded: false,\r\n    };\r\n  }\r\n  draco.destroy(transform);\r\n\r\n  transform = new draco.AttributeOctahedronTransform();\r\n  if (transform.InitFromAttribute(dracoAttribute)) {\r\n    quantization = {\r\n      quantizationBits: transform.quantization_bits(),\r\n      octEncoded: true,\r\n    };\r\n  }\r\n  draco.destroy(transform);\r\n\r\n  const vertexArrayLength = numPoints * numComponents;\r\n  let vertexArray;\r\n  if (defined(quantization)) {\r\n    vertexArray = decodeQuantizedDracoTypedArray(\r\n      dracoGeometry,\r\n      dracoDecoder,\r\n      dracoAttribute,\r\n      quantization,\r\n      vertexArrayLength\r\n    );\r\n  } else {\r\n    vertexArray = decodeDracoTypedArray(\r\n      dracoGeometry,\r\n      dracoDecoder,\r\n      dracoAttribute,\r\n      vertexArrayLength\r\n    );\r\n  }\r\n\r\n  const componentDatatype = ComponentDatatype.fromTypedArray(vertexArray);\r\n\r\n  return {\r\n    array: vertexArray,\r\n    data: {\r\n      componentsPerAttribute: numComponents,\r\n      componentDatatype: componentDatatype,\r\n      byteOffset: dracoAttribute.byte_offset(),\r\n      byteStride:\r\n        ComponentDatatype.getSizeInBytes(componentDatatype) * numComponents,\r\n      normalized: dracoAttribute.normalized(),\r\n      quantization: quantization,\r\n    },\r\n  };\r\n}\r\n\r\nfunction decodePointCloud(parameters) {\r\n  const dracoDecoder = new draco.Decoder();\r\n\r\n  if (parameters.dequantizeInShader) {\r\n    dracoDecoder.SkipAttributeTransform(draco.POSITION);\r\n    dracoDecoder.SkipAttributeTransform(draco.NORMAL);\r\n  }\r\n\r\n  const buffer = new draco.DecoderBuffer();\r\n  buffer.Init(parameters.buffer, parameters.buffer.length);\r\n\r\n  const geometryType = dracoDecoder.GetEncodedGeometryType(buffer);\r\n  if (geometryType !== draco.POINT_CLOUD) {\r\n    throw new RuntimeError(\"Draco geometry type must be POINT_CLOUD.\");\r\n  }\r\n\r\n  const dracoPointCloud = new draco.PointCloud();\r\n  const decodingStatus = dracoDecoder.DecodeBufferToPointCloud(\r\n    buffer,\r\n    dracoPointCloud\r\n  );\r\n  if (!decodingStatus.ok() || dracoPointCloud.ptr === 0) {\r\n    throw new RuntimeError(\r\n      `Error decoding draco point cloud: ${decodingStatus.error_msg()}`\r\n    );\r\n  }\r\n\r\n  draco.destroy(buffer);\r\n\r\n  const result = {};\r\n\r\n  const properties = parameters.properties;\r\n  for (const propertyName in properties) {\r\n    if (properties.hasOwnProperty(propertyName)) {\r\n      let dracoAttribute;\r\n      if (propertyName === \"POSITION\" || propertyName === \"NORMAL\") {\r\n        const dracoAttributeId = dracoDecoder.GetAttributeId(\r\n          dracoPointCloud,\r\n          draco[propertyName]\r\n        );\r\n        dracoAttribute = dracoDecoder.GetAttribute(\r\n          dracoPointCloud,\r\n          dracoAttributeId\r\n        );\r\n      } else {\r\n        const attributeId = properties[propertyName];\r\n        dracoAttribute = dracoDecoder.GetAttributeByUniqueId(\r\n          dracoPointCloud,\r\n          attributeId\r\n        );\r\n      }\r\n      result[propertyName] = decodeAttribute(\r\n        dracoPointCloud,\r\n        dracoDecoder,\r\n        dracoAttribute\r\n      );\r\n    }\r\n  }\r\n\r\n  draco.destroy(dracoPointCloud);\r\n  draco.destroy(dracoDecoder);\r\n\r\n  return result;\r\n}\r\n\r\nfunction decodePrimitive(parameters) {\r\n  const dracoDecoder = new draco.Decoder();\r\n\r\n  // Skip all parameter types except generic\r\n  const attributesToSkip = [\"POSITION\", \"NORMAL\", \"COLOR\", \"TEX_COORD\"];\r\n  if (parameters.dequantizeInShader) {\r\n    for (let i = 0; i < attributesToSkip.length; ++i) {\r\n      dracoDecoder.SkipAttributeTransform(draco[attributesToSkip[i]]);\r\n    }\r\n  }\r\n\r\n  const bufferView = parameters.bufferView;\r\n  const buffer = new draco.DecoderBuffer();\r\n  buffer.Init(parameters.array, bufferView.byteLength);\r\n\r\n  const geometryType = dracoDecoder.GetEncodedGeometryType(buffer);\r\n  if (geometryType !== draco.TRIANGULAR_MESH) {\r\n    throw new RuntimeError(\"Unsupported draco mesh geometry type.\");\r\n  }\r\n\r\n  const dracoGeometry = new draco.Mesh();\r\n  const decodingStatus = dracoDecoder.DecodeBufferToMesh(buffer, dracoGeometry);\r\n  if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\r\n    throw new RuntimeError(\r\n      `Error decoding draco mesh geometry: ${decodingStatus.error_msg()}`\r\n    );\r\n  }\r\n\r\n  draco.destroy(buffer);\r\n\r\n  const attributeData = {};\r\n\r\n  const compressedAttributes = parameters.compressedAttributes;\r\n  for (const attributeName in compressedAttributes) {\r\n    if (compressedAttributes.hasOwnProperty(attributeName)) {\r\n      const compressedAttribute = compressedAttributes[attributeName];\r\n      const dracoAttribute = dracoDecoder.GetAttributeByUniqueId(\r\n        dracoGeometry,\r\n        compressedAttribute\r\n      );\r\n      attributeData[attributeName] = decodeAttribute(\r\n        dracoGeometry,\r\n        dracoDecoder,\r\n        dracoAttribute\r\n      );\r\n    }\r\n  }\r\n\r\n  const result = {\r\n    indexArray: decodeIndexArray(dracoGeometry, dracoDecoder),\r\n    attributeData: attributeData,\r\n  };\r\n\r\n  draco.destroy(dracoGeometry);\r\n  draco.destroy(dracoDecoder);\r\n\r\n  return result;\r\n}\r\n\r\nfunction decode(parameters) {\r\n  if (defined(parameters.bufferView)) {\r\n    return decodePrimitive(parameters);\r\n  }\r\n  return decodePointCloud(parameters);\r\n}\r\n\r\nfunction initWorker(dracoModule) {\r\n  draco = dracoModule;\r\n  self.onmessage = createTaskProcessorWorker(decode);\r\n  self.postMessage(true);\r\n}\r\n\r\nfunction decodeDraco(event) {\r\n  const data = event.data;\r\n\r\n  // Expect the first message to be to load a web assembly module\r\n  const wasmConfig = data.webAssemblyConfig;\r\n  if (defined(wasmConfig)) {\r\n    // Require and compile WebAssembly module, or use fallback if not supported\r\n    return require([wasmConfig.modulePath], function (dracoModule) {\r\n      if (defined(wasmConfig.wasmBinaryFile)) {\r\n        if (!defined(dracoModule)) {\r\n          dracoModule = self.DracoDecoderModule;\r\n        }\r\n\r\n        dracoModule(wasmConfig).then(function (compiledModule) {\r\n          initWorker(compiledModule);\r\n        });\r\n      } else {\r\n        initWorker(dracoModule());\r\n      }\r\n    });\r\n  }\r\n}\r\nexport default decodeDraco;\r\n"],"names":["draco","decodeIndexArray","dracoGeometry","dracoDecoder","numPoints","num_points","numFaces","num_faces","faceIndices","DracoInt32Array","numIndices","indexArray","IndexDatatype","createTypedArray","offset","i","GetFaceFromMesh","GetValue","destroy","typedArray","numberOfIndices","decodeAttribute","dracoAttribute","numComponents","num_components","quantization","transform","AttributeQuantizationTransform","InitFromAttribute","minValues","Array","min_value","quantizationBits","quantization_bits","range","octEncoded","AttributeOctahedronTransform","vertexArrayLength","vertexArray","defined","attributeData","DracoUInt8Array","Uint8Array","GetAttributeUInt8ForAllPoints","DracoUInt16Array","Uint16Array","GetAttributeUInt16ForAllPoints","decodeQuantizedDracoTypedArray","data_type","DracoInt8Array","Int8Array","GetAttributeInt8ForAllPoints","DracoInt16Array","Int16Array","GetAttributeInt16ForAllPoints","Int32Array","GetAttributeInt32ForAllPoints","DracoUInt32Array","Uint32Array","GetAttributeUInt32ForAllPoints","DracoFloat32Array","Float32Array","GetAttributeFloatForAllPoints","decodeDracoTypedArray","componentDatatype","ComponentDatatype","fromTypedArray","array","data","componentsPerAttribute","byteOffset","byte_offset","byteStride","getSizeInBytes","normalized","decode","parameters","bufferView","Decoder","attributesToSkip","dequantizeInShader","length","SkipAttributeTransform","buffer","DecoderBuffer","Init","byteLength","GetEncodedGeometryType","TRIANGULAR_MESH","RuntimeError","Mesh","decodingStatus","DecodeBufferToMesh","ok","ptr","error_msg","compressedAttributes","attributeName","hasOwnProperty","compressedAttribute","GetAttributeByUniqueId","result","decodePrimitive","POSITION","NORMAL","POINT_CLOUD","dracoPointCloud","PointCloud","DecodeBufferToPointCloud","properties","propertyName","dracoAttributeId","GetAttributeId","GetAttribute","attributeId","decodePointCloud","initWorker","dracoModule","self","onmessage","createTaskProcessorWorker","postMessage","event","wasmConfig","webAssemblyConfig","require","modulePath","wasmBinaryFile","DracoDecoderModule","then","compiledModule"],"mappings":"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"}