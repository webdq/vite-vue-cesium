{"version":3,"file":"PolylineVolumeGeometryLibrary-7ee3dcd3.js","sources":["../../../../Source/Core/CornerType.js","../../../../Source/Core/oneTimeWarning.js","../../../../Source/Core/PolylineVolumeGeometryLibrary.js"],"sourcesContent":["/**\r\n * Style options for corners.\r\n *\r\n * @demo The {@link https://sandcastle.cesium.com/index.html?src=Corridor.html&label=Geometries|Corridor Demo}\r\n * demonstrates the three corner types, as used by {@link CorridorGraphics}.\r\n *\r\n * @enum {Number}\r\n */\r\nconst CornerType = {\r\n  /**\r\n   * <img src=\"Images/CornerTypeRounded.png\" style=\"vertical-align: middle;\" width=\"186\" height=\"189\" />\r\n   *\r\n   * Corner has a smooth edge.\r\n   * @type {Number}\r\n   * @constant\r\n   */\r\n  ROUNDED: 0,\r\n\r\n  /**\r\n   * <img src=\"Images/CornerTypeMitered.png\" style=\"vertical-align: middle;\" width=\"186\" height=\"189\" />\r\n   *\r\n   * Corner point is the intersection of adjacent edges.\r\n   * @type {Number}\r\n   * @constant\r\n   */\r\n  MITERED: 1,\r\n\r\n  /**\r\n   * <img src=\"Images/CornerTypeBeveled.png\" style=\"vertical-align: middle;\" width=\"186\" height=\"189\" />\r\n   *\r\n   * Corner is clipped.\r\n   * @type {Number}\r\n   * @constant\r\n   */\r\n  BEVELED: 2,\r\n};\r\nexport default Object.freeze(CornerType);\r\n","import defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\nimport DeveloperError from \"./DeveloperError.js\";\r\n\r\nconst warnings = {};\r\n\r\n/**\r\n * Logs a one time message to the console.  Use this function instead of\r\n * <code>console.log</code> directly since this does not log duplicate messages\r\n * unless it is called from multiple workers.\r\n *\r\n * @function oneTimeWarning\r\n *\r\n * @param {String} identifier The unique identifier for this warning.\r\n * @param {String} [message=identifier] The message to log to the console.\r\n *\r\n * @example\r\n * for(let i=0;i<foo.length;++i) {\r\n *    if (!defined(foo[i].bar)) {\r\n *       // Something that can be recovered from but may happen a lot\r\n *       oneTimeWarning('foo.bar undefined', 'foo.bar is undefined. Setting to 0.');\r\n *       foo[i].bar = 0;\r\n *       // ...\r\n *    }\r\n * }\r\n *\r\n * @private\r\n */\r\nfunction oneTimeWarning(identifier, message) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(identifier)) {\r\n    throw new DeveloperError(\"identifier is required.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(warnings[identifier])) {\r\n    warnings[identifier] = true;\r\n    console.warn(defaultValue(message, identifier));\r\n  }\r\n}\r\n\r\noneTimeWarning.geometryOutlines =\r\n  \"Entity geometry outlines are unsupported on terrain. Outlines will be disabled. To enable outlines, disable geometry terrain clamping by explicitly setting height to 0.\";\r\n\r\noneTimeWarning.geometryZIndex =\r\n  \"Entity geometry with zIndex are unsupported when height or extrudedHeight are defined.  zIndex will be ignored\";\r\n\r\noneTimeWarning.geometryHeightReference =\r\n  \"Entity corridor, ellipse, polygon or rectangle with heightReference must also have a defined height.  heightReference will be ignored\";\r\noneTimeWarning.geometryExtrudedHeightReference =\r\n  \"Entity corridor, ellipse, polygon or rectangle with extrudedHeightReference must also have a defined extrudedHeight.  extrudedHeightReference will be ignored\";\r\nexport default oneTimeWarning;\r\n","import Cartesian2 from \"./Cartesian2.js\";\r\nimport Cartesian3 from \"./Cartesian3.js\";\r\nimport Cartesian4 from \"./Cartesian4.js\";\r\nimport Cartographic from \"./Cartographic.js\";\r\nimport CornerType from \"./CornerType.js\";\r\nimport EllipsoidTangentPlane from \"./EllipsoidTangentPlane.js\";\r\nimport CesiumMath from \"./Math.js\";\r\nimport Matrix3 from \"./Matrix3.js\";\r\nimport Matrix4 from \"./Matrix4.js\";\r\nimport PolylinePipeline from \"./PolylinePipeline.js\";\r\nimport Quaternion from \"./Quaternion.js\";\r\nimport Transforms from \"./Transforms.js\";\r\nimport oneTimeWarning from \"../Core/oneTimeWarning.js\";\r\n\r\nconst scratch2Array = [new Cartesian3(), new Cartesian3()];\r\nconst scratchCartesian1 = new Cartesian3();\r\nconst scratchCartesian2 = new Cartesian3();\r\nconst scratchCartesian3 = new Cartesian3();\r\nconst scratchCartesian4 = new Cartesian3();\r\nconst scratchCartesian5 = new Cartesian3();\r\nconst scratchCartesian6 = new Cartesian3();\r\nconst scratchCartesian7 = new Cartesian3();\r\nconst scratchCartesian8 = new Cartesian3();\r\nconst scratchCartesian9 = new Cartesian3();\r\n\r\nconst scratch1 = new Cartesian3();\r\nconst scratch2 = new Cartesian3();\r\n\r\n/**\r\n * @private\r\n */\r\nconst PolylineVolumeGeometryLibrary = {};\r\n\r\nlet cartographic = new Cartographic();\r\nfunction scaleToSurface(positions, ellipsoid) {\r\n  const heights = new Array(positions.length);\r\n  for (let i = 0; i < positions.length; i++) {\r\n    const pos = positions[i];\r\n    cartographic = ellipsoid.cartesianToCartographic(pos, cartographic);\r\n    heights[i] = cartographic.height;\r\n    positions[i] = ellipsoid.scaleToGeodeticSurface(pos, pos);\r\n  }\r\n  return heights;\r\n}\r\n\r\nfunction subdivideHeights(points, h0, h1, granularity) {\r\n  const p0 = points[0];\r\n  const p1 = points[1];\r\n  const angleBetween = Cartesian3.angleBetween(p0, p1);\r\n  const numPoints = Math.ceil(angleBetween / granularity);\r\n  const heights = new Array(numPoints);\r\n  let i;\r\n  if (h0 === h1) {\r\n    for (i = 0; i < numPoints; i++) {\r\n      heights[i] = h0;\r\n    }\r\n    heights.push(h1);\r\n    return heights;\r\n  }\r\n\r\n  const dHeight = h1 - h0;\r\n  const heightPerVertex = dHeight / numPoints;\r\n\r\n  for (i = 1; i < numPoints; i++) {\r\n    const h = h0 + i * heightPerVertex;\r\n    heights[i] = h;\r\n  }\r\n\r\n  heights[0] = h0;\r\n  heights.push(h1);\r\n  return heights;\r\n}\r\n\r\nconst nextScratch = new Cartesian3();\r\nconst prevScratch = new Cartesian3();\r\n\r\nfunction computeRotationAngle(start, end, position, ellipsoid) {\r\n  const tangentPlane = new EllipsoidTangentPlane(position, ellipsoid);\r\n  const next = tangentPlane.projectPointOntoPlane(\r\n    Cartesian3.add(position, start, nextScratch),\r\n    nextScratch\r\n  );\r\n  const prev = tangentPlane.projectPointOntoPlane(\r\n    Cartesian3.add(position, end, prevScratch),\r\n    prevScratch\r\n  );\r\n  const angle = Cartesian2.angleBetween(next, prev);\r\n\r\n  return prev.x * next.y - prev.y * next.x >= 0.0 ? -angle : angle;\r\n}\r\n\r\nconst negativeX = new Cartesian3(-1, 0, 0);\r\nlet transform = new Matrix4();\r\nconst translation = new Matrix4();\r\nlet rotationZ = new Matrix3();\r\nconst scaleMatrix = Matrix3.IDENTITY.clone();\r\nconst westScratch = new Cartesian3();\r\nconst finalPosScratch = new Cartesian4();\r\nconst heightCartesian = new Cartesian3();\r\nfunction addPosition(\r\n  center,\r\n  left,\r\n  shape,\r\n  finalPositions,\r\n  ellipsoid,\r\n  height,\r\n  xScalar,\r\n  repeat\r\n) {\r\n  let west = westScratch;\r\n  let finalPosition = finalPosScratch;\r\n  transform = Transforms.eastNorthUpToFixedFrame(center, ellipsoid, transform);\r\n\r\n  west = Matrix4.multiplyByPointAsVector(transform, negativeX, west);\r\n  west = Cartesian3.normalize(west, west);\r\n  const angle = computeRotationAngle(west, left, center, ellipsoid);\r\n  rotationZ = Matrix3.fromRotationZ(angle, rotationZ);\r\n\r\n  heightCartesian.z = height;\r\n  transform = Matrix4.multiplyTransformation(\r\n    transform,\r\n    Matrix4.fromRotationTranslation(rotationZ, heightCartesian, translation),\r\n    transform\r\n  );\r\n  const scale = scaleMatrix;\r\n  scale[0] = xScalar;\r\n\r\n  for (let j = 0; j < repeat; j++) {\r\n    for (let i = 0; i < shape.length; i += 3) {\r\n      finalPosition = Cartesian3.fromArray(shape, i, finalPosition);\r\n      finalPosition = Matrix3.multiplyByVector(\r\n        scale,\r\n        finalPosition,\r\n        finalPosition\r\n      );\r\n      finalPosition = Matrix4.multiplyByPoint(\r\n        transform,\r\n        finalPosition,\r\n        finalPosition\r\n      );\r\n      finalPositions.push(finalPosition.x, finalPosition.y, finalPosition.z);\r\n    }\r\n  }\r\n\r\n  return finalPositions;\r\n}\r\n\r\nconst centerScratch = new Cartesian3();\r\nfunction addPositions(\r\n  centers,\r\n  left,\r\n  shape,\r\n  finalPositions,\r\n  ellipsoid,\r\n  heights,\r\n  xScalar\r\n) {\r\n  for (let i = 0; i < centers.length; i += 3) {\r\n    const center = Cartesian3.fromArray(centers, i, centerScratch);\r\n    finalPositions = addPosition(\r\n      center,\r\n      left,\r\n      shape,\r\n      finalPositions,\r\n      ellipsoid,\r\n      heights[i / 3],\r\n      xScalar,\r\n      1\r\n    );\r\n  }\r\n  return finalPositions;\r\n}\r\n\r\nfunction convertShapeTo3DDuplicate(shape2D, boundingRectangle) {\r\n  //orientate 2D shape to XZ plane center at (0, 0, 0), duplicate points\r\n  const length = shape2D.length;\r\n  const shape = new Array(length * 6);\r\n  let index = 0;\r\n  const xOffset = boundingRectangle.x + boundingRectangle.width / 2;\r\n  const yOffset = boundingRectangle.y + boundingRectangle.height / 2;\r\n\r\n  let point = shape2D[0];\r\n  shape[index++] = point.x - xOffset;\r\n  shape[index++] = 0.0;\r\n  shape[index++] = point.y - yOffset;\r\n  for (let i = 1; i < length; i++) {\r\n    point = shape2D[i];\r\n    const x = point.x - xOffset;\r\n    const z = point.y - yOffset;\r\n    shape[index++] = x;\r\n    shape[index++] = 0.0;\r\n    shape[index++] = z;\r\n\r\n    shape[index++] = x;\r\n    shape[index++] = 0.0;\r\n    shape[index++] = z;\r\n  }\r\n  point = shape2D[0];\r\n  shape[index++] = point.x - xOffset;\r\n  shape[index++] = 0.0;\r\n  shape[index++] = point.y - yOffset;\r\n\r\n  return shape;\r\n}\r\n\r\nfunction convertShapeTo3D(shape2D, boundingRectangle) {\r\n  //orientate 2D shape to XZ plane center at (0, 0, 0)\r\n  const length = shape2D.length;\r\n  const shape = new Array(length * 3);\r\n  let index = 0;\r\n  const xOffset = boundingRectangle.x + boundingRectangle.width / 2;\r\n  const yOffset = boundingRectangle.y + boundingRectangle.height / 2;\r\n\r\n  for (let i = 0; i < length; i++) {\r\n    shape[index++] = shape2D[i].x - xOffset;\r\n    shape[index++] = 0;\r\n    shape[index++] = shape2D[i].y - yOffset;\r\n  }\r\n\r\n  return shape;\r\n}\r\n\r\nconst quaterion = new Quaternion();\r\nconst startPointScratch = new Cartesian3();\r\nconst rotMatrix = new Matrix3();\r\nfunction computeRoundCorner(\r\n  pivot,\r\n  startPoint,\r\n  endPoint,\r\n  cornerType,\r\n  leftIsOutside,\r\n  ellipsoid,\r\n  finalPositions,\r\n  shape,\r\n  height,\r\n  duplicatePoints\r\n) {\r\n  const angle = Cartesian3.angleBetween(\r\n    Cartesian3.subtract(startPoint, pivot, scratch1),\r\n    Cartesian3.subtract(endPoint, pivot, scratch2)\r\n  );\r\n  const granularity =\r\n    cornerType === CornerType.BEVELED\r\n      ? 0\r\n      : Math.ceil(angle / CesiumMath.toRadians(5));\r\n\r\n  let m;\r\n  if (leftIsOutside) {\r\n    m = Matrix3.fromQuaternion(\r\n      Quaternion.fromAxisAngle(\r\n        Cartesian3.negate(pivot, scratch1),\r\n        angle / (granularity + 1),\r\n        quaterion\r\n      ),\r\n      rotMatrix\r\n    );\r\n  } else {\r\n    m = Matrix3.fromQuaternion(\r\n      Quaternion.fromAxisAngle(pivot, angle / (granularity + 1), quaterion),\r\n      rotMatrix\r\n    );\r\n  }\r\n\r\n  let left;\r\n  let surfacePoint;\r\n  startPoint = Cartesian3.clone(startPoint, startPointScratch);\r\n  if (granularity > 0) {\r\n    const repeat = duplicatePoints ? 2 : 1;\r\n    for (let i = 0; i < granularity; i++) {\r\n      startPoint = Matrix3.multiplyByVector(m, startPoint, startPoint);\r\n      left = Cartesian3.subtract(startPoint, pivot, scratch1);\r\n      left = Cartesian3.normalize(left, left);\r\n      if (!leftIsOutside) {\r\n        left = Cartesian3.negate(left, left);\r\n      }\r\n      surfacePoint = ellipsoid.scaleToGeodeticSurface(startPoint, scratch2);\r\n      finalPositions = addPosition(\r\n        surfacePoint,\r\n        left,\r\n        shape,\r\n        finalPositions,\r\n        ellipsoid,\r\n        height,\r\n        1,\r\n        repeat\r\n      );\r\n    }\r\n  } else {\r\n    left = Cartesian3.subtract(startPoint, pivot, scratch1);\r\n    left = Cartesian3.normalize(left, left);\r\n    if (!leftIsOutside) {\r\n      left = Cartesian3.negate(left, left);\r\n    }\r\n    surfacePoint = ellipsoid.scaleToGeodeticSurface(startPoint, scratch2);\r\n    finalPositions = addPosition(\r\n      surfacePoint,\r\n      left,\r\n      shape,\r\n      finalPositions,\r\n      ellipsoid,\r\n      height,\r\n      1,\r\n      1\r\n    );\r\n\r\n    endPoint = Cartesian3.clone(endPoint, startPointScratch);\r\n    left = Cartesian3.subtract(endPoint, pivot, scratch1);\r\n    left = Cartesian3.normalize(left, left);\r\n    if (!leftIsOutside) {\r\n      left = Cartesian3.negate(left, left);\r\n    }\r\n    surfacePoint = ellipsoid.scaleToGeodeticSurface(endPoint, scratch2);\r\n    finalPositions = addPosition(\r\n      surfacePoint,\r\n      left,\r\n      shape,\r\n      finalPositions,\r\n      ellipsoid,\r\n      height,\r\n      1,\r\n      1\r\n    );\r\n  }\r\n\r\n  return finalPositions;\r\n}\r\n\r\nPolylineVolumeGeometryLibrary.removeDuplicatesFromShape = function (\r\n  shapePositions\r\n) {\r\n  const length = shapePositions.length;\r\n  const cleanedPositions = [];\r\n  for (let i0 = length - 1, i1 = 0; i1 < length; i0 = i1++) {\r\n    const v0 = shapePositions[i0];\r\n    const v1 = shapePositions[i1];\r\n\r\n    if (!Cartesian2.equals(v0, v1)) {\r\n      cleanedPositions.push(v1); // Shallow copy!\r\n    }\r\n  }\r\n\r\n  return cleanedPositions;\r\n};\r\n\r\nPolylineVolumeGeometryLibrary.angleIsGreaterThanPi = function (\r\n  forward,\r\n  backward,\r\n  position,\r\n  ellipsoid\r\n) {\r\n  const tangentPlane = new EllipsoidTangentPlane(position, ellipsoid);\r\n  const next = tangentPlane.projectPointOntoPlane(\r\n    Cartesian3.add(position, forward, nextScratch),\r\n    nextScratch\r\n  );\r\n  const prev = tangentPlane.projectPointOntoPlane(\r\n    Cartesian3.add(position, backward, prevScratch),\r\n    prevScratch\r\n  );\r\n\r\n  return prev.x * next.y - prev.y * next.x >= 0.0;\r\n};\r\n\r\nconst scratchForwardProjection = new Cartesian3();\r\nconst scratchBackwardProjection = new Cartesian3();\r\n\r\nPolylineVolumeGeometryLibrary.computePositions = function (\r\n  positions,\r\n  shape2D,\r\n  boundingRectangle,\r\n  geometry,\r\n  duplicatePoints\r\n) {\r\n  const ellipsoid = geometry._ellipsoid;\r\n  const heights = scaleToSurface(positions, ellipsoid);\r\n  const granularity = geometry._granularity;\r\n  const cornerType = geometry._cornerType;\r\n  const shapeForSides = duplicatePoints\r\n    ? convertShapeTo3DDuplicate(shape2D, boundingRectangle)\r\n    : convertShapeTo3D(shape2D, boundingRectangle);\r\n  const shapeForEnds = duplicatePoints\r\n    ? convertShapeTo3D(shape2D, boundingRectangle)\r\n    : undefined;\r\n  const heightOffset = boundingRectangle.height / 2;\r\n  const width = boundingRectangle.width / 2;\r\n  let length = positions.length;\r\n  let finalPositions = [];\r\n  let ends = duplicatePoints ? [] : undefined;\r\n\r\n  let forward = scratchCartesian1;\r\n  let backward = scratchCartesian2;\r\n  let cornerDirection = scratchCartesian3;\r\n  let surfaceNormal = scratchCartesian4;\r\n  let pivot = scratchCartesian5;\r\n  let start = scratchCartesian6;\r\n  let end = scratchCartesian7;\r\n  let left = scratchCartesian8;\r\n  let previousPosition = scratchCartesian9;\r\n\r\n  let position = positions[0];\r\n  let nextPosition = positions[1];\r\n  surfaceNormal = ellipsoid.geodeticSurfaceNormal(position, surfaceNormal);\r\n  forward = Cartesian3.subtract(nextPosition, position, forward);\r\n  forward = Cartesian3.normalize(forward, forward);\r\n  left = Cartesian3.cross(surfaceNormal, forward, left);\r\n  left = Cartesian3.normalize(left, left);\r\n  let h0 = heights[0];\r\n  let h1 = heights[1];\r\n  if (duplicatePoints) {\r\n    ends = addPosition(\r\n      position,\r\n      left,\r\n      shapeForEnds,\r\n      ends,\r\n      ellipsoid,\r\n      h0 + heightOffset,\r\n      1,\r\n      1\r\n    );\r\n  }\r\n  previousPosition = Cartesian3.clone(position, previousPosition);\r\n  position = nextPosition;\r\n  backward = Cartesian3.negate(forward, backward);\r\n  let subdividedHeights;\r\n  let subdividedPositions;\r\n  for (let i = 1; i < length - 1; i++) {\r\n    const repeat = duplicatePoints ? 2 : 1;\r\n    nextPosition = positions[i + 1];\r\n    if (position.equals(nextPosition)) {\r\n      oneTimeWarning(\r\n        \"Positions are too close and are considered equivalent with rounding error.\"\r\n      );\r\n      continue;\r\n    }\r\n    forward = Cartesian3.subtract(nextPosition, position, forward);\r\n    forward = Cartesian3.normalize(forward, forward);\r\n    cornerDirection = Cartesian3.add(forward, backward, cornerDirection);\r\n    cornerDirection = Cartesian3.normalize(cornerDirection, cornerDirection);\r\n    surfaceNormal = ellipsoid.geodeticSurfaceNormal(position, surfaceNormal);\r\n\r\n    const forwardProjection = Cartesian3.multiplyByScalar(\r\n      surfaceNormal,\r\n      Cartesian3.dot(forward, surfaceNormal),\r\n      scratchForwardProjection\r\n    );\r\n    Cartesian3.subtract(forward, forwardProjection, forwardProjection);\r\n    Cartesian3.normalize(forwardProjection, forwardProjection);\r\n\r\n    const backwardProjection = Cartesian3.multiplyByScalar(\r\n      surfaceNormal,\r\n      Cartesian3.dot(backward, surfaceNormal),\r\n      scratchBackwardProjection\r\n    );\r\n    Cartesian3.subtract(backward, backwardProjection, backwardProjection);\r\n    Cartesian3.normalize(backwardProjection, backwardProjection);\r\n\r\n    const doCorner = !CesiumMath.equalsEpsilon(\r\n      Math.abs(Cartesian3.dot(forwardProjection, backwardProjection)),\r\n      1.0,\r\n      CesiumMath.EPSILON7\r\n    );\r\n\r\n    if (doCorner) {\r\n      cornerDirection = Cartesian3.cross(\r\n        cornerDirection,\r\n        surfaceNormal,\r\n        cornerDirection\r\n      );\r\n      cornerDirection = Cartesian3.cross(\r\n        surfaceNormal,\r\n        cornerDirection,\r\n        cornerDirection\r\n      );\r\n      cornerDirection = Cartesian3.normalize(cornerDirection, cornerDirection);\r\n      const scalar =\r\n        1 /\r\n        Math.max(\r\n          0.25,\r\n          Cartesian3.magnitude(\r\n            Cartesian3.cross(cornerDirection, backward, scratch1)\r\n          )\r\n        );\r\n      const leftIsOutside = PolylineVolumeGeometryLibrary.angleIsGreaterThanPi(\r\n        forward,\r\n        backward,\r\n        position,\r\n        ellipsoid\r\n      );\r\n      if (leftIsOutside) {\r\n        pivot = Cartesian3.add(\r\n          position,\r\n          Cartesian3.multiplyByScalar(\r\n            cornerDirection,\r\n            scalar * width,\r\n            cornerDirection\r\n          ),\r\n          pivot\r\n        );\r\n        start = Cartesian3.add(\r\n          pivot,\r\n          Cartesian3.multiplyByScalar(left, width, start),\r\n          start\r\n        );\r\n        scratch2Array[0] = Cartesian3.clone(previousPosition, scratch2Array[0]);\r\n        scratch2Array[1] = Cartesian3.clone(start, scratch2Array[1]);\r\n        subdividedHeights = subdivideHeights(\r\n          scratch2Array,\r\n          h0 + heightOffset,\r\n          h1 + heightOffset,\r\n          granularity\r\n        );\r\n        subdividedPositions = PolylinePipeline.generateArc({\r\n          positions: scratch2Array,\r\n          granularity: granularity,\r\n          ellipsoid: ellipsoid,\r\n        });\r\n        finalPositions = addPositions(\r\n          subdividedPositions,\r\n          left,\r\n          shapeForSides,\r\n          finalPositions,\r\n          ellipsoid,\r\n          subdividedHeights,\r\n          1\r\n        );\r\n        left = Cartesian3.cross(surfaceNormal, forward, left);\r\n        left = Cartesian3.normalize(left, left);\r\n        end = Cartesian3.add(\r\n          pivot,\r\n          Cartesian3.multiplyByScalar(left, width, end),\r\n          end\r\n        );\r\n        if (\r\n          cornerType === CornerType.ROUNDED ||\r\n          cornerType === CornerType.BEVELED\r\n        ) {\r\n          computeRoundCorner(\r\n            pivot,\r\n            start,\r\n            end,\r\n            cornerType,\r\n            leftIsOutside,\r\n            ellipsoid,\r\n            finalPositions,\r\n            shapeForSides,\r\n            h1 + heightOffset,\r\n            duplicatePoints\r\n          );\r\n        } else {\r\n          cornerDirection = Cartesian3.negate(cornerDirection, cornerDirection);\r\n          finalPositions = addPosition(\r\n            position,\r\n            cornerDirection,\r\n            shapeForSides,\r\n            finalPositions,\r\n            ellipsoid,\r\n            h1 + heightOffset,\r\n            scalar,\r\n            repeat\r\n          );\r\n        }\r\n        previousPosition = Cartesian3.clone(end, previousPosition);\r\n      } else {\r\n        pivot = Cartesian3.add(\r\n          position,\r\n          Cartesian3.multiplyByScalar(\r\n            cornerDirection,\r\n            scalar * width,\r\n            cornerDirection\r\n          ),\r\n          pivot\r\n        );\r\n        start = Cartesian3.add(\r\n          pivot,\r\n          Cartesian3.multiplyByScalar(left, -width, start),\r\n          start\r\n        );\r\n        scratch2Array[0] = Cartesian3.clone(previousPosition, scratch2Array[0]);\r\n        scratch2Array[1] = Cartesian3.clone(start, scratch2Array[1]);\r\n        subdividedHeights = subdivideHeights(\r\n          scratch2Array,\r\n          h0 + heightOffset,\r\n          h1 + heightOffset,\r\n          granularity\r\n        );\r\n        subdividedPositions = PolylinePipeline.generateArc({\r\n          positions: scratch2Array,\r\n          granularity: granularity,\r\n          ellipsoid: ellipsoid,\r\n        });\r\n        finalPositions = addPositions(\r\n          subdividedPositions,\r\n          left,\r\n          shapeForSides,\r\n          finalPositions,\r\n          ellipsoid,\r\n          subdividedHeights,\r\n          1\r\n        );\r\n        left = Cartesian3.cross(surfaceNormal, forward, left);\r\n        left = Cartesian3.normalize(left, left);\r\n        end = Cartesian3.add(\r\n          pivot,\r\n          Cartesian3.multiplyByScalar(left, -width, end),\r\n          end\r\n        );\r\n        if (\r\n          cornerType === CornerType.ROUNDED ||\r\n          cornerType === CornerType.BEVELED\r\n        ) {\r\n          computeRoundCorner(\r\n            pivot,\r\n            start,\r\n            end,\r\n            cornerType,\r\n            leftIsOutside,\r\n            ellipsoid,\r\n            finalPositions,\r\n            shapeForSides,\r\n            h1 + heightOffset,\r\n            duplicatePoints\r\n          );\r\n        } else {\r\n          finalPositions = addPosition(\r\n            position,\r\n            cornerDirection,\r\n            shapeForSides,\r\n            finalPositions,\r\n            ellipsoid,\r\n            h1 + heightOffset,\r\n            scalar,\r\n            repeat\r\n          );\r\n        }\r\n        previousPosition = Cartesian3.clone(end, previousPosition);\r\n      }\r\n      backward = Cartesian3.negate(forward, backward);\r\n    } else {\r\n      finalPositions = addPosition(\r\n        previousPosition,\r\n        left,\r\n        shapeForSides,\r\n        finalPositions,\r\n        ellipsoid,\r\n        h0 + heightOffset,\r\n        1,\r\n        1\r\n      );\r\n      previousPosition = position;\r\n    }\r\n    h0 = h1;\r\n    h1 = heights[i + 1];\r\n    position = nextPosition;\r\n  }\r\n\r\n  scratch2Array[0] = Cartesian3.clone(previousPosition, scratch2Array[0]);\r\n  scratch2Array[1] = Cartesian3.clone(position, scratch2Array[1]);\r\n  subdividedHeights = subdivideHeights(\r\n    scratch2Array,\r\n    h0 + heightOffset,\r\n    h1 + heightOffset,\r\n    granularity\r\n  );\r\n  subdividedPositions = PolylinePipeline.generateArc({\r\n    positions: scratch2Array,\r\n    granularity: granularity,\r\n    ellipsoid: ellipsoid,\r\n  });\r\n  finalPositions = addPositions(\r\n    subdividedPositions,\r\n    left,\r\n    shapeForSides,\r\n    finalPositions,\r\n    ellipsoid,\r\n    subdividedHeights,\r\n    1\r\n  );\r\n  if (duplicatePoints) {\r\n    ends = addPosition(\r\n      position,\r\n      left,\r\n      shapeForEnds,\r\n      ends,\r\n      ellipsoid,\r\n      h1 + heightOffset,\r\n      1,\r\n      1\r\n    );\r\n  }\r\n\r\n  length = finalPositions.length;\r\n  const posLength = duplicatePoints ? length + ends.length : length;\r\n  const combinedPositions = new Float64Array(posLength);\r\n  combinedPositions.set(finalPositions);\r\n  if (duplicatePoints) {\r\n    combinedPositions.set(ends, length);\r\n  }\r\n\r\n  return combinedPositions;\r\n};\r\nexport default PolylineVolumeGeometryLibrary;\r\n"],"names":["CornerType$1","Object","freeze","ROUNDED","MITERED","BEVELED","warnings","oneTimeWarning","identifier","message","defined","DeveloperError","console","warn","defaultValue","geometryOutlines","geometryZIndex","geometryHeightReference","geometryExtrudedHeightReference","scratch2Array","Cartesian3","scratchCartesian1","scratchCartesian2","scratchCartesian3","scratchCartesian4","scratchCartesian5","scratchCartesian6","scratchCartesian7","scratchCartesian8","scratchCartesian9","scratch1","scratch2","PolylineVolumeGeometryLibrary","cartographic","Cartographic","subdivideHeights","points","h0","h1","granularity","p0","p1","angleBetween","numPoints","Math","ceil","heights","Array","i","push","heightPerVertex","h","nextScratch","prevScratch","negativeX","transform","Matrix4","translation","rotationZ","Matrix3","scaleMatrix","IDENTITY","clone","westScratch","finalPosScratch","Cartesian4","heightCartesian","addPosition","center","left","shape","finalPositions","ellipsoid","height","xScalar","repeat","west","finalPosition","Transforms","eastNorthUpToFixedFrame","multiplyByPointAsVector","normalize","angle","start","end","position","tangentPlane","EllipsoidTangentPlane","next","projectPointOntoPlane","add","prev","Cartesian2","x","y","computeRotationAngle","fromRotationZ","z","multiplyTransformation","fromRotationTranslation","scale","j","length","fromArray","multiplyByVector","multiplyByPoint","centerScratch","addPositions","centers","convertShapeTo3D","shape2D","boundingRectangle","index","xOffset","width","yOffset","quaterion","Quaternion","startPointScratch","rotMatrix","computeRoundCorner","pivot","startPoint","endPoint","cornerType","leftIsOutside","duplicatePoints","subtract","CornerType","CesiumMath","toRadians","m","surfacePoint","fromQuaternion","fromAxisAngle","negate","scaleToGeodeticSurface","removeDuplicatesFromShape","shapePositions","cleanedPositions","i0","i1","v0","v1","equals","angleIsGreaterThanPi","forward","backward","scratchForwardProjection","scratchBackwardProjection","computePositions","positions","geometry","_ellipsoid","pos","cartesianToCartographic","scaleToSurface","_granularity","_cornerType","shapeForSides","point","convertShapeTo3DDuplicate","shapeForEnds","undefined","heightOffset","ends","cornerDirection","surfaceNormal","previousPosition","nextPosition","geodeticSurfaceNormal","cross","subdividedHeights","subdividedPositions","forwardProjection","multiplyByScalar","dot","backwardProjection","equalsEpsilon","abs","EPSILON7","scalar","max","magnitude","PolylinePipeline","generateArc","posLength","combinedPositions","Float64Array","set"],"mappings":"4PAoCA,IAAAA,EAAeC,OAAOC,OA5BH,CAQjBC,QAAS,EASTC,QAAS,EASTC,QAAS,IC9BX,MAAMC,EAAW,GAwBjB,SAASC,EAAeC,EAAYC,GAElC,IAAKC,EAAAA,QAAQF,GACX,MAAM,IAAIG,EAAAA,eAAe,2BAItBD,EAAOA,QAACJ,EAASE,MACpBF,EAASE,IAAc,EACvBI,QAAQC,KAAKC,EAAAA,aAAaL,EAASD,KAIvCD,EAAeQ,iBACb,2KAEFR,EAAeS,eACb,iHAEFT,EAAeU,wBACb,wIACFV,EAAeW,gCACb,gKCpCF,MAAMC,EAAgB,CAAC,IAAIC,EAAAA,WAAc,IAAIA,EAAAA,YACvCC,EAAoB,IAAID,EAAAA,WACxBE,EAAoB,IAAIF,EAAAA,WACxBG,EAAoB,IAAIH,EAAAA,WACxBI,EAAoB,IAAIJ,EAAAA,WACxBK,EAAoB,IAAIL,EAAAA,WACxBM,EAAoB,IAAIN,EAAAA,WACxBO,EAAoB,IAAIP,EAAAA,WACxBQ,EAAoB,IAAIR,EAAAA,WACxBS,EAAoB,IAAIT,EAAAA,WAExBU,EAAW,IAAIV,EAAAA,WACfW,EAAW,IAAIX,EAAAA,WAKfY,EAAgC,GAEtC,IAAIC,EAAe,IAAIC,EAAAA,aAYvB,SAASC,EAAiBC,EAAQC,EAAIC,EAAIC,GACxC,MAAMC,EAAKJ,EAAO,GACZK,EAAKL,EAAO,GACZM,EAAetB,EAAUA,WAACsB,aAAaF,EAAIC,GAC3CE,EAAYC,KAAKC,KAAKH,EAAeH,GACrCO,EAAU,IAAIC,MAAMJ,GAC1B,IAAIK,EACJ,GAAIX,IAAOC,EAAI,CACb,IAAKU,EAAI,EAAGA,EAAIL,EAAWK,IACzBF,EAAQE,GAAKX,EAGf,OADAS,EAAQG,KAAKX,GACNQ,EAGT,MACMI,GADUZ,EAAKD,GACaM,EAElC,IAAKK,EAAI,EAAGA,EAAIL,EAAWK,IAAK,CAC9B,MAAMG,EAAId,EAAKW,EAAIE,EACnBJ,EAAQE,GAAKG,EAKf,OAFAL,EAAQ,GAAKT,EACbS,EAAQG,KAAKX,GACNQ,EAGT,MAAMM,EAAc,IAAIhC,EAAAA,WAClBiC,EAAc,IAAIjC,EAAAA,WAiBxB,MAAMkC,EAAY,IAAIlC,EAAAA,YAAY,EAAG,EAAG,GACxC,IAAImC,EAAY,IAAIC,EAAAA,QACpB,MAAMC,EAAc,IAAID,EAAAA,QACxB,IAAIE,EAAY,IAAIC,EAAAA,QACpB,MAAMC,EAAcD,EAAOA,QAACE,SAASC,QAC/BC,EAAc,IAAI3C,EAAAA,WAClB4C,EAAkB,IAAIC,EAAAA,WACtBC,EAAkB,IAAI9C,EAAAA,WAC5B,SAAS+C,EACPC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,GAEA,IAAIC,EAAOb,EACPc,EAAgBb,EACpBT,EAAYuB,EAAUA,WAACC,wBAAwBX,EAAQI,EAAWjB,GAElEqB,EAAOpB,EAAOA,QAACwB,wBAAwBzB,EAAWD,EAAWsB,GAC7DA,EAAOxD,EAAAA,WAAW6D,UAAUL,EAAMA,GAClC,MAAMM,EAvCR,SAA8BC,EAAOC,EAAKC,EAAUb,GAClD,MAAMc,EAAe,IAAIC,EAAAA,sBAAsBF,EAAUb,GACnDgB,EAAOF,EAAaG,sBACxBrE,EAAAA,WAAWsE,IAAIL,EAAUF,EAAO/B,GAChCA,GAEIuC,EAAOL,EAAaG,sBACxBrE,EAAAA,WAAWsE,IAAIL,EAAUD,EAAK/B,GAC9BA,GAEI6B,EAAQU,EAAUA,WAAClD,aAAa8C,EAAMG,GAE5C,OAAOA,EAAKE,EAAIL,EAAKM,EAAIH,EAAKG,EAAIN,EAAKK,GAAK,GAAOX,EAAQA,EA2B7Ca,CAAqBnB,EAAMP,EAAMD,EAAQI,GACvDd,EAAYC,EAAAA,QAAQqC,cAAcd,EAAOxB,GAEzCQ,EAAgB+B,EAAIxB,EACpBlB,EAAYC,EAAOA,QAAC0C,uBAClB3C,EACAC,EAAAA,QAAQ2C,wBAAwBzC,EAAWQ,EAAiBT,GAC5DF,GAEF,MAAM6C,EAAQxC,EACdwC,EAAM,GAAK1B,EAEX,IAAK,IAAI2B,EAAI,EAAGA,EAAI1B,EAAQ0B,IAC1B,IAAK,IAAIrD,EAAI,EAAGA,EAAIsB,EAAMgC,OAAQtD,GAAK,EACrC6B,EAAgBzD,EAAUA,WAACmF,UAAUjC,EAAOtB,EAAG6B,GAC/CA,EAAgBlB,EAAOA,QAAC6C,iBACtBJ,EACAvB,EACAA,GAEFA,EAAgBrB,EAAOA,QAACiD,gBACtBlD,EACAsB,EACAA,GAEFN,EAAetB,KAAK4B,EAAcgB,EAAGhB,EAAciB,EAAGjB,EAAcoB,GAIxE,OAAO1B,EAGT,MAAMmC,EAAgB,IAAItF,EAAAA,WAC1B,SAASuF,EACPC,EACAvC,EACAC,EACAC,EACAC,EACA1B,EACA4B,GAEA,IAAK,IAAI1B,EAAI,EAAGA,EAAI4D,EAAQN,OAAQtD,GAAK,EAAG,CAE1CuB,EAAiBJ,EADF/C,EAAAA,WAAWmF,UAAUK,EAAS5D,EAAG0D,GAG9CrC,EACAC,EACAC,EACAC,EACA1B,EAAQE,EAAI,GACZ0B,EACA,GAGJ,OAAOH,EAmCT,SAASsC,EAAiBC,EAASC,GAEjC,MAAMT,EAASQ,EAAQR,OACjBhC,EAAQ,IAAIvB,MAAe,EAATuD,GACxB,IAAIU,EAAQ,EACZ,MAAMC,EAAUF,EAAkBlB,EAAIkB,EAAkBG,MAAQ,EAC1DC,EAAUJ,EAAkBjB,EAAIiB,EAAkBtC,OAAS,EAEjE,IAAK,IAAIzB,EAAI,EAAGA,EAAIsD,EAAQtD,IAC1BsB,EAAM0C,KAAWF,EAAQ9D,GAAG6C,EAAIoB,EAChC3C,EAAM0C,KAAW,EACjB1C,EAAM0C,KAAWF,EAAQ9D,GAAG8C,EAAIqB,EAGlC,OAAO7C,EAGT,MAAM8C,EAAY,IAAIC,EAAAA,WAChBC,EAAoB,IAAIlG,EAAAA,WACxBmG,EAAY,IAAI5D,EAAAA,QACtB,SAAS6D,EACPC,EACAC,EACAC,EACAC,EACAC,EACArD,EACAD,EACAD,EACAG,EACAqD,GAEA,MAAM5C,EAAQ9D,EAAAA,WAAWsB,aACvBtB,EAAAA,WAAW2G,SAASL,EAAYD,EAAO3F,GACvCV,EAAAA,WAAW2G,SAASJ,EAAUF,EAAO1F,IAEjCQ,EACJqF,IAAeI,EAAW3H,QACtB,EACAuC,KAAKC,KAAKqC,EAAQ+C,EAAUA,WAACC,UAAU,IAE7C,IAAIC,EAiBA9D,EACA+D,EAEJ,GAlBED,EADEN,EACElE,EAAOA,QAAC0E,eACVhB,EAAAA,WAAWiB,cACTlH,aAAWmH,OAAOd,EAAO3F,GACzBoD,GAAS3C,EAAc,GACvB6E,GAEFG,GAGE5D,EAAOA,QAAC0E,eACVhB,EAAUA,WAACiB,cAAcb,EAAOvC,GAAS3C,EAAc,GAAI6E,GAC3DG,GAMJG,EAAatG,EAAAA,WAAW0C,MAAM4D,EAAYJ,GACtC/E,EAAc,EAAG,CACnB,MAAMoC,EAASmD,EAAkB,EAAI,EACrC,IAAK,IAAI9E,EAAI,EAAGA,EAAIT,EAAaS,IAC/B0E,EAAa/D,EAAOA,QAAC6C,iBAAiB2B,EAAGT,EAAYA,GACrDrD,EAAOjD,EAAUA,WAAC2G,SAASL,EAAYD,EAAO3F,GAC9CuC,EAAOjD,EAAAA,WAAW6D,UAAUZ,EAAMA,GAC7BwD,IACHxD,EAAOjD,EAAAA,WAAWmH,OAAOlE,EAAMA,IAEjC+D,EAAe5D,EAAUgE,uBAAuBd,EAAY3F,GAC5DwC,EAAiBJ,EACfiE,EACA/D,EACAC,EACAC,EACAC,EACAC,EACA,EACAE,QAIJN,EAAOjD,EAAUA,WAAC2G,SAASL,EAAYD,EAAO3F,GAC9CuC,EAAOjD,EAAAA,WAAW6D,UAAUZ,EAAMA,GAC7BwD,IACHxD,EAAOjD,EAAAA,WAAWmH,OAAOlE,EAAMA,IAEjC+D,EAAe5D,EAAUgE,uBAAuBd,EAAY3F,GAC5DwC,EAAiBJ,EACfiE,EACA/D,EACAC,EACAC,EACAC,EACAC,EACA,EACA,GAGFkD,EAAWvG,EAAAA,WAAW0C,MAAM6D,EAAUL,GACtCjD,EAAOjD,EAAUA,WAAC2G,SAASJ,EAAUF,EAAO3F,GAC5CuC,EAAOjD,EAAAA,WAAW6D,UAAUZ,EAAMA,GAC7BwD,IACHxD,EAAOjD,EAAAA,WAAWmH,OAAOlE,EAAMA,IAEjC+D,EAAe5D,EAAUgE,uBAAuBb,EAAU5F,GAC1DwC,EAAiBJ,EACfiE,EACA/D,EACAC,EACAC,EACAC,EACAC,EACA,EACA,GAIJ,OAAOF,EAGTvC,EAA8ByG,0BAA4B,SACxDC,GAEA,MAAMpC,EAASoC,EAAepC,OACxBqC,EAAmB,GACzB,IAAK,IAAIC,EAAKtC,EAAS,EAAGuC,EAAK,EAAGA,EAAKvC,EAAQsC,EAAKC,IAAM,CACxD,MAAMC,EAAKJ,EAAeE,GACpBG,EAAKL,EAAeG,GAErBjD,EAAAA,WAAWoD,OAAOF,EAAIC,IACzBJ,EAAiB1F,KAAK8F,GAI1B,OAAOJ,GAGT3G,EAA8BiH,qBAAuB,SACnDC,EACAC,EACA9D,EACAb,GAEA,MAAMc,EAAe,IAAIC,EAAAA,sBAAsBF,EAAUb,GACnDgB,EAAOF,EAAaG,sBACxBrE,EAAAA,WAAWsE,IAAIL,EAAU6D,EAAS9F,GAClCA,GAEIuC,EAAOL,EAAaG,sBACxBrE,EAAAA,WAAWsE,IAAIL,EAAU8D,EAAU9F,GACnCA,GAGF,OAAOsC,EAAKE,EAAIL,EAAKM,EAAIH,EAAKG,EAAIN,EAAKK,GAAK,GAG9C,MAAMuD,EAA2B,IAAIhI,EAAAA,WAC/BiI,EAA4B,IAAIjI,EAAAA,WAEtCY,EAA8BsH,iBAAmB,SAC/CC,EACAzC,EACAC,EACAyC,EACA1B,GAEA,MAAMtD,EAAYgF,EAASC,WACrB3G,EApVR,SAAwByG,EAAW/E,GACjC,MAAM1B,EAAU,IAAIC,MAAMwG,EAAUjD,QACpC,IAAK,IAAItD,EAAI,EAAGA,EAAIuG,EAAUjD,OAAQtD,IAAK,CACzC,MAAM0G,EAAMH,EAAUvG,GACtBf,EAAeuC,EAAUmF,wBAAwBD,EAAKzH,GACtDa,EAAQE,GAAKf,EAAawC,OAC1B8E,EAAUvG,GAAKwB,EAAUgE,uBAAuBkB,EAAKA,GAEvD,OAAO5G,EA4US8G,CAAeL,EAAW/E,GACpCjC,EAAciH,EAASK,aACvBjC,EAAa4B,EAASM,YACtBC,EAAgBjC,EA5MxB,SAAmChB,EAASC,GAE1C,MAAMT,EAASQ,EAAQR,OACjBhC,EAAQ,IAAIvB,MAAe,EAATuD,GACxB,IAAIU,EAAQ,EACZ,MAAMC,EAAUF,EAAkBlB,EAAIkB,EAAkBG,MAAQ,EAC1DC,EAAUJ,EAAkBjB,EAAIiB,EAAkBtC,OAAS,EAEjE,IAAIuF,EAAQlD,EAAQ,GACpBxC,EAAM0C,KAAWgD,EAAMnE,EAAIoB,EAC3B3C,EAAM0C,KAAW,EACjB1C,EAAM0C,KAAWgD,EAAMlE,EAAIqB,EAC3B,IAAK,IAAInE,EAAI,EAAGA,EAAIsD,EAAQtD,IAAK,CAC/BgH,EAAQlD,EAAQ9D,GAChB,MAAM6C,EAAImE,EAAMnE,EAAIoB,EACdhB,EAAI+D,EAAMlE,EAAIqB,EACpB7C,EAAM0C,KAAWnB,EACjBvB,EAAM0C,KAAW,EACjB1C,EAAM0C,KAAWf,EAEjB3B,EAAM0C,KAAWnB,EACjBvB,EAAM0C,KAAW,EACjB1C,EAAM0C,KAAWf,EAOnB,OALA+D,EAAQlD,EAAQ,GAChBxC,EAAM0C,KAAWgD,EAAMnE,EAAIoB,EAC3B3C,EAAM0C,KAAW,EACjB1C,EAAM0C,KAAWgD,EAAMlE,EAAIqB,EAEpB7C,EAgLH2F,CAA0BnD,EAASC,GACnCF,EAAiBC,EAASC,GACxBmD,EAAepC,EACjBjB,EAAiBC,EAASC,QAC1BoD,EACEC,EAAerD,EAAkBtC,OAAS,EAC1CyC,EAAQH,EAAkBG,MAAQ,EACxC,IAAIZ,EAASiD,EAAUjD,OACnB/B,EAAiB,GACjB8F,EAAOvC,EAAkB,QAAKqC,EAE9BjB,EAAU7H,EACV8H,EAAW7H,EACXgJ,EAAkB/I,EAClBgJ,EAAgB/I,EAChBiG,EAAQhG,EACR0D,EAAQzD,EACR0D,EAAMzD,EACN0C,EAAOzC,EACP4I,EAAmB3I,EAEnBwD,EAAWkE,EAAU,GACrBkB,EAAelB,EAAU,GAC7BgB,EAAgB/F,EAAUkG,sBAAsBrF,EAAUkF,GAC1DrB,EAAU9H,EAAUA,WAAC2G,SAAS0C,EAAcpF,EAAU6D,GACtDA,EAAU9H,EAAAA,WAAW6D,UAAUiE,EAASA,GACxC7E,EAAOjD,EAAUA,WAACuJ,MAAMJ,EAAerB,EAAS7E,GAChDA,EAAOjD,EAAAA,WAAW6D,UAAUZ,EAAMA,GAClC,IAiBIuG,EACAC,EAlBAxI,GAAKS,EAAQ,GACbR,GAAKQ,EAAQ,GACbgF,IACFuC,EAAOlG,EACLkB,EACAhB,EACA6F,EACAG,EACA7F,EACAnC,GAAK+H,EACL,EACA,IAGJI,EAAmBpJ,EAAAA,WAAW0C,MAAMuB,EAAUmF,GAC9CnF,EAAWoF,EACXtB,EAAW/H,EAAAA,WAAWmH,OAAOW,EAASC,GAGtC,IAAK,IAAInG,EAAI,EAAGA,EAAIsD,EAAS,EAAGtD,IAAK,CACnC,MAAM2B,EAASmD,EAAkB,EAAI,EAErC,GADA2C,EAAelB,EAAUvG,EAAI,GACzBqC,EAAS2D,OAAOyB,GAAe,CACjClK,EACE,8EAEF,SAEF2I,EAAU9H,EAAUA,WAAC2G,SAAS0C,EAAcpF,EAAU6D,GACtDA,EAAU9H,EAAAA,WAAW6D,UAAUiE,EAASA,GACxCoB,EAAkBlJ,EAAUA,WAACsE,IAAIwD,EAASC,EAAUmB,GACpDA,EAAkBlJ,EAAAA,WAAW6D,UAAUqF,EAAiBA,GACxDC,EAAgB/F,EAAUkG,sBAAsBrF,EAAUkF,GAE1D,MAAMO,EAAoB1J,EAAAA,WAAW2J,iBACnCR,EACAnJ,aAAW4J,IAAI9B,EAASqB,GACxBnB,GAEFhI,EAAAA,WAAW2G,SAASmB,EAAS4B,EAAmBA,GAChD1J,EAAAA,WAAW6D,UAAU6F,EAAmBA,GAExC,MAAMG,EAAqB7J,EAAAA,WAAW2J,iBACpCR,EACAnJ,aAAW4J,IAAI7B,EAAUoB,GACzBlB,GAEFjI,EAAAA,WAAW2G,SAASoB,EAAU8B,EAAoBA,GAClD7J,EAAAA,WAAW6D,UAAUgG,EAAoBA,GAQzC,IANkBhD,EAAAA,WAAWiD,cAC3BtI,KAAKuI,IAAI/J,EAAUA,WAAC4J,IAAIF,EAAmBG,IAC3C,EACAhD,EAAAA,WAAWmD,UAGC,CACZd,EAAkBlJ,EAAUA,WAACuJ,MAC3BL,EACAC,EACAD,GAEFA,EAAkBlJ,EAAUA,WAACuJ,MAC3BJ,EACAD,EACAA,GAEFA,EAAkBlJ,EAAAA,WAAW6D,UAAUqF,EAAiBA,GACxD,MAAMe,EACJ,EACAzI,KAAK0I,IACH,IACAlK,EAAAA,WAAWmK,UACTnK,EAAAA,WAAWuJ,MAAML,EAAiBnB,EAAUrH,KAG5C+F,EAAgB7F,EAA8BiH,qBAClDC,EACAC,EACA9D,EACAb,GAEEqD,GACFJ,EAAQrG,EAAUA,WAACsE,IACjBL,EACAjE,EAAAA,WAAW2J,iBACTT,EACAe,EAASnE,EACToD,GAEF7C,GAEFtC,EAAQ/D,EAAUA,WAACsE,IACjB+B,EACArG,EAAAA,WAAW2J,iBAAiB1G,EAAM6C,EAAO/B,GACzCA,GAEFhE,EAAc,GAAKC,aAAW0C,MAAM0G,EAAkBrJ,EAAc,IACpEA,EAAc,GAAKC,aAAW0C,MAAMqB,EAAOhE,EAAc,IACzDyJ,EAAoBzI,EAClBhB,EACAkB,GAAK+H,EACL9H,GAAK8H,EACL7H,GAEFsI,EAAsBW,EAAgBA,iBAACC,YAAY,CACjDlC,UAAWpI,EACXoB,YAAaA,EACbiC,UAAWA,IAEbD,EAAiBoC,EACfkE,EACAxG,EACA0F,EACAxF,EACAC,EACAoG,EACA,GAEFvG,EAAOjD,EAAUA,WAACuJ,MAAMJ,EAAerB,EAAS7E,GAChDA,EAAOjD,EAAAA,WAAW6D,UAAUZ,EAAMA,GAClCe,EAAMhE,EAAUA,WAACsE,IACf+B,EACArG,EAAAA,WAAW2J,iBAAiB1G,EAAM6C,EAAO9B,GACzCA,GAGAwC,IAAeI,EAAW7H,SAC1ByH,IAAeI,EAAW3H,QAE1BmH,EACEC,EACAtC,EACAC,EACAwC,EACAC,EACArD,EACAD,EACAwF,EACAzH,GAAK8H,EACLtC,IAGFwC,EAAkBlJ,EAAAA,WAAWmH,OAAO+B,EAAiBA,GACrD/F,EAAiBJ,EACfkB,EACAiF,EACAP,EACAxF,EACAC,EACAlC,GAAK8H,EACLiB,EACA1G,IAGJ6F,EAAmBpJ,EAAAA,WAAW0C,MAAMsB,EAAKoF,KAEzC/C,EAAQrG,EAAUA,WAACsE,IACjBL,EACAjE,EAAAA,WAAW2J,iBACTT,EACAe,EAASnE,EACToD,GAEF7C,GAEFtC,EAAQ/D,EAAUA,WAACsE,IACjB+B,EACArG,EAAAA,WAAW2J,iBAAiB1G,GAAO6C,EAAO/B,GAC1CA,GAEFhE,EAAc,GAAKC,aAAW0C,MAAM0G,EAAkBrJ,EAAc,IACpEA,EAAc,GAAKC,aAAW0C,MAAMqB,EAAOhE,EAAc,IACzDyJ,EAAoBzI,EAClBhB,EACAkB,GAAK+H,EACL9H,GAAK8H,EACL7H,GAEFsI,EAAsBW,EAAgBA,iBAACC,YAAY,CACjDlC,UAAWpI,EACXoB,YAAaA,EACbiC,UAAWA,IAEbD,EAAiBoC,EACfkE,EACAxG,EACA0F,EACAxF,EACAC,EACAoG,EACA,GAEFvG,EAAOjD,EAAUA,WAACuJ,MAAMJ,EAAerB,EAAS7E,GAChDA,EAAOjD,EAAAA,WAAW6D,UAAUZ,EAAMA,GAClCe,EAAMhE,EAAUA,WAACsE,IACf+B,EACArG,EAAAA,WAAW2J,iBAAiB1G,GAAO6C,EAAO9B,GAC1CA,GAGAwC,IAAeI,EAAW7H,SAC1ByH,IAAeI,EAAW3H,QAE1BmH,EACEC,EACAtC,EACAC,EACAwC,EACAC,EACArD,EACAD,EACAwF,EACAzH,GAAK8H,EACLtC,GAGFvD,EAAiBJ,EACfkB,EACAiF,EACAP,EACAxF,EACAC,EACAlC,GAAK8H,EACLiB,EACA1G,GAGJ6F,EAAmBpJ,EAAAA,WAAW0C,MAAMsB,EAAKoF,IAE3CrB,EAAW/H,EAAAA,WAAWmH,OAAOW,EAASC,QAEtC5E,EAAiBJ,EACfqG,EACAnG,EACA0F,EACAxF,EACAC,EACAnC,GAAK+H,EACL,EACA,GAEFI,EAAmBnF,EAErBhD,GAAKC,GACLA,GAAKQ,EAAQE,EAAI,GACjBqC,EAAWoF,EAGbtJ,EAAc,GAAKC,aAAW0C,MAAM0G,EAAkBrJ,EAAc,IACpEA,EAAc,GAAKC,aAAW0C,MAAMuB,EAAUlE,EAAc,IAC5DyJ,EAAoBzI,EAClBhB,EACAkB,GAAK+H,EACL9H,GAAK8H,EACL7H,GAEFsI,EAAsBW,EAAgBA,iBAACC,YAAY,CACjDlC,UAAWpI,EACXoB,YAAaA,EACbiC,UAAWA,IAEbD,EAAiBoC,EACfkE,EACAxG,EACA0F,EACAxF,EACAC,EACAoG,EACA,GAEE9C,IACFuC,EAAOlG,EACLkB,EACAhB,EACA6F,EACAG,EACA7F,EACAlC,GAAK8H,EACL,EACA,IAIJ9D,EAAS/B,EAAe+B,OACxB,MAAMoF,GAAY5D,EAAkBxB,EAAS+D,EAAK/D,OAASA,EACrDqF,GAAoB,IAAIC,aAAaF,IAM3C,OALAC,GAAkBE,IAAItH,GAClBuD,GACF6D,GAAkBE,IAAIxB,EAAM/D,GAGvBqF"}