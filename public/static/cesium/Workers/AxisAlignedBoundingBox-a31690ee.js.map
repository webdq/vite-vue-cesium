{"version":3,"file":"AxisAlignedBoundingBox-a31690ee.js","sources":["../../../../Source/Core/AxisAlignedBoundingBox.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\r\nimport Check from \"./Check.js\";\r\nimport defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\nimport Intersect from \"./Intersect.js\";\r\n\r\n/**\r\n * Creates an instance of an AxisAlignedBoundingBox from the minimum and maximum points along the x, y, and z axes.\r\n * @alias AxisAlignedBoundingBox\r\n * @constructor\r\n *\r\n * @param {Cartesian3} [minimum=Cartesian3.ZERO] The minimum point along the x, y, and z axes.\r\n * @param {Cartesian3} [maximum=Cartesian3.ZERO] The maximum point along the x, y, and z axes.\r\n * @param {Cartesian3} [center] The center of the box; automatically computed if not supplied.\r\n *\r\n * @see BoundingSphere\r\n * @see BoundingRectangle\r\n */\r\nfunction AxisAlignedBoundingBox(minimum, maximum, center) {\r\n  /**\r\n   * The minimum point defining the bounding box.\r\n   * @type {Cartesian3}\r\n   * @default {@link Cartesian3.ZERO}\r\n   */\r\n  this.minimum = Cartesian3.clone(defaultValue(minimum, Cartesian3.ZERO));\r\n\r\n  /**\r\n   * The maximum point defining the bounding box.\r\n   * @type {Cartesian3}\r\n   * @default {@link Cartesian3.ZERO}\r\n   */\r\n  this.maximum = Cartesian3.clone(defaultValue(maximum, Cartesian3.ZERO));\r\n\r\n  // If center was not defined, compute it.\r\n  if (!defined(center)) {\r\n    center = Cartesian3.midpoint(this.minimum, this.maximum, new Cartesian3());\r\n  } else {\r\n    center = Cartesian3.clone(center);\r\n  }\r\n\r\n  /**\r\n   * The center point of the bounding box.\r\n   * @type {Cartesian3}\r\n   */\r\n  this.center = center;\r\n}\r\n\r\n/**\r\n * Creates an instance of an AxisAlignedBoundingBox from its corners.\r\n *\r\n * @param {Cartesian3} minimum The minimum point along the x, y, and z axes.\r\n * @param {Cartesian3} maximum The maximum point along the x, y, and z axes.\r\n * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.\r\n * @returns {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if one was not provided.\r\n *\r\n * @example\r\n * // Compute an axis aligned bounding box from the two corners.\r\n * const box = Cesium.AxisAlignedBoundingBox.fromCorners(new Cesium.Cartesian3(-1, -1, -1), new Cesium.Cartesian3(1, 1, 1));\r\n */\r\nAxisAlignedBoundingBox.fromCorners = function (minimum, maximum, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"minimum\", minimum);\r\n  Check.defined(\"maximum\", maximum);\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    result = new AxisAlignedBoundingBox();\r\n  }\r\n\r\n  result.minimum = Cartesian3.clone(minimum, result.minimum);\r\n  result.maximum = Cartesian3.clone(maximum, result.maximum);\r\n  result.center = Cartesian3.midpoint(minimum, maximum, result.center);\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes an instance of an AxisAlignedBoundingBox. The box is determined by\r\n * finding the points spaced the farthest apart on the x, y, and z axes.\r\n *\r\n * @param {Cartesian3[]} positions List of points that the bounding box will enclose.  Each point must have a <code>x</code>, <code>y</code>, and <code>z</code> properties.\r\n * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.\r\n * @returns {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if one was not provided.\r\n *\r\n * @example\r\n * // Compute an axis aligned bounding box enclosing two points.\r\n * const box = Cesium.AxisAlignedBoundingBox.fromPoints([new Cesium.Cartesian3(2, 0, 0), new Cesium.Cartesian3(-2, 0, 0)]);\r\n */\r\nAxisAlignedBoundingBox.fromPoints = function (positions, result) {\r\n  if (!defined(result)) {\r\n    result = new AxisAlignedBoundingBox();\r\n  }\r\n\r\n  if (!defined(positions) || positions.length === 0) {\r\n    result.minimum = Cartesian3.clone(Cartesian3.ZERO, result.minimum);\r\n    result.maximum = Cartesian3.clone(Cartesian3.ZERO, result.maximum);\r\n    result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\r\n    return result;\r\n  }\r\n\r\n  let minimumX = positions[0].x;\r\n  let minimumY = positions[0].y;\r\n  let minimumZ = positions[0].z;\r\n\r\n  let maximumX = positions[0].x;\r\n  let maximumY = positions[0].y;\r\n  let maximumZ = positions[0].z;\r\n\r\n  const length = positions.length;\r\n  for (let i = 1; i < length; i++) {\r\n    const p = positions[i];\r\n    const x = p.x;\r\n    const y = p.y;\r\n    const z = p.z;\r\n\r\n    minimumX = Math.min(x, minimumX);\r\n    maximumX = Math.max(x, maximumX);\r\n    minimumY = Math.min(y, minimumY);\r\n    maximumY = Math.max(y, maximumY);\r\n    minimumZ = Math.min(z, minimumZ);\r\n    maximumZ = Math.max(z, maximumZ);\r\n  }\r\n\r\n  const minimum = result.minimum;\r\n  minimum.x = minimumX;\r\n  minimum.y = minimumY;\r\n  minimum.z = minimumZ;\r\n\r\n  const maximum = result.maximum;\r\n  maximum.x = maximumX;\r\n  maximum.y = maximumY;\r\n  maximum.z = maximumZ;\r\n\r\n  result.center = Cartesian3.midpoint(minimum, maximum, result.center);\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Duplicates a AxisAlignedBoundingBox instance.\r\n *\r\n * @param {AxisAlignedBoundingBox} box The bounding box to duplicate.\r\n * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.\r\n * @returns {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if none was provided. (Returns undefined if box is undefined)\r\n */\r\nAxisAlignedBoundingBox.clone = function (box, result) {\r\n  if (!defined(box)) {\r\n    return undefined;\r\n  }\r\n\r\n  if (!defined(result)) {\r\n    return new AxisAlignedBoundingBox(box.minimum, box.maximum, box.center);\r\n  }\r\n\r\n  result.minimum = Cartesian3.clone(box.minimum, result.minimum);\r\n  result.maximum = Cartesian3.clone(box.maximum, result.maximum);\r\n  result.center = Cartesian3.clone(box.center, result.center);\r\n  return result;\r\n};\r\n\r\n/**\r\n * Compares the provided AxisAlignedBoundingBox componentwise and returns\r\n * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n *\r\n * @param {AxisAlignedBoundingBox} [left] The first AxisAlignedBoundingBox.\r\n * @param {AxisAlignedBoundingBox} [right] The second AxisAlignedBoundingBox.\r\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\r\n */\r\nAxisAlignedBoundingBox.equals = function (left, right) {\r\n  return (\r\n    left === right ||\r\n    (defined(left) &&\r\n      defined(right) &&\r\n      Cartesian3.equals(left.center, right.center) &&\r\n      Cartesian3.equals(left.minimum, right.minimum) &&\r\n      Cartesian3.equals(left.maximum, right.maximum))\r\n  );\r\n};\r\n\r\nlet intersectScratch = new Cartesian3();\r\n/**\r\n * Determines which side of a plane a box is located.\r\n *\r\n * @param {AxisAlignedBoundingBox} box The bounding box to test.\r\n * @param {Plane} plane The plane to test against.\r\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\r\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\r\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\r\n *                      intersects the plane.\r\n */\r\nAxisAlignedBoundingBox.intersectPlane = function (box, plane) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"box\", box);\r\n  Check.defined(\"plane\", plane);\r\n  //>>includeEnd('debug');\r\n\r\n  intersectScratch = Cartesian3.subtract(\r\n    box.maximum,\r\n    box.minimum,\r\n    intersectScratch\r\n  );\r\n  const h = Cartesian3.multiplyByScalar(\r\n    intersectScratch,\r\n    0.5,\r\n    intersectScratch\r\n  ); //The positive half diagonal\r\n  const normal = plane.normal;\r\n  const e =\r\n    h.x * Math.abs(normal.x) +\r\n    h.y * Math.abs(normal.y) +\r\n    h.z * Math.abs(normal.z);\r\n  const s = Cartesian3.dot(box.center, normal) + plane.distance; //signed distance from center\r\n\r\n  if (s - e > 0) {\r\n    return Intersect.INSIDE;\r\n  }\r\n\r\n  if (s + e < 0) {\r\n    //Not in front because normals point inward\r\n    return Intersect.OUTSIDE;\r\n  }\r\n\r\n  return Intersect.INTERSECTING;\r\n};\r\n\r\n/**\r\n * Duplicates this AxisAlignedBoundingBox instance.\r\n *\r\n * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.\r\n * @returns {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if one was not provided.\r\n */\r\nAxisAlignedBoundingBox.prototype.clone = function (result) {\r\n  return AxisAlignedBoundingBox.clone(this, result);\r\n};\r\n\r\n/**\r\n * Determines which side of a plane this box is located.\r\n *\r\n * @param {Plane} plane The plane to test against.\r\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\r\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\r\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\r\n *                      intersects the plane.\r\n */\r\nAxisAlignedBoundingBox.prototype.intersectPlane = function (plane) {\r\n  return AxisAlignedBoundingBox.intersectPlane(this, plane);\r\n};\r\n\r\n/**\r\n * Compares this AxisAlignedBoundingBox against the provided AxisAlignedBoundingBox componentwise and returns\r\n * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n *\r\n * @param {AxisAlignedBoundingBox} [right] The right hand side AxisAlignedBoundingBox.\r\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\r\n */\r\nAxisAlignedBoundingBox.prototype.equals = function (right) {\r\n  return AxisAlignedBoundingBox.equals(this, right);\r\n};\r\nexport default AxisAlignedBoundingBox;\r\n"],"names":["AxisAlignedBoundingBox","minimum","maximum","center","this","Cartesian3","clone","defaultValue","ZERO","defined","midpoint","fromCorners","result","Check","fromPoints","positions","length","minimumX","x","minimumY","y","minimumZ","z","maximumX","maximumY","maximumZ","i","p","Math","min","max","box","equals","left","right","intersectScratch","intersectPlane","plane","subtract","h","multiplyByScalar","normal","e","abs","s","dot","distance","Intersect","INSIDE","OUTSIDE","INTERSECTING","prototype"],"mappings":"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"}