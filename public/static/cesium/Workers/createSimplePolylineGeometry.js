define(["./defaultValue-69ee94f4","./Matrix2-fb98ca95","./ArcType-e1641d8d","./Transforms-f586e93e","./Color-7b0f070a","./ComponentDatatype-7ed489c0","./RuntimeError-ac440aa5","./GeometryAttribute-c6fd2455","./GeometryAttributes-1b4134a9","./IndexDatatype-b58b63e4","./PolylinePipeline-8738a2dd","./_commonjsHelpers-3aae1032-15991586","./combine-0259f56f","./WebGLConstants-f63312fc","./EllipsoidGeodesic-093468e6","./EllipsoidRhumbLine-99a9f0c8","./IntersectionTests-2d241d2b","./Plane-a09326f5"],(function(e,o,t,r,l,n,i,a,s,d,p,c,f,u,y,h,C,g){"use strict";function m(e,o,t,r,n,i,a){const s=p.PolylinePipeline.numberOfPoints(e,o,n);let d;const c=t.red,f=t.green,u=t.blue,y=t.alpha,h=r.red,C=r.green,g=r.blue,m=r.alpha;if(l.Color.equals(t,r)){for(d=0;d<s;d++)i[a++]=l.Color.floatToByte(c),i[a++]=l.Color.floatToByte(f),i[a++]=l.Color.floatToByte(u),i[a++]=l.Color.floatToByte(y);return a}const T=(h-c)/s,E=(C-f)/s,_=(g-u)/s,P=(m-y)/s;let b=a;for(d=0;d<s;d++)i[b++]=l.Color.floatToByte(c+d*T),i[b++]=l.Color.floatToByte(f+d*E),i[b++]=l.Color.floatToByte(u+d*_),i[b++]=l.Color.floatToByte(y+d*P);return b}function T(r){const a=(r=e.defaultValue(r,e.defaultValue.EMPTY_OBJECT)).positions,s=r.colors,d=e.defaultValue(r.colorsPerVertex,!1);if(!e.defined(a)||a.length<2)throw new i.DeveloperError("At least two positions are required.");if(e.defined(s)&&(d&&s.length<a.length||!d&&s.length<a.length-1))throw new i.DeveloperError("colors has an invalid length.");this._positions=a,this._colors=s,this._colorsPerVertex=d,this._arcType=e.defaultValue(r.arcType,t.ArcType.GEODESIC),this._granularity=e.defaultValue(r.granularity,n.CesiumMath.RADIANS_PER_DEGREE),this._ellipsoid=e.defaultValue(r.ellipsoid,o.Ellipsoid.WGS84),this._workerName="createSimplePolylineGeometry";let p=1+a.length*o.Cartesian3.packedLength;p+=e.defined(s)?1+s.length*l.Color.packedLength:1,this.packedLength=p+o.Ellipsoid.packedLength+3}T.pack=function(t,r,n){if(!e.defined(t))throw new i.DeveloperError("value is required");if(!e.defined(r))throw new i.DeveloperError("array is required");let a;n=e.defaultValue(n,0);const s=t._positions;let d=s.length;for(r[n++]=d,a=0;a<d;++a,n+=o.Cartesian3.packedLength)o.Cartesian3.pack(s[a],r,n);const p=t._colors;for(d=e.defined(p)?p.length:0,r[n++]=d,a=0;a<d;++a,n+=l.Color.packedLength)l.Color.pack(p[a],r,n);return o.Ellipsoid.pack(t._ellipsoid,r,n),n+=o.Ellipsoid.packedLength,r[n++]=t._colorsPerVertex?1:0,r[n++]=t._arcType,r[n]=t._granularity,r},T.unpack=function(t,r,n){if(!e.defined(t))throw new i.DeveloperError("array is required");let a;r=e.defaultValue(r,0);let s=t[r++];const d=new Array(s);for(a=0;a<s;++a,r+=o.Cartesian3.packedLength)d[a]=o.Cartesian3.unpack(t,r);s=t[r++];const p=s>0?new Array(s):void 0;for(a=0;a<s;++a,r+=l.Color.packedLength)p[a]=l.Color.unpack(t,r);const c=o.Ellipsoid.unpack(t,r);r+=o.Ellipsoid.packedLength;const f=1===t[r++],u=t[r++],y=t[r];return e.defined(n)?(n._positions=d,n._colors=p,n._ellipsoid=c,n._colorsPerVertex=f,n._arcType=u,n._granularity=y,n):new T({positions:d,colors:p,ellipsoid:c,colorsPerVertex:f,arcType:u,granularity:y})};const E=new Array(2),_=new Array(2),P={positions:E,height:_,ellipsoid:void 0,minDistance:void 0,granularity:void 0};return T.createGeometry=function(i){const c=i._positions,f=i._colors,u=i._colorsPerVertex,y=i._arcType,h=i._granularity,C=i._ellipsoid,g=n.CesiumMath.chordLength(h,C.maximumRadius),T=e.defined(f)&&!u;let b;const A=c.length;let B,w,k,D,G=0;if(y===t.ArcType.GEODESIC||y===t.ArcType.RHUMB){let o,r,i;y===t.ArcType.GEODESIC?(o=n.CesiumMath.chordLength(h,C.maximumRadius),r=p.PolylinePipeline.numberOfPoints,i=p.PolylinePipeline.generateArc):(o=h,r=p.PolylinePipeline.numberOfPointsRhumbLine,i=p.PolylinePipeline.generateRhumbArc);const a=p.PolylinePipeline.extractHeights(c,C),s=P;if(y===t.ArcType.GEODESIC?s.minDistance=g:s.granularity=h,s.ellipsoid=C,T){let t=0;for(b=0;b<A-1;b++)t+=r(c[b],c[b+1],o)+1;B=new Float64Array(3*t),k=new Uint8Array(4*t),s.positions=E,s.height=_;let n=0;for(b=0;b<A-1;++b){E[0]=c[b],E[1]=c[b+1],_[0]=a[b],_[1]=a[b+1];const o=i(s);if(e.defined(f)){const e=o.length/3;D=f[b];for(let o=0;o<e;++o)k[n++]=l.Color.floatToByte(D.red),k[n++]=l.Color.floatToByte(D.green),k[n++]=l.Color.floatToByte(D.blue),k[n++]=l.Color.floatToByte(D.alpha)}B.set(o,G),G+=o.length}}else if(s.positions=c,s.height=a,B=new Float64Array(i(s)),e.defined(f)){for(k=new Uint8Array(B.length/3*4),b=0;b<A-1;++b){G=m(c[b],c[b+1],f[b],f[b+1],g,k,G)}const e=f[A-1];k[G++]=l.Color.floatToByte(e.red),k[G++]=l.Color.floatToByte(e.green),k[G++]=l.Color.floatToByte(e.blue),k[G++]=l.Color.floatToByte(e.alpha)}}else{w=T?2*A-2:A,B=new Float64Array(3*w),k=e.defined(f)?new Uint8Array(4*w):void 0;let t=0,r=0;for(b=0;b<A;++b){const n=c[b];if(T&&b>0&&(o.Cartesian3.pack(n,B,t),t+=3,D=f[b-1],k[r++]=l.Color.floatToByte(D.red),k[r++]=l.Color.floatToByte(D.green),k[r++]=l.Color.floatToByte(D.blue),k[r++]=l.Color.floatToByte(D.alpha)),T&&b===A-1)break;o.Cartesian3.pack(n,B,t),t+=3,e.defined(f)&&(D=f[b],k[r++]=l.Color.floatToByte(D.red),k[r++]=l.Color.floatToByte(D.green),k[r++]=l.Color.floatToByte(D.blue),k[r++]=l.Color.floatToByte(D.alpha))}}const L=new s.GeometryAttributes;L.position=new a.GeometryAttribute({componentDatatype:n.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:B}),e.defined(f)&&(L.color=new a.GeometryAttribute({componentDatatype:n.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:4,values:k,normalize:!0})),w=B.length/3;const v=2*(w-1),V=d.IndexDatatype.createTypedArray(w,v);let x=0;for(b=0;b<w-1;++b)V[x++]=b,V[x++]=b+1;return new a.Geometry({attributes:L,indices:V,primitiveType:a.PrimitiveType.LINES,boundingSphere:r.BoundingSphere.fromPoints(c)})},function(t,r){return e.defined(r)&&(t=T.unpack(t,r)),t._ellipsoid=o.Ellipsoid.clone(t._ellipsoid),T.createGeometry(t)}}));
//# sourceMappingURL=createSimplePolylineGeometry.js.map
