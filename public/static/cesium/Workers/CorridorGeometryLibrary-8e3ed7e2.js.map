{"version":3,"file":"CorridorGeometryLibrary-8e3ed7e2.js","sources":["../../../../Source/Core/CorridorGeometryLibrary.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\r\nimport CornerType from \"./CornerType.js\";\r\nimport defined from \"./defined.js\";\r\nimport CesiumMath from \"./Math.js\";\r\nimport Matrix3 from \"./Matrix3.js\";\r\nimport PolylinePipeline from \"./PolylinePipeline.js\";\r\nimport PolylineVolumeGeometryLibrary from \"./PolylineVolumeGeometryLibrary.js\";\r\nimport Quaternion from \"./Quaternion.js\";\r\n\r\n/**\r\n * @private\r\n */\r\nconst CorridorGeometryLibrary = {};\r\n\r\nconst scratch1 = new Cartesian3();\r\nconst scratch2 = new Cartesian3();\r\nconst scratch3 = new Cartesian3();\r\nconst scratch4 = new Cartesian3();\r\n\r\nconst scaleArray2 = [new Cartesian3(), new Cartesian3()];\r\n\r\nconst cartesian1 = new Cartesian3();\r\nconst cartesian2 = new Cartesian3();\r\nconst cartesian3 = new Cartesian3();\r\nconst cartesian4 = new Cartesian3();\r\nconst cartesian5 = new Cartesian3();\r\nconst cartesian6 = new Cartesian3();\r\nconst cartesian7 = new Cartesian3();\r\nconst cartesian8 = new Cartesian3();\r\nconst cartesian9 = new Cartesian3();\r\nconst cartesian10 = new Cartesian3();\r\n\r\nconst quaterion = new Quaternion();\r\nconst rotMatrix = new Matrix3();\r\nfunction computeRoundCorner(\r\n  cornerPoint,\r\n  startPoint,\r\n  endPoint,\r\n  cornerType,\r\n  leftIsOutside\r\n) {\r\n  const angle = Cartesian3.angleBetween(\r\n    Cartesian3.subtract(startPoint, cornerPoint, scratch1),\r\n    Cartesian3.subtract(endPoint, cornerPoint, scratch2)\r\n  );\r\n  const granularity =\r\n    cornerType === CornerType.BEVELED\r\n      ? 1\r\n      : Math.ceil(angle / CesiumMath.toRadians(5)) + 1;\r\n\r\n  const size = granularity * 3;\r\n  const array = new Array(size);\r\n\r\n  array[size - 3] = endPoint.x;\r\n  array[size - 2] = endPoint.y;\r\n  array[size - 1] = endPoint.z;\r\n\r\n  let m;\r\n  if (leftIsOutside) {\r\n    m = Matrix3.fromQuaternion(\r\n      Quaternion.fromAxisAngle(\r\n        Cartesian3.negate(cornerPoint, scratch1),\r\n        angle / granularity,\r\n        quaterion\r\n      ),\r\n      rotMatrix\r\n    );\r\n  } else {\r\n    m = Matrix3.fromQuaternion(\r\n      Quaternion.fromAxisAngle(cornerPoint, angle / granularity, quaterion),\r\n      rotMatrix\r\n    );\r\n  }\r\n\r\n  let index = 0;\r\n  startPoint = Cartesian3.clone(startPoint, scratch1);\r\n  for (let i = 0; i < granularity; i++) {\r\n    startPoint = Matrix3.multiplyByVector(m, startPoint, startPoint);\r\n    array[index++] = startPoint.x;\r\n    array[index++] = startPoint.y;\r\n    array[index++] = startPoint.z;\r\n  }\r\n\r\n  return array;\r\n}\r\n\r\nfunction addEndCaps(calculatedPositions) {\r\n  let cornerPoint = cartesian1;\r\n  let startPoint = cartesian2;\r\n  let endPoint = cartesian3;\r\n\r\n  let leftEdge = calculatedPositions[1];\r\n  startPoint = Cartesian3.fromArray(\r\n    calculatedPositions[1],\r\n    leftEdge.length - 3,\r\n    startPoint\r\n  );\r\n  endPoint = Cartesian3.fromArray(calculatedPositions[0], 0, endPoint);\r\n  cornerPoint = Cartesian3.midpoint(startPoint, endPoint, cornerPoint);\r\n  const firstEndCap = computeRoundCorner(\r\n    cornerPoint,\r\n    startPoint,\r\n    endPoint,\r\n    CornerType.ROUNDED,\r\n    false\r\n  );\r\n\r\n  const length = calculatedPositions.length - 1;\r\n  const rightEdge = calculatedPositions[length - 1];\r\n  leftEdge = calculatedPositions[length];\r\n  startPoint = Cartesian3.fromArray(\r\n    rightEdge,\r\n    rightEdge.length - 3,\r\n    startPoint\r\n  );\r\n  endPoint = Cartesian3.fromArray(leftEdge, 0, endPoint);\r\n  cornerPoint = Cartesian3.midpoint(startPoint, endPoint, cornerPoint);\r\n  const lastEndCap = computeRoundCorner(\r\n    cornerPoint,\r\n    startPoint,\r\n    endPoint,\r\n    CornerType.ROUNDED,\r\n    false\r\n  );\r\n\r\n  return [firstEndCap, lastEndCap];\r\n}\r\n\r\nfunction computeMiteredCorner(\r\n  position,\r\n  leftCornerDirection,\r\n  lastPoint,\r\n  leftIsOutside\r\n) {\r\n  let cornerPoint = scratch1;\r\n  if (leftIsOutside) {\r\n    cornerPoint = Cartesian3.add(position, leftCornerDirection, cornerPoint);\r\n  } else {\r\n    leftCornerDirection = Cartesian3.negate(\r\n      leftCornerDirection,\r\n      leftCornerDirection\r\n    );\r\n    cornerPoint = Cartesian3.add(position, leftCornerDirection, cornerPoint);\r\n  }\r\n  return [\r\n    cornerPoint.x,\r\n    cornerPoint.y,\r\n    cornerPoint.z,\r\n    lastPoint.x,\r\n    lastPoint.y,\r\n    lastPoint.z,\r\n  ];\r\n}\r\n\r\nfunction addShiftedPositions(positions, left, scalar, calculatedPositions) {\r\n  const rightPositions = new Array(positions.length);\r\n  const leftPositions = new Array(positions.length);\r\n  const scaledLeft = Cartesian3.multiplyByScalar(left, scalar, scratch1);\r\n  const scaledRight = Cartesian3.negate(scaledLeft, scratch2);\r\n  let rightIndex = 0;\r\n  let leftIndex = positions.length - 1;\r\n\r\n  for (let i = 0; i < positions.length; i += 3) {\r\n    const pos = Cartesian3.fromArray(positions, i, scratch3);\r\n    const rightPos = Cartesian3.add(pos, scaledRight, scratch4);\r\n    rightPositions[rightIndex++] = rightPos.x;\r\n    rightPositions[rightIndex++] = rightPos.y;\r\n    rightPositions[rightIndex++] = rightPos.z;\r\n\r\n    const leftPos = Cartesian3.add(pos, scaledLeft, scratch4);\r\n    leftPositions[leftIndex--] = leftPos.z;\r\n    leftPositions[leftIndex--] = leftPos.y;\r\n    leftPositions[leftIndex--] = leftPos.x;\r\n  }\r\n  calculatedPositions.push(rightPositions, leftPositions);\r\n\r\n  return calculatedPositions;\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\nCorridorGeometryLibrary.addAttribute = function (\r\n  attribute,\r\n  value,\r\n  front,\r\n  back\r\n) {\r\n  const x = value.x;\r\n  const y = value.y;\r\n  const z = value.z;\r\n  if (defined(front)) {\r\n    attribute[front] = x;\r\n    attribute[front + 1] = y;\r\n    attribute[front + 2] = z;\r\n  }\r\n  if (defined(back)) {\r\n    attribute[back] = z;\r\n    attribute[back - 1] = y;\r\n    attribute[back - 2] = x;\r\n  }\r\n};\r\n\r\nconst scratchForwardProjection = new Cartesian3();\r\nconst scratchBackwardProjection = new Cartesian3();\r\n\r\n/**\r\n * @private\r\n */\r\nCorridorGeometryLibrary.computePositions = function (params) {\r\n  const granularity = params.granularity;\r\n  const positions = params.positions;\r\n  const ellipsoid = params.ellipsoid;\r\n  const width = params.width / 2;\r\n  const cornerType = params.cornerType;\r\n  const saveAttributes = params.saveAttributes;\r\n  let normal = cartesian1;\r\n  let forward = cartesian2;\r\n  let backward = cartesian3;\r\n  let left = cartesian4;\r\n  let cornerDirection = cartesian5;\r\n  let startPoint = cartesian6;\r\n  let previousPos = cartesian7;\r\n  let rightPos = cartesian8;\r\n  let leftPos = cartesian9;\r\n  let center = cartesian10;\r\n  let calculatedPositions = [];\r\n  const calculatedLefts = saveAttributes ? [] : undefined;\r\n  const calculatedNormals = saveAttributes ? [] : undefined;\r\n  let position = positions[0]; //add first point\r\n  let nextPosition = positions[1];\r\n\r\n  forward = Cartesian3.normalize(\r\n    Cartesian3.subtract(nextPosition, position, forward),\r\n    forward\r\n  );\r\n  normal = ellipsoid.geodeticSurfaceNormal(position, normal);\r\n  left = Cartesian3.normalize(Cartesian3.cross(normal, forward, left), left);\r\n  if (saveAttributes) {\r\n    calculatedLefts.push(left.x, left.y, left.z);\r\n    calculatedNormals.push(normal.x, normal.y, normal.z);\r\n  }\r\n  previousPos = Cartesian3.clone(position, previousPos);\r\n  position = nextPosition;\r\n  backward = Cartesian3.negate(forward, backward);\r\n\r\n  let subdividedPositions;\r\n  const corners = [];\r\n  let i;\r\n  const length = positions.length;\r\n  for (i = 1; i < length - 1; i++) {\r\n    // add middle points and corners\r\n    normal = ellipsoid.geodeticSurfaceNormal(position, normal);\r\n    nextPosition = positions[i + 1];\r\n    forward = Cartesian3.normalize(\r\n      Cartesian3.subtract(nextPosition, position, forward),\r\n      forward\r\n    );\r\n    cornerDirection = Cartesian3.normalize(\r\n      Cartesian3.add(forward, backward, cornerDirection),\r\n      cornerDirection\r\n    );\r\n\r\n    const forwardProjection = Cartesian3.multiplyByScalar(\r\n      normal,\r\n      Cartesian3.dot(forward, normal),\r\n      scratchForwardProjection\r\n    );\r\n    Cartesian3.subtract(forward, forwardProjection, forwardProjection);\r\n    Cartesian3.normalize(forwardProjection, forwardProjection);\r\n\r\n    const backwardProjection = Cartesian3.multiplyByScalar(\r\n      normal,\r\n      Cartesian3.dot(backward, normal),\r\n      scratchBackwardProjection\r\n    );\r\n    Cartesian3.subtract(backward, backwardProjection, backwardProjection);\r\n    Cartesian3.normalize(backwardProjection, backwardProjection);\r\n\r\n    const doCorner = !CesiumMath.equalsEpsilon(\r\n      Math.abs(Cartesian3.dot(forwardProjection, backwardProjection)),\r\n      1.0,\r\n      CesiumMath.EPSILON7\r\n    );\r\n\r\n    if (doCorner) {\r\n      cornerDirection = Cartesian3.cross(\r\n        cornerDirection,\r\n        normal,\r\n        cornerDirection\r\n      );\r\n      cornerDirection = Cartesian3.cross(\r\n        normal,\r\n        cornerDirection,\r\n        cornerDirection\r\n      );\r\n      cornerDirection = Cartesian3.normalize(cornerDirection, cornerDirection);\r\n      const scalar =\r\n        width /\r\n        Math.max(\r\n          0.25,\r\n          Cartesian3.magnitude(\r\n            Cartesian3.cross(cornerDirection, backward, scratch1)\r\n          )\r\n        );\r\n      const leftIsOutside = PolylineVolumeGeometryLibrary.angleIsGreaterThanPi(\r\n        forward,\r\n        backward,\r\n        position,\r\n        ellipsoid\r\n      );\r\n      cornerDirection = Cartesian3.multiplyByScalar(\r\n        cornerDirection,\r\n        scalar,\r\n        cornerDirection\r\n      );\r\n      if (leftIsOutside) {\r\n        rightPos = Cartesian3.add(position, cornerDirection, rightPos);\r\n        center = Cartesian3.add(\r\n          rightPos,\r\n          Cartesian3.multiplyByScalar(left, width, center),\r\n          center\r\n        );\r\n        leftPos = Cartesian3.add(\r\n          rightPos,\r\n          Cartesian3.multiplyByScalar(left, width * 2, leftPos),\r\n          leftPos\r\n        );\r\n        scaleArray2[0] = Cartesian3.clone(previousPos, scaleArray2[0]);\r\n        scaleArray2[1] = Cartesian3.clone(center, scaleArray2[1]);\r\n        subdividedPositions = PolylinePipeline.generateArc({\r\n          positions: scaleArray2,\r\n          granularity: granularity,\r\n          ellipsoid: ellipsoid,\r\n        });\r\n        calculatedPositions = addShiftedPositions(\r\n          subdividedPositions,\r\n          left,\r\n          width,\r\n          calculatedPositions\r\n        );\r\n        if (saveAttributes) {\r\n          calculatedLefts.push(left.x, left.y, left.z);\r\n          calculatedNormals.push(normal.x, normal.y, normal.z);\r\n        }\r\n        startPoint = Cartesian3.clone(leftPos, startPoint);\r\n        left = Cartesian3.normalize(\r\n          Cartesian3.cross(normal, forward, left),\r\n          left\r\n        );\r\n        leftPos = Cartesian3.add(\r\n          rightPos,\r\n          Cartesian3.multiplyByScalar(left, width * 2, leftPos),\r\n          leftPos\r\n        );\r\n        previousPos = Cartesian3.add(\r\n          rightPos,\r\n          Cartesian3.multiplyByScalar(left, width, previousPos),\r\n          previousPos\r\n        );\r\n        if (\r\n          cornerType === CornerType.ROUNDED ||\r\n          cornerType === CornerType.BEVELED\r\n        ) {\r\n          corners.push({\r\n            leftPositions: computeRoundCorner(\r\n              rightPos,\r\n              startPoint,\r\n              leftPos,\r\n              cornerType,\r\n              leftIsOutside\r\n            ),\r\n          });\r\n        } else {\r\n          corners.push({\r\n            leftPositions: computeMiteredCorner(\r\n              position,\r\n              Cartesian3.negate(cornerDirection, cornerDirection),\r\n              leftPos,\r\n              leftIsOutside\r\n            ),\r\n          });\r\n        }\r\n      } else {\r\n        leftPos = Cartesian3.add(position, cornerDirection, leftPos);\r\n        center = Cartesian3.add(\r\n          leftPos,\r\n          Cartesian3.negate(\r\n            Cartesian3.multiplyByScalar(left, width, center),\r\n            center\r\n          ),\r\n          center\r\n        );\r\n        rightPos = Cartesian3.add(\r\n          leftPos,\r\n          Cartesian3.negate(\r\n            Cartesian3.multiplyByScalar(left, width * 2, rightPos),\r\n            rightPos\r\n          ),\r\n          rightPos\r\n        );\r\n        scaleArray2[0] = Cartesian3.clone(previousPos, scaleArray2[0]);\r\n        scaleArray2[1] = Cartesian3.clone(center, scaleArray2[1]);\r\n        subdividedPositions = PolylinePipeline.generateArc({\r\n          positions: scaleArray2,\r\n          granularity: granularity,\r\n          ellipsoid: ellipsoid,\r\n        });\r\n        calculatedPositions = addShiftedPositions(\r\n          subdividedPositions,\r\n          left,\r\n          width,\r\n          calculatedPositions\r\n        );\r\n        if (saveAttributes) {\r\n          calculatedLefts.push(left.x, left.y, left.z);\r\n          calculatedNormals.push(normal.x, normal.y, normal.z);\r\n        }\r\n        startPoint = Cartesian3.clone(rightPos, startPoint);\r\n        left = Cartesian3.normalize(\r\n          Cartesian3.cross(normal, forward, left),\r\n          left\r\n        );\r\n        rightPos = Cartesian3.add(\r\n          leftPos,\r\n          Cartesian3.negate(\r\n            Cartesian3.multiplyByScalar(left, width * 2, rightPos),\r\n            rightPos\r\n          ),\r\n          rightPos\r\n        );\r\n        previousPos = Cartesian3.add(\r\n          leftPos,\r\n          Cartesian3.negate(\r\n            Cartesian3.multiplyByScalar(left, width, previousPos),\r\n            previousPos\r\n          ),\r\n          previousPos\r\n        );\r\n        if (\r\n          cornerType === CornerType.ROUNDED ||\r\n          cornerType === CornerType.BEVELED\r\n        ) {\r\n          corners.push({\r\n            rightPositions: computeRoundCorner(\r\n              leftPos,\r\n              startPoint,\r\n              rightPos,\r\n              cornerType,\r\n              leftIsOutside\r\n            ),\r\n          });\r\n        } else {\r\n          corners.push({\r\n            rightPositions: computeMiteredCorner(\r\n              position,\r\n              cornerDirection,\r\n              rightPos,\r\n              leftIsOutside\r\n            ),\r\n          });\r\n        }\r\n      }\r\n      backward = Cartesian3.negate(forward, backward);\r\n    }\r\n    position = nextPosition;\r\n  }\r\n\r\n  normal = ellipsoid.geodeticSurfaceNormal(position, normal);\r\n  scaleArray2[0] = Cartesian3.clone(previousPos, scaleArray2[0]);\r\n  scaleArray2[1] = Cartesian3.clone(position, scaleArray2[1]);\r\n  subdividedPositions = PolylinePipeline.generateArc({\r\n    positions: scaleArray2,\r\n    granularity: granularity,\r\n    ellipsoid: ellipsoid,\r\n  });\r\n  calculatedPositions = addShiftedPositions(\r\n    subdividedPositions,\r\n    left,\r\n    width,\r\n    calculatedPositions\r\n  );\r\n  if (saveAttributes) {\r\n    calculatedLefts.push(left.x, left.y, left.z);\r\n    calculatedNormals.push(normal.x, normal.y, normal.z);\r\n  }\r\n\r\n  let endPositions;\r\n  if (cornerType === CornerType.ROUNDED) {\r\n    endPositions = addEndCaps(calculatedPositions);\r\n  }\r\n\r\n  return {\r\n    positions: calculatedPositions,\r\n    corners: corners,\r\n    lefts: calculatedLefts,\r\n    normals: calculatedNormals,\r\n    endPositions: endPositions,\r\n  };\r\n};\r\nexport default CorridorGeometryLibrary;\r\n"],"names":["CorridorGeometryLibrary","scratch1","Cartesian3","scratch2","scratch3","scratch4","scaleArray2","cartesian1","cartesian2","cartesian3","cartesian4","cartesian5","cartesian6","cartesian7","cartesian8","cartesian9","cartesian10","quaterion","Quaternion","rotMatrix","Matrix3","computeRoundCorner","cornerPoint","startPoint","endPoint","cornerType","leftIsOutside","angle","angleBetween","subtract","granularity","CornerType","BEVELED","Math","ceil","CesiumMath","toRadians","size","array","Array","m","x","y","z","fromQuaternion","fromAxisAngle","negate","index","clone","i","multiplyByVector","computeMiteredCorner","position","leftCornerDirection","lastPoint","add","addShiftedPositions","positions","left","scalar","calculatedPositions","rightPositions","length","leftPositions","scaledLeft","multiplyByScalar","scaledRight","rightIndex","leftIndex","pos","fromArray","rightPos","leftPos","push","addAttribute","attribute","value","front","back","defined","scratchForwardProjection","scratchBackwardProjection","computePositions","params","ellipsoid","width","saveAttributes","normal","forward","backward","cornerDirection","previousPos","center","calculatedLefts","undefined","calculatedNormals","subdividedPositions","nextPosition","normalize","geodeticSurfaceNormal","cross","corners","forwardProjection","dot","backwardProjection","equalsEpsilon","abs","EPSILON7","max","magnitude","PolylineVolumeGeometryLibrary","angleIsGreaterThanPi","PolylinePipeline","generateArc","ROUNDED","endPositions","leftEdge","midpoint","firstEndCap","rightEdge","addEndCaps","lefts","normals"],"mappings":"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"}