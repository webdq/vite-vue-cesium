{"version":3,"file":"createVectorTileClampedPolylines.js","sources":["../../../../Source/WorkersES6/createVectorTileClampedPolylines.js"],"sourcesContent":["import AttributeCompression from \"../Core/AttributeCompression.js\";\r\nimport Cartesian3 from \"../Core/Cartesian3.js\";\r\nimport Cartographic from \"../Core/Cartographic.js\";\r\nimport combine from \"../Core/combine.js\";\r\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\r\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\r\nimport CesiumMath from \"../Core/Math.js\";\r\nimport Rectangle from \"../Core/Rectangle.js\";\r\nimport createTaskProcessorWorker from \"./createTaskProcessorWorker.js\";\r\n\r\nconst MAX_SHORT = 32767;\r\nconst MITER_BREAK = Math.cos(CesiumMath.toRadians(150.0));\r\n\r\nconst scratchBVCartographic = new Cartographic();\r\nconst scratchEncodedPosition = new Cartesian3();\r\n\r\nfunction decodePositions(\r\n  uBuffer,\r\n  vBuffer,\r\n  heightBuffer,\r\n  rectangle,\r\n  minimumHeight,\r\n  maximumHeight,\r\n  ellipsoid\r\n) {\r\n  const positionsLength = uBuffer.length;\r\n  const decodedPositions = new Float64Array(positionsLength * 3);\r\n  for (let i = 0; i < positionsLength; ++i) {\r\n    const u = uBuffer[i];\r\n    const v = vBuffer[i];\r\n    const h = heightBuffer[i];\r\n\r\n    const lon = CesiumMath.lerp(rectangle.west, rectangle.east, u / MAX_SHORT);\r\n    const lat = CesiumMath.lerp(\r\n      rectangle.south,\r\n      rectangle.north,\r\n      v / MAX_SHORT\r\n    );\r\n    const alt = CesiumMath.lerp(minimumHeight, maximumHeight, h / MAX_SHORT);\r\n\r\n    const cartographic = Cartographic.fromRadians(\r\n      lon,\r\n      lat,\r\n      alt,\r\n      scratchBVCartographic\r\n    );\r\n    const decodedPosition = ellipsoid.cartographicToCartesian(\r\n      cartographic,\r\n      scratchEncodedPosition\r\n    );\r\n    Cartesian3.pack(decodedPosition, decodedPositions, i * 3);\r\n  }\r\n  return decodedPositions;\r\n}\r\n\r\nfunction getPositionOffsets(counts) {\r\n  const countsLength = counts.length;\r\n  const positionOffsets = new Uint32Array(countsLength + 1);\r\n  let offset = 0;\r\n  for (let i = 0; i < countsLength; ++i) {\r\n    positionOffsets[i] = offset;\r\n    offset += counts[i];\r\n  }\r\n  positionOffsets[countsLength] = offset;\r\n  return positionOffsets;\r\n}\r\n\r\nconst previousCompressedCartographicScratch = new Cartographic();\r\nconst currentCompressedCartographicScratch = new Cartographic();\r\nfunction removeDuplicates(uBuffer, vBuffer, heightBuffer, counts) {\r\n  const countsLength = counts.length;\r\n  const positionsLength = uBuffer.length;\r\n  const markRemoval = new Uint8Array(positionsLength);\r\n  const previous = previousCompressedCartographicScratch;\r\n  const current = currentCompressedCartographicScratch;\r\n  let offset = 0;\r\n  for (let i = 0; i < countsLength; i++) {\r\n    const count = counts[i];\r\n    let updatedCount = count;\r\n    for (let j = 1; j < count; j++) {\r\n      const index = offset + j;\r\n      const previousIndex = index - 1;\r\n      current.longitude = uBuffer[index];\r\n      current.latitude = vBuffer[index];\r\n      previous.longitude = uBuffer[previousIndex];\r\n      previous.latitude = vBuffer[previousIndex];\r\n\r\n      if (Cartographic.equals(current, previous)) {\r\n        updatedCount--;\r\n        markRemoval[previousIndex] = 1;\r\n      }\r\n    }\r\n    counts[i] = updatedCount;\r\n    offset += count;\r\n  }\r\n\r\n  let nextAvailableIndex = 0;\r\n  for (let k = 0; k < positionsLength; k++) {\r\n    if (markRemoval[k] !== 1) {\r\n      uBuffer[nextAvailableIndex] = uBuffer[k];\r\n      vBuffer[nextAvailableIndex] = vBuffer[k];\r\n      heightBuffer[nextAvailableIndex] = heightBuffer[k];\r\n      nextAvailableIndex++;\r\n    }\r\n  }\r\n}\r\n\r\nfunction VertexAttributesAndIndices(volumesCount) {\r\n  const vertexCount = volumesCount * 8;\r\n  const vec3Floats = vertexCount * 3;\r\n  const vec4Floats = vertexCount * 4;\r\n  this.startEllipsoidNormals = new Float32Array(vec3Floats);\r\n  this.endEllipsoidNormals = new Float32Array(vec3Floats);\r\n  this.startPositionAndHeights = new Float32Array(vec4Floats);\r\n  this.startFaceNormalAndVertexCornerIds = new Float32Array(vec4Floats);\r\n  this.endPositionAndHeights = new Float32Array(vec4Floats);\r\n  this.endFaceNormalAndHalfWidths = new Float32Array(vec4Floats);\r\n  this.vertexBatchIds = new Uint16Array(vertexCount);\r\n\r\n  this.indices = IndexDatatype.createTypedArray(vertexCount, 36 * volumesCount);\r\n\r\n  this.vec3Offset = 0;\r\n  this.vec4Offset = 0;\r\n  this.batchIdOffset = 0;\r\n  this.indexOffset = 0;\r\n\r\n  this.volumeStartIndex = 0;\r\n}\r\n\r\nconst towardCurrScratch = new Cartesian3();\r\nconst towardNextScratch = new Cartesian3();\r\nfunction computeMiteredNormal(\r\n  previousPosition,\r\n  position,\r\n  nextPosition,\r\n  ellipsoidSurfaceNormal,\r\n  result\r\n) {\r\n  const towardNext = Cartesian3.subtract(\r\n    nextPosition,\r\n    position,\r\n    towardNextScratch\r\n  );\r\n  let towardCurr = Cartesian3.subtract(\r\n    position,\r\n    previousPosition,\r\n    towardCurrScratch\r\n  );\r\n  Cartesian3.normalize(towardNext, towardNext);\r\n  Cartesian3.normalize(towardCurr, towardCurr);\r\n\r\n  if (Cartesian3.dot(towardNext, towardCurr) < MITER_BREAK) {\r\n    towardCurr = Cartesian3.multiplyByScalar(\r\n      towardCurr,\r\n      -1.0,\r\n      towardCurrScratch\r\n    );\r\n  }\r\n\r\n  Cartesian3.add(towardNext, towardCurr, result);\r\n  if (Cartesian3.equals(result, Cartesian3.ZERO)) {\r\n    result = Cartesian3.subtract(previousPosition, position);\r\n  }\r\n\r\n  // Make sure the normal is orthogonal to the ellipsoid surface normal\r\n  Cartesian3.cross(result, ellipsoidSurfaceNormal, result);\r\n  Cartesian3.cross(ellipsoidSurfaceNormal, result, result);\r\n  Cartesian3.normalize(result, result);\r\n  return result;\r\n}\r\n\r\n// Winding order is reversed so each segment's volume is inside-out\r\n//          3-----------7\r\n//         /|   left   /|\r\n//        / | 1       / |\r\n//       2-----------6  5  end\r\n//       | /         | /\r\n// start |/  right   |/\r\n//       0-----------4\r\n//\r\nconst REFERENCE_INDICES = [\r\n  0,\r\n  2,\r\n  6,\r\n  0,\r\n  6,\r\n  4, // right\r\n  0,\r\n  1,\r\n  3,\r\n  0,\r\n  3,\r\n  2, // start face\r\n  0,\r\n  4,\r\n  5,\r\n  0,\r\n  5,\r\n  1, // bottom\r\n  5,\r\n  3,\r\n  1,\r\n  5,\r\n  7,\r\n  3, // left\r\n  7,\r\n  5,\r\n  4,\r\n  7,\r\n  4,\r\n  6, // end face\r\n  7,\r\n  6,\r\n  2,\r\n  7,\r\n  2,\r\n  3, // top\r\n];\r\nconst REFERENCE_INDICES_LENGTH = REFERENCE_INDICES.length;\r\n\r\nconst positionScratch = new Cartesian3();\r\nconst scratchStartEllipsoidNormal = new Cartesian3();\r\nconst scratchStartFaceNormal = new Cartesian3();\r\nconst scratchEndEllipsoidNormal = new Cartesian3();\r\nconst scratchEndFaceNormal = new Cartesian3();\r\nVertexAttributesAndIndices.prototype.addVolume = function (\r\n  preStartRTC,\r\n  startRTC,\r\n  endRTC,\r\n  postEndRTC,\r\n  startHeight,\r\n  endHeight,\r\n  halfWidth,\r\n  batchId,\r\n  center,\r\n  ellipsoid\r\n) {\r\n  let position = Cartesian3.add(startRTC, center, positionScratch);\r\n  const startEllipsoidNormal = ellipsoid.geodeticSurfaceNormal(\r\n    position,\r\n    scratchStartEllipsoidNormal\r\n  );\r\n  position = Cartesian3.add(endRTC, center, positionScratch);\r\n  const endEllipsoidNormal = ellipsoid.geodeticSurfaceNormal(\r\n    position,\r\n    scratchEndEllipsoidNormal\r\n  );\r\n\r\n  const startFaceNormal = computeMiteredNormal(\r\n    preStartRTC,\r\n    startRTC,\r\n    endRTC,\r\n    startEllipsoidNormal,\r\n    scratchStartFaceNormal\r\n  );\r\n  const endFaceNormal = computeMiteredNormal(\r\n    postEndRTC,\r\n    endRTC,\r\n    startRTC,\r\n    endEllipsoidNormal,\r\n    scratchEndFaceNormal\r\n  );\r\n\r\n  const startEllipsoidNormals = this.startEllipsoidNormals;\r\n  const endEllipsoidNormals = this.endEllipsoidNormals;\r\n  const startPositionAndHeights = this.startPositionAndHeights;\r\n  const startFaceNormalAndVertexCornerIds = this\r\n    .startFaceNormalAndVertexCornerIds;\r\n  const endPositionAndHeights = this.endPositionAndHeights;\r\n  const endFaceNormalAndHalfWidths = this.endFaceNormalAndHalfWidths;\r\n  const vertexBatchIds = this.vertexBatchIds;\r\n\r\n  let batchIdOffset = this.batchIdOffset;\r\n  let vec3Offset = this.vec3Offset;\r\n  let vec4Offset = this.vec4Offset;\r\n\r\n  let i;\r\n  for (i = 0; i < 8; i++) {\r\n    Cartesian3.pack(startEllipsoidNormal, startEllipsoidNormals, vec3Offset);\r\n    Cartesian3.pack(endEllipsoidNormal, endEllipsoidNormals, vec3Offset);\r\n\r\n    Cartesian3.pack(startRTC, startPositionAndHeights, vec4Offset);\r\n    startPositionAndHeights[vec4Offset + 3] = startHeight;\r\n\r\n    Cartesian3.pack(endRTC, endPositionAndHeights, vec4Offset);\r\n    endPositionAndHeights[vec4Offset + 3] = endHeight;\r\n\r\n    Cartesian3.pack(\r\n      startFaceNormal,\r\n      startFaceNormalAndVertexCornerIds,\r\n      vec4Offset\r\n    );\r\n    startFaceNormalAndVertexCornerIds[vec4Offset + 3] = i;\r\n\r\n    Cartesian3.pack(endFaceNormal, endFaceNormalAndHalfWidths, vec4Offset);\r\n    endFaceNormalAndHalfWidths[vec4Offset + 3] = halfWidth;\r\n\r\n    vertexBatchIds[batchIdOffset++] = batchId;\r\n\r\n    vec3Offset += 3;\r\n    vec4Offset += 4;\r\n  }\r\n\r\n  this.batchIdOffset = batchIdOffset;\r\n  this.vec3Offset = vec3Offset;\r\n  this.vec4Offset = vec4Offset;\r\n  const indices = this.indices;\r\n  const volumeStartIndex = this.volumeStartIndex;\r\n\r\n  const indexOffset = this.indexOffset;\r\n  for (i = 0; i < REFERENCE_INDICES_LENGTH; i++) {\r\n    indices[indexOffset + i] = REFERENCE_INDICES[i] + volumeStartIndex;\r\n  }\r\n\r\n  this.volumeStartIndex += 8;\r\n  this.indexOffset += REFERENCE_INDICES_LENGTH;\r\n};\r\n\r\nconst scratchRectangle = new Rectangle();\r\nconst scratchEllipsoid = new Ellipsoid();\r\nconst scratchCenter = new Cartesian3();\r\n\r\nconst scratchPrev = new Cartesian3();\r\nconst scratchP0 = new Cartesian3();\r\nconst scratchP1 = new Cartesian3();\r\nconst scratchNext = new Cartesian3();\r\nfunction createVectorTileClampedPolylines(parameters, transferableObjects) {\r\n  const encodedPositions = new Uint16Array(parameters.positions);\r\n  const widths = new Uint16Array(parameters.widths);\r\n  const counts = new Uint32Array(parameters.counts);\r\n  const batchIds = new Uint16Array(parameters.batchIds);\r\n\r\n  // Unpack tile decoding parameters\r\n  const rectangle = scratchRectangle;\r\n  const ellipsoid = scratchEllipsoid;\r\n  const center = scratchCenter;\r\n  const packedBuffer = new Float64Array(parameters.packedBuffer);\r\n\r\n  let offset = 0;\r\n  const minimumHeight = packedBuffer[offset++];\r\n  const maximumHeight = packedBuffer[offset++];\r\n\r\n  Rectangle.unpack(packedBuffer, offset, rectangle);\r\n  offset += Rectangle.packedLength;\r\n\r\n  Ellipsoid.unpack(packedBuffer, offset, ellipsoid);\r\n  offset += Ellipsoid.packedLength;\r\n\r\n  Cartesian3.unpack(packedBuffer, offset, center);\r\n\r\n  let i;\r\n\r\n  // Unpack positions and generate volumes\r\n  let positionsLength = encodedPositions.length / 3;\r\n  const uBuffer = encodedPositions.subarray(0, positionsLength);\r\n  const vBuffer = encodedPositions.subarray(\r\n    positionsLength,\r\n    2 * positionsLength\r\n  );\r\n  const heightBuffer = encodedPositions.subarray(\r\n    2 * positionsLength,\r\n    3 * positionsLength\r\n  );\r\n  AttributeCompression.zigZagDeltaDecode(uBuffer, vBuffer, heightBuffer);\r\n\r\n  removeDuplicates(uBuffer, vBuffer, heightBuffer, counts);\r\n\r\n  // Figure out how many volumes and how many vertices there will be.\r\n  const countsLength = counts.length;\r\n  let volumesCount = 0;\r\n  for (i = 0; i < countsLength; i++) {\r\n    const polylinePositionCount = counts[i];\r\n    volumesCount += polylinePositionCount - 1;\r\n  }\r\n\r\n  const attribsAndIndices = new VertexAttributesAndIndices(volumesCount);\r\n\r\n  const positions = decodePositions(\r\n    uBuffer,\r\n    vBuffer,\r\n    heightBuffer,\r\n    rectangle,\r\n    minimumHeight,\r\n    maximumHeight,\r\n    ellipsoid,\r\n    center\r\n  );\r\n\r\n  positionsLength = uBuffer.length;\r\n  const positionsRTC = new Float32Array(positionsLength * 3);\r\n  for (i = 0; i < positionsLength; ++i) {\r\n    positionsRTC[i * 3] = positions[i * 3] - center.x;\r\n    positionsRTC[i * 3 + 1] = positions[i * 3 + 1] - center.y;\r\n    positionsRTC[i * 3 + 2] = positions[i * 3 + 2] - center.z;\r\n  }\r\n\r\n  let currentPositionIndex = 0;\r\n  let currentHeightIndex = 0;\r\n  for (i = 0; i < countsLength; i++) {\r\n    const polylineVolumeCount = counts[i] - 1;\r\n    const halfWidth = widths[i] * 0.5;\r\n    const batchId = batchIds[i];\r\n    const volumeFirstPositionIndex = currentPositionIndex;\r\n    for (let j = 0; j < polylineVolumeCount; j++) {\r\n      const volumeStart = Cartesian3.unpack(\r\n        positionsRTC,\r\n        currentPositionIndex,\r\n        scratchP0\r\n      );\r\n      const volumeEnd = Cartesian3.unpack(\r\n        positionsRTC,\r\n        currentPositionIndex + 3,\r\n        scratchP1\r\n      );\r\n\r\n      let startHeight = heightBuffer[currentHeightIndex];\r\n      let endHeight = heightBuffer[currentHeightIndex + 1];\r\n      startHeight = CesiumMath.lerp(\r\n        minimumHeight,\r\n        maximumHeight,\r\n        startHeight / MAX_SHORT\r\n      );\r\n      endHeight = CesiumMath.lerp(\r\n        minimumHeight,\r\n        maximumHeight,\r\n        endHeight / MAX_SHORT\r\n      );\r\n\r\n      currentHeightIndex++;\r\n\r\n      let preStart = scratchPrev;\r\n      let postEnd = scratchNext;\r\n      if (j === 0) {\r\n        // Check if this volume is like a loop\r\n        const finalPositionIndex =\r\n          volumeFirstPositionIndex + polylineVolumeCount * 3;\r\n        const finalPosition = Cartesian3.unpack(\r\n          positionsRTC,\r\n          finalPositionIndex,\r\n          scratchPrev\r\n        );\r\n        if (Cartesian3.equals(finalPosition, volumeStart)) {\r\n          Cartesian3.unpack(positionsRTC, finalPositionIndex - 3, preStart);\r\n        } else {\r\n          const offsetPastStart = Cartesian3.subtract(\r\n            volumeStart,\r\n            volumeEnd,\r\n            scratchPrev\r\n          );\r\n          preStart = Cartesian3.add(offsetPastStart, volumeStart, scratchPrev);\r\n        }\r\n      } else {\r\n        Cartesian3.unpack(positionsRTC, currentPositionIndex - 3, preStart);\r\n      }\r\n\r\n      if (j === polylineVolumeCount - 1) {\r\n        // Check if this volume is like a loop\r\n        const firstPosition = Cartesian3.unpack(\r\n          positionsRTC,\r\n          volumeFirstPositionIndex,\r\n          scratchNext\r\n        );\r\n        if (Cartesian3.equals(firstPosition, volumeEnd)) {\r\n          Cartesian3.unpack(\r\n            positionsRTC,\r\n            volumeFirstPositionIndex + 3,\r\n            postEnd\r\n          );\r\n        } else {\r\n          const offsetPastEnd = Cartesian3.subtract(\r\n            volumeEnd,\r\n            volumeStart,\r\n            scratchNext\r\n          );\r\n          postEnd = Cartesian3.add(offsetPastEnd, volumeEnd, scratchNext);\r\n        }\r\n      } else {\r\n        Cartesian3.unpack(positionsRTC, currentPositionIndex + 6, postEnd);\r\n      }\r\n\r\n      attribsAndIndices.addVolume(\r\n        preStart,\r\n        volumeStart,\r\n        volumeEnd,\r\n        postEnd,\r\n        startHeight,\r\n        endHeight,\r\n        halfWidth,\r\n        batchId,\r\n        center,\r\n        ellipsoid\r\n      );\r\n\r\n      currentPositionIndex += 3;\r\n    }\r\n    currentPositionIndex += 3;\r\n    currentHeightIndex++;\r\n  }\r\n\r\n  const indices = attribsAndIndices.indices;\r\n\r\n  transferableObjects.push(attribsAndIndices.startEllipsoidNormals.buffer);\r\n  transferableObjects.push(attribsAndIndices.endEllipsoidNormals.buffer);\r\n  transferableObjects.push(attribsAndIndices.startPositionAndHeights.buffer);\r\n  transferableObjects.push(\r\n    attribsAndIndices.startFaceNormalAndVertexCornerIds.buffer\r\n  );\r\n  transferableObjects.push(attribsAndIndices.endPositionAndHeights.buffer);\r\n  transferableObjects.push(attribsAndIndices.endFaceNormalAndHalfWidths.buffer);\r\n  transferableObjects.push(attribsAndIndices.vertexBatchIds.buffer);\r\n  transferableObjects.push(indices.buffer);\r\n\r\n  let results = {\r\n    indexDatatype:\r\n      indices.BYTES_PER_ELEMENT === 2\r\n        ? IndexDatatype.UNSIGNED_SHORT\r\n        : IndexDatatype.UNSIGNED_INT,\r\n    startEllipsoidNormals: attribsAndIndices.startEllipsoidNormals.buffer,\r\n    endEllipsoidNormals: attribsAndIndices.endEllipsoidNormals.buffer,\r\n    startPositionAndHeights: attribsAndIndices.startPositionAndHeights.buffer,\r\n    startFaceNormalAndVertexCornerIds:\r\n      attribsAndIndices.startFaceNormalAndVertexCornerIds.buffer,\r\n    endPositionAndHeights: attribsAndIndices.endPositionAndHeights.buffer,\r\n    endFaceNormalAndHalfWidths:\r\n      attribsAndIndices.endFaceNormalAndHalfWidths.buffer,\r\n    vertexBatchIds: attribsAndIndices.vertexBatchIds.buffer,\r\n    indices: indices.buffer,\r\n  };\r\n\r\n  if (parameters.keepDecodedPositions) {\r\n    const positionOffsets = getPositionOffsets(counts);\r\n    transferableObjects.push(positions.buffer, positionOffsets.buffer);\r\n    results = combine(results, {\r\n      decodedPositions: positions.buffer,\r\n      decodedPositionOffsets: positionOffsets.buffer,\r\n    });\r\n  }\r\n\r\n  return results;\r\n}\r\nexport default createTaskProcessorWorker(createVectorTileClampedPolylines);\r\n"],"names":["MAX_SHORT","MITER_BREAK","Math","cos","CesiumMath","toRadians","scratchBVCartographic","Cartographic","scratchEncodedPosition","Cartesian3","previousCompressedCartographicScratch","currentCompressedCartographicScratch","VertexAttributesAndIndices","volumesCount","vertexCount","vec3Floats","vec4Floats","this","startEllipsoidNormals","Float32Array","endEllipsoidNormals","startPositionAndHeights","startFaceNormalAndVertexCornerIds","endPositionAndHeights","endFaceNormalAndHalfWidths","vertexBatchIds","Uint16Array","indices","IndexDatatype","createTypedArray","vec3Offset","vec4Offset","batchIdOffset","indexOffset","volumeStartIndex","towardCurrScratch","towardNextScratch","computeMiteredNormal","previousPosition","position","nextPosition","ellipsoidSurfaceNormal","result","towardNext","subtract","towardCurr","normalize","dot","multiplyByScalar","add","equals","ZERO","cross","REFERENCE_INDICES","REFERENCE_INDICES_LENGTH","length","positionScratch","scratchStartEllipsoidNormal","scratchStartFaceNormal","scratchEndEllipsoidNormal","scratchEndFaceNormal","prototype","addVolume","preStartRTC","startRTC","endRTC","postEndRTC","startHeight","endHeight","halfWidth","batchId","center","ellipsoid","startEllipsoidNormal","geodeticSurfaceNormal","endEllipsoidNormal","startFaceNormal","endFaceNormal","i","pack","scratchRectangle","Rectangle","scratchEllipsoid","Ellipsoid","scratchCenter","scratchPrev","scratchP0","scratchP1","scratchNext","createTaskProcessorWorker","parameters","transferableObjects","encodedPositions","positions","widths","counts","Uint32Array","batchIds","rectangle","packedBuffer","Float64Array","offset","minimumHeight","maximumHeight","unpack","packedLength","positionsLength","uBuffer","subarray","vBuffer","heightBuffer","AttributeCompression","zigZagDeltaDecode","countsLength","markRemoval","Uint8Array","previous","current","count","updatedCount","j","index","previousIndex","longitude","latitude","nextAvailableIndex","k","removeDuplicates","attribsAndIndices","decodedPositions","u","v","h","lon","lerp","west","east","lat","south","north","alt","cartographic","fromRadians","decodedPosition","cartographicToCartesian","decodePositions","positionsRTC","x","y","z","currentPositionIndex","currentHeightIndex","polylineVolumeCount","volumeFirstPositionIndex","volumeStart","volumeEnd","preStart","postEnd","finalPositionIndex","finalPosition","offsetPastStart","firstPosition","offsetPastEnd","push","buffer","results","indexDatatype","BYTES_PER_ELEMENT","UNSIGNED_SHORT","UNSIGNED_INT","keepDecodedPositions","positionOffsets","getPositionOffsets","combine","decodedPositionOffsets"],"mappings":"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"}