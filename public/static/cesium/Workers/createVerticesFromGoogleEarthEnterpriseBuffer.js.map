{"version":3,"file":"createVerticesFromGoogleEarthEnterpriseBuffer.js","sources":["../../../../Source/WorkersES6/createVerticesFromGoogleEarthEnterpriseBuffer.js"],"sourcesContent":["import AxisAlignedBoundingBox from \"../Core/AxisAlignedBoundingBox.js\";\r\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\r\nimport Cartesian2 from \"../Core/Cartesian2.js\";\r\nimport Cartesian3 from \"../Core/Cartesian3.js\";\r\nimport Cartographic from \"../Core/Cartographic.js\";\r\nimport defaultValue from \"../Core/defaultValue.js\";\r\nimport defined from \"../Core/defined.js\";\r\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\r\nimport EllipsoidalOccluder from \"../Core/EllipsoidalOccluder.js\";\r\nimport CesiumMath from \"../Core/Math.js\";\r\nimport Matrix4 from \"../Core/Matrix4.js\";\r\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\r\nimport Rectangle from \"../Core/Rectangle.js\";\r\nimport RuntimeError from \"../Core/RuntimeError.js\";\r\nimport TerrainEncoding from \"../Core/TerrainEncoding.js\";\r\nimport Transforms from \"../Core/Transforms.js\";\r\nimport WebMercatorProjection from \"../Core/WebMercatorProjection.js\";\r\nimport createTaskProcessorWorker from \"./createTaskProcessorWorker.js\";\r\n\r\nconst sizeOfUint16 = Uint16Array.BYTES_PER_ELEMENT;\r\nconst sizeOfInt32 = Int32Array.BYTES_PER_ELEMENT;\r\nconst sizeOfUint32 = Uint32Array.BYTES_PER_ELEMENT;\r\nconst sizeOfFloat = Float32Array.BYTES_PER_ELEMENT;\r\nconst sizeOfDouble = Float64Array.BYTES_PER_ELEMENT;\r\n\r\nfunction indexOfEpsilon(arr, elem, elemType) {\r\n  elemType = defaultValue(elemType, CesiumMath);\r\n  const count = arr.length;\r\n  for (let i = 0; i < count; ++i) {\r\n    if (elemType.equalsEpsilon(arr[i], elem, CesiumMath.EPSILON12)) {\r\n      return i;\r\n    }\r\n  }\r\n\r\n  return -1;\r\n}\r\n\r\nfunction createVerticesFromGoogleEarthEnterpriseBuffer(\r\n  parameters,\r\n  transferableObjects\r\n) {\r\n  parameters.ellipsoid = Ellipsoid.clone(parameters.ellipsoid);\r\n  parameters.rectangle = Rectangle.clone(parameters.rectangle);\r\n\r\n  const statistics = processBuffer(\r\n    parameters.buffer,\r\n    parameters.relativeToCenter,\r\n    parameters.ellipsoid,\r\n    parameters.rectangle,\r\n    parameters.nativeRectangle,\r\n    parameters.exaggeration,\r\n    parameters.exaggerationRelativeHeight,\r\n    parameters.skirtHeight,\r\n    parameters.includeWebMercatorT,\r\n    parameters.negativeAltitudeExponentBias,\r\n    parameters.negativeElevationThreshold\r\n  );\r\n  const vertices = statistics.vertices;\r\n  transferableObjects.push(vertices.buffer);\r\n  const indices = statistics.indices;\r\n  transferableObjects.push(indices.buffer);\r\n\r\n  return {\r\n    vertices: vertices.buffer,\r\n    indices: indices.buffer,\r\n    numberOfAttributes: statistics.encoding.stride,\r\n    minimumHeight: statistics.minimumHeight,\r\n    maximumHeight: statistics.maximumHeight,\r\n    boundingSphere3D: statistics.boundingSphere3D,\r\n    orientedBoundingBox: statistics.orientedBoundingBox,\r\n    occludeePointInScaledSpace: statistics.occludeePointInScaledSpace,\r\n    encoding: statistics.encoding,\r\n    vertexCountWithoutSkirts: statistics.vertexCountWithoutSkirts,\r\n    indexCountWithoutSkirts: statistics.indexCountWithoutSkirts,\r\n    westIndicesSouthToNorth: statistics.westIndicesSouthToNorth,\r\n    southIndicesEastToWest: statistics.southIndicesEastToWest,\r\n    eastIndicesNorthToSouth: statistics.eastIndicesNorthToSouth,\r\n    northIndicesWestToEast: statistics.northIndicesWestToEast,\r\n  };\r\n}\r\n\r\nconst scratchCartographic = new Cartographic();\r\nconst scratchCartesian = new Cartesian3();\r\nconst minimumScratch = new Cartesian3();\r\nconst maximumScratch = new Cartesian3();\r\nconst matrix4Scratch = new Matrix4();\r\n\r\nfunction processBuffer(\r\n  buffer,\r\n  relativeToCenter,\r\n  ellipsoid,\r\n  rectangle,\r\n  nativeRectangle,\r\n  exaggeration,\r\n  exaggerationRelativeHeight,\r\n  skirtHeight,\r\n  includeWebMercatorT,\r\n  negativeAltitudeExponentBias,\r\n  negativeElevationThreshold\r\n) {\r\n  let geographicWest;\r\n  let geographicSouth;\r\n  let geographicEast;\r\n  let geographicNorth;\r\n  let rectangleWidth, rectangleHeight;\r\n\r\n  if (!defined(rectangle)) {\r\n    geographicWest = CesiumMath.toRadians(nativeRectangle.west);\r\n    geographicSouth = CesiumMath.toRadians(nativeRectangle.south);\r\n    geographicEast = CesiumMath.toRadians(nativeRectangle.east);\r\n    geographicNorth = CesiumMath.toRadians(nativeRectangle.north);\r\n    rectangleWidth = CesiumMath.toRadians(rectangle.width);\r\n    rectangleHeight = CesiumMath.toRadians(rectangle.height);\r\n  } else {\r\n    geographicWest = rectangle.west;\r\n    geographicSouth = rectangle.south;\r\n    geographicEast = rectangle.east;\r\n    geographicNorth = rectangle.north;\r\n    rectangleWidth = rectangle.width;\r\n    rectangleHeight = rectangle.height;\r\n  }\r\n\r\n  // Keep track of quad borders so we can remove duplicates around the borders\r\n  const quadBorderLatitudes = [geographicSouth, geographicNorth];\r\n  const quadBorderLongitudes = [geographicWest, geographicEast];\r\n\r\n  const fromENU = Transforms.eastNorthUpToFixedFrame(\r\n    relativeToCenter,\r\n    ellipsoid\r\n  );\r\n  const toENU = Matrix4.inverseTransformation(fromENU, matrix4Scratch);\r\n\r\n  let southMercatorY;\r\n  let oneOverMercatorHeight;\r\n  if (includeWebMercatorT) {\r\n    southMercatorY = WebMercatorProjection.geodeticLatitudeToMercatorAngle(\r\n      geographicSouth\r\n    );\r\n    oneOverMercatorHeight =\r\n      1.0 /\r\n      (WebMercatorProjection.geodeticLatitudeToMercatorAngle(geographicNorth) -\r\n        southMercatorY);\r\n  }\r\n\r\n  const hasExaggeration = exaggeration !== 1.0;\r\n  const includeGeodeticSurfaceNormals = hasExaggeration;\r\n\r\n  const dv = new DataView(buffer);\r\n\r\n  let minHeight = Number.POSITIVE_INFINITY;\r\n  let maxHeight = Number.NEGATIVE_INFINITY;\r\n\r\n  const minimum = minimumScratch;\r\n  minimum.x = Number.POSITIVE_INFINITY;\r\n  minimum.y = Number.POSITIVE_INFINITY;\r\n  minimum.z = Number.POSITIVE_INFINITY;\r\n\r\n  const maximum = maximumScratch;\r\n  maximum.x = Number.NEGATIVE_INFINITY;\r\n  maximum.y = Number.NEGATIVE_INFINITY;\r\n  maximum.z = Number.NEGATIVE_INFINITY;\r\n\r\n  // Compute sizes\r\n  let offset = 0;\r\n  let size = 0;\r\n  let indicesSize = 0;\r\n  let quadSize;\r\n  let quad;\r\n  for (quad = 0; quad < 4; ++quad) {\r\n    let o = offset;\r\n    quadSize = dv.getUint32(o, true);\r\n    o += sizeOfUint32;\r\n\r\n    const x = CesiumMath.toRadians(dv.getFloat64(o, true) * 180.0);\r\n    o += sizeOfDouble;\r\n    if (indexOfEpsilon(quadBorderLongitudes, x) === -1) {\r\n      quadBorderLongitudes.push(x);\r\n    }\r\n\r\n    const y = CesiumMath.toRadians(dv.getFloat64(o, true) * 180.0);\r\n    o += sizeOfDouble;\r\n    if (indexOfEpsilon(quadBorderLatitudes, y) === -1) {\r\n      quadBorderLatitudes.push(y);\r\n    }\r\n\r\n    o += 2 * sizeOfDouble; // stepX + stepY\r\n\r\n    let c = dv.getInt32(o, true); // Read point count\r\n    o += sizeOfInt32;\r\n    size += c;\r\n\r\n    c = dv.getInt32(o, true); // Read index count\r\n    indicesSize += c * 3;\r\n\r\n    offset += quadSize + sizeOfUint32; // Jump to next quad\r\n  }\r\n\r\n  // Quad Border points to remove duplicates\r\n  const quadBorderPoints = [];\r\n  const quadBorderIndices = [];\r\n\r\n  // Create arrays\r\n  const positions = new Array(size);\r\n  const uvs = new Array(size);\r\n  const heights = new Array(size);\r\n  const webMercatorTs = includeWebMercatorT ? new Array(size) : [];\r\n  const geodeticSurfaceNormals = includeGeodeticSurfaceNormals\r\n    ? new Array(size)\r\n    : [];\r\n  const indices = new Array(indicesSize);\r\n\r\n  // Points are laid out in rows starting at SW, so storing border points as we\r\n  //  come across them all points will be adjacent.\r\n  const westBorder = [];\r\n  const southBorder = [];\r\n  const eastBorder = [];\r\n  const northBorder = [];\r\n\r\n  // Each tile is split into 4 parts\r\n  let pointOffset = 0;\r\n  let indicesOffset = 0;\r\n  offset = 0;\r\n  for (quad = 0; quad < 4; ++quad) {\r\n    quadSize = dv.getUint32(offset, true);\r\n    offset += sizeOfUint32;\r\n    const startQuad = offset;\r\n\r\n    const originX = CesiumMath.toRadians(dv.getFloat64(offset, true) * 180.0);\r\n    offset += sizeOfDouble;\r\n\r\n    const originY = CesiumMath.toRadians(dv.getFloat64(offset, true) * 180.0);\r\n    offset += sizeOfDouble;\r\n\r\n    const stepX = CesiumMath.toRadians(dv.getFloat64(offset, true) * 180.0);\r\n    const halfStepX = stepX * 0.5;\r\n    offset += sizeOfDouble;\r\n\r\n    const stepY = CesiumMath.toRadians(dv.getFloat64(offset, true) * 180.0);\r\n    const halfStepY = stepY * 0.5;\r\n    offset += sizeOfDouble;\r\n\r\n    const numPoints = dv.getInt32(offset, true);\r\n    offset += sizeOfInt32;\r\n\r\n    const numFaces = dv.getInt32(offset, true);\r\n    offset += sizeOfInt32;\r\n\r\n    //const level = dv.getInt32(offset, true);\r\n    offset += sizeOfInt32;\r\n\r\n    // Keep track of quad indices to overall tile indices\r\n    const indicesMapping = new Array(numPoints);\r\n    for (let i = 0; i < numPoints; ++i) {\r\n      const longitude = originX + dv.getUint8(offset++) * stepX;\r\n      scratchCartographic.longitude = longitude;\r\n      const latitude = originY + dv.getUint8(offset++) * stepY;\r\n      scratchCartographic.latitude = latitude;\r\n\r\n      let height = dv.getFloat32(offset, true);\r\n      offset += sizeOfFloat;\r\n\r\n      // In order to support old clients, negative altitude values are stored as\r\n      // height/-2^32. Old clients see the value as really close to 0 but new clients multiply\r\n      // by -2^32 to get the real negative altitude value.\r\n      if (height !== 0 && height < negativeElevationThreshold) {\r\n        height *= -Math.pow(2, negativeAltitudeExponentBias);\r\n      }\r\n\r\n      // Height is stored in units of (1/EarthRadius) or (1/6371010.0)\r\n      height *= 6371010.0;\r\n\r\n      scratchCartographic.height = height;\r\n\r\n      // Is it along a quad border - if so check if already exists and use that index\r\n      if (\r\n        indexOfEpsilon(quadBorderLongitudes, longitude) !== -1 ||\r\n        indexOfEpsilon(quadBorderLatitudes, latitude) !== -1\r\n      ) {\r\n        const index = indexOfEpsilon(\r\n          quadBorderPoints,\r\n          scratchCartographic,\r\n          Cartographic\r\n        );\r\n        if (index === -1) {\r\n          quadBorderPoints.push(Cartographic.clone(scratchCartographic));\r\n          quadBorderIndices.push(pointOffset);\r\n        } else {\r\n          indicesMapping[i] = quadBorderIndices[index];\r\n          continue;\r\n        }\r\n      }\r\n      indicesMapping[i] = pointOffset;\r\n\r\n      if (Math.abs(longitude - geographicWest) < halfStepX) {\r\n        westBorder.push({\r\n          index: pointOffset,\r\n          cartographic: Cartographic.clone(scratchCartographic),\r\n        });\r\n      } else if (Math.abs(longitude - geographicEast) < halfStepX) {\r\n        eastBorder.push({\r\n          index: pointOffset,\r\n          cartographic: Cartographic.clone(scratchCartographic),\r\n        });\r\n      } else if (Math.abs(latitude - geographicSouth) < halfStepY) {\r\n        southBorder.push({\r\n          index: pointOffset,\r\n          cartographic: Cartographic.clone(scratchCartographic),\r\n        });\r\n      } else if (Math.abs(latitude - geographicNorth) < halfStepY) {\r\n        northBorder.push({\r\n          index: pointOffset,\r\n          cartographic: Cartographic.clone(scratchCartographic),\r\n        });\r\n      }\r\n\r\n      minHeight = Math.min(height, minHeight);\r\n      maxHeight = Math.max(height, maxHeight);\r\n      heights[pointOffset] = height;\r\n\r\n      const pos = ellipsoid.cartographicToCartesian(scratchCartographic);\r\n      positions[pointOffset] = pos;\r\n\r\n      if (includeWebMercatorT) {\r\n        webMercatorTs[pointOffset] =\r\n          (WebMercatorProjection.geodeticLatitudeToMercatorAngle(latitude) -\r\n            southMercatorY) *\r\n          oneOverMercatorHeight;\r\n      }\r\n\r\n      if (includeGeodeticSurfaceNormals) {\r\n        const normal = ellipsoid.geodeticSurfaceNormal(pos);\r\n        geodeticSurfaceNormals[pointOffset] = normal;\r\n      }\r\n\r\n      Matrix4.multiplyByPoint(toENU, pos, scratchCartesian);\r\n\r\n      Cartesian3.minimumByComponent(scratchCartesian, minimum, minimum);\r\n      Cartesian3.maximumByComponent(scratchCartesian, maximum, maximum);\r\n\r\n      let u = (longitude - geographicWest) / (geographicEast - geographicWest);\r\n      u = CesiumMath.clamp(u, 0.0, 1.0);\r\n      let v =\r\n        (latitude - geographicSouth) / (geographicNorth - geographicSouth);\r\n      v = CesiumMath.clamp(v, 0.0, 1.0);\r\n\r\n      uvs[pointOffset] = new Cartesian2(u, v);\r\n      ++pointOffset;\r\n    }\r\n\r\n    const facesElementCount = numFaces * 3;\r\n    for (let j = 0; j < facesElementCount; ++j, ++indicesOffset) {\r\n      indices[indicesOffset] = indicesMapping[dv.getUint16(offset, true)];\r\n      offset += sizeOfUint16;\r\n    }\r\n\r\n    if (quadSize !== offset - startQuad) {\r\n      throw new RuntimeError(\"Invalid terrain tile.\");\r\n    }\r\n  }\r\n\r\n  positions.length = pointOffset;\r\n  uvs.length = pointOffset;\r\n  heights.length = pointOffset;\r\n  if (includeWebMercatorT) {\r\n    webMercatorTs.length = pointOffset;\r\n  }\r\n  if (includeGeodeticSurfaceNormals) {\r\n    geodeticSurfaceNormals.length = pointOffset;\r\n  }\r\n\r\n  const vertexCountWithoutSkirts = pointOffset;\r\n  const indexCountWithoutSkirts = indicesOffset;\r\n\r\n  // Add skirt points\r\n  const skirtOptions = {\r\n    hMin: minHeight,\r\n    lastBorderPoint: undefined,\r\n    skirtHeight: skirtHeight,\r\n    toENU: toENU,\r\n    ellipsoid: ellipsoid,\r\n    minimum: minimum,\r\n    maximum: maximum,\r\n  };\r\n\r\n  // Sort counter clockwise from NW corner\r\n  // Corner points are in the east/west arrays\r\n  westBorder.sort(function (a, b) {\r\n    return b.cartographic.latitude - a.cartographic.latitude;\r\n  });\r\n  southBorder.sort(function (a, b) {\r\n    return a.cartographic.longitude - b.cartographic.longitude;\r\n  });\r\n  eastBorder.sort(function (a, b) {\r\n    return a.cartographic.latitude - b.cartographic.latitude;\r\n  });\r\n  northBorder.sort(function (a, b) {\r\n    return b.cartographic.longitude - a.cartographic.longitude;\r\n  });\r\n\r\n  const percentage = 0.00001;\r\n  addSkirt(\r\n    positions,\r\n    heights,\r\n    uvs,\r\n    webMercatorTs,\r\n    geodeticSurfaceNormals,\r\n    indices,\r\n    skirtOptions,\r\n    westBorder,\r\n    -percentage * rectangleWidth,\r\n    true,\r\n    -percentage * rectangleHeight\r\n  );\r\n  addSkirt(\r\n    positions,\r\n    heights,\r\n    uvs,\r\n    webMercatorTs,\r\n    geodeticSurfaceNormals,\r\n    indices,\r\n    skirtOptions,\r\n    southBorder,\r\n    -percentage * rectangleHeight,\r\n    false\r\n  );\r\n  addSkirt(\r\n    positions,\r\n    heights,\r\n    uvs,\r\n    webMercatorTs,\r\n    geodeticSurfaceNormals,\r\n    indices,\r\n    skirtOptions,\r\n    eastBorder,\r\n    percentage * rectangleWidth,\r\n    true,\r\n    percentage * rectangleHeight\r\n  );\r\n  addSkirt(\r\n    positions,\r\n    heights,\r\n    uvs,\r\n    webMercatorTs,\r\n    geodeticSurfaceNormals,\r\n    indices,\r\n    skirtOptions,\r\n    northBorder,\r\n    percentage * rectangleHeight,\r\n    false\r\n  );\r\n\r\n  // Since the corner between the north and west sides is in the west array, generate the last\r\n  //  two triangles between the last north vertex and the first west vertex\r\n  if (westBorder.length > 0 && northBorder.length > 0) {\r\n    const firstBorderIndex = westBorder[0].index;\r\n    const firstSkirtIndex = vertexCountWithoutSkirts;\r\n    const lastBorderIndex = northBorder[northBorder.length - 1].index;\r\n    const lastSkirtIndex = positions.length - 1;\r\n\r\n    indices.push(\r\n      lastBorderIndex,\r\n      lastSkirtIndex,\r\n      firstSkirtIndex,\r\n      firstSkirtIndex,\r\n      firstBorderIndex,\r\n      lastBorderIndex\r\n    );\r\n  }\r\n\r\n  size = positions.length; // Get new size with skirt vertices\r\n\r\n  const boundingSphere3D = BoundingSphere.fromPoints(positions);\r\n  let orientedBoundingBox;\r\n  if (defined(rectangle)) {\r\n    orientedBoundingBox = OrientedBoundingBox.fromRectangle(\r\n      rectangle,\r\n      minHeight,\r\n      maxHeight,\r\n      ellipsoid\r\n    );\r\n  }\r\n\r\n  const occluder = new EllipsoidalOccluder(ellipsoid);\r\n  const occludeePointInScaledSpace = occluder.computeHorizonCullingPointPossiblyUnderEllipsoid(\r\n    relativeToCenter,\r\n    positions,\r\n    minHeight\r\n  );\r\n\r\n  const aaBox = new AxisAlignedBoundingBox(minimum, maximum, relativeToCenter);\r\n  const encoding = new TerrainEncoding(\r\n    relativeToCenter,\r\n    aaBox,\r\n    skirtOptions.hMin,\r\n    maxHeight,\r\n    fromENU,\r\n    false,\r\n    includeWebMercatorT,\r\n    includeGeodeticSurfaceNormals,\r\n    exaggeration,\r\n    exaggerationRelativeHeight\r\n  );\r\n  const vertices = new Float32Array(size * encoding.stride);\r\n\r\n  let bufferIndex = 0;\r\n  for (let k = 0; k < size; ++k) {\r\n    bufferIndex = encoding.encode(\r\n      vertices,\r\n      bufferIndex,\r\n      positions[k],\r\n      uvs[k],\r\n      heights[k],\r\n      undefined,\r\n      webMercatorTs[k],\r\n      geodeticSurfaceNormals[k]\r\n    );\r\n  }\r\n\r\n  const westIndicesSouthToNorth = westBorder\r\n    .map(function (vertex) {\r\n      return vertex.index;\r\n    })\r\n    .reverse();\r\n  const southIndicesEastToWest = southBorder\r\n    .map(function (vertex) {\r\n      return vertex.index;\r\n    })\r\n    .reverse();\r\n  const eastIndicesNorthToSouth = eastBorder\r\n    .map(function (vertex) {\r\n      return vertex.index;\r\n    })\r\n    .reverse();\r\n  const northIndicesWestToEast = northBorder\r\n    .map(function (vertex) {\r\n      return vertex.index;\r\n    })\r\n    .reverse();\r\n\r\n  southIndicesEastToWest.unshift(\r\n    eastIndicesNorthToSouth[eastIndicesNorthToSouth.length - 1]\r\n  );\r\n  southIndicesEastToWest.push(westIndicesSouthToNorth[0]);\r\n\r\n  northIndicesWestToEast.unshift(\r\n    westIndicesSouthToNorth[westIndicesSouthToNorth.length - 1]\r\n  );\r\n  northIndicesWestToEast.push(eastIndicesNorthToSouth[0]);\r\n\r\n  return {\r\n    vertices: vertices,\r\n    indices: new Uint16Array(indices),\r\n    maximumHeight: maxHeight,\r\n    minimumHeight: minHeight,\r\n    encoding: encoding,\r\n    boundingSphere3D: boundingSphere3D,\r\n    orientedBoundingBox: orientedBoundingBox,\r\n    occludeePointInScaledSpace: occludeePointInScaledSpace,\r\n    vertexCountWithoutSkirts: vertexCountWithoutSkirts,\r\n    indexCountWithoutSkirts: indexCountWithoutSkirts,\r\n    westIndicesSouthToNorth: westIndicesSouthToNorth,\r\n    southIndicesEastToWest: southIndicesEastToWest,\r\n    eastIndicesNorthToSouth: eastIndicesNorthToSouth,\r\n    northIndicesWestToEast: northIndicesWestToEast,\r\n  };\r\n}\r\n\r\nfunction addSkirt(\r\n  positions,\r\n  heights,\r\n  uvs,\r\n  webMercatorTs,\r\n  geodeticSurfaceNormals,\r\n  indices,\r\n  skirtOptions,\r\n  borderPoints,\r\n  fudgeFactor,\r\n  eastOrWest,\r\n  cornerFudge\r\n) {\r\n  const count = borderPoints.length;\r\n  for (let j = 0; j < count; ++j) {\r\n    const borderPoint = borderPoints[j];\r\n    const borderCartographic = borderPoint.cartographic;\r\n    const borderIndex = borderPoint.index;\r\n    const currentIndex = positions.length;\r\n\r\n    const longitude = borderCartographic.longitude;\r\n    let latitude = borderCartographic.latitude;\r\n    latitude = CesiumMath.clamp(\r\n      latitude,\r\n      -CesiumMath.PI_OVER_TWO,\r\n      CesiumMath.PI_OVER_TWO\r\n    ); // Don't go over the poles\r\n    const height = borderCartographic.height - skirtOptions.skirtHeight;\r\n    skirtOptions.hMin = Math.min(skirtOptions.hMin, height);\r\n\r\n    Cartographic.fromRadians(longitude, latitude, height, scratchCartographic);\r\n\r\n    // Adjust sides to angle out\r\n    if (eastOrWest) {\r\n      scratchCartographic.longitude += fudgeFactor;\r\n    }\r\n\r\n    // Adjust top or bottom to angle out\r\n    // Since corners are in the east/west arrays angle the first and last points as well\r\n    if (!eastOrWest) {\r\n      scratchCartographic.latitude += fudgeFactor;\r\n    } else if (j === count - 1) {\r\n      scratchCartographic.latitude += cornerFudge;\r\n    } else if (j === 0) {\r\n      scratchCartographic.latitude -= cornerFudge;\r\n    }\r\n\r\n    const pos = skirtOptions.ellipsoid.cartographicToCartesian(\r\n      scratchCartographic\r\n    );\r\n    positions.push(pos);\r\n    heights.push(height);\r\n    uvs.push(Cartesian2.clone(uvs[borderIndex])); // Copy UVs from border point\r\n    if (webMercatorTs.length > 0) {\r\n      webMercatorTs.push(webMercatorTs[borderIndex]);\r\n    }\r\n    if (geodeticSurfaceNormals.length > 0) {\r\n      geodeticSurfaceNormals.push(geodeticSurfaceNormals[borderIndex]);\r\n    }\r\n\r\n    Matrix4.multiplyByPoint(skirtOptions.toENU, pos, scratchCartesian);\r\n\r\n    const minimum = skirtOptions.minimum;\r\n    const maximum = skirtOptions.maximum;\r\n    Cartesian3.minimumByComponent(scratchCartesian, minimum, minimum);\r\n    Cartesian3.maximumByComponent(scratchCartesian, maximum, maximum);\r\n\r\n    const lastBorderPoint = skirtOptions.lastBorderPoint;\r\n    if (defined(lastBorderPoint)) {\r\n      const lastBorderIndex = lastBorderPoint.index;\r\n      indices.push(\r\n        lastBorderIndex,\r\n        currentIndex - 1,\r\n        currentIndex,\r\n        currentIndex,\r\n        borderIndex,\r\n        lastBorderIndex\r\n      );\r\n    }\r\n\r\n    skirtOptions.lastBorderPoint = borderPoint;\r\n  }\r\n}\r\nexport default createTaskProcessorWorker(\r\n  createVerticesFromGoogleEarthEnterpriseBuffer\r\n);\r\n"],"names":["sizeOfUint16","Uint16Array","BYTES_PER_ELEMENT","sizeOfInt32","Int32Array","sizeOfUint32","Uint32Array","sizeOfFloat","Float32Array","sizeOfDouble","Float64Array","indexOfEpsilon","arr","elem","elemType","defaultValue","CesiumMath","count","length","i","equalsEpsilon","EPSILON12","scratchCartographic","Cartographic","scratchCartesian","Cartesian3","minimumScratch","maximumScratch","matrix4Scratch","Matrix4","addSkirt","positions","heights","uvs","webMercatorTs","geodeticSurfaceNormals","indices","skirtOptions","borderPoints","fudgeFactor","eastOrWest","cornerFudge","j","borderPoint","borderCartographic","cartographic","borderIndex","index","currentIndex","longitude","latitude","clamp","PI_OVER_TWO","height","skirtHeight","hMin","Math","min","fromRadians","pos","ellipsoid","cartographicToCartesian","push","Cartesian2","clone","multiplyByPoint","toENU","minimum","maximum","minimumByComponent","maximumByComponent","lastBorderPoint","defined","lastBorderIndex","createTaskProcessorWorker","parameters","transferableObjects","Ellipsoid","rectangle","Rectangle","statistics","buffer","relativeToCenter","nativeRectangle","exaggeration","exaggerationRelativeHeight","includeWebMercatorT","negativeAltitudeExponentBias","negativeElevationThreshold","geographicWest","geographicSouth","geographicEast","geographicNorth","rectangleWidth","rectangleHeight","west","south","east","north","width","toRadians","quadBorderLatitudes","quadBorderLongitudes","fromENU","Transforms","eastNorthUpToFixedFrame","inverseTransformation","southMercatorY","oneOverMercatorHeight","WebMercatorProjection","geodeticLatitudeToMercatorAngle","includeGeodeticSurfaceNormals","dv","DataView","minHeight","Number","POSITIVE_INFINITY","maxHeight","NEGATIVE_INFINITY","x","y","z","quadSize","quad","offset","size","indicesSize","o","getUint32","getFloat64","c","getInt32","quadBorderPoints","quadBorderIndices","Array","westBorder","southBorder","eastBorder","northBorder","pointOffset","indicesOffset","startQuad","originX","originY","stepX","halfStepX","stepY","halfStepY","numPoints","numFaces","indicesMapping","getUint8","getFloat32","pow","abs","max","normal","geodeticSurfaceNormal","u","v","facesElementCount","getUint16","RuntimeError","vertexCountWithoutSkirts","indexCountWithoutSkirts","undefined","sort","a","b","percentage","firstBorderIndex","firstSkirtIndex","lastSkirtIndex","boundingSphere3D","BoundingSphere","fromPoints","orientedBoundingBox","OrientedBoundingBox","fromRectangle","occludeePointInScaledSpace","EllipsoidalOccluder","computeHorizonCullingPointPossiblyUnderEllipsoid","aaBox","AxisAlignedBoundingBox","encoding","TerrainEncoding","vertices","stride","bufferIndex","k","encode","westIndicesSouthToNorth","map","vertex","reverse","southIndicesEastToWest","eastIndicesNorthToSouth","northIndicesWestToEast","unshift","maximumHeight","minimumHeight","processBuffer","numberOfAttributes"],"mappings":"qjBAmBA,MAAMA,EAAeC,YAAYC,kBAC3BC,EAAcC,WAAWF,kBACzBG,EAAeC,YAAYJ,kBAC3BK,EAAcC,aAAaN,kBAC3BO,EAAeC,aAAaR,kBAElC,SAASS,EAAeC,EAAKC,EAAMC,GACjCA,EAAWC,EAAYA,aAACD,EAAUE,EAAAA,YAClC,MAAMC,EAAQL,EAAIM,OAClB,IAAK,IAAIC,EAAI,EAAGA,EAAIF,IAASE,EAC3B,GAAIL,EAASM,cAAcR,EAAIO,GAAIN,EAAMG,EAAAA,WAAWK,WAClD,OAAOF,EAIX,OAAQ,EA+CV,MAAMG,EAAsB,IAAIC,EAAAA,aAC1BC,EAAmB,IAAIC,EAAAA,WACvBC,EAAiB,IAAID,EAAAA,WACrBE,EAAiB,IAAIF,EAAAA,WACrBG,EAAiB,IAAIC,EAAAA,QAke3B,SAASC,EACPC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,GAEA,MAAMxB,EAAQqB,EAAapB,OAC3B,IAAK,IAAIwB,EAAI,EAAGA,EAAIzB,IAASyB,EAAG,CAC9B,MAAMC,EAAcL,EAAaI,GAC3BE,EAAqBD,EAAYE,aACjCC,EAAcH,EAAYI,MAC1BC,EAAejB,EAAUb,OAEzB+B,EAAYL,EAAmBK,UACrC,IAAIC,EAAWN,EAAmBM,SAClCA,EAAWlC,EAAUA,WAACmC,MACpBD,GACClC,EAAUA,WAACoC,YACZpC,EAAAA,WAAWoC,aAEb,MAAMC,EAAST,EAAmBS,OAAShB,EAAaiB,YACxDjB,EAAakB,KAAOC,KAAKC,IAAIpB,EAAakB,KAAMF,GAEhD9B,EAAYA,aAACmC,YAAYT,EAAWC,EAAUG,EAAQ/B,GAGlDkB,IACFlB,EAAoB2B,WAAaV,GAK9BC,EAEME,IAAMzB,EAAQ,EACvBK,EAAoB4B,UAAYT,EACjB,IAANC,IACTpB,EAAoB4B,UAAYT,GAJhCnB,EAAoB4B,UAAYX,EAOlC,MAAMoB,EAAMtB,EAAauB,UAAUC,wBACjCvC,GAEFS,EAAU+B,KAAKH,GACf3B,EAAQ8B,KAAKT,GACbpB,EAAI6B,KAAKC,aAAWC,MAAM/B,EAAIa,KAC1BZ,EAAchB,OAAS,GACzBgB,EAAc4B,KAAK5B,EAAcY,IAE/BX,EAAuBjB,OAAS,GAClCiB,EAAuB2B,KAAK3B,EAAuBW,IAGrDjB,EAAOA,QAACoC,gBAAgB5B,EAAa6B,MAAOP,EAAKnC,GAEjD,MAAM2C,EAAU9B,EAAa8B,QACvBC,EAAU/B,EAAa+B,QAC7B3C,EAAAA,WAAW4C,mBAAmB7C,EAAkB2C,EAASA,GACzD1C,EAAAA,WAAW6C,mBAAmB9C,EAAkB4C,EAASA,GAEzD,MAAMG,EAAkBlC,EAAakC,gBACrC,GAAIC,EAAAA,QAAQD,GAAkB,CAC5B,MAAME,EAAkBF,EAAgBxB,MACxCX,EAAQ0B,KACNW,EACAzB,EAAe,EACfA,EACAA,EACAF,EACA2B,GAIJpC,EAAakC,gBAAkB5B,UAGpB+B,GArmBf,SACEC,EACAC,GAEAD,EAAWf,UAAYiB,EAASA,UAACb,MAAMW,EAAWf,WAClDe,EAAWG,UAAYC,EAASA,UAACf,MAAMW,EAAWG,WAElD,MAAME,EA2CR,SACEC,EACAC,EACAtB,EACAkB,EACAK,EACAC,EACAC,EACA/B,EACAgC,EACAC,EACAC,GAEA,IAAIC,EACAC,EACAC,EACAC,EACAC,EAAgBC,EAEftB,EAAAA,QAAQM,IAQXW,EAAiBX,EAAUiB,KAC3BL,EAAkBZ,EAAUkB,MAC5BL,EAAiBb,EAAUmB,KAC3BL,EAAkBd,EAAUoB,MAC5BL,EAAiBf,EAAUqB,MAC3BL,EAAkBhB,EAAUzB,SAZ5BoC,EAAiBzE,EAAAA,WAAWoF,UAAUjB,EAAgBY,MACtDL,EAAkB1E,EAAAA,WAAWoF,UAAUjB,EAAgBa,OACvDL,EAAiB3E,EAAAA,WAAWoF,UAAUjB,EAAgBc,MACtDL,EAAkB5E,EAAAA,WAAWoF,UAAUjB,EAAgBe,OACvDL,EAAiB7E,EAAAA,WAAWoF,UAAUtB,EAAUqB,OAChDL,EAAkB9E,EAAAA,WAAWoF,UAAUtB,EAAUzB,SAWnD,MAAMgD,EAAsB,CAACX,EAAiBE,GACxCU,EAAuB,CAACb,EAAgBE,GAExCY,EAAUC,EAAAA,WAAWC,wBACzBvB,EACAtB,GAEIM,EAAQrC,EAAOA,QAAC6E,sBAAsBH,EAAS3E,GAErD,IAAI+E,EACAC,EACAtB,IACFqB,EAAiBE,EAAqBA,sBAACC,gCACrCpB,GAEFkB,EACE,GACCC,EAAqBA,sBAACC,gCAAgClB,GACrDe,IAGN,MACMI,EADmC,IAAjB3B,EAGlB4B,EAAK,IAAIC,SAAShC,GAExB,IAAIiC,EAAYC,OAAOC,kBACnBC,EAAYF,OAAOG,kBAEvB,MAAMnD,EAAUzC,EAChByC,EAAQoD,EAAIJ,OAAOC,kBACnBjD,EAAQqD,EAAIL,OAAOC,kBACnBjD,EAAQsD,EAAIN,OAAOC,kBAEnB,MAAMhD,EAAUzC,EAChByC,EAAQmD,EAAIJ,OAAOG,kBACnBlD,EAAQoD,EAAIL,OAAOG,kBACnBlD,EAAQqD,EAAIN,OAAOG,kBAGnB,IAGII,EACAC,EAJAC,EAAS,EACTC,EAAO,EACPC,GAAc,EAGlB,IAAKH,EAAO,EAAGA,EAAO,IAAKA,EAAM,CAC/B,IAAII,EAAIH,EACRF,EAAWV,EAAGgB,UAAUD,GAAG,GAC3BA,GAAK1H,EAEL,MAAMkH,EAAIvG,aAAWoF,UAAmC,IAAzBY,EAAGiB,WAAWF,GAAG,IAChDA,GAAKtH,GAC4C,IAA7CE,EAAe2F,EAAsBiB,IACvCjB,EAAqBxC,KAAKyD,GAG5B,MAAMC,EAAIxG,aAAWoF,UAAmC,IAAzBY,EAAGiB,WAAWF,GAAG,IAChDA,GAAKtH,GAC2C,IAA5CE,EAAe0F,EAAqBmB,IACtCnB,EAAoBvC,KAAK0D,GAG3BO,GAAK,EAAItH,EAET,IAAIyH,EAAIlB,EAAGmB,SAASJ,GAAG,GACvBA,GAAK5H,EACL0H,GAAQK,EAERA,EAAIlB,EAAGmB,SAASJ,GAAG,GACnBD,IAAmB,EAAJI,EAEfN,GAAUF,EAAWrH,EAIvB,MAAM+H,GAAmB,GACnBC,GAAoB,GAGpBtG,GAAY,IAAIuG,MAAMT,GACtB5F,GAAM,IAAIqG,MAAMT,GAChB7F,GAAU,IAAIsG,MAAMT,GACpB3F,GAAgBoD,EAAsB,IAAIgD,MAAMT,GAAQ,GACxD1F,GAAyB4E,EAC3B,IAAIuB,MAAMT,GACV,GACEzF,GAAU,IAAIkG,MAAMR,IAIpBS,GAAa,GACbC,GAAc,GACdC,GAAa,GACbC,GAAc,GAGpB,IAAIC,GAAc,EACdC,GAAgB,EAEpB,IADAhB,EAAS,EACJD,EAAO,EAAGA,EAAO,IAAKA,EAAM,CAC/BD,EAAWV,EAAGgB,UAAUJ,GAAQ,GAChCA,GAAUvH,EACV,MAAMwI,EAAYjB,EAEZkB,EAAU9H,aAAWoF,UAAwC,IAA9BY,EAAGiB,WAAWL,GAAQ,IAC3DA,GAAUnH,EAEV,MAAMsI,EAAU/H,aAAWoF,UAAwC,IAA9BY,EAAGiB,WAAWL,GAAQ,IAC3DA,GAAUnH,EAEV,MAAMuI,EAAQhI,aAAWoF,UAAwC,IAA9BY,EAAGiB,WAAWL,GAAQ,IACnDqB,EAAoB,GAARD,EAClBpB,GAAUnH,EAEV,MAAMyI,EAAQlI,aAAWoF,UAAwC,IAA9BY,EAAGiB,WAAWL,GAAQ,IACnDuB,EAAoB,GAARD,EAClBtB,GAAUnH,EAEV,MAAM2I,EAAYpC,EAAGmB,SAASP,GAAQ,GACtCA,GAAUzH,EAEV,MAAMkJ,EAAWrC,EAAGmB,SAASP,GAAQ,GACrCA,GAAUzH,EAGVyH,GAAUzH,EAGV,MAAMmJ,EAAiB,IAAIhB,MAAMc,GACjC,IAAK,IAAIjI,EAAI,EAAGA,EAAIiI,IAAajI,EAAG,CAClC,MAAM8B,EAAY6F,EAAU9B,EAAGuC,SAAS3B,KAAYoB,EACpD1H,EAAoB2B,UAAYA,EAChC,MAAMC,EAAW6F,EAAU/B,EAAGuC,SAAS3B,KAAYsB,EACnD5H,EAAoB4B,SAAWA,EAE/B,IAAIG,EAAS2D,EAAGwC,WAAW5B,GAAQ,GAgBnC,GAfAA,GAAUrH,EAKK,IAAX8C,GAAgBA,EAASmC,IAC3BnC,IAAWG,KAAKiG,IAAI,EAAGlE,IAIzBlC,GAAU,QAEV/B,EAAoB+B,OAASA,GAI0B,IAArD1C,EAAe2F,EAAsBrD,KACc,IAAnDtC,EAAe0F,EAAqBnD,GACpC,CACA,MAAMH,EAAQpC,EACZyH,GACA9G,EACAC,EAAYA,cAEd,IAAe,IAAXwB,EAGG,CACLuG,EAAenI,GAAKkH,GAAkBtF,GACtC,SAJAqF,GAAiBtE,KAAKvC,EAAAA,aAAayC,MAAM1C,IACzC+G,GAAkBvE,KAAK6E,IAM3BW,EAAenI,GAAKwH,GAEhBnF,KAAKkG,IAAIzG,EAAYwC,GAAkBwD,EACzCV,GAAWzE,KAAK,CACdf,MAAO4F,GACP9F,aAActB,EAAAA,aAAayC,MAAM1C,KAE1BkC,KAAKkG,IAAIzG,EAAY0C,GAAkBsD,EAChDR,GAAW3E,KAAK,CACdf,MAAO4F,GACP9F,aAActB,EAAAA,aAAayC,MAAM1C,KAE1BkC,KAAKkG,IAAIxG,EAAWwC,GAAmByD,EAChDX,GAAY1E,KAAK,CACff,MAAO4F,GACP9F,aAActB,EAAAA,aAAayC,MAAM1C,KAE1BkC,KAAKkG,IAAIxG,EAAW0C,GAAmBuD,GAChDT,GAAY5E,KAAK,CACff,MAAO4F,GACP9F,aAActB,EAAAA,aAAayC,MAAM1C,KAIrC4F,EAAY1D,KAAKC,IAAIJ,EAAQ6D,GAC7BG,EAAY7D,KAAKmG,IAAItG,EAAQgE,GAC7BrF,GAAQ2G,IAAetF,EAEvB,MAAMM,EAAMC,EAAUC,wBAAwBvC,GAU9C,GATAS,GAAU4G,IAAehF,EAErB2B,IACFpD,GAAcyG,KACX9B,EAAqBA,sBAACC,gCAAgC5D,GACrDyD,GACFC,GAGAG,EAA+B,CACjC,MAAM6C,EAAShG,EAAUiG,sBAAsBlG,GAC/CxB,GAAuBwG,IAAeiB,EAGxC/H,EAAAA,QAAQoC,gBAAgBC,EAAOP,EAAKnC,GAEpCC,EAAAA,WAAW4C,mBAAmB7C,EAAkB2C,EAASA,GACzD1C,EAAAA,WAAW6C,mBAAmB9C,EAAkB4C,EAASA,GAEzD,IAAI0F,GAAK7G,EAAYwC,IAAmBE,EAAiBF,GACzDqE,EAAI9I,EAAUA,WAACmC,MAAM2G,EAAG,EAAK,GAC7B,IAAIC,GACD7G,EAAWwC,IAAoBE,EAAkBF,GACpDqE,EAAI/I,EAAUA,WAACmC,MAAM4G,EAAG,EAAK,GAE7B9H,GAAI0G,IAAe,IAAI5E,EAAUA,WAAC+F,EAAGC,KACnCpB,GAGJ,MAAMqB,EAA+B,EAAXX,EAC1B,IAAK,IAAI3G,EAAI,EAAGA,EAAIsH,IAAqBtH,IAAKkG,GAC5CxG,GAAQwG,IAAiBU,EAAetC,EAAGiD,UAAUrC,GAAQ,IAC7DA,GAAU5H,EAGZ,GAAI0H,IAAaE,EAASiB,EACxB,MAAM,IAAIqB,EAAAA,aAAa,yBAI3BnI,GAAUb,OAASyH,GACnB1G,GAAIf,OAASyH,GACb3G,GAAQd,OAASyH,GACbrD,IACFpD,GAAchB,OAASyH,IAErB5B,IACF5E,GAAuBjB,OAASyH,IAGlC,MAAMwB,GAA2BxB,GAC3ByB,GAA0BxB,GAG1BvG,GAAe,CACnBkB,KAAM2D,EACN3C,qBAAiB8F,EACjB/G,YAAaA,EACbY,MAAOA,EACPN,UAAWA,EACXO,QAASA,EACTC,QAASA,GAKXmE,GAAW+B,MAAK,SAAUC,EAAGC,GAC3B,OAAOA,EAAE3H,aAAaK,SAAWqH,EAAE1H,aAAaK,YAElDsF,GAAY8B,MAAK,SAAUC,EAAGC,GAC5B,OAAOD,EAAE1H,aAAaI,UAAYuH,EAAE3H,aAAaI,aAEnDwF,GAAW6B,MAAK,SAAUC,EAAGC,GAC3B,OAAOD,EAAE1H,aAAaK,SAAWsH,EAAE3H,aAAaK,YAElDwF,GAAY4B,MAAK,SAAUC,EAAGC,GAC5B,OAAOA,EAAE3H,aAAaI,UAAYsH,EAAE1H,aAAaI,aAGnD,MAAMwH,GAAa,KAsDnB,GArDA3I,EACEC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAkG,IACCkC,GAAa5E,GACd,GACC4E,GAAa3E,GAEhBhE,EACEC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAmG,IACCiC,GAAa3E,GACd,GAEFhE,EACEC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAoG,GACAgC,GAAa5E,GACb,EACA4E,GAAa3E,GAEfhE,EACEC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAqG,GACA+B,GAAa3E,GACb,GAKEyC,GAAWrH,OAAS,GAAKwH,GAAYxH,OAAS,EAAG,CACnD,MAAMwJ,EAAmBnC,GAAW,GAAGxF,MACjC4H,EAAkBR,GAClB1F,EAAkBiE,GAAYA,GAAYxH,OAAS,GAAG6B,MACtD6H,EAAiB7I,GAAUb,OAAS,EAE1CkB,GAAQ0B,KACNW,EACAmG,EACAD,EACAA,EACAD,EACAjG,GAIJoD,EAAO9F,GAAUb,OAEjB,MAAM2J,GAAmBC,EAAAA,eAAeC,WAAWhJ,IACnD,IAAIiJ,GACAxG,EAAAA,QAAQM,KACVkG,GAAsBC,EAAmBA,oBAACC,cACxCpG,EACAoC,EACAG,EACAzD,IAIJ,MACMuH,GADW,IAAIC,sBAAoBxH,GACGyH,iDAC1CnG,EACAnD,GACAmF,GAGIoE,GAAQ,IAAIC,EAAsBA,uBAACpH,EAASC,EAASc,GACrDsG,GAAW,IAAIC,EAAeA,gBAClCvG,EACAoG,GACAjJ,GAAakB,KACb8D,EACAd,GACA,EACAjB,EACAyB,EACA3B,EACAC,GAEIqG,GAAW,IAAIlL,aAAaqH,EAAO2D,GAASG,QAElD,IAAIC,GAAc,EAClB,IAAK,IAAIC,EAAI,EAAGA,EAAIhE,IAAQgE,EAC1BD,GAAcJ,GAASM,OACrBJ,GACAE,GACA7J,GAAU8J,GACV5J,GAAI4J,GACJ7J,GAAQ6J,QACRxB,EACAnI,GAAc2J,GACd1J,GAAuB0J,IAI3B,MAAME,GAA0BxD,GAC7ByD,KAAI,SAAUC,GACb,OAAOA,EAAOlJ,SAEfmJ,UACGC,GAAyB3D,GAC5BwD,KAAI,SAAUC,GACb,OAAOA,EAAOlJ,SAEfmJ,UACGE,GAA0B3D,GAC7BuD,KAAI,SAAUC,GACb,OAAOA,EAAOlJ,SAEfmJ,UACGG,GAAyB3D,GAC5BsD,KAAI,SAAUC,GACb,OAAOA,EAAOlJ,SAEfmJ,UAYH,OAVAC,GAAuBG,QACrBF,GAAwBA,GAAwBlL,OAAS,IAE3DiL,GAAuBrI,KAAKiI,GAAwB,IAEpDM,GAAuBC,QACrBP,GAAwBA,GAAwB7K,OAAS,IAE3DmL,GAAuBvI,KAAKsI,GAAwB,IAE7C,CACLV,SAAUA,GACVtJ,QAAS,IAAInC,YAAYmC,IACzBmK,cAAelF,EACfmF,cAAetF,EACfsE,SAAUA,GACVX,iBAAkBA,GAClBG,oBAAqBA,GACrBG,2BAA4BA,GAC5BhB,yBAA0BA,GAC1BC,wBAAyBA,GACzB2B,wBAAyBA,GACzBI,uBAAwBA,GACxBC,wBAAyBA,GACzBC,uBAAwBA,IAvgBPI,CACjB9H,EAAWM,OACXN,EAAWO,iBACXP,EAAWf,UACXe,EAAWG,UACXH,EAAWQ,gBACXR,EAAWS,aACXT,EAAWU,2BACXV,EAAWrB,YACXqB,EAAWW,oBACXX,EAAWY,6BACXZ,EAAWa,4BAEPkG,EAAW1G,EAAW0G,SAC5B9G,EAAoBd,KAAK4H,EAASzG,QAClC,MAAM7C,EAAU4C,EAAW5C,QAG3B,OAFAwC,EAAoBd,KAAK1B,EAAQ6C,QAE1B,CACLyG,SAAUA,EAASzG,OACnB7C,QAASA,EAAQ6C,OACjByH,mBAAoB1H,EAAWwG,SAASG,OACxCa,cAAexH,EAAWwH,cAC1BD,cAAevH,EAAWuH,cAC1B1B,iBAAkB7F,EAAW6F,iBAC7BG,oBAAqBhG,EAAWgG,oBAChCG,2BAA4BnG,EAAWmG,2BACvCK,SAAUxG,EAAWwG,SACrBrB,yBAA0BnF,EAAWmF,yBACrCC,wBAAyBpF,EAAWoF,wBACpC2B,wBAAyB/G,EAAW+G,wBACpCI,uBAAwBnH,EAAWmH,uBACnCC,wBAAyBpH,EAAWoH,wBACpCC,uBAAwBrH,EAAWqH"}