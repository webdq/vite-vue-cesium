{"version":3,"file":"PolygonGeometryLibrary-3d351e50.js","sources":["../../../../Source/Core/Queue.js","../../../../Source/Core/PolygonGeometryLibrary.js"],"sourcesContent":["/**\r\n * A queue that can enqueue items at the end, and dequeue items from the front.\r\n *\r\n * @alias Queue\r\n * @constructor\r\n */\r\nfunction Queue() {\r\n  this._array = [];\r\n  this._offset = 0;\r\n  this._length = 0;\r\n}\r\n\r\nObject.defineProperties(Queue.prototype, {\r\n  /**\r\n   * The length of the queue.\r\n   *\r\n   * @memberof Queue.prototype\r\n   *\r\n   * @type {Number}\r\n   * @readonly\r\n   */\r\n  length: {\r\n    get: function () {\r\n      return this._length;\r\n    },\r\n  },\r\n});\r\n\r\n/**\r\n * Enqueues the specified item.\r\n *\r\n * @param {*} item The item to enqueue.\r\n */\r\nQueue.prototype.enqueue = function (item) {\r\n  this._array.push(item);\r\n  this._length++;\r\n};\r\n\r\n/**\r\n * Dequeues an item.  Returns undefined if the queue is empty.\r\n *\r\n * @returns {*} The the dequeued item.\r\n */\r\nQueue.prototype.dequeue = function () {\r\n  if (this._length === 0) {\r\n    return undefined;\r\n  }\r\n\r\n  const array = this._array;\r\n  let offset = this._offset;\r\n  const item = array[offset];\r\n  array[offset] = undefined;\r\n\r\n  offset++;\r\n  if (offset > 10 && offset * 2 > array.length) {\r\n    //compact array\r\n    this._array = array.slice(offset);\r\n    offset = 0;\r\n  }\r\n\r\n  this._offset = offset;\r\n  this._length--;\r\n\r\n  return item;\r\n};\r\n\r\n/**\r\n * Returns the item at the front of the queue.  Returns undefined if the queue is empty.\r\n *\r\n * @returns {*} The item at the front of the queue.\r\n */\r\nQueue.prototype.peek = function () {\r\n  if (this._length === 0) {\r\n    return undefined;\r\n  }\r\n\r\n  return this._array[this._offset];\r\n};\r\n\r\n/**\r\n * Check whether this queue contains the specified item.\r\n *\r\n * @param {*} item The item to search for.\r\n */\r\nQueue.prototype.contains = function (item) {\r\n  return this._array.indexOf(item) !== -1;\r\n};\r\n\r\n/**\r\n * Remove all items from the queue.\r\n */\r\nQueue.prototype.clear = function () {\r\n  this._array.length = this._offset = this._length = 0;\r\n};\r\n\r\n/**\r\n * Sort the items in the queue in-place.\r\n *\r\n * @param {Queue.Comparator} compareFunction A function that defines the sort order.\r\n */\r\nQueue.prototype.sort = function (compareFunction) {\r\n  if (this._offset > 0) {\r\n    //compact array\r\n    this._array = this._array.slice(this._offset);\r\n    this._offset = 0;\r\n  }\r\n\r\n  this._array.sort(compareFunction);\r\n};\r\n\r\n/**\r\n * A function used to compare two items while sorting a queue.\r\n * @callback Queue.Comparator\r\n *\r\n * @param {*} a An item in the array.\r\n * @param {*} b An item in the array.\r\n * @returns {Number} Returns a negative value if <code>a</code> is less than <code>b</code>,\r\n *          a positive value if <code>a</code> is greater than <code>b</code>, or\r\n *          0 if <code>a</code> is equal to <code>b</code>.\r\n *\r\n * @example\r\n * function compareNumbers(a, b) {\r\n *     return a - b;\r\n * }\r\n */\r\nexport default Queue;\r\n","import ArcType from \"./ArcType.js\";\r\nimport arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\r\nimport Cartesian2 from \"./Cartesian2.js\";\r\nimport Cartesian3 from \"./Cartesian3.js\";\r\nimport Cartographic from \"./Cartographic.js\";\r\nimport ComponentDatatype from \"./ComponentDatatype.js\";\r\nimport defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\nimport Ellipsoid from \"./Ellipsoid.js\";\r\nimport EllipsoidRhumbLine from \"./EllipsoidRhumbLine.js\";\r\nimport Geometry from \"./Geometry.js\";\r\nimport GeometryAttribute from \"./GeometryAttribute.js\";\r\nimport GeometryAttributes from \"./GeometryAttributes.js\";\r\nimport GeometryPipeline from \"./GeometryPipeline.js\";\r\nimport IndexDatatype from \"./IndexDatatype.js\";\r\nimport CesiumMath from \"./Math.js\";\r\nimport Matrix3 from \"./Matrix3.js\";\r\nimport PolygonPipeline from \"./PolygonPipeline.js\";\r\nimport PrimitiveType from \"./PrimitiveType.js\";\r\nimport Quaternion from \"./Quaternion.js\";\r\nimport Queue from \"./Queue.js\";\r\nimport WindingOrder from \"./WindingOrder.js\";\r\n\r\n/**\r\n * @private\r\n */\r\nconst PolygonGeometryLibrary = {};\r\n\r\nPolygonGeometryLibrary.computeHierarchyPackedLength = function (\r\n  polygonHierarchy\r\n) {\r\n  let numComponents = 0;\r\n  const stack = [polygonHierarchy];\r\n  while (stack.length > 0) {\r\n    const hierarchy = stack.pop();\r\n    if (!defined(hierarchy)) {\r\n      continue;\r\n    }\r\n\r\n    numComponents += 2;\r\n\r\n    const positions = hierarchy.positions;\r\n    const holes = hierarchy.holes;\r\n\r\n    if (defined(positions)) {\r\n      numComponents += positions.length * Cartesian3.packedLength;\r\n    }\r\n\r\n    if (defined(holes)) {\r\n      const length = holes.length;\r\n      for (let i = 0; i < length; ++i) {\r\n        stack.push(holes[i]);\r\n      }\r\n    }\r\n  }\r\n\r\n  return numComponents;\r\n};\r\n\r\nPolygonGeometryLibrary.packPolygonHierarchy = function (\r\n  polygonHierarchy,\r\n  array,\r\n  startingIndex\r\n) {\r\n  const stack = [polygonHierarchy];\r\n  while (stack.length > 0) {\r\n    const hierarchy = stack.pop();\r\n    if (!defined(hierarchy)) {\r\n      continue;\r\n    }\r\n\r\n    const positions = hierarchy.positions;\r\n    const holes = hierarchy.holes;\r\n\r\n    array[startingIndex++] = defined(positions) ? positions.length : 0;\r\n    array[startingIndex++] = defined(holes) ? holes.length : 0;\r\n\r\n    if (defined(positions)) {\r\n      const positionsLength = positions.length;\r\n      for (let i = 0; i < positionsLength; ++i, startingIndex += 3) {\r\n        Cartesian3.pack(positions[i], array, startingIndex);\r\n      }\r\n    }\r\n\r\n    if (defined(holes)) {\r\n      const holesLength = holes.length;\r\n      for (let j = 0; j < holesLength; ++j) {\r\n        stack.push(holes[j]);\r\n      }\r\n    }\r\n  }\r\n\r\n  return startingIndex;\r\n};\r\n\r\nPolygonGeometryLibrary.unpackPolygonHierarchy = function (\r\n  array,\r\n  startingIndex\r\n) {\r\n  const positionsLength = array[startingIndex++];\r\n  const holesLength = array[startingIndex++];\r\n\r\n  const positions = new Array(positionsLength);\r\n  const holes = holesLength > 0 ? new Array(holesLength) : undefined;\r\n\r\n  for (\r\n    let i = 0;\r\n    i < positionsLength;\r\n    ++i, startingIndex += Cartesian3.packedLength\r\n  ) {\r\n    positions[i] = Cartesian3.unpack(array, startingIndex);\r\n  }\r\n\r\n  for (let j = 0; j < holesLength; ++j) {\r\n    holes[j] = PolygonGeometryLibrary.unpackPolygonHierarchy(\r\n      array,\r\n      startingIndex\r\n    );\r\n    startingIndex = holes[j].startingIndex;\r\n    delete holes[j].startingIndex;\r\n  }\r\n\r\n  return {\r\n    positions: positions,\r\n    holes: holes,\r\n    startingIndex: startingIndex,\r\n  };\r\n};\r\n\r\nconst distanceScratch = new Cartesian3();\r\nfunction getPointAtDistance(p0, p1, distance, length) {\r\n  Cartesian3.subtract(p1, p0, distanceScratch);\r\n  Cartesian3.multiplyByScalar(\r\n    distanceScratch,\r\n    distance / length,\r\n    distanceScratch\r\n  );\r\n  Cartesian3.add(p0, distanceScratch, distanceScratch);\r\n  return [distanceScratch.x, distanceScratch.y, distanceScratch.z];\r\n}\r\n\r\nPolygonGeometryLibrary.subdivideLineCount = function (p0, p1, minDistance) {\r\n  const distance = Cartesian3.distance(p0, p1);\r\n  const n = distance / minDistance;\r\n  const countDivide = Math.max(0, Math.ceil(CesiumMath.log2(n)));\r\n  return Math.pow(2, countDivide);\r\n};\r\n\r\nconst scratchCartographic0 = new Cartographic();\r\nconst scratchCartographic1 = new Cartographic();\r\nconst scratchCartographic2 = new Cartographic();\r\nconst scratchCartesian0 = new Cartesian3();\r\nPolygonGeometryLibrary.subdivideRhumbLineCount = function (\r\n  ellipsoid,\r\n  p0,\r\n  p1,\r\n  minDistance\r\n) {\r\n  const c0 = ellipsoid.cartesianToCartographic(p0, scratchCartographic0);\r\n  const c1 = ellipsoid.cartesianToCartographic(p1, scratchCartographic1);\r\n  const rhumb = new EllipsoidRhumbLine(c0, c1, ellipsoid);\r\n  const n = rhumb.surfaceDistance / minDistance;\r\n  const countDivide = Math.max(0, Math.ceil(CesiumMath.log2(n)));\r\n  return Math.pow(2, countDivide);\r\n};\r\n\r\nPolygonGeometryLibrary.subdivideLine = function (p0, p1, minDistance, result) {\r\n  const numVertices = PolygonGeometryLibrary.subdivideLineCount(\r\n    p0,\r\n    p1,\r\n    minDistance\r\n  );\r\n  const length = Cartesian3.distance(p0, p1);\r\n  const distanceBetweenVertices = length / numVertices;\r\n\r\n  if (!defined(result)) {\r\n    result = [];\r\n  }\r\n\r\n  const positions = result;\r\n  positions.length = numVertices * 3;\r\n\r\n  let index = 0;\r\n  for (let i = 0; i < numVertices; i++) {\r\n    const p = getPointAtDistance(p0, p1, i * distanceBetweenVertices, length);\r\n    positions[index++] = p[0];\r\n    positions[index++] = p[1];\r\n    positions[index++] = p[2];\r\n  }\r\n\r\n  return positions;\r\n};\r\n\r\nPolygonGeometryLibrary.subdivideRhumbLine = function (\r\n  ellipsoid,\r\n  p0,\r\n  p1,\r\n  minDistance,\r\n  result\r\n) {\r\n  const c0 = ellipsoid.cartesianToCartographic(p0, scratchCartographic0);\r\n  const c1 = ellipsoid.cartesianToCartographic(p1, scratchCartographic1);\r\n  const rhumb = new EllipsoidRhumbLine(c0, c1, ellipsoid);\r\n\r\n  const n = rhumb.surfaceDistance / minDistance;\r\n  const countDivide = Math.max(0, Math.ceil(CesiumMath.log2(n)));\r\n  const numVertices = Math.pow(2, countDivide);\r\n  const distanceBetweenVertices = rhumb.surfaceDistance / numVertices;\r\n\r\n  if (!defined(result)) {\r\n    result = [];\r\n  }\r\n\r\n  const positions = result;\r\n  positions.length = numVertices * 3;\r\n\r\n  let index = 0;\r\n  for (let i = 0; i < numVertices; i++) {\r\n    const c = rhumb.interpolateUsingSurfaceDistance(\r\n      i * distanceBetweenVertices,\r\n      scratchCartographic2\r\n    );\r\n    const p = ellipsoid.cartographicToCartesian(c, scratchCartesian0);\r\n    positions[index++] = p.x;\r\n    positions[index++] = p.y;\r\n    positions[index++] = p.z;\r\n  }\r\n\r\n  return positions;\r\n};\r\n\r\nconst scaleToGeodeticHeightN1 = new Cartesian3();\r\nconst scaleToGeodeticHeightN2 = new Cartesian3();\r\nconst scaleToGeodeticHeightP1 = new Cartesian3();\r\nconst scaleToGeodeticHeightP2 = new Cartesian3();\r\n\r\nPolygonGeometryLibrary.scaleToGeodeticHeightExtruded = function (\r\n  geometry,\r\n  maxHeight,\r\n  minHeight,\r\n  ellipsoid,\r\n  perPositionHeight\r\n) {\r\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\r\n\r\n  const n1 = scaleToGeodeticHeightN1;\r\n  let n2 = scaleToGeodeticHeightN2;\r\n  const p = scaleToGeodeticHeightP1;\r\n  let p2 = scaleToGeodeticHeightP2;\r\n\r\n  if (\r\n    defined(geometry) &&\r\n    defined(geometry.attributes) &&\r\n    defined(geometry.attributes.position)\r\n  ) {\r\n    const positions = geometry.attributes.position.values;\r\n    const length = positions.length / 2;\r\n\r\n    for (let i = 0; i < length; i += 3) {\r\n      Cartesian3.fromArray(positions, i, p);\r\n\r\n      ellipsoid.geodeticSurfaceNormal(p, n1);\r\n      p2 = ellipsoid.scaleToGeodeticSurface(p, p2);\r\n      n2 = Cartesian3.multiplyByScalar(n1, minHeight, n2);\r\n      n2 = Cartesian3.add(p2, n2, n2);\r\n      positions[i + length] = n2.x;\r\n      positions[i + 1 + length] = n2.y;\r\n      positions[i + 2 + length] = n2.z;\r\n\r\n      if (perPositionHeight) {\r\n        p2 = Cartesian3.clone(p, p2);\r\n      }\r\n      n2 = Cartesian3.multiplyByScalar(n1, maxHeight, n2);\r\n      n2 = Cartesian3.add(p2, n2, n2);\r\n      positions[i] = n2.x;\r\n      positions[i + 1] = n2.y;\r\n      positions[i + 2] = n2.z;\r\n    }\r\n  }\r\n  return geometry;\r\n};\r\n\r\nPolygonGeometryLibrary.polygonOutlinesFromHierarchy = function (\r\n  polygonHierarchy,\r\n  scaleToEllipsoidSurface,\r\n  ellipsoid\r\n) {\r\n  // create from a polygon hierarchy\r\n  // Algorithm adapted from http://www.geometrictools.com/Documentation/TriangulationByEarClipping.pdf\r\n  const polygons = [];\r\n  const queue = new Queue();\r\n  queue.enqueue(polygonHierarchy);\r\n  let i;\r\n  let j;\r\n  let length;\r\n  while (queue.length !== 0) {\r\n    const outerNode = queue.dequeue();\r\n    let outerRing = outerNode.positions;\r\n    if (scaleToEllipsoidSurface) {\r\n      length = outerRing.length;\r\n      for (i = 0; i < length; i++) {\r\n        ellipsoid.scaleToGeodeticSurface(outerRing[i], outerRing[i]);\r\n      }\r\n    }\r\n    outerRing = arrayRemoveDuplicates(\r\n      outerRing,\r\n      Cartesian3.equalsEpsilon,\r\n      true\r\n    );\r\n    if (outerRing.length < 3) {\r\n      continue;\r\n    }\r\n\r\n    const numChildren = outerNode.holes ? outerNode.holes.length : 0;\r\n    // The outer polygon contains inner polygons\r\n    for (i = 0; i < numChildren; i++) {\r\n      const hole = outerNode.holes[i];\r\n      let holePositions = hole.positions;\r\n      if (scaleToEllipsoidSurface) {\r\n        length = holePositions.length;\r\n        for (j = 0; j < length; ++j) {\r\n          ellipsoid.scaleToGeodeticSurface(holePositions[j], holePositions[j]);\r\n        }\r\n      }\r\n      holePositions = arrayRemoveDuplicates(\r\n        holePositions,\r\n        Cartesian3.equalsEpsilon,\r\n        true\r\n      );\r\n      if (holePositions.length < 3) {\r\n        continue;\r\n      }\r\n      polygons.push(holePositions);\r\n\r\n      let numGrandchildren = 0;\r\n      if (defined(hole.holes)) {\r\n        numGrandchildren = hole.holes.length;\r\n      }\r\n\r\n      for (j = 0; j < numGrandchildren; j++) {\r\n        queue.enqueue(hole.holes[j]);\r\n      }\r\n    }\r\n\r\n    polygons.push(outerRing);\r\n  }\r\n\r\n  return polygons;\r\n};\r\n\r\nPolygonGeometryLibrary.polygonsFromHierarchy = function (\r\n  polygonHierarchy,\r\n  projectPointsTo2D,\r\n  scaleToEllipsoidSurface,\r\n  ellipsoid\r\n) {\r\n  // create from a polygon hierarchy\r\n  // Algorithm adapted from http://www.geometrictools.com/Documentation/TriangulationByEarClipping.pdf\r\n  const hierarchy = [];\r\n  const polygons = [];\r\n\r\n  const queue = new Queue();\r\n  queue.enqueue(polygonHierarchy);\r\n\r\n  while (queue.length !== 0) {\r\n    const outerNode = queue.dequeue();\r\n    let outerRing = outerNode.positions;\r\n    const holes = outerNode.holes;\r\n\r\n    let i;\r\n    let length;\r\n    if (scaleToEllipsoidSurface) {\r\n      length = outerRing.length;\r\n      for (i = 0; i < length; i++) {\r\n        ellipsoid.scaleToGeodeticSurface(outerRing[i], outerRing[i]);\r\n      }\r\n    }\r\n\r\n    outerRing = arrayRemoveDuplicates(\r\n      outerRing,\r\n      Cartesian3.equalsEpsilon,\r\n      true\r\n    );\r\n    if (outerRing.length < 3) {\r\n      continue;\r\n    }\r\n\r\n    let positions2D = projectPointsTo2D(outerRing);\r\n    if (!defined(positions2D)) {\r\n      continue;\r\n    }\r\n    const holeIndices = [];\r\n\r\n    let originalWindingOrder = PolygonPipeline.computeWindingOrder2D(\r\n      positions2D\r\n    );\r\n    if (originalWindingOrder === WindingOrder.CLOCKWISE) {\r\n      positions2D.reverse();\r\n      outerRing = outerRing.slice().reverse();\r\n    }\r\n\r\n    let positions = outerRing.slice();\r\n    const numChildren = defined(holes) ? holes.length : 0;\r\n    const polygonHoles = [];\r\n    let j;\r\n\r\n    for (i = 0; i < numChildren; i++) {\r\n      const hole = holes[i];\r\n      let holePositions = hole.positions;\r\n      if (scaleToEllipsoidSurface) {\r\n        length = holePositions.length;\r\n        for (j = 0; j < length; ++j) {\r\n          ellipsoid.scaleToGeodeticSurface(holePositions[j], holePositions[j]);\r\n        }\r\n      }\r\n\r\n      holePositions = arrayRemoveDuplicates(\r\n        holePositions,\r\n        Cartesian3.equalsEpsilon,\r\n        true\r\n      );\r\n      if (holePositions.length < 3) {\r\n        continue;\r\n      }\r\n\r\n      const holePositions2D = projectPointsTo2D(holePositions);\r\n      if (!defined(holePositions2D)) {\r\n        continue;\r\n      }\r\n\r\n      originalWindingOrder = PolygonPipeline.computeWindingOrder2D(\r\n        holePositions2D\r\n      );\r\n      if (originalWindingOrder === WindingOrder.CLOCKWISE) {\r\n        holePositions2D.reverse();\r\n        holePositions = holePositions.slice().reverse();\r\n      }\r\n\r\n      polygonHoles.push(holePositions);\r\n      holeIndices.push(positions.length);\r\n      positions = positions.concat(holePositions);\r\n      positions2D = positions2D.concat(holePositions2D);\r\n\r\n      let numGrandchildren = 0;\r\n      if (defined(hole.holes)) {\r\n        numGrandchildren = hole.holes.length;\r\n      }\r\n\r\n      for (j = 0; j < numGrandchildren; j++) {\r\n        queue.enqueue(hole.holes[j]);\r\n      }\r\n    }\r\n\r\n    hierarchy.push({\r\n      outerRing: outerRing,\r\n      holes: polygonHoles,\r\n    });\r\n    polygons.push({\r\n      positions: positions,\r\n      positions2D: positions2D,\r\n      holes: holeIndices,\r\n    });\r\n  }\r\n\r\n  return {\r\n    hierarchy: hierarchy,\r\n    polygons: polygons,\r\n  };\r\n};\r\n\r\nconst computeBoundingRectangleCartesian2 = new Cartesian2();\r\nconst computeBoundingRectangleCartesian3 = new Cartesian3();\r\nconst computeBoundingRectangleQuaternion = new Quaternion();\r\nconst computeBoundingRectangleMatrix3 = new Matrix3();\r\nPolygonGeometryLibrary.computeBoundingRectangle = function (\r\n  planeNormal,\r\n  projectPointTo2D,\r\n  positions,\r\n  angle,\r\n  result\r\n) {\r\n  const rotation = Quaternion.fromAxisAngle(\r\n    planeNormal,\r\n    angle,\r\n    computeBoundingRectangleQuaternion\r\n  );\r\n  const textureMatrix = Matrix3.fromQuaternion(\r\n    rotation,\r\n    computeBoundingRectangleMatrix3\r\n  );\r\n\r\n  let minX = Number.POSITIVE_INFINITY;\r\n  let maxX = Number.NEGATIVE_INFINITY;\r\n  let minY = Number.POSITIVE_INFINITY;\r\n  let maxY = Number.NEGATIVE_INFINITY;\r\n\r\n  const length = positions.length;\r\n  for (let i = 0; i < length; ++i) {\r\n    const p = Cartesian3.clone(\r\n      positions[i],\r\n      computeBoundingRectangleCartesian3\r\n    );\r\n    Matrix3.multiplyByVector(textureMatrix, p, p);\r\n    const st = projectPointTo2D(p, computeBoundingRectangleCartesian2);\r\n\r\n    if (defined(st)) {\r\n      minX = Math.min(minX, st.x);\r\n      maxX = Math.max(maxX, st.x);\r\n\r\n      minY = Math.min(minY, st.y);\r\n      maxY = Math.max(maxY, st.y);\r\n    }\r\n  }\r\n\r\n  result.x = minX;\r\n  result.y = minY;\r\n  result.width = maxX - minX;\r\n  result.height = maxY - minY;\r\n  return result;\r\n};\r\n\r\nPolygonGeometryLibrary.createGeometryFromPositions = function (\r\n  ellipsoid,\r\n  polygon,\r\n  granularity,\r\n  perPositionHeight,\r\n  vertexFormat,\r\n  arcType\r\n) {\r\n  let indices = PolygonPipeline.triangulate(polygon.positions2D, polygon.holes);\r\n\r\n  /* If polygon is completely unrenderable, just use the first three vertices */\r\n  if (indices.length < 3) {\r\n    indices = [0, 1, 2];\r\n  }\r\n\r\n  const positions = polygon.positions;\r\n\r\n  if (perPositionHeight) {\r\n    const length = positions.length;\r\n    const flattenedPositions = new Array(length * 3);\r\n    let index = 0;\r\n    for (let i = 0; i < length; i++) {\r\n      const p = positions[i];\r\n      flattenedPositions[index++] = p.x;\r\n      flattenedPositions[index++] = p.y;\r\n      flattenedPositions[index++] = p.z;\r\n    }\r\n    const geometry = new Geometry({\r\n      attributes: {\r\n        position: new GeometryAttribute({\r\n          componentDatatype: ComponentDatatype.DOUBLE,\r\n          componentsPerAttribute: 3,\r\n          values: flattenedPositions,\r\n        }),\r\n      },\r\n      indices: indices,\r\n      primitiveType: PrimitiveType.TRIANGLES,\r\n    });\r\n\r\n    if (vertexFormat.normal) {\r\n      return GeometryPipeline.computeNormal(geometry);\r\n    }\r\n\r\n    return geometry;\r\n  }\r\n\r\n  if (arcType === ArcType.GEODESIC) {\r\n    return PolygonPipeline.computeSubdivision(\r\n      ellipsoid,\r\n      positions,\r\n      indices,\r\n      granularity\r\n    );\r\n  } else if (arcType === ArcType.RHUMB) {\r\n    return PolygonPipeline.computeRhumbLineSubdivision(\r\n      ellipsoid,\r\n      positions,\r\n      indices,\r\n      granularity\r\n    );\r\n  }\r\n};\r\n\r\nconst computeWallIndicesSubdivided = [];\r\nconst p1Scratch = new Cartesian3();\r\nconst p2Scratch = new Cartesian3();\r\n\r\nPolygonGeometryLibrary.computeWallGeometry = function (\r\n  positions,\r\n  ellipsoid,\r\n  granularity,\r\n  perPositionHeight,\r\n  arcType\r\n) {\r\n  let edgePositions;\r\n  let topEdgeLength;\r\n  let i;\r\n  let p1;\r\n  let p2;\r\n\r\n  let length = positions.length;\r\n  let index = 0;\r\n\r\n  if (!perPositionHeight) {\r\n    const minDistance = CesiumMath.chordLength(\r\n      granularity,\r\n      ellipsoid.maximumRadius\r\n    );\r\n\r\n    let numVertices = 0;\r\n    if (arcType === ArcType.GEODESIC) {\r\n      for (i = 0; i < length; i++) {\r\n        numVertices += PolygonGeometryLibrary.subdivideLineCount(\r\n          positions[i],\r\n          positions[(i + 1) % length],\r\n          minDistance\r\n        );\r\n      }\r\n    } else if (arcType === ArcType.RHUMB) {\r\n      for (i = 0; i < length; i++) {\r\n        numVertices += PolygonGeometryLibrary.subdivideRhumbLineCount(\r\n          ellipsoid,\r\n          positions[i],\r\n          positions[(i + 1) % length],\r\n          minDistance\r\n        );\r\n      }\r\n    }\r\n\r\n    topEdgeLength = (numVertices + length) * 3;\r\n    edgePositions = new Array(topEdgeLength * 2);\r\n    for (i = 0; i < length; i++) {\r\n      p1 = positions[i];\r\n      p2 = positions[(i + 1) % length];\r\n\r\n      let tempPositions;\r\n      if (arcType === ArcType.GEODESIC) {\r\n        tempPositions = PolygonGeometryLibrary.subdivideLine(\r\n          p1,\r\n          p2,\r\n          minDistance,\r\n          computeWallIndicesSubdivided\r\n        );\r\n      } else if (arcType === ArcType.RHUMB) {\r\n        tempPositions = PolygonGeometryLibrary.subdivideRhumbLine(\r\n          ellipsoid,\r\n          p1,\r\n          p2,\r\n          minDistance,\r\n          computeWallIndicesSubdivided\r\n        );\r\n      }\r\n      const tempPositionsLength = tempPositions.length;\r\n      for (let j = 0; j < tempPositionsLength; ++j, ++index) {\r\n        edgePositions[index] = tempPositions[j];\r\n        edgePositions[index + topEdgeLength] = tempPositions[j];\r\n      }\r\n\r\n      edgePositions[index] = p2.x;\r\n      edgePositions[index + topEdgeLength] = p2.x;\r\n      ++index;\r\n\r\n      edgePositions[index] = p2.y;\r\n      edgePositions[index + topEdgeLength] = p2.y;\r\n      ++index;\r\n\r\n      edgePositions[index] = p2.z;\r\n      edgePositions[index + topEdgeLength] = p2.z;\r\n      ++index;\r\n    }\r\n  } else {\r\n    topEdgeLength = length * 3 * 2;\r\n    edgePositions = new Array(topEdgeLength * 2);\r\n    for (i = 0; i < length; i++) {\r\n      p1 = positions[i];\r\n      p2 = positions[(i + 1) % length];\r\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p1.x;\r\n      ++index;\r\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p1.y;\r\n      ++index;\r\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p1.z;\r\n      ++index;\r\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p2.x;\r\n      ++index;\r\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p2.y;\r\n      ++index;\r\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p2.z;\r\n      ++index;\r\n    }\r\n  }\r\n\r\n  length = edgePositions.length;\r\n  const indices = IndexDatatype.createTypedArray(\r\n    length / 3,\r\n    length - positions.length * 6\r\n  );\r\n  let edgeIndex = 0;\r\n  length /= 6;\r\n\r\n  for (i = 0; i < length; i++) {\r\n    const UL = i;\r\n    const UR = UL + 1;\r\n    const LL = UL + length;\r\n    const LR = LL + 1;\r\n\r\n    p1 = Cartesian3.fromArray(edgePositions, UL * 3, p1Scratch);\r\n    p2 = Cartesian3.fromArray(edgePositions, UR * 3, p2Scratch);\r\n    if (\r\n      Cartesian3.equalsEpsilon(\r\n        p1,\r\n        p2,\r\n        CesiumMath.EPSILON10,\r\n        CesiumMath.EPSILON10\r\n      )\r\n    ) {\r\n      //skip corner\r\n      continue;\r\n    }\r\n\r\n    indices[edgeIndex++] = UL;\r\n    indices[edgeIndex++] = LL;\r\n    indices[edgeIndex++] = UR;\r\n    indices[edgeIndex++] = UR;\r\n    indices[edgeIndex++] = LL;\r\n    indices[edgeIndex++] = LR;\r\n  }\r\n\r\n  return new Geometry({\r\n    attributes: new GeometryAttributes({\r\n      position: new GeometryAttribute({\r\n        componentDatatype: ComponentDatatype.DOUBLE,\r\n        componentsPerAttribute: 3,\r\n        values: edgePositions,\r\n      }),\r\n    }),\r\n    indices: indices,\r\n    primitiveType: PrimitiveType.TRIANGLES,\r\n  });\r\n};\r\nexport default PolygonGeometryLibrary;\r\n"],"names":["Queue","this","_array","_offset","_length","Object","defineProperties","prototype","length","get","enqueue","item","push","dequeue","array","offset","undefined","slice","peek","contains","indexOf","clear","sort","compareFunction","PolygonGeometryLibrary","polygonHierarchy","numComponents","stack","hierarchy","pop","defined","positions","holes","Cartesian3","packedLength","i","startingIndex","positionsLength","pack","holesLength","j","Array","unpack","unpackPolygonHierarchy","distanceScratch","getPointAtDistance","p0","p1","distance","subtract","multiplyByScalar","add","x","y","z","subdivideLineCount","minDistance","n","countDivide","Math","max","ceil","CesiumMath","log2","pow","scratchCartographic0","Cartographic","scratchCartographic1","scratchCartographic2","scratchCartesian0","subdivideRhumbLineCount","ellipsoid","c0","cartesianToCartographic","c1","EllipsoidRhumbLine","surfaceDistance","subdivideLine","result","numVertices","distanceBetweenVertices","index","p","subdivideRhumbLine","rhumb","c","interpolateUsingSurfaceDistance","cartographicToCartesian","scaleToGeodeticHeightN1","scaleToGeodeticHeightN2","scaleToGeodeticHeightP1","scaleToGeodeticHeightP2","scaleToGeodeticHeightExtruded","geometry","maxHeight","minHeight","perPositionHeight","defaultValue","Ellipsoid","WGS84","n1","n2","p2","attributes","position","values","fromArray","geodeticSurfaceNormal","scaleToGeodeticSurface","clone","polygonOutlinesFromHierarchy","scaleToEllipsoidSurface","polygons","queue","outerNode","outerRing","arrayRemoveDuplicates","equalsEpsilon","numChildren","hole","holePositions","numGrandchildren","polygonsFromHierarchy","projectPointsTo2D","positions2D","holeIndices","originalWindingOrder","PolygonPipeline","computeWindingOrder2D","WindingOrder","CLOCKWISE","reverse","polygonHoles","holePositions2D","concat","computeBoundingRectangleCartesian2","Cartesian2","computeBoundingRectangleCartesian3","computeBoundingRectangleQuaternion","Quaternion","computeBoundingRectangleMatrix3","Matrix3","computeBoundingRectangle","planeNormal","projectPointTo2D","angle","rotation","fromAxisAngle","textureMatrix","fromQuaternion","minX","Number","POSITIVE_INFINITY","maxX","NEGATIVE_INFINITY","minY","maxY","multiplyByVector","st","min","width","height","createGeometryFromPositions","polygon","granularity","vertexFormat","arcType","indices","triangulate","flattenedPositions","Geometry","GeometryAttribute","componentDatatype","ComponentDatatype","DOUBLE","componentsPerAttribute","primitiveType","PrimitiveType","TRIANGLES","normal","GeometryPipeline","computeNormal","ArcType","GEODESIC","computeSubdivision","RHUMB","computeRhumbLineSubdivision","computeWallIndicesSubdivided","p1Scratch","p2Scratch","computeWallGeometry","edgePositions","topEdgeLength","chordLength","maximumRadius","tempPositions","tempPositionsLength","IndexDatatype","createTypedArray","edgeIndex","UL","UR","LL","LR","EPSILON10","GeometryAttributes"],"mappings":"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"}