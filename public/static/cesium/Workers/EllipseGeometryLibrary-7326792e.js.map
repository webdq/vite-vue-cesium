{"version":3,"file":"EllipseGeometryLibrary-7326792e.js","sources":["../../../../Source/Core/EllipseGeometryLibrary.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\r\nimport CesiumMath from \"./Math.js\";\r\nimport Matrix3 from \"./Matrix3.js\";\r\nimport Quaternion from \"./Quaternion.js\";\r\n\r\nconst EllipseGeometryLibrary = {};\r\n\r\nconst rotAxis = new Cartesian3();\r\nconst tempVec = new Cartesian3();\r\nconst unitQuat = new Quaternion();\r\nconst rotMtx = new Matrix3();\r\n\r\nfunction pointOnEllipsoid(\r\n  theta,\r\n  rotation,\r\n  northVec,\r\n  eastVec,\r\n  aSqr,\r\n  ab,\r\n  bSqr,\r\n  mag,\r\n  unitPos,\r\n  result\r\n) {\r\n  const azimuth = theta + rotation;\r\n\r\n  Cartesian3.multiplyByScalar(eastVec, Math.cos(azimuth), rotAxis);\r\n  Cartesian3.multiplyByScalar(northVec, Math.sin(azimuth), tempVec);\r\n  Cartesian3.add(rotAxis, tempVec, rotAxis);\r\n\r\n  let cosThetaSquared = Math.cos(theta);\r\n  cosThetaSquared = cosThetaSquared * cosThetaSquared;\r\n\r\n  let sinThetaSquared = Math.sin(theta);\r\n  sinThetaSquared = sinThetaSquared * sinThetaSquared;\r\n\r\n  const radius =\r\n    ab / Math.sqrt(bSqr * cosThetaSquared + aSqr * sinThetaSquared);\r\n  const angle = radius / mag;\r\n\r\n  // Create the quaternion to rotate the position vector to the boundary of the ellipse.\r\n  Quaternion.fromAxisAngle(rotAxis, angle, unitQuat);\r\n  Matrix3.fromQuaternion(unitQuat, rotMtx);\r\n\r\n  Matrix3.multiplyByVector(rotMtx, unitPos, result);\r\n  Cartesian3.normalize(result, result);\r\n  Cartesian3.multiplyByScalar(result, mag, result);\r\n  return result;\r\n}\r\n\r\nconst scratchCartesian1 = new Cartesian3();\r\nconst scratchCartesian2 = new Cartesian3();\r\nconst scratchCartesian3 = new Cartesian3();\r\nconst scratchNormal = new Cartesian3();\r\n/**\r\n * Returns the positions raised to the given heights\r\n * @private\r\n */\r\nEllipseGeometryLibrary.raisePositionsToHeight = function (\r\n  positions,\r\n  options,\r\n  extrude\r\n) {\r\n  const ellipsoid = options.ellipsoid;\r\n  const height = options.height;\r\n  const extrudedHeight = options.extrudedHeight;\r\n  const size = extrude ? (positions.length / 3) * 2 : positions.length / 3;\r\n\r\n  const finalPositions = new Float64Array(size * 3);\r\n\r\n  const length = positions.length;\r\n  const bottomOffset = extrude ? length : 0;\r\n  for (let i = 0; i < length; i += 3) {\r\n    const i1 = i + 1;\r\n    const i2 = i + 2;\r\n\r\n    const position = Cartesian3.fromArray(positions, i, scratchCartesian1);\r\n    ellipsoid.scaleToGeodeticSurface(position, position);\r\n\r\n    const extrudedPosition = Cartesian3.clone(position, scratchCartesian2);\r\n    const normal = ellipsoid.geodeticSurfaceNormal(position, scratchNormal);\r\n    const scaledNormal = Cartesian3.multiplyByScalar(\r\n      normal,\r\n      height,\r\n      scratchCartesian3\r\n    );\r\n    Cartesian3.add(position, scaledNormal, position);\r\n\r\n    if (extrude) {\r\n      Cartesian3.multiplyByScalar(normal, extrudedHeight, scaledNormal);\r\n      Cartesian3.add(extrudedPosition, scaledNormal, extrudedPosition);\r\n\r\n      finalPositions[i + bottomOffset] = extrudedPosition.x;\r\n      finalPositions[i1 + bottomOffset] = extrudedPosition.y;\r\n      finalPositions[i2 + bottomOffset] = extrudedPosition.z;\r\n    }\r\n\r\n    finalPositions[i] = position.x;\r\n    finalPositions[i1] = position.y;\r\n    finalPositions[i2] = position.z;\r\n  }\r\n\r\n  return finalPositions;\r\n};\r\n\r\nconst unitPosScratch = new Cartesian3();\r\nconst eastVecScratch = new Cartesian3();\r\nconst northVecScratch = new Cartesian3();\r\n/**\r\n * Returns an array of positions that make up the ellipse.\r\n * @private\r\n */\r\nEllipseGeometryLibrary.computeEllipsePositions = function (\r\n  options,\r\n  addFillPositions,\r\n  addEdgePositions\r\n) {\r\n  const semiMinorAxis = options.semiMinorAxis;\r\n  const semiMajorAxis = options.semiMajorAxis;\r\n  const rotation = options.rotation;\r\n  const center = options.center;\r\n\r\n  // Computing the arc-length of the ellipse is too expensive to be practical. Estimating it using the\r\n  // arc length of the sphere is too inaccurate and creates sharp edges when either the semi-major or\r\n  // semi-minor axis is much bigger than the other. Instead, scale the angle delta to make\r\n  // the distance along the ellipse boundary more closely match the granularity.\r\n  const granularity = options.granularity * 8.0;\r\n\r\n  const aSqr = semiMinorAxis * semiMinorAxis;\r\n  const bSqr = semiMajorAxis * semiMajorAxis;\r\n  const ab = semiMajorAxis * semiMinorAxis;\r\n\r\n  const mag = Cartesian3.magnitude(center);\r\n\r\n  const unitPos = Cartesian3.normalize(center, unitPosScratch);\r\n  let eastVec = Cartesian3.cross(Cartesian3.UNIT_Z, center, eastVecScratch);\r\n  eastVec = Cartesian3.normalize(eastVec, eastVec);\r\n  const northVec = Cartesian3.cross(unitPos, eastVec, northVecScratch);\r\n\r\n  // The number of points in the first quadrant\r\n  let numPts = 1 + Math.ceil(CesiumMath.PI_OVER_TWO / granularity);\r\n\r\n  const deltaTheta = CesiumMath.PI_OVER_TWO / (numPts - 1);\r\n  let theta = CesiumMath.PI_OVER_TWO - numPts * deltaTheta;\r\n  if (theta < 0.0) {\r\n    numPts -= Math.ceil(Math.abs(theta) / deltaTheta);\r\n  }\r\n\r\n  // If the number of points were three, the ellipse\r\n  // would be tessellated like below:\r\n  //\r\n  //         *---*\r\n  //       / | \\ | \\\r\n  //     *---*---*---*\r\n  //   / | \\ | \\ | \\ | \\\r\n  //  / .*---*---*---*. \\\r\n  // * ` | \\ | \\ | \\ | `*\r\n  //  \\`.*---*---*---*.`/\r\n  //   \\ | \\ | \\ | \\ | /\r\n  //     *---*---*---*\r\n  //       \\ | \\ | /\r\n  //         *---*\r\n  // The first and last column have one position and fan to connect to the adjacent column.\r\n  // Each other vertical column contains an even number of positions.\r\n  const size = 2 * (numPts * (numPts + 2));\r\n  const positions = addFillPositions ? new Array(size * 3) : undefined;\r\n  let positionIndex = 0;\r\n  let position = scratchCartesian1;\r\n  let reflectedPosition = scratchCartesian2;\r\n\r\n  const outerPositionsLength = numPts * 4 * 3;\r\n  let outerRightIndex = outerPositionsLength - 1;\r\n  let outerLeftIndex = 0;\r\n  const outerPositions = addEdgePositions\r\n    ? new Array(outerPositionsLength)\r\n    : undefined;\r\n\r\n  let i;\r\n  let j;\r\n  let numInterior;\r\n  let t;\r\n  let interiorPosition;\r\n\r\n  // Compute points in the 'eastern' half of the ellipse\r\n  theta = CesiumMath.PI_OVER_TWO;\r\n  position = pointOnEllipsoid(\r\n    theta,\r\n    rotation,\r\n    northVec,\r\n    eastVec,\r\n    aSqr,\r\n    ab,\r\n    bSqr,\r\n    mag,\r\n    unitPos,\r\n    position\r\n  );\r\n  if (addFillPositions) {\r\n    positions[positionIndex++] = position.x;\r\n    positions[positionIndex++] = position.y;\r\n    positions[positionIndex++] = position.z;\r\n  }\r\n  if (addEdgePositions) {\r\n    outerPositions[outerRightIndex--] = position.z;\r\n    outerPositions[outerRightIndex--] = position.y;\r\n    outerPositions[outerRightIndex--] = position.x;\r\n  }\r\n  theta = CesiumMath.PI_OVER_TWO - deltaTheta;\r\n  for (i = 1; i < numPts + 1; ++i) {\r\n    position = pointOnEllipsoid(\r\n      theta,\r\n      rotation,\r\n      northVec,\r\n      eastVec,\r\n      aSqr,\r\n      ab,\r\n      bSqr,\r\n      mag,\r\n      unitPos,\r\n      position\r\n    );\r\n    reflectedPosition = pointOnEllipsoid(\r\n      Math.PI - theta,\r\n      rotation,\r\n      northVec,\r\n      eastVec,\r\n      aSqr,\r\n      ab,\r\n      bSqr,\r\n      mag,\r\n      unitPos,\r\n      reflectedPosition\r\n    );\r\n\r\n    if (addFillPositions) {\r\n      positions[positionIndex++] = position.x;\r\n      positions[positionIndex++] = position.y;\r\n      positions[positionIndex++] = position.z;\r\n\r\n      numInterior = 2 * i + 2;\r\n      for (j = 1; j < numInterior - 1; ++j) {\r\n        t = j / (numInterior - 1);\r\n        interiorPosition = Cartesian3.lerp(\r\n          position,\r\n          reflectedPosition,\r\n          t,\r\n          scratchCartesian3\r\n        );\r\n        positions[positionIndex++] = interiorPosition.x;\r\n        positions[positionIndex++] = interiorPosition.y;\r\n        positions[positionIndex++] = interiorPosition.z;\r\n      }\r\n\r\n      positions[positionIndex++] = reflectedPosition.x;\r\n      positions[positionIndex++] = reflectedPosition.y;\r\n      positions[positionIndex++] = reflectedPosition.z;\r\n    }\r\n\r\n    if (addEdgePositions) {\r\n      outerPositions[outerRightIndex--] = position.z;\r\n      outerPositions[outerRightIndex--] = position.y;\r\n      outerPositions[outerRightIndex--] = position.x;\r\n      outerPositions[outerLeftIndex++] = reflectedPosition.x;\r\n      outerPositions[outerLeftIndex++] = reflectedPosition.y;\r\n      outerPositions[outerLeftIndex++] = reflectedPosition.z;\r\n    }\r\n\r\n    theta = CesiumMath.PI_OVER_TWO - (i + 1) * deltaTheta;\r\n  }\r\n\r\n  // Compute points in the 'western' half of the ellipse\r\n  for (i = numPts; i > 1; --i) {\r\n    theta = CesiumMath.PI_OVER_TWO - (i - 1) * deltaTheta;\r\n\r\n    position = pointOnEllipsoid(\r\n      -theta,\r\n      rotation,\r\n      northVec,\r\n      eastVec,\r\n      aSqr,\r\n      ab,\r\n      bSqr,\r\n      mag,\r\n      unitPos,\r\n      position\r\n    );\r\n    reflectedPosition = pointOnEllipsoid(\r\n      theta + Math.PI,\r\n      rotation,\r\n      northVec,\r\n      eastVec,\r\n      aSqr,\r\n      ab,\r\n      bSqr,\r\n      mag,\r\n      unitPos,\r\n      reflectedPosition\r\n    );\r\n\r\n    if (addFillPositions) {\r\n      positions[positionIndex++] = position.x;\r\n      positions[positionIndex++] = position.y;\r\n      positions[positionIndex++] = position.z;\r\n\r\n      numInterior = 2 * (i - 1) + 2;\r\n      for (j = 1; j < numInterior - 1; ++j) {\r\n        t = j / (numInterior - 1);\r\n        interiorPosition = Cartesian3.lerp(\r\n          position,\r\n          reflectedPosition,\r\n          t,\r\n          scratchCartesian3\r\n        );\r\n        positions[positionIndex++] = interiorPosition.x;\r\n        positions[positionIndex++] = interiorPosition.y;\r\n        positions[positionIndex++] = interiorPosition.z;\r\n      }\r\n\r\n      positions[positionIndex++] = reflectedPosition.x;\r\n      positions[positionIndex++] = reflectedPosition.y;\r\n      positions[positionIndex++] = reflectedPosition.z;\r\n    }\r\n\r\n    if (addEdgePositions) {\r\n      outerPositions[outerRightIndex--] = position.z;\r\n      outerPositions[outerRightIndex--] = position.y;\r\n      outerPositions[outerRightIndex--] = position.x;\r\n      outerPositions[outerLeftIndex++] = reflectedPosition.x;\r\n      outerPositions[outerLeftIndex++] = reflectedPosition.y;\r\n      outerPositions[outerLeftIndex++] = reflectedPosition.z;\r\n    }\r\n  }\r\n\r\n  theta = CesiumMath.PI_OVER_TWO;\r\n  position = pointOnEllipsoid(\r\n    -theta,\r\n    rotation,\r\n    northVec,\r\n    eastVec,\r\n    aSqr,\r\n    ab,\r\n    bSqr,\r\n    mag,\r\n    unitPos,\r\n    position\r\n  );\r\n\r\n  const r = {};\r\n  if (addFillPositions) {\r\n    positions[positionIndex++] = position.x;\r\n    positions[positionIndex++] = position.y;\r\n    positions[positionIndex++] = position.z;\r\n    r.positions = positions;\r\n    r.numPts = numPts;\r\n  }\r\n  if (addEdgePositions) {\r\n    outerPositions[outerRightIndex--] = position.z;\r\n    outerPositions[outerRightIndex--] = position.y;\r\n    outerPositions[outerRightIndex--] = position.x;\r\n    r.outerPositions = outerPositions;\r\n  }\r\n\r\n  return r;\r\n};\r\nexport default EllipseGeometryLibrary;\r\n"],"names":["EllipseGeometryLibrary","rotAxis","Cartesian3","tempVec","unitQuat","Quaternion","rotMtx","Matrix3","pointOnEllipsoid","theta","rotation","northVec","eastVec","aSqr","ab","bSqr","mag","unitPos","result","azimuth","multiplyByScalar","Math","cos","sin","add","cosThetaSquared","sinThetaSquared","angle","sqrt","fromAxisAngle","fromQuaternion","multiplyByVector","normalize","scratchCartesian1","scratchCartesian2","scratchCartesian3","scratchNormal","raisePositionsToHeight","positions","options","extrude","ellipsoid","height","extrudedHeight","size","length","finalPositions","Float64Array","bottomOffset","i","i1","i2","position","fromArray","scaleToGeodeticSurface","extrudedPosition","clone","normal","geodeticSurfaceNormal","scaledNormal","x","y","z","unitPosScratch","eastVecScratch","northVecScratch","computeEllipsePositions","addFillPositions","addEdgePositions","semiMinorAxis","semiMajorAxis","center","granularity","magnitude","cross","UNIT_Z","numPts","ceil","CesiumMath","PI_OVER_TWO","deltaTheta","abs","Array","undefined","positionIndex","reflectedPosition","outerPositionsLength","outerRightIndex","outerLeftIndex","outerPositions","j","numInterior","t","interiorPosition","PI","lerp","r"],"mappings":"+HAKM,MAAAA,EAAyB,GAEzBC,EAAU,IAAIC,EAAAA,WACdC,EAAU,IAAID,EAAAA,WACdE,EAAW,IAAIC,EAAAA,WACfC,EAAS,IAAIC,EAAAA,QAEnB,SAASC,EACPC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,GAEA,MAAMC,EAAUV,EAAQC,EAExBR,EAAUA,WAACkB,iBAAiBR,EAASS,KAAKC,IAAIH,GAAUlB,GACxDC,EAAUA,WAACkB,iBAAiBT,EAAUU,KAAKE,IAAIJ,GAAUhB,GACzDD,EAAAA,WAAWsB,IAAIvB,EAASE,EAASF,GAEjC,IAAIwB,EAAkBJ,KAAKC,IAAIb,GAC/BgB,GAAoCA,EAEpC,IAAIC,EAAkBL,KAAKE,IAAId,GAC/BiB,GAAoCA,EAEpC,MAEMC,EADJb,EAAKO,KAAKO,KAAKb,EAAOU,EAAkBZ,EAAOa,GAC1BV,EASvB,OANAX,EAAAA,WAAWwB,cAAc5B,EAAS0B,EAAOvB,GACzCG,EAAAA,QAAQuB,eAAe1B,EAAUE,GAEjCC,EAAAA,QAAQwB,iBAAiBzB,EAAQW,EAASC,GAC1ChB,EAAAA,WAAW8B,UAAUd,EAAQA,GAC7BhB,EAAAA,WAAWkB,iBAAiBF,EAAQF,EAAKE,GAClCA,EAGT,MAAMe,EAAoB,IAAI/B,EAAAA,WACxBgC,EAAoB,IAAIhC,EAAAA,WACxBiC,EAAoB,IAAIjC,EAAAA,WACxBkC,EAAgB,IAAIlC,EAAAA,WAK1BF,EAAuBqC,uBAAyB,SAC9CC,EACAC,EACAC,GAEA,MAAMC,EAAYF,EAAQE,UACpBC,EAASH,EAAQG,OACjBC,EAAiBJ,EAAQI,eACzBC,EAAOJ,EAAWF,EAAUO,OAAS,EAAK,EAAIP,EAAUO,OAAS,EAEjEC,EAAiB,IAAIC,aAAoB,EAAPH,GAElCC,EAASP,EAAUO,OACnBG,EAAeR,EAAUK,EAAS,EACxC,IAAK,IAAII,EAAI,EAAGA,EAAIJ,EAAQI,GAAK,EAAG,CAClC,MAAMC,EAAKD,EAAI,EACTE,EAAKF,EAAI,EAETG,EAAWlD,EAAAA,WAAWmD,UAAUf,EAAWW,EAAGhB,GACpDQ,EAAUa,uBAAuBF,EAAUA,GAE3C,MAAMG,EAAmBrD,EAAUA,WAACsD,MAAMJ,EAAUlB,GAC9CuB,EAAShB,EAAUiB,sBAAsBN,EAAUhB,GACnDuB,EAAezD,EAAAA,WAAWkB,iBAC9BqC,EACAf,EACAP,GAEFjC,EAAAA,WAAWsB,IAAI4B,EAAUO,EAAcP,GAEnCZ,IACFtC,EAAAA,WAAWkB,iBAAiBqC,EAAQd,EAAgBgB,GACpDzD,EAAAA,WAAWsB,IAAI+B,EAAkBI,EAAcJ,GAE/CT,EAAeG,EAAID,GAAgBO,EAAiBK,EACpDd,EAAeI,EAAKF,GAAgBO,EAAiBM,EACrDf,EAAeK,EAAKH,GAAgBO,EAAiBO,GAGvDhB,EAAeG,GAAKG,EAASQ,EAC7Bd,EAAeI,GAAME,EAASS,EAC9Bf,EAAeK,GAAMC,EAASU,EAGhC,OAAOhB,GAGT,MAAMiB,EAAiB,IAAI7D,EAAAA,WACrB8D,EAAiB,IAAI9D,EAAAA,WACrB+D,EAAkB,IAAI/D,EAAAA,WAK5BF,EAAuBkE,wBAA0B,SAC/C3B,EACA4B,EACAC,GAEA,MAAMC,EAAgB9B,EAAQ8B,cACxBC,EAAgB/B,EAAQ+B,cACxB5D,EAAW6B,EAAQ7B,SACnB6D,EAAShC,EAAQgC,OAMjBC,EAAoC,EAAtBjC,EAAQiC,YAEtB3D,EAAOwD,EAAgBA,EACvBtD,EAAOuD,EAAgBA,EACvBxD,EAAKwD,EAAgBD,EAErBrD,EAAMd,EAAAA,WAAWuE,UAAUF,GAE3BtD,EAAUf,EAAUA,WAAC8B,UAAUuC,EAAQR,GAC7C,IAAInD,EAAUV,EAAAA,WAAWwE,MAAMxE,EAAUA,WAACyE,OAAQJ,EAAQP,GAC1DpD,EAAUV,EAAAA,WAAW8B,UAAUpB,EAASA,GACxC,MAAMD,EAAWT,EAAAA,WAAWwE,MAAMzD,EAASL,EAASqD,GAGpD,IAAIW,EAAS,EAAIvD,KAAKwD,KAAKC,aAAWC,YAAcP,GAEpD,MAAMQ,EAAaF,EAAUA,WAACC,aAAeH,EAAS,GACtD,IAAInE,EAAQqE,EAAUA,WAACC,YAAcH,EAASI,EAC1CvE,EAAQ,IACVmE,GAAUvD,KAAKwD,KAAKxD,KAAK4D,IAAIxE,GAASuE,IAmBxC,MACM1C,EAAY6B,EAAmB,IAAIe,MAAa,GADpCN,GAAUA,EAAS,GAAxB,SAC8CO,EAC3D,IAAIC,EAAgB,EAChBhC,EAAWnB,EACXoD,EAAoBnD,EAExB,MAAMoD,EAAgC,EAATV,EAAa,EAC1C,IAAIW,EAAkBD,EAAuB,EACzCE,EAAiB,EACrB,MAAMC,EAAiBrB,EACnB,IAAIc,MAAMI,QACVH,EAEJ,IAAIlC,EACAyC,EACAC,EACAC,EACAC,EA2BJ,IAxBApF,EAAQqE,EAAUA,WAACC,YACnB3B,EAAW5C,EACTC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAmC,GAEEe,IACF7B,EAAU8C,KAAmBhC,EAASQ,EACtCtB,EAAU8C,KAAmBhC,EAASS,EACtCvB,EAAU8C,KAAmBhC,EAASU,GAEpCM,IACFqB,EAAeF,KAAqBnC,EAASU,EAC7C2B,EAAeF,KAAqBnC,EAASS,EAC7C4B,EAAeF,KAAqBnC,EAASQ,GAE/CnD,EAAQqE,EAAAA,WAAWC,YAAcC,EAC5B/B,EAAI,EAAGA,EAAI2B,EAAS,IAAK3B,EAAG,CA0B/B,GAzBAG,EAAW5C,EACTC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAmC,GAEFiC,EAAoB7E,EAClBa,KAAKyE,GAAKrF,EACVC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAoE,GAGElB,EAAkB,CAMpB,IALA7B,EAAU8C,KAAmBhC,EAASQ,EACtCtB,EAAU8C,KAAmBhC,EAASS,EACtCvB,EAAU8C,KAAmBhC,EAASU,EAEtC6B,EAAc,EAAI1C,EAAI,EACjByC,EAAI,EAAGA,EAAIC,EAAc,IAAKD,EACjCE,EAAIF,GAAKC,EAAc,GACvBE,EAAmB3F,EAAUA,WAAC6F,KAC5B3C,EACAiC,EACAO,EACAzD,GAEFG,EAAU8C,KAAmBS,EAAiBjC,EAC9CtB,EAAU8C,KAAmBS,EAAiBhC,EAC9CvB,EAAU8C,KAAmBS,EAAiB/B,EAGhDxB,EAAU8C,KAAmBC,EAAkBzB,EAC/CtB,EAAU8C,KAAmBC,EAAkBxB,EAC/CvB,EAAU8C,KAAmBC,EAAkBvB,EAG7CM,IACFqB,EAAeF,KAAqBnC,EAASU,EAC7C2B,EAAeF,KAAqBnC,EAASS,EAC7C4B,EAAeF,KAAqBnC,EAASQ,EAC7C6B,EAAeD,KAAoBH,EAAkBzB,EACrD6B,EAAeD,KAAoBH,EAAkBxB,EACrD4B,EAAeD,KAAoBH,EAAkBvB,GAGvDrD,EAAQqE,EAAUA,WAACC,aAAe9B,EAAI,GAAK+B,EAI7C,IAAK/B,EAAI2B,EAAQ3B,EAAI,IAAKA,EAAG,CA4B3B,GA3BAxC,EAAQqE,EAAUA,WAACC,aAAe9B,EAAI,GAAK+B,EAE3C5B,EAAW5C,GACRC,EACDC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAmC,GAEFiC,EAAoB7E,EAClBC,EAAQY,KAAKyE,GACbpF,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAoE,GAGElB,EAAkB,CAMpB,IALA7B,EAAU8C,KAAmBhC,EAASQ,EACtCtB,EAAU8C,KAAmBhC,EAASS,EACtCvB,EAAU8C,KAAmBhC,EAASU,EAEtC6B,EAAc,GAAK1C,EAAI,GAAK,EACvByC,EAAI,EAAGA,EAAIC,EAAc,IAAKD,EACjCE,EAAIF,GAAKC,EAAc,GACvBE,EAAmB3F,EAAUA,WAAC6F,KAC5B3C,EACAiC,EACAO,EACAzD,GAEFG,EAAU8C,KAAmBS,EAAiBjC,EAC9CtB,EAAU8C,KAAmBS,EAAiBhC,EAC9CvB,EAAU8C,KAAmBS,EAAiB/B,EAGhDxB,EAAU8C,KAAmBC,EAAkBzB,EAC/CtB,EAAU8C,KAAmBC,EAAkBxB,EAC/CvB,EAAU8C,KAAmBC,EAAkBvB,EAG7CM,IACFqB,EAAeF,KAAqBnC,EAASU,EAC7C2B,EAAeF,KAAqBnC,EAASS,EAC7C4B,EAAeF,KAAqBnC,EAASQ,EAC7C6B,EAAeD,KAAoBH,EAAkBzB,EACrD6B,EAAeD,KAAoBH,EAAkBxB,EACrD4B,EAAeD,KAAoBH,EAAkBvB,GAIzDrD,EAAQqE,EAAUA,WAACC,YACnB3B,EAAW5C,GACRC,EACDC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAmC,GAGF,MAAM4C,EAAI,GAeV,OAdI7B,IACF7B,EAAU8C,KAAmBhC,EAASQ,EACtCtB,EAAU8C,KAAmBhC,EAASS,EACtCvB,EAAU8C,KAAmBhC,EAASU,EACtCkC,EAAE1D,UAAYA,EACd0D,EAAEpB,OAASA,GAETR,IACFqB,EAAeF,KAAqBnC,EAASU,EAC7C2B,EAAeF,KAAqBnC,EAASS,EAC7C4B,EAAeF,KAAqBnC,EAASQ,EAC7CoC,EAAEP,eAAiBA,GAGdO"}