{"version":3,"file":"createRectangleOutlineGeometry.js","sources":["../../../../Source/Core/RectangleOutlineGeometry.js","../../../../Source/WorkersES6/createRectangleOutlineGeometry.js"],"sourcesContent":["import arrayFill from \"./arrayFill.js\";\r\nimport BoundingSphere from \"./BoundingSphere.js\";\r\nimport Cartesian3 from \"./Cartesian3.js\";\r\nimport Cartographic from \"./Cartographic.js\";\r\nimport ComponentDatatype from \"./ComponentDatatype.js\";\r\nimport defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\nimport DeveloperError from \"./DeveloperError.js\";\r\nimport Ellipsoid from \"./Ellipsoid.js\";\r\nimport Geometry from \"./Geometry.js\";\r\nimport GeometryAttribute from \"./GeometryAttribute.js\";\r\nimport GeometryAttributes from \"./GeometryAttributes.js\";\r\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\r\nimport IndexDatatype from \"./IndexDatatype.js\";\r\nimport CesiumMath from \"./Math.js\";\r\nimport PolygonPipeline from \"./PolygonPipeline.js\";\r\nimport PrimitiveType from \"./PrimitiveType.js\";\r\nimport Rectangle from \"./Rectangle.js\";\r\nimport RectangleGeometryLibrary from \"./RectangleGeometryLibrary.js\";\r\n\r\nconst bottomBoundingSphere = new BoundingSphere();\r\nconst topBoundingSphere = new BoundingSphere();\r\nconst positionScratch = new Cartesian3();\r\nconst rectangleScratch = new Rectangle();\r\n\r\nfunction constructRectangle(geometry, computedOptions) {\r\n  const ellipsoid = geometry._ellipsoid;\r\n  const height = computedOptions.height;\r\n  const width = computedOptions.width;\r\n  const northCap = computedOptions.northCap;\r\n  const southCap = computedOptions.southCap;\r\n\r\n  let rowHeight = height;\r\n  let widthMultiplier = 2;\r\n  let size = 0;\r\n  let corners = 4;\r\n  if (northCap) {\r\n    widthMultiplier -= 1;\r\n    rowHeight -= 1;\r\n    size += 1;\r\n    corners -= 2;\r\n  }\r\n  if (southCap) {\r\n    widthMultiplier -= 1;\r\n    rowHeight -= 1;\r\n    size += 1;\r\n    corners -= 2;\r\n  }\r\n  size += widthMultiplier * width + 2 * rowHeight - corners;\r\n\r\n  const positions = new Float64Array(size * 3);\r\n\r\n  let posIndex = 0;\r\n  let row = 0;\r\n  let col;\r\n  const position = positionScratch;\r\n  if (northCap) {\r\n    RectangleGeometryLibrary.computePosition(\r\n      computedOptions,\r\n      ellipsoid,\r\n      false,\r\n      row,\r\n      0,\r\n      position\r\n    );\r\n    positions[posIndex++] = position.x;\r\n    positions[posIndex++] = position.y;\r\n    positions[posIndex++] = position.z;\r\n  } else {\r\n    for (col = 0; col < width; col++) {\r\n      RectangleGeometryLibrary.computePosition(\r\n        computedOptions,\r\n        ellipsoid,\r\n        false,\r\n        row,\r\n        col,\r\n        position\r\n      );\r\n      positions[posIndex++] = position.x;\r\n      positions[posIndex++] = position.y;\r\n      positions[posIndex++] = position.z;\r\n    }\r\n  }\r\n\r\n  col = width - 1;\r\n  for (row = 1; row < height; row++) {\r\n    RectangleGeometryLibrary.computePosition(\r\n      computedOptions,\r\n      ellipsoid,\r\n      false,\r\n      row,\r\n      col,\r\n      position\r\n    );\r\n    positions[posIndex++] = position.x;\r\n    positions[posIndex++] = position.y;\r\n    positions[posIndex++] = position.z;\r\n  }\r\n\r\n  row = height - 1;\r\n  if (!southCap) {\r\n    // if southCap is true, we dont need to add any more points because the south pole point was added by the iteration above\r\n    for (col = width - 2; col >= 0; col--) {\r\n      RectangleGeometryLibrary.computePosition(\r\n        computedOptions,\r\n        ellipsoid,\r\n        false,\r\n        row,\r\n        col,\r\n        position\r\n      );\r\n      positions[posIndex++] = position.x;\r\n      positions[posIndex++] = position.y;\r\n      positions[posIndex++] = position.z;\r\n    }\r\n  }\r\n\r\n  col = 0;\r\n  for (row = height - 2; row > 0; row--) {\r\n    RectangleGeometryLibrary.computePosition(\r\n      computedOptions,\r\n      ellipsoid,\r\n      false,\r\n      row,\r\n      col,\r\n      position\r\n    );\r\n    positions[posIndex++] = position.x;\r\n    positions[posIndex++] = position.y;\r\n    positions[posIndex++] = position.z;\r\n  }\r\n\r\n  const indicesSize = (positions.length / 3) * 2;\r\n  const indices = IndexDatatype.createTypedArray(\r\n    positions.length / 3,\r\n    indicesSize\r\n  );\r\n\r\n  let index = 0;\r\n  for (let i = 0; i < positions.length / 3 - 1; i++) {\r\n    indices[index++] = i;\r\n    indices[index++] = i + 1;\r\n  }\r\n  indices[index++] = positions.length / 3 - 1;\r\n  indices[index++] = 0;\r\n\r\n  const geo = new Geometry({\r\n    attributes: new GeometryAttributes(),\r\n    primitiveType: PrimitiveType.LINES,\r\n  });\r\n\r\n  geo.attributes.position = new GeometryAttribute({\r\n    componentDatatype: ComponentDatatype.DOUBLE,\r\n    componentsPerAttribute: 3,\r\n    values: positions,\r\n  });\r\n  geo.indices = indices;\r\n\r\n  return geo;\r\n}\r\n\r\nfunction constructExtrudedRectangle(rectangleGeometry, computedOptions) {\r\n  const surfaceHeight = rectangleGeometry._surfaceHeight;\r\n  const extrudedHeight = rectangleGeometry._extrudedHeight;\r\n  const ellipsoid = rectangleGeometry._ellipsoid;\r\n  const minHeight = extrudedHeight;\r\n  const maxHeight = surfaceHeight;\r\n  const geo = constructRectangle(rectangleGeometry, computedOptions);\r\n\r\n  const height = computedOptions.height;\r\n  const width = computedOptions.width;\r\n\r\n  const topPositions = PolygonPipeline.scaleToGeodeticHeight(\r\n    geo.attributes.position.values,\r\n    maxHeight,\r\n    ellipsoid,\r\n    false\r\n  );\r\n  let length = topPositions.length;\r\n  const positions = new Float64Array(length * 2);\r\n  positions.set(topPositions);\r\n  const bottomPositions = PolygonPipeline.scaleToGeodeticHeight(\r\n    geo.attributes.position.values,\r\n    minHeight,\r\n    ellipsoid\r\n  );\r\n  positions.set(bottomPositions, length);\r\n  geo.attributes.position.values = positions;\r\n\r\n  const northCap = computedOptions.northCap;\r\n  const southCap = computedOptions.southCap;\r\n  let corners = 4;\r\n  if (northCap) {\r\n    corners -= 1;\r\n  }\r\n  if (southCap) {\r\n    corners -= 1;\r\n  }\r\n\r\n  const indicesSize = (positions.length / 3 + corners) * 2;\r\n  const indices = IndexDatatype.createTypedArray(\r\n    positions.length / 3,\r\n    indicesSize\r\n  );\r\n  length = positions.length / 6;\r\n  let index = 0;\r\n  for (let i = 0; i < length - 1; i++) {\r\n    indices[index++] = i;\r\n    indices[index++] = i + 1;\r\n    indices[index++] = i + length;\r\n    indices[index++] = i + length + 1;\r\n  }\r\n  indices[index++] = length - 1;\r\n  indices[index++] = 0;\r\n  indices[index++] = length + length - 1;\r\n  indices[index++] = length;\r\n\r\n  indices[index++] = 0;\r\n  indices[index++] = length;\r\n\r\n  let bottomCorner;\r\n  if (northCap) {\r\n    bottomCorner = height - 1;\r\n  } else {\r\n    const topRightCorner = width - 1;\r\n    indices[index++] = topRightCorner;\r\n    indices[index++] = topRightCorner + length;\r\n    bottomCorner = width + height - 2;\r\n  }\r\n\r\n  indices[index++] = bottomCorner;\r\n  indices[index++] = bottomCorner + length;\r\n\r\n  if (!southCap) {\r\n    const bottomLeftCorner = width + bottomCorner - 1;\r\n    indices[index++] = bottomLeftCorner;\r\n    indices[index] = bottomLeftCorner + length;\r\n  }\r\n\r\n  geo.indices = indices;\r\n\r\n  return geo;\r\n}\r\n\r\n/**\r\n * A description of the outline of a a cartographic rectangle on an ellipsoid centered at the origin.\r\n *\r\n * @alias RectangleOutlineGeometry\r\n * @constructor\r\n *\r\n * @param {Object} options Object with the following properties:\r\n * @param {Rectangle} options.rectangle A cartographic rectangle with north, south, east and west properties in radians.\r\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the rectangle lies.\r\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\r\n * @param {Number} [options.height=0.0] The distance in meters between the rectangle and the ellipsoid surface.\r\n * @param {Number} [options.rotation=0.0] The rotation of the rectangle, in radians. A positive rotation is counter-clockwise.\r\n * @param {Number} [options.extrudedHeight] The distance in meters between the rectangle's extruded face and the ellipsoid surface.\r\n *\r\n * @exception {DeveloperError} <code>options.rectangle.north</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\r\n * @exception {DeveloperError} <code>options.rectangle.south</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\r\n * @exception {DeveloperError} <code>options.rectangle.east</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\r\n * @exception {DeveloperError} <code>options.rectangle.west</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\r\n * @exception {DeveloperError} <code>options.rectangle.north</code> must be greater than <code>rectangle.south</code>.\r\n *\r\n * @see RectangleOutlineGeometry#createGeometry\r\n *\r\n * @example\r\n * const rectangle = new Cesium.RectangleOutlineGeometry({\r\n *   ellipsoid : Cesium.Ellipsoid.WGS84,\r\n *   rectangle : Cesium.Rectangle.fromDegrees(-80.0, 39.0, -74.0, 42.0),\r\n *   height : 10000.0\r\n * });\r\n * const geometry = Cesium.RectangleOutlineGeometry.createGeometry(rectangle);\r\n */\r\nfunction RectangleOutlineGeometry(options) {\r\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n\r\n  const rectangle = options.rectangle;\r\n  const granularity = defaultValue(\r\n    options.granularity,\r\n    CesiumMath.RADIANS_PER_DEGREE\r\n  );\r\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\r\n  const rotation = defaultValue(options.rotation, 0.0);\r\n\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(rectangle)) {\r\n    throw new DeveloperError(\"rectangle is required.\");\r\n  }\r\n  Rectangle.validate(rectangle);\r\n  if (rectangle.north < rectangle.south) {\r\n    throw new DeveloperError(\r\n      \"options.rectangle.north must be greater than options.rectangle.south\"\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const height = defaultValue(options.height, 0.0);\r\n  const extrudedHeight = defaultValue(options.extrudedHeight, height);\r\n\r\n  this._rectangle = Rectangle.clone(rectangle);\r\n  this._granularity = granularity;\r\n  this._ellipsoid = ellipsoid;\r\n  this._surfaceHeight = Math.max(height, extrudedHeight);\r\n  this._rotation = rotation;\r\n  this._extrudedHeight = Math.min(height, extrudedHeight);\r\n  this._offsetAttribute = options.offsetAttribute;\r\n  this._workerName = \"createRectangleOutlineGeometry\";\r\n}\r\n\r\n/**\r\n * The number of elements used to pack the object into an array.\r\n * @type {Number}\r\n */\r\nRectangleOutlineGeometry.packedLength =\r\n  Rectangle.packedLength + Ellipsoid.packedLength + 5;\r\n\r\n/**\r\n * Stores the provided instance into the provided array.\r\n *\r\n * @param {RectangleOutlineGeometry} value The value to pack.\r\n * @param {Number[]} array The array to pack into.\r\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n *\r\n * @returns {Number[]} The array that was packed into\r\n */\r\nRectangleOutlineGeometry.pack = function (value, array, startingIndex) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(value)) {\r\n    throw new DeveloperError(\"value is required\");\r\n  }\r\n\r\n  if (!defined(array)) {\r\n    throw new DeveloperError(\"array is required\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  Rectangle.pack(value._rectangle, array, startingIndex);\r\n  startingIndex += Rectangle.packedLength;\r\n\r\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\r\n  startingIndex += Ellipsoid.packedLength;\r\n\r\n  array[startingIndex++] = value._granularity;\r\n  array[startingIndex++] = value._surfaceHeight;\r\n  array[startingIndex++] = value._rotation;\r\n  array[startingIndex++] = value._extrudedHeight;\r\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\r\n\r\n  return array;\r\n};\r\n\r\nconst scratchRectangle = new Rectangle();\r\nconst scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\r\nconst scratchOptions = {\r\n  rectangle: scratchRectangle,\r\n  ellipsoid: scratchEllipsoid,\r\n  granularity: undefined,\r\n  height: undefined,\r\n  rotation: undefined,\r\n  extrudedHeight: undefined,\r\n  offsetAttribute: undefined,\r\n};\r\n\r\n/**\r\n * Retrieves an instance from a packed array.\r\n *\r\n * @param {Number[]} array The packed array.\r\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n * @param {RectangleOutlineGeometry} [result] The object into which to store the result.\r\n * @returns {RectangleOutlineGeometry} The modified result parameter or a new Quaternion instance if one was not provided.\r\n */\r\nRectangleOutlineGeometry.unpack = function (array, startingIndex, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(array)) {\r\n    throw new DeveloperError(\"array is required\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  const rectangle = Rectangle.unpack(array, startingIndex, scratchRectangle);\r\n  startingIndex += Rectangle.packedLength;\r\n\r\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\r\n  startingIndex += Ellipsoid.packedLength;\r\n\r\n  const granularity = array[startingIndex++];\r\n  const height = array[startingIndex++];\r\n  const rotation = array[startingIndex++];\r\n  const extrudedHeight = array[startingIndex++];\r\n  const offsetAttribute = array[startingIndex];\r\n\r\n  if (!defined(result)) {\r\n    scratchOptions.granularity = granularity;\r\n    scratchOptions.height = height;\r\n    scratchOptions.rotation = rotation;\r\n    scratchOptions.extrudedHeight = extrudedHeight;\r\n    scratchOptions.offsetAttribute =\r\n      offsetAttribute === -1 ? undefined : offsetAttribute;\r\n\r\n    return new RectangleOutlineGeometry(scratchOptions);\r\n  }\r\n\r\n  result._rectangle = Rectangle.clone(rectangle, result._rectangle);\r\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\r\n  result._surfaceHeight = height;\r\n  result._rotation = rotation;\r\n  result._extrudedHeight = extrudedHeight;\r\n  result._offsetAttribute =\r\n    offsetAttribute === -1 ? undefined : offsetAttribute;\r\n\r\n  return result;\r\n};\r\n\r\nconst nwScratch = new Cartographic();\r\n/**\r\n * Computes the geometric representation of an outline of a rectangle, including its vertices, indices, and a bounding sphere.\r\n *\r\n * @param {RectangleOutlineGeometry} rectangleGeometry A description of the rectangle outline.\r\n * @returns {Geometry|undefined} The computed vertices and indices.\r\n *\r\n * @exception {DeveloperError} Rotated rectangle is invalid.\r\n */\r\nRectangleOutlineGeometry.createGeometry = function (rectangleGeometry) {\r\n  const rectangle = rectangleGeometry._rectangle;\r\n  const ellipsoid = rectangleGeometry._ellipsoid;\r\n  const computedOptions = RectangleGeometryLibrary.computeOptions(\r\n    rectangle,\r\n    rectangleGeometry._granularity,\r\n    rectangleGeometry._rotation,\r\n    0,\r\n    rectangleScratch,\r\n    nwScratch\r\n  );\r\n\r\n  let geometry;\r\n  let boundingSphere;\r\n\r\n  if (\r\n    CesiumMath.equalsEpsilon(\r\n      rectangle.north,\r\n      rectangle.south,\r\n      CesiumMath.EPSILON10\r\n    ) ||\r\n    CesiumMath.equalsEpsilon(\r\n      rectangle.east,\r\n      rectangle.west,\r\n      CesiumMath.EPSILON10\r\n    )\r\n  ) {\r\n    return undefined;\r\n  }\r\n\r\n  const surfaceHeight = rectangleGeometry._surfaceHeight;\r\n  const extrudedHeight = rectangleGeometry._extrudedHeight;\r\n  const extrude = !CesiumMath.equalsEpsilon(\r\n    surfaceHeight,\r\n    extrudedHeight,\r\n    0,\r\n    CesiumMath.EPSILON2\r\n  );\r\n  let offsetValue;\r\n  if (extrude) {\r\n    geometry = constructExtrudedRectangle(rectangleGeometry, computedOptions);\r\n    if (defined(rectangleGeometry._offsetAttribute)) {\r\n      const size = geometry.attributes.position.values.length / 3;\r\n      let offsetAttribute = new Uint8Array(size);\r\n      if (rectangleGeometry._offsetAttribute === GeometryOffsetAttribute.TOP) {\r\n        offsetAttribute = arrayFill(offsetAttribute, 1, 0, size / 2);\r\n      } else {\r\n        offsetValue =\r\n          rectangleGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\r\n            ? 0\r\n            : 1;\r\n        offsetAttribute = arrayFill(offsetAttribute, offsetValue);\r\n      }\r\n\r\n      geometry.attributes.applyOffset = new GeometryAttribute({\r\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\r\n        componentsPerAttribute: 1,\r\n        values: offsetAttribute,\r\n      });\r\n    }\r\n    const topBS = BoundingSphere.fromRectangle3D(\r\n      rectangle,\r\n      ellipsoid,\r\n      surfaceHeight,\r\n      topBoundingSphere\r\n    );\r\n    const bottomBS = BoundingSphere.fromRectangle3D(\r\n      rectangle,\r\n      ellipsoid,\r\n      extrudedHeight,\r\n      bottomBoundingSphere\r\n    );\r\n    boundingSphere = BoundingSphere.union(topBS, bottomBS);\r\n  } else {\r\n    geometry = constructRectangle(rectangleGeometry, computedOptions);\r\n    geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(\r\n      geometry.attributes.position.values,\r\n      surfaceHeight,\r\n      ellipsoid,\r\n      false\r\n    );\r\n\r\n    if (defined(rectangleGeometry._offsetAttribute)) {\r\n      const length = geometry.attributes.position.values.length;\r\n      const applyOffset = new Uint8Array(length / 3);\r\n      offsetValue =\r\n        rectangleGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\r\n          ? 0\r\n          : 1;\r\n      arrayFill(applyOffset, offsetValue);\r\n      geometry.attributes.applyOffset = new GeometryAttribute({\r\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\r\n        componentsPerAttribute: 1,\r\n        values: applyOffset,\r\n      });\r\n    }\r\n\r\n    boundingSphere = BoundingSphere.fromRectangle3D(\r\n      rectangle,\r\n      ellipsoid,\r\n      surfaceHeight\r\n    );\r\n  }\r\n\r\n  return new Geometry({\r\n    attributes: geometry.attributes,\r\n    indices: geometry.indices,\r\n    primitiveType: PrimitiveType.LINES,\r\n    boundingSphere: boundingSphere,\r\n    offsetAttribute: rectangleGeometry._offsetAttribute,\r\n  });\r\n};\r\nexport default RectangleOutlineGeometry;\r\n","import defined from \"../Core/defined.js\";\r\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\r\nimport Rectangle from \"../Core/Rectangle.js\";\r\nimport RectangleOutlineGeometry from \"../Core/RectangleOutlineGeometry.js\";\r\n\r\nfunction createRectangleOutlineGeometry(rectangleGeometry, offset) {\r\n  if (defined(offset)) {\r\n    rectangleGeometry = RectangleOutlineGeometry.unpack(\r\n      rectangleGeometry,\r\n      offset\r\n    );\r\n  }\r\n  rectangleGeometry._ellipsoid = Ellipsoid.clone(rectangleGeometry._ellipsoid);\r\n  rectangleGeometry._rectangle = Rectangle.clone(rectangleGeometry._rectangle);\r\n  return RectangleOutlineGeometry.createGeometry(rectangleGeometry);\r\n}\r\nexport default createRectangleOutlineGeometry;\r\n"],"names":["bottomBoundingSphere","BoundingSphere","topBoundingSphere","positionScratch","Cartesian3","rectangleScratch","Rectangle","constructRectangle","geometry","computedOptions","ellipsoid","_ellipsoid","height","width","northCap","southCap","rowHeight","widthMultiplier","size","corners","positions","Float64Array","col","posIndex","row","position","RectangleGeometryLibrary","computePosition","x","y","z","indicesSize","length","indices","IndexDatatype","createTypedArray","index","i","geo","Geometry","attributes","GeometryAttributes","primitiveType","PrimitiveType","LINES","GeometryAttribute","componentDatatype","ComponentDatatype","DOUBLE","componentsPerAttribute","values","RectangleOutlineGeometry","options","rectangle","defaultValue","EMPTY_OBJECT","granularity","CesiumMath","RADIANS_PER_DEGREE","Ellipsoid","WGS84","rotation","defined","DeveloperError","validate","north","south","extrudedHeight","this","_rectangle","clone","_granularity","_surfaceHeight","Math","max","_rotation","_extrudedHeight","min","_offsetAttribute","offsetAttribute","_workerName","packedLength","pack","value","array","startingIndex","scratchRectangle","scratchEllipsoid","UNIT_SPHERE","scratchOptions","undefined","unpack","result","nwScratch","Cartographic","createGeometry","rectangleGeometry","computeOptions","boundingSphere","equalsEpsilon","EPSILON10","east","west","surfaceHeight","offsetValue","EPSILON2","minHeight","maxHeight","topPositions","PolygonPipeline","scaleToGeodeticHeight","set","bottomPositions","bottomCorner","topRightCorner","bottomLeftCorner","constructExtrudedRectangle","Uint8Array","GeometryOffsetAttribute","TOP","arrayFill","NONE","applyOffset","UNSIGNED_BYTE","topBS","fromRectangle3D","bottomBS","union","offset"],"mappings":"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"}