{"version":3,"file":"EncodedCartesian3-928e138a.js","sources":["../../../../Source/Core/EncodedCartesian3.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\r\nimport Check from \"./Check.js\";\r\nimport defined from \"./defined.js\";\r\n\r\n/**\r\n * A fixed-point encoding of a {@link Cartesian3} with 64-bit floating-point components, as two {@link Cartesian3}\r\n * values that, when converted to 32-bit floating-point and added, approximate the original input.\r\n * <p>\r\n * This is used to encode positions in vertex buffers for rendering without jittering artifacts\r\n * as described in {@link http://help.agi.com/AGIComponents/html/BlogPrecisionsPrecisions.htm|Precisions, Precisions}.\r\n * </p>\r\n *\r\n * @alias EncodedCartesian3\r\n * @constructor\r\n *\r\n * @private\r\n */\r\nfunction EncodedCartesian3() {\r\n  /**\r\n   * The high bits for each component.  Bits 0 to 22 store the whole value.  Bits 23 to 31 are not used.\r\n   *\r\n   * @type {Cartesian3}\r\n   * @default {@link Cartesian3.ZERO}\r\n   */\r\n  this.high = Cartesian3.clone(Cartesian3.ZERO);\r\n\r\n  /**\r\n   * The low bits for each component.  Bits 7 to 22 store the whole value, and bits 0 to 6 store the fraction.  Bits 23 to 31 are not used.\r\n   *\r\n   * @type {Cartesian3}\r\n   * @default {@link Cartesian3.ZERO}\r\n   */\r\n  this.low = Cartesian3.clone(Cartesian3.ZERO);\r\n}\r\n\r\n/**\r\n * Encodes a 64-bit floating-point value as two floating-point values that, when converted to\r\n * 32-bit floating-point and added, approximate the original input.  The returned object\r\n * has <code>high</code> and <code>low</code> properties for the high and low bits, respectively.\r\n * <p>\r\n * The fixed-point encoding follows {@link http://help.agi.com/AGIComponents/html/BlogPrecisionsPrecisions.htm|Precisions, Precisions}.\r\n * </p>\r\n *\r\n * @param {Number} value The floating-point value to encode.\r\n * @param {Object} [result] The object onto which to store the result.\r\n * @returns {Object} The modified result parameter or a new instance if one was not provided.\r\n *\r\n * @example\r\n * const value = 1234567.1234567;\r\n * const splitValue = Cesium.EncodedCartesian3.encode(value);\r\n */\r\nEncodedCartesian3.encode = function (value, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.number(\"value\", value);\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    result = {\r\n      high: 0.0,\r\n      low: 0.0,\r\n    };\r\n  }\r\n\r\n  let doubleHigh;\r\n  if (value >= 0.0) {\r\n    doubleHigh = Math.floor(value / 65536.0) * 65536.0;\r\n    result.high = doubleHigh;\r\n    result.low = value - doubleHigh;\r\n  } else {\r\n    doubleHigh = Math.floor(-value / 65536.0) * 65536.0;\r\n    result.high = -doubleHigh;\r\n    result.low = value + doubleHigh;\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\nconst scratchEncode = {\r\n  high: 0.0,\r\n  low: 0.0,\r\n};\r\n\r\n/**\r\n * Encodes a {@link Cartesian3} with 64-bit floating-point components as two {@link Cartesian3}\r\n * values that, when converted to 32-bit floating-point and added, approximate the original input.\r\n * <p>\r\n * The fixed-point encoding follows {@link https://help.agi.com/AGIComponents/html/BlogPrecisionsPrecisions.htm|Precisions, Precisions}.\r\n * </p>\r\n *\r\n * @param {Cartesian3} cartesian The cartesian to encode.\r\n * @param {EncodedCartesian3} [result] The object onto which to store the result.\r\n * @returns {EncodedCartesian3} The modified result parameter or a new EncodedCartesian3 instance if one was not provided.\r\n *\r\n * @example\r\n * const cart = new Cesium.Cartesian3(-10000000.0, 0.0, 10000000.0);\r\n * const encoded = Cesium.EncodedCartesian3.fromCartesian(cart);\r\n */\r\nEncodedCartesian3.fromCartesian = function (cartesian, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"cartesian\", cartesian);\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    result = new EncodedCartesian3();\r\n  }\r\n\r\n  const high = result.high;\r\n  const low = result.low;\r\n\r\n  EncodedCartesian3.encode(cartesian.x, scratchEncode);\r\n  high.x = scratchEncode.high;\r\n  low.x = scratchEncode.low;\r\n\r\n  EncodedCartesian3.encode(cartesian.y, scratchEncode);\r\n  high.y = scratchEncode.high;\r\n  low.y = scratchEncode.low;\r\n\r\n  EncodedCartesian3.encode(cartesian.z, scratchEncode);\r\n  high.z = scratchEncode.high;\r\n  low.z = scratchEncode.low;\r\n\r\n  return result;\r\n};\r\n\r\nconst encodedP = new EncodedCartesian3();\r\n\r\n/**\r\n * Encodes the provided <code>cartesian</code>, and writes it to an array with <code>high</code>\r\n * components followed by <code>low</code> components, i.e. <code>[high.x, high.y, high.z, low.x, low.y, low.z]</code>.\r\n * <p>\r\n * This is used to create interleaved high-precision position vertex attributes.\r\n * </p>\r\n *\r\n * @param {Cartesian3} cartesian The cartesian to encode.\r\n * @param {Number[]} cartesianArray The array to write to.\r\n * @param {Number} index The index into the array to start writing.  Six elements will be written.\r\n *\r\n * @exception {DeveloperError} index must be a number greater than or equal to 0.\r\n *\r\n * @example\r\n * const positions = [\r\n *    new Cesium.Cartesian3(),\r\n *    // ...\r\n * ];\r\n * const encodedPositions = new Float32Array(2 * 3 * positions.length);\r\n * let j = 0;\r\n * for (let i = 0; i < positions.length; ++i) {\r\n *   Cesium.EncodedCartesian3.writeElement(positions[i], encodedPositions, j);\r\n *   j += 6;\r\n * }\r\n */\r\nEncodedCartesian3.writeElements = function (cartesian, cartesianArray, index) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"cartesianArray\", cartesianArray);\r\n  Check.typeOf.number(\"index\", index);\r\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\r\n  //>>includeEnd('debug');\r\n\r\n  EncodedCartesian3.fromCartesian(cartesian, encodedP);\r\n  const high = encodedP.high;\r\n  const low = encodedP.low;\r\n\r\n  cartesianArray[index] = high.x;\r\n  cartesianArray[index + 1] = high.y;\r\n  cartesianArray[index + 2] = high.z;\r\n  cartesianArray[index + 3] = low.x;\r\n  cartesianArray[index + 4] = low.y;\r\n  cartesianArray[index + 5] = low.z;\r\n};\r\nexport default EncodedCartesian3;\r\n"],"names":["EncodedCartesian3","this","high","Cartesian3","clone","ZERO","low","encode","value","result","doubleHigh","Check","typeOf","number","defined","Math","floor","scratchEncode","fromCartesian","cartesian","object","x","y","z","encodedP","writeElements","cartesianArray","index","greaterThanOrEquals"],"mappings":"4HAiBA,SAASA,IAOPC,KAAKC,KAAOC,EAAUA,WAACC,MAAMD,EAAUA,WAACE,MAQxCJ,KAAKK,IAAMH,EAAUA,WAACC,MAAMD,EAAUA,WAACE,MAmBzCL,EAAkBO,OAAS,SAAUC,EAAOC,GAY1C,IAAIC,EAWJ,OArBAC,EAAAA,MAAMC,OAAOC,OAAO,QAASL,GAGxBM,EAAAA,QAAQL,KACXA,EAAS,CACPP,KAAM,EACNI,IAAK,IAKLE,GAAS,GACXE,EAA2C,MAA9BK,KAAKC,MAAMR,EAAQ,OAChCC,EAAOP,KAAOQ,EACdD,EAAOH,IAAME,EAAQE,IAErBA,EAA4C,MAA/BK,KAAKC,OAAOR,EAAQ,OACjCC,EAAOP,MAAQQ,EACfD,EAAOH,IAAME,EAAQE,GAGhBD,GAGT,MAAMQ,EAAgB,CACpBf,KAAM,EACNI,IAAK,GAkBPN,EAAkBkB,cAAgB,SAAUC,EAAWV,GAErDE,EAAAA,MAAMC,OAAOQ,OAAO,YAAaD,GAG5BL,EAAAA,QAAQL,KACXA,EAAS,IAAIT,GAGf,MAAME,EAAOO,EAAOP,KACdI,EAAMG,EAAOH,IAcnB,OAZAN,EAAkBO,OAAOY,EAAUE,EAAGJ,GACtCf,EAAKmB,EAAIJ,EAAcf,KACvBI,EAAIe,EAAIJ,EAAcX,IAEtBN,EAAkBO,OAAOY,EAAUG,EAAGL,GACtCf,EAAKoB,EAAIL,EAAcf,KACvBI,EAAIgB,EAAIL,EAAcX,IAEtBN,EAAkBO,OAAOY,EAAUI,EAAGN,GACtCf,EAAKqB,EAAIN,EAAcf,KACvBI,EAAIiB,EAAIN,EAAcX,IAEfG,GAGT,MAAMe,EAAW,IAAIxB,EA2BrBA,EAAkByB,cAAgB,SAAUN,EAAWO,EAAgBC,GAErEhB,EAAAA,MAAMG,QAAQ,iBAAkBY,GAChCf,EAAAA,MAAMC,OAAOC,OAAO,QAASc,GAC7BhB,EAAKA,MAACC,OAAOC,OAAOe,oBAAoB,QAASD,EAAO,GAGxD3B,EAAkBkB,cAAcC,EAAWK,GAC3C,MAAMtB,EAAOsB,EAAStB,KAChBI,EAAMkB,EAASlB,IAErBoB,EAAeC,GAASzB,EAAKmB,EAC7BK,EAAeC,EAAQ,GAAKzB,EAAKoB,EACjCI,EAAeC,EAAQ,GAAKzB,EAAKqB,EACjCG,EAAeC,EAAQ,GAAKrB,EAAIe,EAChCK,EAAeC,EAAQ,GAAKrB,EAAIgB,EAChCI,EAAeC,EAAQ,GAAKrB,EAAIiB"}