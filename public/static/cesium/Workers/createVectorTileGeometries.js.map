{"version":3,"file":"createVectorTileGeometries.js","sources":["../../../../Source/Scene/Vector3DTileBatch.js","../../../../Source/WorkersES6/createVectorTileGeometries.js"],"sourcesContent":["/**\r\n * Describes a renderable batch of geometry.\r\n *\r\n * @alias Vector3DTileBatch\r\n * @constructor\r\n *\r\n * @param {Object} options An object with the following properties:\r\n * @param {Number} options.offset The offset of the batch into the indices buffer.\r\n * @param {Number} options.count The number of indices in the batch.\r\n * @param {Color} options.color The color of the geometry in the batch.\r\n * @param {Number[]} options.batchIds An array where each element is the batch id of the geometry in the batch.\r\n *\r\n * @private\r\n */\r\nfunction Vector3DTileBatch(options) {\r\n  /**\r\n   * The offset of the batch into the indices buffer.\r\n   * @type {Number}\r\n   */\r\n  this.offset = options.offset;\r\n  /**\r\n   * The number of indices in the batch.\r\n   * @type {Number}\r\n   */\r\n  this.count = options.count;\r\n  /**\r\n   * The color of the geometry in the batch.\r\n   * @type {Color}\r\n   */\r\n  this.color = options.color;\r\n  /**\r\n   * An array where each element is the batch id of the geometry in the batch.\r\n   * @type {Number[]}\r\n   */\r\n  this.batchIds = options.batchIds;\r\n}\r\nexport default Vector3DTileBatch;\r\n","import BoundingSphere from \"../Core/BoundingSphere.js\";\r\nimport BoxGeometry from \"../Core/BoxGeometry.js\";\r\nimport Cartesian3 from \"../Core/Cartesian3.js\";\r\nimport Color from \"../Core/Color.js\";\r\nimport CylinderGeometry from \"../Core/CylinderGeometry.js\";\r\nimport defined from \"../Core/defined.js\";\r\nimport EllipsoidGeometry from \"../Core/EllipsoidGeometry.js\";\r\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\r\nimport Matrix4 from \"../Core/Matrix4.js\";\r\nimport Vector3DTileBatch from \"../Scene/Vector3DTileBatch.js\";\r\nimport createTaskProcessorWorker from \"./createTaskProcessorWorker.js\";\r\n\r\nconst scratchCartesian = new Cartesian3();\r\n\r\nconst packedBoxLength = Matrix4.packedLength + Cartesian3.packedLength;\r\nconst packedCylinderLength = Matrix4.packedLength + 2;\r\nconst packedEllipsoidLength = Matrix4.packedLength + Cartesian3.packedLength;\r\nconst packedSphereLength = Cartesian3.packedLength + 1;\r\n\r\nconst scratchModelMatrixAndBV = {\r\n  modelMatrix: new Matrix4(),\r\n  boundingVolume: new BoundingSphere(),\r\n};\r\n\r\nfunction boxModelMatrixAndBoundingVolume(boxes, index) {\r\n  let boxIndex = index * packedBoxLength;\r\n\r\n  const dimensions = Cartesian3.unpack(boxes, boxIndex, scratchCartesian);\r\n  boxIndex += Cartesian3.packedLength;\r\n\r\n  const boxModelMatrix = Matrix4.unpack(\r\n    boxes,\r\n    boxIndex,\r\n    scratchModelMatrixAndBV.modelMatrix\r\n  );\r\n  Matrix4.multiplyByScale(boxModelMatrix, dimensions, boxModelMatrix);\r\n\r\n  const boundingVolume = scratchModelMatrixAndBV.boundingVolume;\r\n  Cartesian3.clone(Cartesian3.ZERO, boundingVolume.center);\r\n  boundingVolume.radius = Math.sqrt(3.0);\r\n\r\n  return scratchModelMatrixAndBV;\r\n}\r\n\r\nfunction cylinderModelMatrixAndBoundingVolume(cylinders, index) {\r\n  let cylinderIndex = index * packedCylinderLength;\r\n\r\n  const cylinderRadius = cylinders[cylinderIndex++];\r\n  const length = cylinders[cylinderIndex++];\r\n  const scale = Cartesian3.fromElements(\r\n    cylinderRadius,\r\n    cylinderRadius,\r\n    length,\r\n    scratchCartesian\r\n  );\r\n\r\n  const cylinderModelMatrix = Matrix4.unpack(\r\n    cylinders,\r\n    cylinderIndex,\r\n    scratchModelMatrixAndBV.modelMatrix\r\n  );\r\n  Matrix4.multiplyByScale(cylinderModelMatrix, scale, cylinderModelMatrix);\r\n\r\n  const boundingVolume = scratchModelMatrixAndBV.boundingVolume;\r\n  Cartesian3.clone(Cartesian3.ZERO, boundingVolume.center);\r\n  boundingVolume.radius = Math.sqrt(2.0);\r\n\r\n  return scratchModelMatrixAndBV;\r\n}\r\n\r\nfunction ellipsoidModelMatrixAndBoundingVolume(ellipsoids, index) {\r\n  let ellipsoidIndex = index * packedEllipsoidLength;\r\n\r\n  const radii = Cartesian3.unpack(ellipsoids, ellipsoidIndex, scratchCartesian);\r\n  ellipsoidIndex += Cartesian3.packedLength;\r\n\r\n  const ellipsoidModelMatrix = Matrix4.unpack(\r\n    ellipsoids,\r\n    ellipsoidIndex,\r\n    scratchModelMatrixAndBV.modelMatrix\r\n  );\r\n  Matrix4.multiplyByScale(ellipsoidModelMatrix, radii, ellipsoidModelMatrix);\r\n\r\n  const boundingVolume = scratchModelMatrixAndBV.boundingVolume;\r\n  Cartesian3.clone(Cartesian3.ZERO, boundingVolume.center);\r\n  boundingVolume.radius = 1.0;\r\n\r\n  return scratchModelMatrixAndBV;\r\n}\r\n\r\nfunction sphereModelMatrixAndBoundingVolume(spheres, index) {\r\n  let sphereIndex = index * packedSphereLength;\r\n\r\n  const sphereRadius = spheres[sphereIndex++];\r\n\r\n  const sphereTranslation = Cartesian3.unpack(\r\n    spheres,\r\n    sphereIndex,\r\n    scratchCartesian\r\n  );\r\n  const sphereModelMatrix = Matrix4.fromTranslation(\r\n    sphereTranslation,\r\n    scratchModelMatrixAndBV.modelMatrix\r\n  );\r\n  Matrix4.multiplyByUniformScale(\r\n    sphereModelMatrix,\r\n    sphereRadius,\r\n    sphereModelMatrix\r\n  );\r\n\r\n  const boundingVolume = scratchModelMatrixAndBV.boundingVolume;\r\n  Cartesian3.clone(Cartesian3.ZERO, boundingVolume.center);\r\n  boundingVolume.radius = 1.0;\r\n\r\n  return scratchModelMatrixAndBV;\r\n}\r\n\r\nconst scratchPosition = new Cartesian3();\r\n\r\nfunction createPrimitive(\r\n  options,\r\n  primitive,\r\n  primitiveBatchIds,\r\n  geometry,\r\n  getModelMatrixAndBoundingVolume\r\n) {\r\n  if (!defined(primitive)) {\r\n    return;\r\n  }\r\n\r\n  const numberOfPrimitives = primitiveBatchIds.length;\r\n  const geometryPositions = geometry.attributes.position.values;\r\n  const geometryIndices = geometry.indices;\r\n\r\n  const positions = options.positions;\r\n  const vertexBatchIds = options.vertexBatchIds;\r\n  const indices = options.indices;\r\n\r\n  const batchIds = options.batchIds;\r\n  const batchTableColors = options.batchTableColors;\r\n  const batchedIndices = options.batchedIndices;\r\n  const indexOffsets = options.indexOffsets;\r\n  const indexCounts = options.indexCounts;\r\n  const boundingVolumes = options.boundingVolumes;\r\n\r\n  const modelMatrix = options.modelMatrix;\r\n  const center = options.center;\r\n\r\n  let positionOffset = options.positionOffset;\r\n  let batchIdIndex = options.batchIdIndex;\r\n  let indexOffset = options.indexOffset;\r\n  const batchedIndicesOffset = options.batchedIndicesOffset;\r\n\r\n  for (let i = 0; i < numberOfPrimitives; ++i) {\r\n    const primitiveModelMatrixAndBV = getModelMatrixAndBoundingVolume(\r\n      primitive,\r\n      i\r\n    );\r\n    const primitiveModelMatrix = primitiveModelMatrixAndBV.modelMatrix;\r\n    Matrix4.multiply(modelMatrix, primitiveModelMatrix, primitiveModelMatrix);\r\n\r\n    const batchId = primitiveBatchIds[i];\r\n\r\n    const positionsLength = geometryPositions.length;\r\n    for (let j = 0; j < positionsLength; j += 3) {\r\n      const position = Cartesian3.unpack(geometryPositions, j, scratchPosition);\r\n      Matrix4.multiplyByPoint(primitiveModelMatrix, position, position);\r\n      Cartesian3.subtract(position, center, position);\r\n\r\n      Cartesian3.pack(position, positions, positionOffset * 3 + j);\r\n      vertexBatchIds[batchIdIndex++] = batchId;\r\n    }\r\n\r\n    const indicesLength = geometryIndices.length;\r\n    for (let k = 0; k < indicesLength; ++k) {\r\n      indices[indexOffset + k] = geometryIndices[k] + positionOffset;\r\n    }\r\n\r\n    const offset = i + batchedIndicesOffset;\r\n    batchedIndices[offset] = new Vector3DTileBatch({\r\n      offset: indexOffset,\r\n      count: indicesLength,\r\n      color: Color.fromRgba(batchTableColors[batchId]),\r\n      batchIds: [batchId],\r\n    });\r\n    batchIds[offset] = batchId;\r\n    indexOffsets[offset] = indexOffset;\r\n    indexCounts[offset] = indicesLength;\r\n    boundingVolumes[offset] = BoundingSphere.transform(\r\n      primitiveModelMatrixAndBV.boundingVolume,\r\n      primitiveModelMatrix\r\n    );\r\n\r\n    positionOffset += positionsLength / 3;\r\n    indexOffset += indicesLength;\r\n  }\r\n\r\n  options.positionOffset = positionOffset;\r\n  options.batchIdIndex = batchIdIndex;\r\n  options.indexOffset = indexOffset;\r\n  options.batchedIndicesOffset += numberOfPrimitives;\r\n}\r\n\r\nconst scratchCenter = new Cartesian3();\r\nconst scratchMatrix4 = new Matrix4();\r\n\r\nfunction unpackBuffer(buffer) {\r\n  const packedBuffer = new Float64Array(buffer);\r\n\r\n  let offset = 0;\r\n  Cartesian3.unpack(packedBuffer, offset, scratchCenter);\r\n  offset += Cartesian3.packedLength;\r\n\r\n  Matrix4.unpack(packedBuffer, offset, scratchMatrix4);\r\n}\r\n\r\nfunction packedBatchedIndicesLength(batchedIndices) {\r\n  const length = batchedIndices.length;\r\n  let count = 0;\r\n  for (let i = 0; i < length; ++i) {\r\n    count += Color.packedLength + 3 + batchedIndices[i].batchIds.length;\r\n  }\r\n  return count;\r\n}\r\n\r\nfunction packBuffer(indicesBytesPerElement, batchedIndices, boundingVolumes) {\r\n  const numBVs = boundingVolumes.length;\r\n  const length =\r\n    1 +\r\n    1 +\r\n    numBVs * BoundingSphere.packedLength +\r\n    1 +\r\n    packedBatchedIndicesLength(batchedIndices);\r\n\r\n  const packedBuffer = new Float64Array(length);\r\n\r\n  let offset = 0;\r\n  packedBuffer[offset++] = indicesBytesPerElement;\r\n  packedBuffer[offset++] = numBVs;\r\n\r\n  for (let i = 0; i < numBVs; ++i) {\r\n    BoundingSphere.pack(boundingVolumes[i], packedBuffer, offset);\r\n    offset += BoundingSphere.packedLength;\r\n  }\r\n\r\n  const indicesLength = batchedIndices.length;\r\n  packedBuffer[offset++] = indicesLength;\r\n\r\n  for (let j = 0; j < indicesLength; ++j) {\r\n    const batchedIndex = batchedIndices[j];\r\n\r\n    Color.pack(batchedIndex.color, packedBuffer, offset);\r\n    offset += Color.packedLength;\r\n\r\n    packedBuffer[offset++] = batchedIndex.offset;\r\n    packedBuffer[offset++] = batchedIndex.count;\r\n\r\n    const batchIds = batchedIndex.batchIds;\r\n    const batchIdsLength = batchIds.length;\r\n    packedBuffer[offset++] = batchIdsLength;\r\n\r\n    for (let k = 0; k < batchIdsLength; ++k) {\r\n      packedBuffer[offset++] = batchIds[k];\r\n    }\r\n  }\r\n\r\n  return packedBuffer;\r\n}\r\n\r\nfunction createVectorTileGeometries(parameters, transferableObjects) {\r\n  const boxes = defined(parameters.boxes)\r\n    ? new Float32Array(parameters.boxes)\r\n    : undefined;\r\n  const boxBatchIds = defined(parameters.boxBatchIds)\r\n    ? new Uint16Array(parameters.boxBatchIds)\r\n    : undefined;\r\n  const cylinders = defined(parameters.cylinders)\r\n    ? new Float32Array(parameters.cylinders)\r\n    : undefined;\r\n  const cylinderBatchIds = defined(parameters.cylinderBatchIds)\r\n    ? new Uint16Array(parameters.cylinderBatchIds)\r\n    : undefined;\r\n  const ellipsoids = defined(parameters.ellipsoids)\r\n    ? new Float32Array(parameters.ellipsoids)\r\n    : undefined;\r\n  const ellipsoidBatchIds = defined(parameters.ellipsoidBatchIds)\r\n    ? new Uint16Array(parameters.ellipsoidBatchIds)\r\n    : undefined;\r\n  const spheres = defined(parameters.spheres)\r\n    ? new Float32Array(parameters.spheres)\r\n    : undefined;\r\n  const sphereBatchIds = defined(parameters.sphereBatchIds)\r\n    ? new Uint16Array(parameters.sphereBatchIds)\r\n    : undefined;\r\n\r\n  const numberOfBoxes = defined(boxes) ? boxBatchIds.length : 0;\r\n  const numberOfCylinders = defined(cylinders) ? cylinderBatchIds.length : 0;\r\n  const numberOfEllipsoids = defined(ellipsoids) ? ellipsoidBatchIds.length : 0;\r\n  const numberOfSpheres = defined(spheres) ? sphereBatchIds.length : 0;\r\n\r\n  const boxGeometry = BoxGeometry.getUnitBox();\r\n  const cylinderGeometry = CylinderGeometry.getUnitCylinder();\r\n  const ellipsoidGeometry = EllipsoidGeometry.getUnitEllipsoid();\r\n\r\n  const boxPositions = boxGeometry.attributes.position.values;\r\n  const cylinderPositions = cylinderGeometry.attributes.position.values;\r\n  const ellipsoidPositions = ellipsoidGeometry.attributes.position.values;\r\n\r\n  let numberOfPositions = boxPositions.length * numberOfBoxes;\r\n  numberOfPositions += cylinderPositions.length * numberOfCylinders;\r\n  numberOfPositions +=\r\n    ellipsoidPositions.length * (numberOfEllipsoids + numberOfSpheres);\r\n\r\n  const boxIndices = boxGeometry.indices;\r\n  const cylinderIndices = cylinderGeometry.indices;\r\n  const ellipsoidIndices = ellipsoidGeometry.indices;\r\n\r\n  let numberOfIndices = boxIndices.length * numberOfBoxes;\r\n  numberOfIndices += cylinderIndices.length * numberOfCylinders;\r\n  numberOfIndices +=\r\n    ellipsoidIndices.length * (numberOfEllipsoids + numberOfSpheres);\r\n\r\n  const positions = new Float32Array(numberOfPositions);\r\n  const vertexBatchIds = new Uint16Array(numberOfPositions / 3);\r\n  const indices = IndexDatatype.createTypedArray(\r\n    numberOfPositions / 3,\r\n    numberOfIndices\r\n  );\r\n\r\n  const numberOfGeometries =\r\n    numberOfBoxes + numberOfCylinders + numberOfEllipsoids + numberOfSpheres;\r\n  const batchIds = new Uint16Array(numberOfGeometries);\r\n  const batchedIndices = new Array(numberOfGeometries);\r\n  const indexOffsets = new Uint32Array(numberOfGeometries);\r\n  const indexCounts = new Uint32Array(numberOfGeometries);\r\n  const boundingVolumes = new Array(numberOfGeometries);\r\n\r\n  unpackBuffer(parameters.packedBuffer);\r\n\r\n  const options = {\r\n    batchTableColors: new Uint32Array(parameters.batchTableColors),\r\n    positions: positions,\r\n    vertexBatchIds: vertexBatchIds,\r\n    indices: indices,\r\n    batchIds: batchIds,\r\n    batchedIndices: batchedIndices,\r\n    indexOffsets: indexOffsets,\r\n    indexCounts: indexCounts,\r\n    boundingVolumes: boundingVolumes,\r\n    positionOffset: 0,\r\n    batchIdIndex: 0,\r\n    indexOffset: 0,\r\n    batchedIndicesOffset: 0,\r\n    modelMatrix: scratchMatrix4,\r\n    center: scratchCenter,\r\n  };\r\n\r\n  createPrimitive(\r\n    options,\r\n    boxes,\r\n    boxBatchIds,\r\n    boxGeometry,\r\n    boxModelMatrixAndBoundingVolume\r\n  );\r\n  createPrimitive(\r\n    options,\r\n    cylinders,\r\n    cylinderBatchIds,\r\n    cylinderGeometry,\r\n    cylinderModelMatrixAndBoundingVolume\r\n  );\r\n  createPrimitive(\r\n    options,\r\n    ellipsoids,\r\n    ellipsoidBatchIds,\r\n    ellipsoidGeometry,\r\n    ellipsoidModelMatrixAndBoundingVolume\r\n  );\r\n  createPrimitive(\r\n    options,\r\n    spheres,\r\n    sphereBatchIds,\r\n    ellipsoidGeometry,\r\n    sphereModelMatrixAndBoundingVolume\r\n  );\r\n\r\n  const packedBuffer = packBuffer(\r\n    indices.BYTES_PER_ELEMENT,\r\n    batchedIndices,\r\n    boundingVolumes\r\n  );\r\n  transferableObjects.push(\r\n    positions.buffer,\r\n    vertexBatchIds.buffer,\r\n    indices.buffer\r\n  );\r\n  transferableObjects.push(\r\n    batchIds.buffer,\r\n    indexOffsets.buffer,\r\n    indexCounts.buffer\r\n  );\r\n  transferableObjects.push(packedBuffer.buffer);\r\n\r\n  return {\r\n    positions: positions.buffer,\r\n    vertexBatchIds: vertexBatchIds.buffer,\r\n    indices: indices.buffer,\r\n    indexOffsets: indexOffsets.buffer,\r\n    indexCounts: indexCounts.buffer,\r\n    batchIds: batchIds.buffer,\r\n    packedBuffer: packedBuffer.buffer,\r\n  };\r\n}\r\nexport default createTaskProcessorWorker(createVectorTileGeometries);\r\n"],"names":["Vector3DTileBatch","options","this","offset","count","color","batchIds","scratchCartesian","Cartesian3","packedBoxLength","Matrix4","packedLength","packedCylinderLength","packedEllipsoidLength","packedSphereLength","scratchModelMatrixAndBV","modelMatrix","boundingVolume","BoundingSphere","boxModelMatrixAndBoundingVolume","boxes","index","boxIndex","dimensions","unpack","boxModelMatrix","multiplyByScale","clone","ZERO","center","radius","Math","sqrt","cylinderModelMatrixAndBoundingVolume","cylinders","cylinderIndex","cylinderRadius","length","scale","fromElements","cylinderModelMatrix","ellipsoidModelMatrixAndBoundingVolume","ellipsoids","ellipsoidIndex","radii","ellipsoidModelMatrix","sphereModelMatrixAndBoundingVolume","spheres","sphereIndex","sphereRadius","sphereTranslation","sphereModelMatrix","fromTranslation","multiplyByUniformScale","scratchPosition","createPrimitive","primitive","primitiveBatchIds","geometry","getModelMatrixAndBoundingVolume","defined","numberOfPrimitives","geometryPositions","attributes","position","values","geometryIndices","indices","positions","vertexBatchIds","batchTableColors","batchedIndices","indexOffsets","indexCounts","boundingVolumes","positionOffset","batchIdIndex","indexOffset","batchedIndicesOffset","i","primitiveModelMatrixAndBV","primitiveModelMatrix","multiply","batchId","positionsLength","j","multiplyByPoint","subtract","pack","indicesLength","k","Color","fromRgba","transform","scratchCenter","scratchMatrix4","packBuffer","indicesBytesPerElement","numBVs","packedBatchedIndicesLength","packedBuffer","Float64Array","batchedIndex","batchIdsLength","createTaskProcessorWorker","parameters","transferableObjects","Float32Array","undefined","boxBatchIds","Uint16Array","cylinderBatchIds","ellipsoidBatchIds","sphereBatchIds","numberOfBoxes","numberOfCylinders","numberOfEllipsoids","numberOfSpheres","boxGeometry","BoxGeometry","getUnitBox","cylinderGeometry","CylinderGeometry","getUnitCylinder","ellipsoidGeometry","EllipsoidGeometry","getUnitEllipsoid","boxPositions","cylinderPositions","ellipsoidPositions","numberOfPositions","boxIndices","cylinderIndices","ellipsoidIndices","numberOfIndices","IndexDatatype","createTypedArray","numberOfGeometries","Array","Uint32Array","buffer","unpackBuffer","BYTES_PER_ELEMENT","push"],"mappings":"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"}