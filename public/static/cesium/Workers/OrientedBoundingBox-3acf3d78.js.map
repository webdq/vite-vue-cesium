{"version":3,"file":"OrientedBoundingBox-3acf3d78.js","sources":["../../../../Source/Core/OrientedBoundingBox.js"],"sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\r\nimport Cartesian2 from \"./Cartesian2.js\";\r\nimport Cartesian3 from \"./Cartesian3.js\";\r\nimport Cartographic from \"./Cartographic.js\";\r\nimport Check from \"./Check.js\";\r\nimport defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\nimport DeveloperError from \"./DeveloperError.js\";\r\nimport Ellipsoid from \"./Ellipsoid.js\";\r\nimport EllipsoidTangentPlane from \"./EllipsoidTangentPlane.js\";\r\nimport Intersect from \"./Intersect.js\";\r\nimport Interval from \"./Interval.js\";\r\nimport CesiumMath from \"./Math.js\";\r\nimport Matrix3 from \"./Matrix3.js\";\r\nimport Matrix4 from \"./Matrix4.js\";\r\nimport Plane from \"./Plane.js\";\r\nimport Rectangle from \"./Rectangle.js\";\r\n\r\n/**\r\n * Creates an instance of an OrientedBoundingBox.\r\n * An OrientedBoundingBox of some object is a closed and convex cuboid. It can provide a tighter bounding volume than {@link BoundingSphere} or {@link AxisAlignedBoundingBox} in many cases.\r\n * @alias OrientedBoundingBox\r\n * @constructor\r\n *\r\n * @param {Cartesian3} [center=Cartesian3.ZERO] The center of the box.\r\n * @param {Matrix3} [halfAxes=Matrix3.ZERO] The three orthogonal half-axes of the bounding box.\r\n *                                          Equivalently, the transformation matrix, to rotate and scale a 0x0x0\r\n *                                          cube centered at the origin.\r\n *\r\n *\r\n * @example\r\n * // Create an OrientedBoundingBox using a transformation matrix, a position where the box will be translated, and a scale.\r\n * const center = new Cesium.Cartesian3(1.0, 0.0, 0.0);\r\n * const halfAxes = Cesium.Matrix3.fromScale(new Cesium.Cartesian3(1.0, 3.0, 2.0), new Cesium.Matrix3());\r\n *\r\n * const obb = new Cesium.OrientedBoundingBox(center, halfAxes);\r\n *\r\n * @see BoundingSphere\r\n * @see BoundingRectangle\r\n */\r\nfunction OrientedBoundingBox(center, halfAxes) {\r\n  /**\r\n   * The center of the box.\r\n   * @type {Cartesian3}\r\n   * @default {@link Cartesian3.ZERO}\r\n   */\r\n  this.center = Cartesian3.clone(defaultValue(center, Cartesian3.ZERO));\r\n  /**\r\n   * The transformation matrix, to rotate the box to the right position.\r\n   * @type {Matrix3}\r\n   * @default {@link Matrix3.ZERO}\r\n   */\r\n  this.halfAxes = Matrix3.clone(defaultValue(halfAxes, Matrix3.ZERO));\r\n}\r\n\r\n/**\r\n * The number of elements used to pack the object into an array.\r\n * @type {Number}\r\n */\r\nOrientedBoundingBox.packedLength =\r\n  Cartesian3.packedLength + Matrix3.packedLength;\r\n\r\n/**\r\n * Stores the provided instance into the provided array.\r\n *\r\n * @param {OrientedBoundingBox} value The value to pack.\r\n * @param {Number[]} array The array to pack into.\r\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n *\r\n * @returns {Number[]} The array that was packed into\r\n */\r\nOrientedBoundingBox.pack = function (value, array, startingIndex) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"value\", value);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  Cartesian3.pack(value.center, array, startingIndex);\r\n  Matrix3.pack(value.halfAxes, array, startingIndex + Cartesian3.packedLength);\r\n\r\n  return array;\r\n};\r\n\r\n/**\r\n * Retrieves an instance from a packed array.\r\n *\r\n * @param {Number[]} array The packed array.\r\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n * @param {OrientedBoundingBox} [result] The object into which to store the result.\r\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.\r\n */\r\nOrientedBoundingBox.unpack = function (array, startingIndex, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  if (!defined(result)) {\r\n    result = new OrientedBoundingBox();\r\n  }\r\n\r\n  Cartesian3.unpack(array, startingIndex, result.center);\r\n  Matrix3.unpack(\r\n    array,\r\n    startingIndex + Cartesian3.packedLength,\r\n    result.halfAxes\r\n  );\r\n  return result;\r\n};\r\n\r\nconst scratchCartesian1 = new Cartesian3();\r\nconst scratchCartesian2 = new Cartesian3();\r\nconst scratchCartesian3 = new Cartesian3();\r\nconst scratchCartesian4 = new Cartesian3();\r\nconst scratchCartesian5 = new Cartesian3();\r\nconst scratchCartesian6 = new Cartesian3();\r\nconst scratchCovarianceResult = new Matrix3();\r\nconst scratchEigenResult = {\r\n  unitary: new Matrix3(),\r\n  diagonal: new Matrix3(),\r\n};\r\n\r\n/**\r\n * Computes an instance of an OrientedBoundingBox of the given positions.\r\n * This is an implementation of Stefan Gottschalk's Collision Queries using Oriented Bounding Boxes solution (PHD thesis).\r\n * Reference: http://gamma.cs.unc.edu/users/gottschalk/main.pdf\r\n *\r\n * @param {Cartesian3[]} [positions] List of {@link Cartesian3} points that the bounding box will enclose.\r\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\r\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.\r\n *\r\n * @example\r\n * // Compute an object oriented bounding box enclosing two points.\r\n * const box = Cesium.OrientedBoundingBox.fromPoints([new Cesium.Cartesian3(2, 0, 0), new Cesium.Cartesian3(-2, 0, 0)]);\r\n */\r\nOrientedBoundingBox.fromPoints = function (positions, result) {\r\n  if (!defined(result)) {\r\n    result = new OrientedBoundingBox();\r\n  }\r\n\r\n  if (!defined(positions) || positions.length === 0) {\r\n    result.halfAxes = Matrix3.ZERO;\r\n    result.center = Cartesian3.ZERO;\r\n    return result;\r\n  }\r\n\r\n  let i;\r\n  const length = positions.length;\r\n\r\n  const meanPoint = Cartesian3.clone(positions[0], scratchCartesian1);\r\n  for (i = 1; i < length; i++) {\r\n    Cartesian3.add(meanPoint, positions[i], meanPoint);\r\n  }\r\n  const invLength = 1.0 / length;\r\n  Cartesian3.multiplyByScalar(meanPoint, invLength, meanPoint);\r\n\r\n  let exx = 0.0;\r\n  let exy = 0.0;\r\n  let exz = 0.0;\r\n  let eyy = 0.0;\r\n  let eyz = 0.0;\r\n  let ezz = 0.0;\r\n  let p;\r\n\r\n  for (i = 0; i < length; i++) {\r\n    p = Cartesian3.subtract(positions[i], meanPoint, scratchCartesian2);\r\n    exx += p.x * p.x;\r\n    exy += p.x * p.y;\r\n    exz += p.x * p.z;\r\n    eyy += p.y * p.y;\r\n    eyz += p.y * p.z;\r\n    ezz += p.z * p.z;\r\n  }\r\n\r\n  exx *= invLength;\r\n  exy *= invLength;\r\n  exz *= invLength;\r\n  eyy *= invLength;\r\n  eyz *= invLength;\r\n  ezz *= invLength;\r\n\r\n  const covarianceMatrix = scratchCovarianceResult;\r\n  covarianceMatrix[0] = exx;\r\n  covarianceMatrix[1] = exy;\r\n  covarianceMatrix[2] = exz;\r\n  covarianceMatrix[3] = exy;\r\n  covarianceMatrix[4] = eyy;\r\n  covarianceMatrix[5] = eyz;\r\n  covarianceMatrix[6] = exz;\r\n  covarianceMatrix[7] = eyz;\r\n  covarianceMatrix[8] = ezz;\r\n\r\n  const eigenDecomposition = Matrix3.computeEigenDecomposition(\r\n    covarianceMatrix,\r\n    scratchEigenResult\r\n  );\r\n  const rotation = Matrix3.clone(eigenDecomposition.unitary, result.halfAxes);\r\n\r\n  let v1 = Matrix3.getColumn(rotation, 0, scratchCartesian4);\r\n  let v2 = Matrix3.getColumn(rotation, 1, scratchCartesian5);\r\n  let v3 = Matrix3.getColumn(rotation, 2, scratchCartesian6);\r\n\r\n  let u1 = -Number.MAX_VALUE;\r\n  let u2 = -Number.MAX_VALUE;\r\n  let u3 = -Number.MAX_VALUE;\r\n  let l1 = Number.MAX_VALUE;\r\n  let l2 = Number.MAX_VALUE;\r\n  let l3 = Number.MAX_VALUE;\r\n\r\n  for (i = 0; i < length; i++) {\r\n    p = positions[i];\r\n    u1 = Math.max(Cartesian3.dot(v1, p), u1);\r\n    u2 = Math.max(Cartesian3.dot(v2, p), u2);\r\n    u3 = Math.max(Cartesian3.dot(v3, p), u3);\r\n\r\n    l1 = Math.min(Cartesian3.dot(v1, p), l1);\r\n    l2 = Math.min(Cartesian3.dot(v2, p), l2);\r\n    l3 = Math.min(Cartesian3.dot(v3, p), l3);\r\n  }\r\n\r\n  v1 = Cartesian3.multiplyByScalar(v1, 0.5 * (l1 + u1), v1);\r\n  v2 = Cartesian3.multiplyByScalar(v2, 0.5 * (l2 + u2), v2);\r\n  v3 = Cartesian3.multiplyByScalar(v3, 0.5 * (l3 + u3), v3);\r\n\r\n  const center = Cartesian3.add(v1, v2, result.center);\r\n  Cartesian3.add(center, v3, center);\r\n\r\n  const scale = scratchCartesian3;\r\n  scale.x = u1 - l1;\r\n  scale.y = u2 - l2;\r\n  scale.z = u3 - l3;\r\n  Cartesian3.multiplyByScalar(scale, 0.5, scale);\r\n  Matrix3.multiplyByScale(result.halfAxes, scale, result.halfAxes);\r\n\r\n  return result;\r\n};\r\n\r\nconst scratchOffset = new Cartesian3();\r\nconst scratchScale = new Cartesian3();\r\nfunction fromPlaneExtents(\r\n  planeOrigin,\r\n  planeXAxis,\r\n  planeYAxis,\r\n  planeZAxis,\r\n  minimumX,\r\n  maximumX,\r\n  minimumY,\r\n  maximumY,\r\n  minimumZ,\r\n  maximumZ,\r\n  result\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (\r\n    !defined(minimumX) ||\r\n    !defined(maximumX) ||\r\n    !defined(minimumY) ||\r\n    !defined(maximumY) ||\r\n    !defined(minimumZ) ||\r\n    !defined(maximumZ)\r\n  ) {\r\n    throw new DeveloperError(\r\n      \"all extents (minimum/maximum X/Y/Z) are required.\"\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    result = new OrientedBoundingBox();\r\n  }\r\n\r\n  const halfAxes = result.halfAxes;\r\n  Matrix3.setColumn(halfAxes, 0, planeXAxis, halfAxes);\r\n  Matrix3.setColumn(halfAxes, 1, planeYAxis, halfAxes);\r\n  Matrix3.setColumn(halfAxes, 2, planeZAxis, halfAxes);\r\n\r\n  let centerOffset = scratchOffset;\r\n  centerOffset.x = (minimumX + maximumX) / 2.0;\r\n  centerOffset.y = (minimumY + maximumY) / 2.0;\r\n  centerOffset.z = (minimumZ + maximumZ) / 2.0;\r\n\r\n  const scale = scratchScale;\r\n  scale.x = (maximumX - minimumX) / 2.0;\r\n  scale.y = (maximumY - minimumY) / 2.0;\r\n  scale.z = (maximumZ - minimumZ) / 2.0;\r\n\r\n  const center = result.center;\r\n  centerOffset = Matrix3.multiplyByVector(halfAxes, centerOffset, centerOffset);\r\n  Cartesian3.add(planeOrigin, centerOffset, center);\r\n  Matrix3.multiplyByScale(halfAxes, scale, halfAxes);\r\n\r\n  return result;\r\n}\r\n\r\nconst scratchRectangleCenterCartographic = new Cartographic();\r\nconst scratchRectangleCenter = new Cartesian3();\r\nconst scratchPerimeterCartographicNC = new Cartographic();\r\nconst scratchPerimeterCartographicNW = new Cartographic();\r\nconst scratchPerimeterCartographicCW = new Cartographic();\r\nconst scratchPerimeterCartographicSW = new Cartographic();\r\nconst scratchPerimeterCartographicSC = new Cartographic();\r\nconst scratchPerimeterCartesianNC = new Cartesian3();\r\nconst scratchPerimeterCartesianNW = new Cartesian3();\r\nconst scratchPerimeterCartesianCW = new Cartesian3();\r\nconst scratchPerimeterCartesianSW = new Cartesian3();\r\nconst scratchPerimeterCartesianSC = new Cartesian3();\r\nconst scratchPerimeterProjectedNC = new Cartesian2();\r\nconst scratchPerimeterProjectedNW = new Cartesian2();\r\nconst scratchPerimeterProjectedCW = new Cartesian2();\r\nconst scratchPerimeterProjectedSW = new Cartesian2();\r\nconst scratchPerimeterProjectedSC = new Cartesian2();\r\n\r\nconst scratchPlaneOrigin = new Cartesian3();\r\nconst scratchPlaneNormal = new Cartesian3();\r\nconst scratchPlaneXAxis = new Cartesian3();\r\nconst scratchHorizonCartesian = new Cartesian3();\r\nconst scratchHorizonProjected = new Cartesian2();\r\nconst scratchMaxY = new Cartesian3();\r\nconst scratchMinY = new Cartesian3();\r\nconst scratchZ = new Cartesian3();\r\nconst scratchPlane = new Plane(Cartesian3.UNIT_X, 0.0);\r\n\r\n/**\r\n * Computes an OrientedBoundingBox that bounds a {@link Rectangle} on the surface of an {@link Ellipsoid}.\r\n * There are no guarantees about the orientation of the bounding box.\r\n *\r\n * @param {Rectangle} rectangle The cartographic rectangle on the surface of the ellipsoid.\r\n * @param {Number} [minimumHeight=0.0] The minimum height (elevation) within the tile.\r\n * @param {Number} [maximumHeight=0.0] The maximum height (elevation) within the tile.\r\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the rectangle is defined.\r\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\r\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if none was provided.\r\n *\r\n * @exception {DeveloperError} rectangle.width must be between 0 and pi.\r\n * @exception {DeveloperError} rectangle.height must be between 0 and pi.\r\n * @exception {DeveloperError} ellipsoid must be an ellipsoid of revolution (<code>radii.x == radii.y</code>)\r\n */\r\nOrientedBoundingBox.fromRectangle = function (\r\n  rectangle,\r\n  minimumHeight,\r\n  maximumHeight,\r\n  ellipsoid,\r\n  result\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(rectangle)) {\r\n    throw new DeveloperError(\"rectangle is required\");\r\n  }\r\n  if (rectangle.width < 0.0 || rectangle.width > CesiumMath.TWO_PI) {\r\n    throw new DeveloperError(\"Rectangle width must be between 0 and 2*pi\");\r\n  }\r\n  if (rectangle.height < 0.0 || rectangle.height > CesiumMath.PI) {\r\n    throw new DeveloperError(\"Rectangle height must be between 0 and pi\");\r\n  }\r\n  if (\r\n    defined(ellipsoid) &&\r\n    !CesiumMath.equalsEpsilon(\r\n      ellipsoid.radii.x,\r\n      ellipsoid.radii.y,\r\n      CesiumMath.EPSILON15\r\n    )\r\n  ) {\r\n    throw new DeveloperError(\r\n      \"Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)\"\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  minimumHeight = defaultValue(minimumHeight, 0.0);\r\n  maximumHeight = defaultValue(maximumHeight, 0.0);\r\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\r\n\r\n  let minX, maxX, minY, maxY, minZ, maxZ, plane;\r\n\r\n  if (rectangle.width <= CesiumMath.PI) {\r\n    // The bounding box will be aligned with the tangent plane at the center of the rectangle.\r\n    const tangentPointCartographic = Rectangle.center(\r\n      rectangle,\r\n      scratchRectangleCenterCartographic\r\n    );\r\n    const tangentPoint = ellipsoid.cartographicToCartesian(\r\n      tangentPointCartographic,\r\n      scratchRectangleCenter\r\n    );\r\n    const tangentPlane = new EllipsoidTangentPlane(tangentPoint, ellipsoid);\r\n    plane = tangentPlane.plane;\r\n\r\n    // If the rectangle spans the equator, CW is instead aligned with the equator (because it sticks out the farthest at the equator).\r\n    const lonCenter = tangentPointCartographic.longitude;\r\n    const latCenter =\r\n      rectangle.south < 0.0 && rectangle.north > 0.0\r\n        ? 0.0\r\n        : tangentPointCartographic.latitude;\r\n\r\n    // Compute XY extents using the rectangle at maximum height\r\n    const perimeterCartographicNC = Cartographic.fromRadians(\r\n      lonCenter,\r\n      rectangle.north,\r\n      maximumHeight,\r\n      scratchPerimeterCartographicNC\r\n    );\r\n    const perimeterCartographicNW = Cartographic.fromRadians(\r\n      rectangle.west,\r\n      rectangle.north,\r\n      maximumHeight,\r\n      scratchPerimeterCartographicNW\r\n    );\r\n    const perimeterCartographicCW = Cartographic.fromRadians(\r\n      rectangle.west,\r\n      latCenter,\r\n      maximumHeight,\r\n      scratchPerimeterCartographicCW\r\n    );\r\n    const perimeterCartographicSW = Cartographic.fromRadians(\r\n      rectangle.west,\r\n      rectangle.south,\r\n      maximumHeight,\r\n      scratchPerimeterCartographicSW\r\n    );\r\n    const perimeterCartographicSC = Cartographic.fromRadians(\r\n      lonCenter,\r\n      rectangle.south,\r\n      maximumHeight,\r\n      scratchPerimeterCartographicSC\r\n    );\r\n\r\n    const perimeterCartesianNC = ellipsoid.cartographicToCartesian(\r\n      perimeterCartographicNC,\r\n      scratchPerimeterCartesianNC\r\n    );\r\n    let perimeterCartesianNW = ellipsoid.cartographicToCartesian(\r\n      perimeterCartographicNW,\r\n      scratchPerimeterCartesianNW\r\n    );\r\n    const perimeterCartesianCW = ellipsoid.cartographicToCartesian(\r\n      perimeterCartographicCW,\r\n      scratchPerimeterCartesianCW\r\n    );\r\n    let perimeterCartesianSW = ellipsoid.cartographicToCartesian(\r\n      perimeterCartographicSW,\r\n      scratchPerimeterCartesianSW\r\n    );\r\n    const perimeterCartesianSC = ellipsoid.cartographicToCartesian(\r\n      perimeterCartographicSC,\r\n      scratchPerimeterCartesianSC\r\n    );\r\n\r\n    const perimeterProjectedNC = tangentPlane.projectPointToNearestOnPlane(\r\n      perimeterCartesianNC,\r\n      scratchPerimeterProjectedNC\r\n    );\r\n    const perimeterProjectedNW = tangentPlane.projectPointToNearestOnPlane(\r\n      perimeterCartesianNW,\r\n      scratchPerimeterProjectedNW\r\n    );\r\n    const perimeterProjectedCW = tangentPlane.projectPointToNearestOnPlane(\r\n      perimeterCartesianCW,\r\n      scratchPerimeterProjectedCW\r\n    );\r\n    const perimeterProjectedSW = tangentPlane.projectPointToNearestOnPlane(\r\n      perimeterCartesianSW,\r\n      scratchPerimeterProjectedSW\r\n    );\r\n    const perimeterProjectedSC = tangentPlane.projectPointToNearestOnPlane(\r\n      perimeterCartesianSC,\r\n      scratchPerimeterProjectedSC\r\n    );\r\n\r\n    minX = Math.min(\r\n      perimeterProjectedNW.x,\r\n      perimeterProjectedCW.x,\r\n      perimeterProjectedSW.x\r\n    );\r\n    maxX = -minX; // symmetrical\r\n\r\n    maxY = Math.max(perimeterProjectedNW.y, perimeterProjectedNC.y);\r\n    minY = Math.min(perimeterProjectedSW.y, perimeterProjectedSC.y);\r\n\r\n    // Compute minimum Z using the rectangle at minimum height, since it will be deeper than the maximum height\r\n    perimeterCartographicNW.height = perimeterCartographicSW.height = minimumHeight;\r\n    perimeterCartesianNW = ellipsoid.cartographicToCartesian(\r\n      perimeterCartographicNW,\r\n      scratchPerimeterCartesianNW\r\n    );\r\n    perimeterCartesianSW = ellipsoid.cartographicToCartesian(\r\n      perimeterCartographicSW,\r\n      scratchPerimeterCartesianSW\r\n    );\r\n\r\n    minZ = Math.min(\r\n      Plane.getPointDistance(plane, perimeterCartesianNW),\r\n      Plane.getPointDistance(plane, perimeterCartesianSW)\r\n    );\r\n    maxZ = maximumHeight; // Since the tangent plane touches the surface at height = 0, this is okay\r\n\r\n    return fromPlaneExtents(\r\n      tangentPlane.origin,\r\n      tangentPlane.xAxis,\r\n      tangentPlane.yAxis,\r\n      tangentPlane.zAxis,\r\n      minX,\r\n      maxX,\r\n      minY,\r\n      maxY,\r\n      minZ,\r\n      maxZ,\r\n      result\r\n    );\r\n  }\r\n\r\n  // Handle the case where rectangle width is greater than PI (wraps around more than half the ellipsoid).\r\n  const fullyAboveEquator = rectangle.south > 0.0;\r\n  const fullyBelowEquator = rectangle.north < 0.0;\r\n  const latitudeNearestToEquator = fullyAboveEquator\r\n    ? rectangle.south\r\n    : fullyBelowEquator\r\n    ? rectangle.north\r\n    : 0.0;\r\n  const centerLongitude = Rectangle.center(\r\n    rectangle,\r\n    scratchRectangleCenterCartographic\r\n  ).longitude;\r\n\r\n  // Plane is located at the rectangle's center longitude and the rectangle's latitude that is closest to the equator. It rotates around the Z axis.\r\n  // This results in a better fit than the obb approach for smaller rectangles, which orients with the rectangle's center normal.\r\n  const planeOrigin = Cartesian3.fromRadians(\r\n    centerLongitude,\r\n    latitudeNearestToEquator,\r\n    maximumHeight,\r\n    ellipsoid,\r\n    scratchPlaneOrigin\r\n  );\r\n  planeOrigin.z = 0.0; // center the plane on the equator to simpify plane normal calculation\r\n  const isPole =\r\n    Math.abs(planeOrigin.x) < CesiumMath.EPSILON10 &&\r\n    Math.abs(planeOrigin.y) < CesiumMath.EPSILON10;\r\n  const planeNormal = !isPole\r\n    ? Cartesian3.normalize(planeOrigin, scratchPlaneNormal)\r\n    : Cartesian3.UNIT_X;\r\n  const planeYAxis = Cartesian3.UNIT_Z;\r\n  const planeXAxis = Cartesian3.cross(\r\n    planeNormal,\r\n    planeYAxis,\r\n    scratchPlaneXAxis\r\n  );\r\n  plane = Plane.fromPointNormal(planeOrigin, planeNormal, scratchPlane);\r\n\r\n  // Get the horizon point relative to the center. This will be the farthest extent in the plane's X dimension.\r\n  const horizonCartesian = Cartesian3.fromRadians(\r\n    centerLongitude + CesiumMath.PI_OVER_TWO,\r\n    latitudeNearestToEquator,\r\n    maximumHeight,\r\n    ellipsoid,\r\n    scratchHorizonCartesian\r\n  );\r\n  maxX = Cartesian3.dot(\r\n    Plane.projectPointOntoPlane(\r\n      plane,\r\n      horizonCartesian,\r\n      scratchHorizonProjected\r\n    ),\r\n    planeXAxis\r\n  );\r\n  minX = -maxX; // symmetrical\r\n\r\n  // Get the min and max Y, using the height that will give the largest extent\r\n  maxY = Cartesian3.fromRadians(\r\n    0.0,\r\n    rectangle.north,\r\n    fullyBelowEquator ? minimumHeight : maximumHeight,\r\n    ellipsoid,\r\n    scratchMaxY\r\n  ).z;\r\n  minY = Cartesian3.fromRadians(\r\n    0.0,\r\n    rectangle.south,\r\n    fullyAboveEquator ? minimumHeight : maximumHeight,\r\n    ellipsoid,\r\n    scratchMinY\r\n  ).z;\r\n\r\n  const farZ = Cartesian3.fromRadians(\r\n    rectangle.east,\r\n    latitudeNearestToEquator,\r\n    maximumHeight,\r\n    ellipsoid,\r\n    scratchZ\r\n  );\r\n  minZ = Plane.getPointDistance(plane, farZ);\r\n  maxZ = 0.0; // plane origin starts at maxZ already\r\n\r\n  // min and max are local to the plane axes\r\n  return fromPlaneExtents(\r\n    planeOrigin,\r\n    planeXAxis,\r\n    planeYAxis,\r\n    planeNormal,\r\n    minX,\r\n    maxX,\r\n    minY,\r\n    maxY,\r\n    minZ,\r\n    maxZ,\r\n    result\r\n  );\r\n};\r\n\r\n/**\r\n * Computes an OrientedBoundingBox that bounds an affine transformation.\r\n *\r\n * @param {Matrix4} transformation The affine transformation.\r\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\r\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if none was provided.\r\n */\r\nOrientedBoundingBox.fromTransformation = function (transformation, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"transformation\", transformation);\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    result = new OrientedBoundingBox();\r\n  }\r\n\r\n  result.center = Matrix4.getTranslation(transformation, result.center);\r\n  result.halfAxes = Matrix4.getMatrix3(transformation, result.halfAxes);\r\n  result.halfAxes = Matrix3.multiplyByScalar(\r\n    result.halfAxes,\r\n    0.5,\r\n    result.halfAxes\r\n  );\r\n  return result;\r\n};\r\n\r\n/**\r\n * Duplicates a OrientedBoundingBox instance.\r\n *\r\n * @param {OrientedBoundingBox} box The bounding box to duplicate.\r\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\r\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if none was provided. (Returns undefined if box is undefined)\r\n */\r\nOrientedBoundingBox.clone = function (box, result) {\r\n  if (!defined(box)) {\r\n    return undefined;\r\n  }\r\n\r\n  if (!defined(result)) {\r\n    return new OrientedBoundingBox(box.center, box.halfAxes);\r\n  }\r\n\r\n  Cartesian3.clone(box.center, result.center);\r\n  Matrix3.clone(box.halfAxes, result.halfAxes);\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Determines which side of a plane the oriented bounding box is located.\r\n *\r\n * @param {OrientedBoundingBox} box The oriented bounding box to test.\r\n * @param {Plane} plane The plane to test against.\r\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\r\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\r\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\r\n *                      intersects the plane.\r\n */\r\nOrientedBoundingBox.intersectPlane = function (box, plane) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(box)) {\r\n    throw new DeveloperError(\"box is required.\");\r\n  }\r\n\r\n  if (!defined(plane)) {\r\n    throw new DeveloperError(\"plane is required.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const center = box.center;\r\n  const normal = plane.normal;\r\n  const halfAxes = box.halfAxes;\r\n  const normalX = normal.x,\r\n    normalY = normal.y,\r\n    normalZ = normal.z;\r\n  // plane is used as if it is its normal; the first three components are assumed to be normalized\r\n  const radEffective =\r\n    Math.abs(\r\n      normalX * halfAxes[Matrix3.COLUMN0ROW0] +\r\n        normalY * halfAxes[Matrix3.COLUMN0ROW1] +\r\n        normalZ * halfAxes[Matrix3.COLUMN0ROW2]\r\n    ) +\r\n    Math.abs(\r\n      normalX * halfAxes[Matrix3.COLUMN1ROW0] +\r\n        normalY * halfAxes[Matrix3.COLUMN1ROW1] +\r\n        normalZ * halfAxes[Matrix3.COLUMN1ROW2]\r\n    ) +\r\n    Math.abs(\r\n      normalX * halfAxes[Matrix3.COLUMN2ROW0] +\r\n        normalY * halfAxes[Matrix3.COLUMN2ROW1] +\r\n        normalZ * halfAxes[Matrix3.COLUMN2ROW2]\r\n    );\r\n  const distanceToPlane = Cartesian3.dot(normal, center) + plane.distance;\r\n\r\n  if (distanceToPlane <= -radEffective) {\r\n    // The entire box is on the negative side of the plane normal\r\n    return Intersect.OUTSIDE;\r\n  } else if (distanceToPlane >= radEffective) {\r\n    // The entire box is on the positive side of the plane normal\r\n    return Intersect.INSIDE;\r\n  }\r\n  return Intersect.INTERSECTING;\r\n};\r\n\r\nconst scratchCartesianU = new Cartesian3();\r\nconst scratchCartesianV = new Cartesian3();\r\nconst scratchCartesianW = new Cartesian3();\r\nconst scratchValidAxis2 = new Cartesian3();\r\nconst scratchValidAxis3 = new Cartesian3();\r\nconst scratchPPrime = new Cartesian3();\r\n\r\n/**\r\n * Computes the estimated distance squared from the closest point on a bounding box to a point.\r\n *\r\n * @param {OrientedBoundingBox} box The box.\r\n * @param {Cartesian3} cartesian The point\r\n * @returns {Number} The distance squared from the oriented bounding box to the point. Returns 0 if the point is inside the box.\r\n *\r\n * @example\r\n * // Sort bounding boxes from back to front\r\n * boxes.sort(function(a, b) {\r\n *     return Cesium.OrientedBoundingBox.distanceSquaredTo(b, camera.positionWC) - Cesium.OrientedBoundingBox.distanceSquaredTo(a, camera.positionWC);\r\n * });\r\n */\r\nOrientedBoundingBox.distanceSquaredTo = function (box, cartesian) {\r\n  // See Geometric Tools for Computer Graphics 10.4.2\r\n\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(box)) {\r\n    throw new DeveloperError(\"box is required.\");\r\n  }\r\n  if (!defined(cartesian)) {\r\n    throw new DeveloperError(\"cartesian is required.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const offset = Cartesian3.subtract(cartesian, box.center, scratchOffset);\r\n\r\n  const halfAxes = box.halfAxes;\r\n  let u = Matrix3.getColumn(halfAxes, 0, scratchCartesianU);\r\n  let v = Matrix3.getColumn(halfAxes, 1, scratchCartesianV);\r\n  let w = Matrix3.getColumn(halfAxes, 2, scratchCartesianW);\r\n\r\n  const uHalf = Cartesian3.magnitude(u);\r\n  const vHalf = Cartesian3.magnitude(v);\r\n  const wHalf = Cartesian3.magnitude(w);\r\n\r\n  let uValid = true;\r\n  let vValid = true;\r\n  let wValid = true;\r\n\r\n  if (uHalf > 0) {\r\n    Cartesian3.divideByScalar(u, uHalf, u);\r\n  } else {\r\n    uValid = false;\r\n  }\r\n\r\n  if (vHalf > 0) {\r\n    Cartesian3.divideByScalar(v, vHalf, v);\r\n  } else {\r\n    vValid = false;\r\n  }\r\n\r\n  if (wHalf > 0) {\r\n    Cartesian3.divideByScalar(w, wHalf, w);\r\n  } else {\r\n    wValid = false;\r\n  }\r\n\r\n  const numberOfDegenerateAxes = !uValid + !vValid + !wValid;\r\n  let validAxis1;\r\n  let validAxis2;\r\n  let validAxis3;\r\n\r\n  if (numberOfDegenerateAxes === 1) {\r\n    let degenerateAxis = u;\r\n    validAxis1 = v;\r\n    validAxis2 = w;\r\n    if (!vValid) {\r\n      degenerateAxis = v;\r\n      validAxis1 = u;\r\n    } else if (!wValid) {\r\n      degenerateAxis = w;\r\n      validAxis2 = u;\r\n    }\r\n\r\n    validAxis3 = Cartesian3.cross(validAxis1, validAxis2, scratchValidAxis3);\r\n\r\n    if (degenerateAxis === u) {\r\n      u = validAxis3;\r\n    } else if (degenerateAxis === v) {\r\n      v = validAxis3;\r\n    } else if (degenerateAxis === w) {\r\n      w = validAxis3;\r\n    }\r\n  } else if (numberOfDegenerateAxes === 2) {\r\n    validAxis1 = u;\r\n    if (vValid) {\r\n      validAxis1 = v;\r\n    } else if (wValid) {\r\n      validAxis1 = w;\r\n    }\r\n\r\n    let crossVector = Cartesian3.UNIT_Y;\r\n    if (crossVector.equalsEpsilon(validAxis1, CesiumMath.EPSILON3)) {\r\n      crossVector = Cartesian3.UNIT_X;\r\n    }\r\n\r\n    validAxis2 = Cartesian3.cross(validAxis1, crossVector, scratchValidAxis2);\r\n    Cartesian3.normalize(validAxis2, validAxis2);\r\n    validAxis3 = Cartesian3.cross(validAxis1, validAxis2, scratchValidAxis3);\r\n    Cartesian3.normalize(validAxis3, validAxis3);\r\n\r\n    if (validAxis1 === u) {\r\n      v = validAxis2;\r\n      w = validAxis3;\r\n    } else if (validAxis1 === v) {\r\n      w = validAxis2;\r\n      u = validAxis3;\r\n    } else if (validAxis1 === w) {\r\n      u = validAxis2;\r\n      v = validAxis3;\r\n    }\r\n  } else if (numberOfDegenerateAxes === 3) {\r\n    u = Cartesian3.UNIT_X;\r\n    v = Cartesian3.UNIT_Y;\r\n    w = Cartesian3.UNIT_Z;\r\n  }\r\n\r\n  const pPrime = scratchPPrime;\r\n  pPrime.x = Cartesian3.dot(offset, u);\r\n  pPrime.y = Cartesian3.dot(offset, v);\r\n  pPrime.z = Cartesian3.dot(offset, w);\r\n\r\n  let distanceSquared = 0.0;\r\n  let d;\r\n\r\n  if (pPrime.x < -uHalf) {\r\n    d = pPrime.x + uHalf;\r\n    distanceSquared += d * d;\r\n  } else if (pPrime.x > uHalf) {\r\n    d = pPrime.x - uHalf;\r\n    distanceSquared += d * d;\r\n  }\r\n\r\n  if (pPrime.y < -vHalf) {\r\n    d = pPrime.y + vHalf;\r\n    distanceSquared += d * d;\r\n  } else if (pPrime.y > vHalf) {\r\n    d = pPrime.y - vHalf;\r\n    distanceSquared += d * d;\r\n  }\r\n\r\n  if (pPrime.z < -wHalf) {\r\n    d = pPrime.z + wHalf;\r\n    distanceSquared += d * d;\r\n  } else if (pPrime.z > wHalf) {\r\n    d = pPrime.z - wHalf;\r\n    distanceSquared += d * d;\r\n  }\r\n\r\n  return distanceSquared;\r\n};\r\n\r\nconst scratchCorner = new Cartesian3();\r\nconst scratchToCenter = new Cartesian3();\r\n\r\n/**\r\n * The distances calculated by the vector from the center of the bounding box to position projected onto direction.\r\n * <br>\r\n * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\r\n * closest and farthest planes from position that intersect the bounding box.\r\n *\r\n * @param {OrientedBoundingBox} box The bounding box to calculate the distance to.\r\n * @param {Cartesian3} position The position to calculate the distance from.\r\n * @param {Cartesian3} direction The direction from position.\r\n * @param {Interval} [result] A Interval to store the nearest and farthest distances.\r\n * @returns {Interval} The nearest and farthest distances on the bounding box from position in direction.\r\n */\r\nOrientedBoundingBox.computePlaneDistances = function (\r\n  box,\r\n  position,\r\n  direction,\r\n  result\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(box)) {\r\n    throw new DeveloperError(\"box is required.\");\r\n  }\r\n\r\n  if (!defined(position)) {\r\n    throw new DeveloperError(\"position is required.\");\r\n  }\r\n\r\n  if (!defined(direction)) {\r\n    throw new DeveloperError(\"direction is required.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    result = new Interval();\r\n  }\r\n\r\n  let minDist = Number.POSITIVE_INFINITY;\r\n  let maxDist = Number.NEGATIVE_INFINITY;\r\n\r\n  const center = box.center;\r\n  const halfAxes = box.halfAxes;\r\n\r\n  const u = Matrix3.getColumn(halfAxes, 0, scratchCartesianU);\r\n  const v = Matrix3.getColumn(halfAxes, 1, scratchCartesianV);\r\n  const w = Matrix3.getColumn(halfAxes, 2, scratchCartesianW);\r\n\r\n  // project first corner\r\n  const corner = Cartesian3.add(u, v, scratchCorner);\r\n  Cartesian3.add(corner, w, corner);\r\n  Cartesian3.add(corner, center, corner);\r\n\r\n  const toCenter = Cartesian3.subtract(corner, position, scratchToCenter);\r\n  let mag = Cartesian3.dot(direction, toCenter);\r\n\r\n  minDist = Math.min(mag, minDist);\r\n  maxDist = Math.max(mag, maxDist);\r\n\r\n  // project second corner\r\n  Cartesian3.add(center, u, corner);\r\n  Cartesian3.add(corner, v, corner);\r\n  Cartesian3.subtract(corner, w, corner);\r\n\r\n  Cartesian3.subtract(corner, position, toCenter);\r\n  mag = Cartesian3.dot(direction, toCenter);\r\n\r\n  minDist = Math.min(mag, minDist);\r\n  maxDist = Math.max(mag, maxDist);\r\n\r\n  // project third corner\r\n  Cartesian3.add(center, u, corner);\r\n  Cartesian3.subtract(corner, v, corner);\r\n  Cartesian3.add(corner, w, corner);\r\n\r\n  Cartesian3.subtract(corner, position, toCenter);\r\n  mag = Cartesian3.dot(direction, toCenter);\r\n\r\n  minDist = Math.min(mag, minDist);\r\n  maxDist = Math.max(mag, maxDist);\r\n\r\n  // project fourth corner\r\n  Cartesian3.add(center, u, corner);\r\n  Cartesian3.subtract(corner, v, corner);\r\n  Cartesian3.subtract(corner, w, corner);\r\n\r\n  Cartesian3.subtract(corner, position, toCenter);\r\n  mag = Cartesian3.dot(direction, toCenter);\r\n\r\n  minDist = Math.min(mag, minDist);\r\n  maxDist = Math.max(mag, maxDist);\r\n\r\n  // project fifth corner\r\n  Cartesian3.subtract(center, u, corner);\r\n  Cartesian3.add(corner, v, corner);\r\n  Cartesian3.add(corner, w, corner);\r\n\r\n  Cartesian3.subtract(corner, position, toCenter);\r\n  mag = Cartesian3.dot(direction, toCenter);\r\n\r\n  minDist = Math.min(mag, minDist);\r\n  maxDist = Math.max(mag, maxDist);\r\n\r\n  // project sixth corner\r\n  Cartesian3.subtract(center, u, corner);\r\n  Cartesian3.add(corner, v, corner);\r\n  Cartesian3.subtract(corner, w, corner);\r\n\r\n  Cartesian3.subtract(corner, position, toCenter);\r\n  mag = Cartesian3.dot(direction, toCenter);\r\n\r\n  minDist = Math.min(mag, minDist);\r\n  maxDist = Math.max(mag, maxDist);\r\n\r\n  // project seventh corner\r\n  Cartesian3.subtract(center, u, corner);\r\n  Cartesian3.subtract(corner, v, corner);\r\n  Cartesian3.add(corner, w, corner);\r\n\r\n  Cartesian3.subtract(corner, position, toCenter);\r\n  mag = Cartesian3.dot(direction, toCenter);\r\n\r\n  minDist = Math.min(mag, minDist);\r\n  maxDist = Math.max(mag, maxDist);\r\n\r\n  // project eighth corner\r\n  Cartesian3.subtract(center, u, corner);\r\n  Cartesian3.subtract(corner, v, corner);\r\n  Cartesian3.subtract(corner, w, corner);\r\n\r\n  Cartesian3.subtract(corner, position, toCenter);\r\n  mag = Cartesian3.dot(direction, toCenter);\r\n\r\n  minDist = Math.min(mag, minDist);\r\n  maxDist = Math.max(mag, maxDist);\r\n\r\n  result.start = minDist;\r\n  result.stop = maxDist;\r\n  return result;\r\n};\r\n\r\nconst scratchXAxis = new Cartesian3();\r\nconst scratchYAxis = new Cartesian3();\r\nconst scratchZAxis = new Cartesian3();\r\n\r\n/**\r\n * Computes the eight corners of an oriented bounding box. The corners are ordered by (-X, -Y, -Z), (-X, -Y, +Z), (-X, +Y, -Z), (-X, +Y, +Z), (+X, -Y, -Z), (+X, -Y, +Z), (+X, +Y, -Z), (+X, +Y, +Z).\r\n *\r\n * @param {OrientedBoundingBox} box The oriented bounding box.\r\n * @param {Cartesian3[]} [result] An array of eight {@link Cartesian3} instances onto which to store the corners.\r\n * @returns {Cartesian3[]} The modified result parameter or a new array if none was provided.\r\n */\r\nOrientedBoundingBox.computeCorners = function (box, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"box\", box);\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    result = [\r\n      new Cartesian3(),\r\n      new Cartesian3(),\r\n      new Cartesian3(),\r\n      new Cartesian3(),\r\n      new Cartesian3(),\r\n      new Cartesian3(),\r\n      new Cartesian3(),\r\n      new Cartesian3(),\r\n    ];\r\n  }\r\n\r\n  const center = box.center;\r\n  const halfAxes = box.halfAxes;\r\n  const xAxis = Matrix3.getColumn(halfAxes, 0, scratchXAxis);\r\n  const yAxis = Matrix3.getColumn(halfAxes, 1, scratchYAxis);\r\n  const zAxis = Matrix3.getColumn(halfAxes, 2, scratchZAxis);\r\n\r\n  Cartesian3.clone(center, result[0]);\r\n  Cartesian3.subtract(result[0], xAxis, result[0]);\r\n  Cartesian3.subtract(result[0], yAxis, result[0]);\r\n  Cartesian3.subtract(result[0], zAxis, result[0]);\r\n\r\n  Cartesian3.clone(center, result[1]);\r\n  Cartesian3.subtract(result[1], xAxis, result[1]);\r\n  Cartesian3.subtract(result[1], yAxis, result[1]);\r\n  Cartesian3.add(result[1], zAxis, result[1]);\r\n\r\n  Cartesian3.clone(center, result[2]);\r\n  Cartesian3.subtract(result[2], xAxis, result[2]);\r\n  Cartesian3.add(result[2], yAxis, result[2]);\r\n  Cartesian3.subtract(result[2], zAxis, result[2]);\r\n\r\n  Cartesian3.clone(center, result[3]);\r\n  Cartesian3.subtract(result[3], xAxis, result[3]);\r\n  Cartesian3.add(result[3], yAxis, result[3]);\r\n  Cartesian3.add(result[3], zAxis, result[3]);\r\n\r\n  Cartesian3.clone(center, result[4]);\r\n  Cartesian3.add(result[4], xAxis, result[4]);\r\n  Cartesian3.subtract(result[4], yAxis, result[4]);\r\n  Cartesian3.subtract(result[4], zAxis, result[4]);\r\n\r\n  Cartesian3.clone(center, result[5]);\r\n  Cartesian3.add(result[5], xAxis, result[5]);\r\n  Cartesian3.subtract(result[5], yAxis, result[5]);\r\n  Cartesian3.add(result[5], zAxis, result[5]);\r\n\r\n  Cartesian3.clone(center, result[6]);\r\n  Cartesian3.add(result[6], xAxis, result[6]);\r\n  Cartesian3.add(result[6], yAxis, result[6]);\r\n  Cartesian3.subtract(result[6], zAxis, result[6]);\r\n\r\n  Cartesian3.clone(center, result[7]);\r\n  Cartesian3.add(result[7], xAxis, result[7]);\r\n  Cartesian3.add(result[7], yAxis, result[7]);\r\n  Cartesian3.add(result[7], zAxis, result[7]);\r\n\r\n  return result;\r\n};\r\n\r\nconst scratchRotationScale = new Matrix3();\r\n\r\n/**\r\n * Computes a transformation matrix from an oriented bounding box.\r\n *\r\n * @param {OrientedBoundingBox} box The oriented bounding box.\r\n * @param {Matrix4} result The object onto which to store the result.\r\n * @returns {Matrix4} The modified result parameter or a new {@link Matrix4} instance if none was provided.\r\n */\r\nOrientedBoundingBox.computeTransformation = function (box, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"box\", box);\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    result = new Matrix4();\r\n  }\r\n\r\n  const translation = box.center;\r\n  const rotationScale = Matrix3.multiplyByUniformScale(\r\n    box.halfAxes,\r\n    2.0,\r\n    scratchRotationScale\r\n  );\r\n  return Matrix4.fromRotationTranslation(rotationScale, translation, result);\r\n};\r\n\r\nconst scratchBoundingSphere = new BoundingSphere();\r\n\r\n/**\r\n * Determines whether or not a bounding box is hidden from view by the occluder.\r\n *\r\n * @param {OrientedBoundingBox} box The bounding box surrounding the occludee object.\r\n * @param {Occluder} occluder The occluder.\r\n * @returns {Boolean} <code>true</code> if the box is not visible; otherwise <code>false</code>.\r\n */\r\nOrientedBoundingBox.isOccluded = function (box, occluder) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(box)) {\r\n    throw new DeveloperError(\"box is required.\");\r\n  }\r\n  if (!defined(occluder)) {\r\n    throw new DeveloperError(\"occluder is required.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const sphere = BoundingSphere.fromOrientedBoundingBox(\r\n    box,\r\n    scratchBoundingSphere\r\n  );\r\n\r\n  return !occluder.isBoundingSphereVisible(sphere);\r\n};\r\n\r\n/**\r\n * Determines which side of a plane the oriented bounding box is located.\r\n *\r\n * @param {Plane} plane The plane to test against.\r\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\r\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\r\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\r\n *                      intersects the plane.\r\n */\r\nOrientedBoundingBox.prototype.intersectPlane = function (plane) {\r\n  return OrientedBoundingBox.intersectPlane(this, plane);\r\n};\r\n\r\n/**\r\n * Computes the estimated distance squared from the closest point on a bounding box to a point.\r\n *\r\n * @param {Cartesian3} cartesian The point\r\n * @returns {Number} The estimated distance squared from the bounding sphere to the point.\r\n *\r\n * @example\r\n * // Sort bounding boxes from back to front\r\n * boxes.sort(function(a, b) {\r\n *     return b.distanceSquaredTo(camera.positionWC) - a.distanceSquaredTo(camera.positionWC);\r\n * });\r\n */\r\nOrientedBoundingBox.prototype.distanceSquaredTo = function (cartesian) {\r\n  return OrientedBoundingBox.distanceSquaredTo(this, cartesian);\r\n};\r\n\r\n/**\r\n * The distances calculated by the vector from the center of the bounding box to position projected onto direction.\r\n * <br>\r\n * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\r\n * closest and farthest planes from position that intersect the bounding box.\r\n *\r\n * @param {Cartesian3} position The position to calculate the distance from.\r\n * @param {Cartesian3} direction The direction from position.\r\n * @param {Interval} [result] A Interval to store the nearest and farthest distances.\r\n * @returns {Interval} The nearest and farthest distances on the bounding box from position in direction.\r\n */\r\nOrientedBoundingBox.prototype.computePlaneDistances = function (\r\n  position,\r\n  direction,\r\n  result\r\n) {\r\n  return OrientedBoundingBox.computePlaneDistances(\r\n    this,\r\n    position,\r\n    direction,\r\n    result\r\n  );\r\n};\r\n\r\n/**\r\n * Computes the eight corners of an oriented bounding box. The corners are ordered by (-X, -Y, -Z), (-X, -Y, +Z), (-X, +Y, -Z), (-X, +Y, +Z), (+X, -Y, -Z), (+X, -Y, +Z), (+X, +Y, -Z), (+X, +Y, +Z).\r\n *\r\n * @param {Cartesian3[]} [result] An array of eight {@link Cartesian3} instances onto which to store the corners.\r\n * @returns {Cartesian3[]} The modified result parameter or a new array if none was provided.\r\n */\r\nOrientedBoundingBox.prototype.computeCorners = function (result) {\r\n  return OrientedBoundingBox.computeCorners(this, result);\r\n};\r\n\r\n/**\r\n * Computes a transformation matrix from an oriented bounding box.\r\n *\r\n * @param {Matrix4} result The object onto which to store the result.\r\n * @returns {Matrix4} The modified result parameter or a new {@link Matrix4} instance if none was provided.\r\n */\r\nOrientedBoundingBox.prototype.computeTransformation = function (result) {\r\n  return OrientedBoundingBox.computeTransformation(this, result);\r\n};\r\n\r\n/**\r\n * Determines whether or not a bounding box is hidden from view by the occluder.\r\n *\r\n * @param {Occluder} occluder The occluder.\r\n * @returns {Boolean} <code>true</code> if the sphere is not visible; otherwise <code>false</code>.\r\n */\r\nOrientedBoundingBox.prototype.isOccluded = function (occluder) {\r\n  return OrientedBoundingBox.isOccluded(this, occluder);\r\n};\r\n\r\n/**\r\n * Compares the provided OrientedBoundingBox componentwise and returns\r\n * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n *\r\n * @param {OrientedBoundingBox} left The first OrientedBoundingBox.\r\n * @param {OrientedBoundingBox} right The second OrientedBoundingBox.\r\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\r\n */\r\nOrientedBoundingBox.equals = function (left, right) {\r\n  return (\r\n    left === right ||\r\n    (defined(left) &&\r\n      defined(right) &&\r\n      Cartesian3.equals(left.center, right.center) &&\r\n      Matrix3.equals(left.halfAxes, right.halfAxes))\r\n  );\r\n};\r\n\r\n/**\r\n * Duplicates this OrientedBoundingBox instance.\r\n *\r\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\r\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.\r\n */\r\nOrientedBoundingBox.prototype.clone = function (result) {\r\n  return OrientedBoundingBox.clone(this, result);\r\n};\r\n\r\n/**\r\n * Compares this OrientedBoundingBox against the provided OrientedBoundingBox componentwise and returns\r\n * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n *\r\n * @param {OrientedBoundingBox} [right] The right hand side OrientedBoundingBox.\r\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\r\n */\r\nOrientedBoundingBox.prototype.equals = function (right) {\r\n  return OrientedBoundingBox.equals(this, right);\r\n};\r\nexport default OrientedBoundingBox;\r\n"],"names":["OrientedBoundingBox","center","halfAxes","this","Cartesian3","clone","defaultValue","ZERO","Matrix3","packedLength","pack","value","array","startingIndex","Check","typeOf","object","defined","unpack","result","scratchCartesian1","scratchCartesian2","scratchCartesian3","scratchCartesian4","scratchCartesian5","scratchCartesian6","scratchCovarianceResult","scratchEigenResult","unitary","diagonal","fromPoints","positions","length","i","meanPoint","add","invLength","multiplyByScalar","p","exx","exy","exz","eyy","eyz","ezz","subtract","x","y","z","covarianceMatrix","eigenDecomposition","computeEigenDecomposition","rotation","v1","getColumn","v2","v3","u1","Number","MAX_VALUE","u2","u3","l1","l2","l3","Math","max","dot","min","scale","multiplyByScale","scratchOffset","scratchScale","fromPlaneExtents","planeOrigin","planeXAxis","planeYAxis","planeZAxis","minimumX","maximumX","minimumY","maximumY","minimumZ","maximumZ","DeveloperError","setColumn","centerOffset","multiplyByVector","scratchRectangleCenterCartographic","Cartographic","scratchRectangleCenter","scratchPerimeterCartographicNC","scratchPerimeterCartographicNW","scratchPerimeterCartographicCW","scratchPerimeterCartographicSW","scratchPerimeterCartographicSC","scratchPerimeterCartesianNC","scratchPerimeterCartesianNW","scratchPerimeterCartesianCW","scratchPerimeterCartesianSW","scratchPerimeterCartesianSC","scratchPerimeterProjectedNC","Cartesian2","scratchPerimeterProjectedNW","scratchPerimeterProjectedCW","scratchPerimeterProjectedSW","scratchPerimeterProjectedSC","scratchPlaneOrigin","scratchPlaneNormal","scratchPlaneXAxis","scratchHorizonCartesian","scratchHorizonProjected","scratchMaxY","scratchMinY","scratchZ","scratchPlane","Plane","UNIT_X","fromRectangle","rectangle","minimumHeight","maximumHeight","ellipsoid","width","CesiumMath","TWO_PI","height","PI","equalsEpsilon","radii","EPSILON15","minX","maxX","minY","maxY","minZ","maxZ","plane","Ellipsoid","WGS84","tangentPointCartographic","Rectangle","tangentPoint","cartographicToCartesian","tangentPlane","EllipsoidTangentPlane","lonCenter","longitude","latCenter","south","north","latitude","perimeterCartographicNC","fromRadians","perimeterCartographicNW","west","perimeterCartographicCW","perimeterCartographicSW","perimeterCartographicSC","perimeterCartesianNC","perimeterCartesianNW","perimeterCartesianCW","perimeterCartesianSW","perimeterCartesianSC","perimeterProjectedNC","projectPointToNearestOnPlane","perimeterProjectedNW","perimeterProjectedCW","perimeterProjectedSW","perimeterProjectedSC","getPointDistance","origin","xAxis","yAxis","zAxis","fullyAboveEquator","fullyBelowEquator","latitudeNearestToEquator","centerLongitude","planeNormal","abs","EPSILON10","normalize","UNIT_Z","cross","fromPointNormal","horizonCartesian","PI_OVER_TWO","projectPointOntoPlane","farZ","east","fromTransformation","transformation","Matrix4","getTranslation","getMatrix3","box","intersectPlane","normal","normalX","normalY","normalZ","radEffective","COLUMN0ROW0","COLUMN0ROW1","COLUMN0ROW2","COLUMN1ROW0","COLUMN1ROW1","COLUMN1ROW2","COLUMN2ROW0","COLUMN2ROW1","COLUMN2ROW2","distanceToPlane","distance","Intersect","OUTSIDE","INSIDE","INTERSECTING","scratchCartesianU","scratchCartesianV","scratchCartesianW","scratchValidAxis2","scratchValidAxis3","scratchPPrime","distanceSquaredTo","cartesian","offset","u","v","w","uHalf","magnitude","vHalf","wHalf","uValid","vValid","wValid","divideByScalar","numberOfDegenerateAxes","validAxis1","validAxis2","validAxis3","degenerateAxis","crossVector","UNIT_Y","EPSILON3","pPrime","d","distanceSquared","scratchCorner","scratchToCenter","computePlaneDistances","position","direction","Interval","minDist","POSITIVE_INFINITY","maxDist","NEGATIVE_INFINITY","corner","toCenter","mag","start","stop","scratchXAxis","scratchYAxis","scratchZAxis","computeCorners","scratchRotationScale","computeTransformation","translation","rotationScale","multiplyByUniformScale","fromRotationTranslation","scratchBoundingSphere","BoundingSphere","isOccluded","occluder","sphere","fromOrientedBoundingBox","isBoundingSphereVisible","prototype","equals","left","right"],"mappings":"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"}