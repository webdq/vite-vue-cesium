{"version":3,"file":"FrustumGeometry-d0beee3a.js","sources":["../../../../Source/Core/CullingVolume.js","../../../../Source/Core/OrthographicOffCenterFrustum.js","../../../../Source/Core/OrthographicFrustum.js","../../../../Source/Core/PerspectiveOffCenterFrustum.js","../../../../Source/Core/PerspectiveFrustum.js","../../../../Source/Core/FrustumGeometry.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\r\nimport Cartesian4 from \"./Cartesian4.js\";\r\nimport defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\nimport DeveloperError from \"./DeveloperError.js\";\r\nimport Intersect from \"./Intersect.js\";\r\nimport Plane from \"./Plane.js\";\r\n\r\n/**\r\n * The culling volume defined by planes.\r\n *\r\n * @alias CullingVolume\r\n * @constructor\r\n *\r\n * @param {Cartesian4[]} [planes] An array of clipping planes.\r\n */\r\nfunction CullingVolume(planes) {\r\n  /**\r\n   * Each plane is represented by a Cartesian4 object, where the x, y, and z components\r\n   * define the unit vector normal to the plane, and the w component is the distance of the\r\n   * plane from the origin.\r\n   * @type {Cartesian4[]}\r\n   * @default []\r\n   */\r\n  this.planes = defaultValue(planes, []);\r\n}\r\n\r\nconst faces = [new Cartesian3(), new Cartesian3(), new Cartesian3()];\r\nCartesian3.clone(Cartesian3.UNIT_X, faces[0]);\r\nCartesian3.clone(Cartesian3.UNIT_Y, faces[1]);\r\nCartesian3.clone(Cartesian3.UNIT_Z, faces[2]);\r\n\r\nconst scratchPlaneCenter = new Cartesian3();\r\nconst scratchPlaneNormal = new Cartesian3();\r\nconst scratchPlane = new Plane(new Cartesian3(1.0, 0.0, 0.0), 0.0);\r\n\r\n/**\r\n * Constructs a culling volume from a bounding sphere. Creates six planes that create a box containing the sphere.\r\n * The planes are aligned to the x, y, and z axes in world coordinates.\r\n *\r\n * @param {BoundingSphere} boundingSphere The bounding sphere used to create the culling volume.\r\n * @param {CullingVolume} [result] The object onto which to store the result.\r\n * @returns {CullingVolume} The culling volume created from the bounding sphere.\r\n */\r\nCullingVolume.fromBoundingSphere = function (boundingSphere, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(boundingSphere)) {\r\n    throw new DeveloperError(\"boundingSphere is required.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    result = new CullingVolume();\r\n  }\r\n\r\n  const length = faces.length;\r\n  const planes = result.planes;\r\n  planes.length = 2 * length;\r\n\r\n  const center = boundingSphere.center;\r\n  const radius = boundingSphere.radius;\r\n\r\n  let planeIndex = 0;\r\n\r\n  for (let i = 0; i < length; ++i) {\r\n    const faceNormal = faces[i];\r\n\r\n    let plane0 = planes[planeIndex];\r\n    let plane1 = planes[planeIndex + 1];\r\n\r\n    if (!defined(plane0)) {\r\n      plane0 = planes[planeIndex] = new Cartesian4();\r\n    }\r\n    if (!defined(plane1)) {\r\n      plane1 = planes[planeIndex + 1] = new Cartesian4();\r\n    }\r\n\r\n    Cartesian3.multiplyByScalar(faceNormal, -radius, scratchPlaneCenter);\r\n    Cartesian3.add(center, scratchPlaneCenter, scratchPlaneCenter);\r\n\r\n    plane0.x = faceNormal.x;\r\n    plane0.y = faceNormal.y;\r\n    plane0.z = faceNormal.z;\r\n    plane0.w = -Cartesian3.dot(faceNormal, scratchPlaneCenter);\r\n\r\n    Cartesian3.multiplyByScalar(faceNormal, radius, scratchPlaneCenter);\r\n    Cartesian3.add(center, scratchPlaneCenter, scratchPlaneCenter);\r\n\r\n    plane1.x = -faceNormal.x;\r\n    plane1.y = -faceNormal.y;\r\n    plane1.z = -faceNormal.z;\r\n    plane1.w = -Cartesian3.dot(\r\n      Cartesian3.negate(faceNormal, scratchPlaneNormal),\r\n      scratchPlaneCenter\r\n    );\r\n\r\n    planeIndex += 2;\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Determines whether a bounding volume intersects the culling volume.\r\n *\r\n * @param {Object} boundingVolume The bounding volume whose intersection with the culling volume is to be tested.\r\n * @returns {Intersect}  Intersect.OUTSIDE, Intersect.INTERSECTING, or Intersect.INSIDE.\r\n */\r\nCullingVolume.prototype.computeVisibility = function (boundingVolume) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(boundingVolume)) {\r\n    throw new DeveloperError(\"boundingVolume is required.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const planes = this.planes;\r\n  let intersecting = false;\r\n  for (let k = 0, len = planes.length; k < len; ++k) {\r\n    const result = boundingVolume.intersectPlane(\r\n      Plane.fromCartesian4(planes[k], scratchPlane)\r\n    );\r\n    if (result === Intersect.OUTSIDE) {\r\n      return Intersect.OUTSIDE;\r\n    } else if (result === Intersect.INTERSECTING) {\r\n      intersecting = true;\r\n    }\r\n  }\r\n\r\n  return intersecting ? Intersect.INTERSECTING : Intersect.INSIDE;\r\n};\r\n\r\n/**\r\n * Determines whether a bounding volume intersects the culling volume.\r\n *\r\n * @param {Object} boundingVolume The bounding volume whose intersection with the culling volume is to be tested.\r\n * @param {Number} parentPlaneMask A bit mask from the boundingVolume's parent's check against the same culling\r\n *                                 volume, such that if (planeMask & (1 << planeIndex) === 0), for k < 31, then\r\n *                                 the parent (and therefore this) volume is completely inside plane[planeIndex]\r\n *                                 and that plane check can be skipped.\r\n * @returns {Number} A plane mask as described above (which can be applied to this boundingVolume's children).\r\n *\r\n * @private\r\n */\r\nCullingVolume.prototype.computeVisibilityWithPlaneMask = function (\r\n  boundingVolume,\r\n  parentPlaneMask\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(boundingVolume)) {\r\n    throw new DeveloperError(\"boundingVolume is required.\");\r\n  }\r\n  if (!defined(parentPlaneMask)) {\r\n    throw new DeveloperError(\"parentPlaneMask is required.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  if (\r\n    parentPlaneMask === CullingVolume.MASK_OUTSIDE ||\r\n    parentPlaneMask === CullingVolume.MASK_INSIDE\r\n  ) {\r\n    // parent is completely outside or completely inside, so this child is as well.\r\n    return parentPlaneMask;\r\n  }\r\n\r\n  // Start with MASK_INSIDE (all zeros) so that after the loop, the return value can be compared with MASK_INSIDE.\r\n  // (Because if there are fewer than 31 planes, the upper bits wont be changed.)\r\n  let mask = CullingVolume.MASK_INSIDE;\r\n\r\n  const planes = this.planes;\r\n  for (let k = 0, len = planes.length; k < len; ++k) {\r\n    // For k greater than 31 (since 31 is the maximum number of INSIDE/INTERSECTING bits we can store), skip the optimization.\r\n    const flag = k < 31 ? 1 << k : 0;\r\n    if (k < 31 && (parentPlaneMask & flag) === 0) {\r\n      // boundingVolume is known to be INSIDE this plane.\r\n      continue;\r\n    }\r\n\r\n    const result = boundingVolume.intersectPlane(\r\n      Plane.fromCartesian4(planes[k], scratchPlane)\r\n    );\r\n    if (result === Intersect.OUTSIDE) {\r\n      return CullingVolume.MASK_OUTSIDE;\r\n    } else if (result === Intersect.INTERSECTING) {\r\n      mask |= flag;\r\n    }\r\n  }\r\n\r\n  return mask;\r\n};\r\n\r\n/**\r\n * For plane masks (as used in {@link CullingVolume#computeVisibilityWithPlaneMask}), this special value\r\n * represents the case where the object bounding volume is entirely outside the culling volume.\r\n *\r\n * @type {Number}\r\n * @private\r\n */\r\nCullingVolume.MASK_OUTSIDE = 0xffffffff;\r\n\r\n/**\r\n * For plane masks (as used in {@link CullingVolume.prototype.computeVisibilityWithPlaneMask}), this value\r\n * represents the case where the object bounding volume is entirely inside the culling volume.\r\n *\r\n * @type {Number}\r\n * @private\r\n */\r\nCullingVolume.MASK_INSIDE = 0x00000000;\r\n\r\n/**\r\n * For plane masks (as used in {@link CullingVolume.prototype.computeVisibilityWithPlaneMask}), this value\r\n * represents the case where the object bounding volume (may) intersect all planes of the culling volume.\r\n *\r\n * @type {Number}\r\n * @private\r\n */\r\nCullingVolume.MASK_INDETERMINATE = 0x7fffffff;\r\nexport default CullingVolume;\r\n","import Cartesian3 from \"./Cartesian3.js\";\r\nimport Cartesian4 from \"./Cartesian4.js\";\r\nimport CullingVolume from \"./CullingVolume.js\";\r\nimport defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\nimport DeveloperError from \"./DeveloperError.js\";\r\nimport CesiumMath from \"./Math.js\";\r\nimport Matrix4 from \"./Matrix4.js\";\r\n\r\n/**\r\n * The viewing frustum is defined by 6 planes.\r\n * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components\r\n * define the unit vector normal to the plane, and the w component is the distance of the\r\n * plane from the origin/camera position.\r\n *\r\n * @alias OrthographicOffCenterFrustum\r\n * @constructor\r\n *\r\n * @param {Object} [options] An object with the following properties:\r\n * @param {Number} [options.left] The left clipping plane distance.\r\n * @param {Number} [options.right] The right clipping plane distance.\r\n * @param {Number} [options.top] The top clipping plane distance.\r\n * @param {Number} [options.bottom] The bottom clipping plane distance.\r\n * @param {Number} [options.near=1.0] The near clipping plane distance.\r\n * @param {Number} [options.far=500000000.0] The far clipping plane distance.\r\n *\r\n * @example\r\n * const maxRadii = ellipsoid.maximumRadius;\r\n *\r\n * const frustum = new Cesium.OrthographicOffCenterFrustum();\r\n * frustum.right = maxRadii * Cesium.Math.PI;\r\n * frustum.left = -c.frustum.right;\r\n * frustum.top = c.frustum.right * (canvas.clientHeight / canvas.clientWidth);\r\n * frustum.bottom = -c.frustum.top;\r\n * frustum.near = 0.01 * maxRadii;\r\n * frustum.far = 50.0 * maxRadii;\r\n */\r\nfunction OrthographicOffCenterFrustum(options) {\r\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n\r\n  /**\r\n   * The left clipping plane.\r\n   * @type {Number}\r\n   * @default undefined\r\n   */\r\n  this.left = options.left;\r\n  this._left = undefined;\r\n\r\n  /**\r\n   * The right clipping plane.\r\n   * @type {Number}\r\n   * @default undefined\r\n   */\r\n  this.right = options.right;\r\n  this._right = undefined;\r\n\r\n  /**\r\n   * The top clipping plane.\r\n   * @type {Number}\r\n   * @default undefined\r\n   */\r\n  this.top = options.top;\r\n  this._top = undefined;\r\n\r\n  /**\r\n   * The bottom clipping plane.\r\n   * @type {Number}\r\n   * @default undefined\r\n   */\r\n  this.bottom = options.bottom;\r\n  this._bottom = undefined;\r\n\r\n  /**\r\n   * The distance of the near plane.\r\n   * @type {Number}\r\n   * @default 1.0\r\n   */\r\n  this.near = defaultValue(options.near, 1.0);\r\n  this._near = this.near;\r\n\r\n  /**\r\n   * The distance of the far plane.\r\n   * @type {Number}\r\n   * @default 500000000.0;\r\n   */\r\n  this.far = defaultValue(options.far, 500000000.0);\r\n  this._far = this.far;\r\n\r\n  this._cullingVolume = new CullingVolume();\r\n  this._orthographicMatrix = new Matrix4();\r\n}\r\n\r\nfunction update(frustum) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (\r\n    !defined(frustum.right) ||\r\n    !defined(frustum.left) ||\r\n    !defined(frustum.top) ||\r\n    !defined(frustum.bottom) ||\r\n    !defined(frustum.near) ||\r\n    !defined(frustum.far)\r\n  ) {\r\n    throw new DeveloperError(\r\n      \"right, left, top, bottom, near, or far parameters are not set.\"\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  if (\r\n    frustum.top !== frustum._top ||\r\n    frustum.bottom !== frustum._bottom ||\r\n    frustum.left !== frustum._left ||\r\n    frustum.right !== frustum._right ||\r\n    frustum.near !== frustum._near ||\r\n    frustum.far !== frustum._far\r\n  ) {\r\n    //>>includeStart('debug', pragmas.debug);\r\n    if (frustum.left > frustum.right) {\r\n      throw new DeveloperError(\"right must be greater than left.\");\r\n    }\r\n    if (frustum.bottom > frustum.top) {\r\n      throw new DeveloperError(\"top must be greater than bottom.\");\r\n    }\r\n    if (frustum.near <= 0 || frustum.near > frustum.far) {\r\n      throw new DeveloperError(\r\n        \"near must be greater than zero and less than far.\"\r\n      );\r\n    }\r\n    //>>includeEnd('debug');\r\n\r\n    frustum._left = frustum.left;\r\n    frustum._right = frustum.right;\r\n    frustum._top = frustum.top;\r\n    frustum._bottom = frustum.bottom;\r\n    frustum._near = frustum.near;\r\n    frustum._far = frustum.far;\r\n    frustum._orthographicMatrix = Matrix4.computeOrthographicOffCenter(\r\n      frustum.left,\r\n      frustum.right,\r\n      frustum.bottom,\r\n      frustum.top,\r\n      frustum.near,\r\n      frustum.far,\r\n      frustum._orthographicMatrix\r\n    );\r\n  }\r\n}\r\n\r\nObject.defineProperties(OrthographicOffCenterFrustum.prototype, {\r\n  /**\r\n   * Gets the orthographic projection matrix computed from the view frustum.\r\n   * @memberof OrthographicOffCenterFrustum.prototype\r\n   * @type {Matrix4}\r\n   * @readonly\r\n   */\r\n  projectionMatrix: {\r\n    get: function () {\r\n      update(this);\r\n      return this._orthographicMatrix;\r\n    },\r\n  },\r\n});\r\n\r\nconst getPlanesRight = new Cartesian3();\r\nconst getPlanesNearCenter = new Cartesian3();\r\nconst getPlanesPoint = new Cartesian3();\r\nconst negateScratch = new Cartesian3();\r\n\r\n/**\r\n * Creates a culling volume for this frustum.\r\n *\r\n * @param {Cartesian3} position The eye position.\r\n * @param {Cartesian3} direction The view direction.\r\n * @param {Cartesian3} up The up direction.\r\n * @returns {CullingVolume} A culling volume at the given position and orientation.\r\n *\r\n * @example\r\n * // Check if a bounding volume intersects the frustum.\r\n * const cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\r\n * const intersect = cullingVolume.computeVisibility(boundingVolume);\r\n */\r\nOrthographicOffCenterFrustum.prototype.computeCullingVolume = function (\r\n  position,\r\n  direction,\r\n  up\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(position)) {\r\n    throw new DeveloperError(\"position is required.\");\r\n  }\r\n  if (!defined(direction)) {\r\n    throw new DeveloperError(\"direction is required.\");\r\n  }\r\n  if (!defined(up)) {\r\n    throw new DeveloperError(\"up is required.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const planes = this._cullingVolume.planes;\r\n  const t = this.top;\r\n  const b = this.bottom;\r\n  const r = this.right;\r\n  const l = this.left;\r\n  const n = this.near;\r\n  const f = this.far;\r\n\r\n  const right = Cartesian3.cross(direction, up, getPlanesRight);\r\n  Cartesian3.normalize(right, right);\r\n  const nearCenter = getPlanesNearCenter;\r\n  Cartesian3.multiplyByScalar(direction, n, nearCenter);\r\n  Cartesian3.add(position, nearCenter, nearCenter);\r\n\r\n  const point = getPlanesPoint;\r\n\r\n  // Left plane\r\n  Cartesian3.multiplyByScalar(right, l, point);\r\n  Cartesian3.add(nearCenter, point, point);\r\n\r\n  let plane = planes[0];\r\n  if (!defined(plane)) {\r\n    plane = planes[0] = new Cartesian4();\r\n  }\r\n  plane.x = right.x;\r\n  plane.y = right.y;\r\n  plane.z = right.z;\r\n  plane.w = -Cartesian3.dot(right, point);\r\n\r\n  // Right plane\r\n  Cartesian3.multiplyByScalar(right, r, point);\r\n  Cartesian3.add(nearCenter, point, point);\r\n\r\n  plane = planes[1];\r\n  if (!defined(plane)) {\r\n    plane = planes[1] = new Cartesian4();\r\n  }\r\n  plane.x = -right.x;\r\n  plane.y = -right.y;\r\n  plane.z = -right.z;\r\n  plane.w = -Cartesian3.dot(Cartesian3.negate(right, negateScratch), point);\r\n\r\n  // Bottom plane\r\n  Cartesian3.multiplyByScalar(up, b, point);\r\n  Cartesian3.add(nearCenter, point, point);\r\n\r\n  plane = planes[2];\r\n  if (!defined(plane)) {\r\n    plane = planes[2] = new Cartesian4();\r\n  }\r\n  plane.x = up.x;\r\n  plane.y = up.y;\r\n  plane.z = up.z;\r\n  plane.w = -Cartesian3.dot(up, point);\r\n\r\n  // Top plane\r\n  Cartesian3.multiplyByScalar(up, t, point);\r\n  Cartesian3.add(nearCenter, point, point);\r\n\r\n  plane = planes[3];\r\n  if (!defined(plane)) {\r\n    plane = planes[3] = new Cartesian4();\r\n  }\r\n  plane.x = -up.x;\r\n  plane.y = -up.y;\r\n  plane.z = -up.z;\r\n  plane.w = -Cartesian3.dot(Cartesian3.negate(up, negateScratch), point);\r\n\r\n  // Near plane\r\n  plane = planes[4];\r\n  if (!defined(plane)) {\r\n    plane = planes[4] = new Cartesian4();\r\n  }\r\n  plane.x = direction.x;\r\n  plane.y = direction.y;\r\n  plane.z = direction.z;\r\n  plane.w = -Cartesian3.dot(direction, nearCenter);\r\n\r\n  // Far plane\r\n  Cartesian3.multiplyByScalar(direction, f, point);\r\n  Cartesian3.add(position, point, point);\r\n\r\n  plane = planes[5];\r\n  if (!defined(plane)) {\r\n    plane = planes[5] = new Cartesian4();\r\n  }\r\n  plane.x = -direction.x;\r\n  plane.y = -direction.y;\r\n  plane.z = -direction.z;\r\n  plane.w = -Cartesian3.dot(Cartesian3.negate(direction, negateScratch), point);\r\n\r\n  return this._cullingVolume;\r\n};\r\n\r\n/**\r\n * Returns the pixel's width and height in meters.\r\n *\r\n * @param {Number} drawingBufferWidth The width of the drawing buffer.\r\n * @param {Number} drawingBufferHeight The height of the drawing buffer.\r\n * @param {Number} distance The distance to the near plane in meters.\r\n * @param {Number} pixelRatio The scaling factor from pixel space to coordinate space.\r\n * @param {Cartesian2} result The object onto which to store the result.\r\n * @returns {Cartesian2} The modified result parameter or a new instance of {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.\r\n *\r\n * @exception {DeveloperError} drawingBufferWidth must be greater than zero.\r\n * @exception {DeveloperError} drawingBufferHeight must be greater than zero.\r\n * @exception {DeveloperError} pixelRatio must be greater than zero.\r\n *\r\n * @example\r\n * // Example 1\r\n * // Get the width and height of a pixel.\r\n * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 0.0, scene.pixelRatio, new Cesium.Cartesian2());\r\n */\r\nOrthographicOffCenterFrustum.prototype.getPixelDimensions = function (\r\n  drawingBufferWidth,\r\n  drawingBufferHeight,\r\n  distance,\r\n  pixelRatio,\r\n  result\r\n) {\r\n  update(this);\r\n\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(drawingBufferWidth) || !defined(drawingBufferHeight)) {\r\n    throw new DeveloperError(\r\n      \"Both drawingBufferWidth and drawingBufferHeight are required.\"\r\n    );\r\n  }\r\n  if (drawingBufferWidth <= 0) {\r\n    throw new DeveloperError(\"drawingBufferWidth must be greater than zero.\");\r\n  }\r\n  if (drawingBufferHeight <= 0) {\r\n    throw new DeveloperError(\"drawingBufferHeight must be greater than zero.\");\r\n  }\r\n  if (!defined(distance)) {\r\n    throw new DeveloperError(\"distance is required.\");\r\n  }\r\n  if (!defined(pixelRatio)) {\r\n    throw new DeveloperError(\"pixelRatio is required.\");\r\n  }\r\n  if (pixelRatio <= 0) {\r\n    throw new DeveloperError(\"pixelRatio must be greater than zero.\");\r\n  }\r\n  if (!defined(result)) {\r\n    throw new DeveloperError(\"A result object is required.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const frustumWidth = this.right - this.left;\r\n  const frustumHeight = this.top - this.bottom;\r\n  const pixelWidth = (pixelRatio * frustumWidth) / drawingBufferWidth;\r\n  const pixelHeight = (pixelRatio * frustumHeight) / drawingBufferHeight;\r\n\r\n  result.x = pixelWidth;\r\n  result.y = pixelHeight;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Returns a duplicate of a OrthographicOffCenterFrustum instance.\r\n *\r\n * @param {OrthographicOffCenterFrustum} [result] The object onto which to store the result.\r\n * @returns {OrthographicOffCenterFrustum} The modified result parameter or a new OrthographicOffCenterFrustum instance if one was not provided.\r\n */\r\nOrthographicOffCenterFrustum.prototype.clone = function (result) {\r\n  if (!defined(result)) {\r\n    result = new OrthographicOffCenterFrustum();\r\n  }\r\n\r\n  result.left = this.left;\r\n  result.right = this.right;\r\n  result.top = this.top;\r\n  result.bottom = this.bottom;\r\n  result.near = this.near;\r\n  result.far = this.far;\r\n\r\n  // force update of clone to compute matrices\r\n  result._left = undefined;\r\n  result._right = undefined;\r\n  result._top = undefined;\r\n  result._bottom = undefined;\r\n  result._near = undefined;\r\n  result._far = undefined;\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Compares the provided OrthographicOffCenterFrustum componentwise and returns\r\n * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n *\r\n * @param {OrthographicOffCenterFrustum} [other] The right hand side OrthographicOffCenterFrustum.\r\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\r\n */\r\nOrthographicOffCenterFrustum.prototype.equals = function (other) {\r\n  return (\r\n    defined(other) &&\r\n    other instanceof OrthographicOffCenterFrustum &&\r\n    this.right === other.right &&\r\n    this.left === other.left &&\r\n    this.top === other.top &&\r\n    this.bottom === other.bottom &&\r\n    this.near === other.near &&\r\n    this.far === other.far\r\n  );\r\n};\r\n\r\n/**\r\n * Compares the provided OrthographicOffCenterFrustum componentwise and returns\r\n * <code>true</code> if they pass an absolute or relative tolerance test,\r\n * <code>false</code> otherwise.\r\n *\r\n * @param {OrthographicOffCenterFrustum} other The right hand side OrthographicOffCenterFrustum.\r\n * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\r\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\r\n * @returns {Boolean} <code>true</code> if this and other are within the provided epsilon, <code>false</code> otherwise.\r\n */\r\nOrthographicOffCenterFrustum.prototype.equalsEpsilon = function (\r\n  other,\r\n  relativeEpsilon,\r\n  absoluteEpsilon\r\n) {\r\n  return (\r\n    other === this ||\r\n    (defined(other) &&\r\n      other instanceof OrthographicOffCenterFrustum &&\r\n      CesiumMath.equalsEpsilon(\r\n        this.right,\r\n        other.right,\r\n        relativeEpsilon,\r\n        absoluteEpsilon\r\n      ) &&\r\n      CesiumMath.equalsEpsilon(\r\n        this.left,\r\n        other.left,\r\n        relativeEpsilon,\r\n        absoluteEpsilon\r\n      ) &&\r\n      CesiumMath.equalsEpsilon(\r\n        this.top,\r\n        other.top,\r\n        relativeEpsilon,\r\n        absoluteEpsilon\r\n      ) &&\r\n      CesiumMath.equalsEpsilon(\r\n        this.bottom,\r\n        other.bottom,\r\n        relativeEpsilon,\r\n        absoluteEpsilon\r\n      ) &&\r\n      CesiumMath.equalsEpsilon(\r\n        this.near,\r\n        other.near,\r\n        relativeEpsilon,\r\n        absoluteEpsilon\r\n      ) &&\r\n      CesiumMath.equalsEpsilon(\r\n        this.far,\r\n        other.far,\r\n        relativeEpsilon,\r\n        absoluteEpsilon\r\n      ))\r\n  );\r\n};\r\nexport default OrthographicOffCenterFrustum;\r\n","import Check from \"./Check.js\";\r\nimport defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\nimport DeveloperError from \"./DeveloperError.js\";\r\nimport CesiumMath from \"./Math.js\";\r\nimport OrthographicOffCenterFrustum from \"./OrthographicOffCenterFrustum.js\";\r\n\r\n/**\r\n * The viewing frustum is defined by 6 planes.\r\n * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components\r\n * define the unit vector normal to the plane, and the w component is the distance of the\r\n * plane from the origin/camera position.\r\n *\r\n * @alias OrthographicFrustum\r\n * @constructor\r\n *\r\n * @param {Object} [options] An object with the following properties:\r\n * @param {Number} [options.width] The width of the frustum in meters.\r\n * @param {Number} [options.aspectRatio] The aspect ratio of the frustum's width to it's height.\r\n * @param {Number} [options.near=1.0] The distance of the near plane.\r\n * @param {Number} [options.far=500000000.0] The distance of the far plane.\r\n *\r\n * @example\r\n * const maxRadii = ellipsoid.maximumRadius;\r\n *\r\n * const frustum = new Cesium.OrthographicFrustum();\r\n * frustum.near = 0.01 * maxRadii;\r\n * frustum.far = 50.0 * maxRadii;\r\n */\r\nfunction OrthographicFrustum(options) {\r\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n\r\n  this._offCenterFrustum = new OrthographicOffCenterFrustum();\r\n\r\n  /**\r\n   * The horizontal width of the frustum in meters.\r\n   * @type {Number}\r\n   * @default undefined\r\n   */\r\n  this.width = options.width;\r\n  this._width = undefined;\r\n\r\n  /**\r\n   * The aspect ratio of the frustum's width to it's height.\r\n   * @type {Number}\r\n   * @default undefined\r\n   */\r\n  this.aspectRatio = options.aspectRatio;\r\n  this._aspectRatio = undefined;\r\n\r\n  /**\r\n   * The distance of the near plane.\r\n   * @type {Number}\r\n   * @default 1.0\r\n   */\r\n  this.near = defaultValue(options.near, 1.0);\r\n  this._near = this.near;\r\n\r\n  /**\r\n   * The distance of the far plane.\r\n   * @type {Number}\r\n   * @default 500000000.0;\r\n   */\r\n  this.far = defaultValue(options.far, 500000000.0);\r\n  this._far = this.far;\r\n}\r\n\r\n/**\r\n * The number of elements used to pack the object into an array.\r\n * @type {Number}\r\n */\r\nOrthographicFrustum.packedLength = 4;\r\n\r\n/**\r\n * Stores the provided instance into the provided array.\r\n *\r\n * @param {OrthographicFrustum} value The value to pack.\r\n * @param {Number[]} array The array to pack into.\r\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n *\r\n * @returns {Number[]} The array that was packed into\r\n */\r\nOrthographicFrustum.pack = function (value, array, startingIndex) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"value\", value);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  array[startingIndex++] = value.width;\r\n  array[startingIndex++] = value.aspectRatio;\r\n  array[startingIndex++] = value.near;\r\n  array[startingIndex] = value.far;\r\n\r\n  return array;\r\n};\r\n\r\n/**\r\n * Retrieves an instance from a packed array.\r\n *\r\n * @param {Number[]} array The packed array.\r\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n * @param {OrthographicFrustum} [result] The object into which to store the result.\r\n * @returns {OrthographicFrustum} The modified result parameter or a new OrthographicFrustum instance if one was not provided.\r\n */\r\nOrthographicFrustum.unpack = function (array, startingIndex, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  if (!defined(result)) {\r\n    result = new OrthographicFrustum();\r\n  }\r\n\r\n  result.width = array[startingIndex++];\r\n  result.aspectRatio = array[startingIndex++];\r\n  result.near = array[startingIndex++];\r\n  result.far = array[startingIndex];\r\n\r\n  return result;\r\n};\r\n\r\nfunction update(frustum) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (\r\n    !defined(frustum.width) ||\r\n    !defined(frustum.aspectRatio) ||\r\n    !defined(frustum.near) ||\r\n    !defined(frustum.far)\r\n  ) {\r\n    throw new DeveloperError(\r\n      \"width, aspectRatio, near, or far parameters are not set.\"\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const f = frustum._offCenterFrustum;\r\n\r\n  if (\r\n    frustum.width !== frustum._width ||\r\n    frustum.aspectRatio !== frustum._aspectRatio ||\r\n    frustum.near !== frustum._near ||\r\n    frustum.far !== frustum._far\r\n  ) {\r\n    //>>includeStart('debug', pragmas.debug);\r\n    if (frustum.aspectRatio < 0) {\r\n      throw new DeveloperError(\"aspectRatio must be positive.\");\r\n    }\r\n    if (frustum.near < 0 || frustum.near > frustum.far) {\r\n      throw new DeveloperError(\r\n        \"near must be greater than zero and less than far.\"\r\n      );\r\n    }\r\n    //>>includeEnd('debug');\r\n\r\n    frustum._aspectRatio = frustum.aspectRatio;\r\n    frustum._width = frustum.width;\r\n    frustum._near = frustum.near;\r\n    frustum._far = frustum.far;\r\n\r\n    const ratio = 1.0 / frustum.aspectRatio;\r\n    f.right = frustum.width * 0.5;\r\n    f.left = -f.right;\r\n    f.top = ratio * f.right;\r\n    f.bottom = -f.top;\r\n    f.near = frustum.near;\r\n    f.far = frustum.far;\r\n  }\r\n}\r\n\r\nObject.defineProperties(OrthographicFrustum.prototype, {\r\n  /**\r\n   * Gets the orthographic projection matrix computed from the view frustum.\r\n   * @memberof OrthographicFrustum.prototype\r\n   * @type {Matrix4}\r\n   * @readonly\r\n   */\r\n  projectionMatrix: {\r\n    get: function () {\r\n      update(this);\r\n      return this._offCenterFrustum.projectionMatrix;\r\n    },\r\n  },\r\n});\r\n\r\n/**\r\n * Creates a culling volume for this frustum.\r\n *\r\n * @param {Cartesian3} position The eye position.\r\n * @param {Cartesian3} direction The view direction.\r\n * @param {Cartesian3} up The up direction.\r\n * @returns {CullingVolume} A culling volume at the given position and orientation.\r\n *\r\n * @example\r\n * // Check if a bounding volume intersects the frustum.\r\n * const cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\r\n * const intersect = cullingVolume.computeVisibility(boundingVolume);\r\n */\r\nOrthographicFrustum.prototype.computeCullingVolume = function (\r\n  position,\r\n  direction,\r\n  up\r\n) {\r\n  update(this);\r\n  return this._offCenterFrustum.computeCullingVolume(position, direction, up);\r\n};\r\n\r\n/**\r\n * Returns the pixel's width and height in meters.\r\n *\r\n * @param {Number} drawingBufferWidth The width of the drawing buffer.\r\n * @param {Number} drawingBufferHeight The height of the drawing buffer.\r\n * @param {Number} distance The distance to the near plane in meters.\r\n * @param {Number} pixelRatio The scaling factor from pixel space to coordinate space.\r\n * @param {Cartesian2} result The object onto which to store the result.\r\n * @returns {Cartesian2} The modified result parameter or a new instance of {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.\r\n *\r\n * @exception {DeveloperError} drawingBufferWidth must be greater than zero.\r\n * @exception {DeveloperError} drawingBufferHeight must be greater than zero.\r\n * @exception {DeveloperError} pixelRatio must be greater than zero.\r\n *\r\n * @example\r\n * // Example 1\r\n * // Get the width and height of a pixel.\r\n * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 0.0, scene.pixelRatio, new Cesium.Cartesian2());\r\n */\r\nOrthographicFrustum.prototype.getPixelDimensions = function (\r\n  drawingBufferWidth,\r\n  drawingBufferHeight,\r\n  distance,\r\n  pixelRatio,\r\n  result\r\n) {\r\n  update(this);\r\n  return this._offCenterFrustum.getPixelDimensions(\r\n    drawingBufferWidth,\r\n    drawingBufferHeight,\r\n    distance,\r\n    pixelRatio,\r\n    result\r\n  );\r\n};\r\n\r\n/**\r\n * Returns a duplicate of a OrthographicFrustum instance.\r\n *\r\n * @param {OrthographicFrustum} [result] The object onto which to store the result.\r\n * @returns {OrthographicFrustum} The modified result parameter or a new OrthographicFrustum instance if one was not provided.\r\n */\r\nOrthographicFrustum.prototype.clone = function (result) {\r\n  if (!defined(result)) {\r\n    result = new OrthographicFrustum();\r\n  }\r\n\r\n  result.aspectRatio = this.aspectRatio;\r\n  result.width = this.width;\r\n  result.near = this.near;\r\n  result.far = this.far;\r\n\r\n  // force update of clone to compute matrices\r\n  result._aspectRatio = undefined;\r\n  result._width = undefined;\r\n  result._near = undefined;\r\n  result._far = undefined;\r\n\r\n  this._offCenterFrustum.clone(result._offCenterFrustum);\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Compares the provided OrthographicFrustum componentwise and returns\r\n * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n *\r\n * @param {OrthographicFrustum} [other] The right hand side OrthographicFrustum.\r\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\r\n */\r\nOrthographicFrustum.prototype.equals = function (other) {\r\n  if (!defined(other) || !(other instanceof OrthographicFrustum)) {\r\n    return false;\r\n  }\r\n\r\n  update(this);\r\n  update(other);\r\n\r\n  return (\r\n    this.width === other.width &&\r\n    this.aspectRatio === other.aspectRatio &&\r\n    this._offCenterFrustum.equals(other._offCenterFrustum)\r\n  );\r\n};\r\n\r\n/**\r\n * Compares the provided OrthographicFrustum componentwise and returns\r\n * <code>true</code> if they pass an absolute or relative tolerance test,\r\n * <code>false</code> otherwise.\r\n *\r\n * @param {OrthographicFrustum} other The right hand side OrthographicFrustum.\r\n * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\r\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\r\n * @returns {Boolean} <code>true</code> if this and other are within the provided epsilon, <code>false</code> otherwise.\r\n */\r\nOrthographicFrustum.prototype.equalsEpsilon = function (\r\n  other,\r\n  relativeEpsilon,\r\n  absoluteEpsilon\r\n) {\r\n  if (!defined(other) || !(other instanceof OrthographicFrustum)) {\r\n    return false;\r\n  }\r\n\r\n  update(this);\r\n  update(other);\r\n\r\n  return (\r\n    CesiumMath.equalsEpsilon(\r\n      this.width,\r\n      other.width,\r\n      relativeEpsilon,\r\n      absoluteEpsilon\r\n    ) &&\r\n    CesiumMath.equalsEpsilon(\r\n      this.aspectRatio,\r\n      other.aspectRatio,\r\n      relativeEpsilon,\r\n      absoluteEpsilon\r\n    ) &&\r\n    this._offCenterFrustum.equalsEpsilon(\r\n      other._offCenterFrustum,\r\n      relativeEpsilon,\r\n      absoluteEpsilon\r\n    )\r\n  );\r\n};\r\nexport default OrthographicFrustum;\r\n","import Cartesian3 from \"./Cartesian3.js\";\r\nimport Cartesian4 from \"./Cartesian4.js\";\r\nimport CullingVolume from \"./CullingVolume.js\";\r\nimport defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\nimport DeveloperError from \"./DeveloperError.js\";\r\nimport CesiumMath from \"./Math.js\";\r\nimport Matrix4 from \"./Matrix4.js\";\r\n\r\n/**\r\n * The viewing frustum is defined by 6 planes.\r\n * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components\r\n * define the unit vector normal to the plane, and the w component is the distance of the\r\n * plane from the origin/camera position.\r\n *\r\n * @alias PerspectiveOffCenterFrustum\r\n * @constructor\r\n *\r\n * @param {Object} [options] An object with the following properties:\r\n * @param {Number} [options.left] The left clipping plane distance.\r\n * @param {Number} [options.right] The right clipping plane distance.\r\n * @param {Number} [options.top] The top clipping plane distance.\r\n * @param {Number} [options.bottom] The bottom clipping plane distance.\r\n * @param {Number} [options.near=1.0] The near clipping plane distance.\r\n * @param {Number} [options.far=500000000.0] The far clipping plane distance.\r\n *\r\n * @example\r\n * const frustum = new Cesium.PerspectiveOffCenterFrustum({\r\n *     left : -1.0,\r\n *     right : 1.0,\r\n *     top : 1.0,\r\n *     bottom : -1.0,\r\n *     near : 1.0,\r\n *     far : 100.0\r\n * });\r\n *\r\n * @see PerspectiveFrustum\r\n */\r\nfunction PerspectiveOffCenterFrustum(options) {\r\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n\r\n  /**\r\n   * Defines the left clipping plane.\r\n   * @type {Number}\r\n   * @default undefined\r\n   */\r\n  this.left = options.left;\r\n  this._left = undefined;\r\n\r\n  /**\r\n   * Defines the right clipping plane.\r\n   * @type {Number}\r\n   * @default undefined\r\n   */\r\n  this.right = options.right;\r\n  this._right = undefined;\r\n\r\n  /**\r\n   * Defines the top clipping plane.\r\n   * @type {Number}\r\n   * @default undefined\r\n   */\r\n  this.top = options.top;\r\n  this._top = undefined;\r\n\r\n  /**\r\n   * Defines the bottom clipping plane.\r\n   * @type {Number}\r\n   * @default undefined\r\n   */\r\n  this.bottom = options.bottom;\r\n  this._bottom = undefined;\r\n\r\n  /**\r\n   * The distance of the near plane.\r\n   * @type {Number}\r\n   * @default 1.0\r\n   */\r\n  this.near = defaultValue(options.near, 1.0);\r\n  this._near = this.near;\r\n\r\n  /**\r\n   * The distance of the far plane.\r\n   * @type {Number}\r\n   * @default 500000000.0\r\n   */\r\n  this.far = defaultValue(options.far, 500000000.0);\r\n  this._far = this.far;\r\n\r\n  this._cullingVolume = new CullingVolume();\r\n  this._perspectiveMatrix = new Matrix4();\r\n  this._infinitePerspective = new Matrix4();\r\n}\r\n\r\nfunction update(frustum) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (\r\n    !defined(frustum.right) ||\r\n    !defined(frustum.left) ||\r\n    !defined(frustum.top) ||\r\n    !defined(frustum.bottom) ||\r\n    !defined(frustum.near) ||\r\n    !defined(frustum.far)\r\n  ) {\r\n    throw new DeveloperError(\r\n      \"right, left, top, bottom, near, or far parameters are not set.\"\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const t = frustum.top;\r\n  const b = frustum.bottom;\r\n  const r = frustum.right;\r\n  const l = frustum.left;\r\n  const n = frustum.near;\r\n  const f = frustum.far;\r\n\r\n  if (\r\n    t !== frustum._top ||\r\n    b !== frustum._bottom ||\r\n    l !== frustum._left ||\r\n    r !== frustum._right ||\r\n    n !== frustum._near ||\r\n    f !== frustum._far\r\n  ) {\r\n    //>>includeStart('debug', pragmas.debug);\r\n    if (frustum.near <= 0 || frustum.near > frustum.far) {\r\n      throw new DeveloperError(\r\n        \"near must be greater than zero and less than far.\"\r\n      );\r\n    }\r\n    //>>includeEnd('debug');\r\n\r\n    frustum._left = l;\r\n    frustum._right = r;\r\n    frustum._top = t;\r\n    frustum._bottom = b;\r\n    frustum._near = n;\r\n    frustum._far = f;\r\n    frustum._perspectiveMatrix = Matrix4.computePerspectiveOffCenter(\r\n      l,\r\n      r,\r\n      b,\r\n      t,\r\n      n,\r\n      f,\r\n      frustum._perspectiveMatrix\r\n    );\r\n    frustum._infinitePerspective = Matrix4.computeInfinitePerspectiveOffCenter(\r\n      l,\r\n      r,\r\n      b,\r\n      t,\r\n      n,\r\n      frustum._infinitePerspective\r\n    );\r\n  }\r\n}\r\n\r\nObject.defineProperties(PerspectiveOffCenterFrustum.prototype, {\r\n  /**\r\n   * Gets the perspective projection matrix computed from the view frustum.\r\n   * @memberof PerspectiveOffCenterFrustum.prototype\r\n   * @type {Matrix4}\r\n   * @readonly\r\n   *\r\n   * @see PerspectiveOffCenterFrustum#infiniteProjectionMatrix\r\n   */\r\n  projectionMatrix: {\r\n    get: function () {\r\n      update(this);\r\n      return this._perspectiveMatrix;\r\n    },\r\n  },\r\n\r\n  /**\r\n   * Gets the perspective projection matrix computed from the view frustum with an infinite far plane.\r\n   * @memberof PerspectiveOffCenterFrustum.prototype\r\n   * @type {Matrix4}\r\n   * @readonly\r\n   *\r\n   * @see PerspectiveOffCenterFrustum#projectionMatrix\r\n   */\r\n  infiniteProjectionMatrix: {\r\n    get: function () {\r\n      update(this);\r\n      return this._infinitePerspective;\r\n    },\r\n  },\r\n});\r\n\r\nconst getPlanesRight = new Cartesian3();\r\nconst getPlanesNearCenter = new Cartesian3();\r\nconst getPlanesFarCenter = new Cartesian3();\r\nconst getPlanesNormal = new Cartesian3();\r\n/**\r\n * Creates a culling volume for this frustum.\r\n *\r\n * @param {Cartesian3} position The eye position.\r\n * @param {Cartesian3} direction The view direction.\r\n * @param {Cartesian3} up The up direction.\r\n * @returns {CullingVolume} A culling volume at the given position and orientation.\r\n *\r\n * @example\r\n * // Check if a bounding volume intersects the frustum.\r\n * const cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\r\n * const intersect = cullingVolume.computeVisibility(boundingVolume);\r\n */\r\nPerspectiveOffCenterFrustum.prototype.computeCullingVolume = function (\r\n  position,\r\n  direction,\r\n  up\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(position)) {\r\n    throw new DeveloperError(\"position is required.\");\r\n  }\r\n\r\n  if (!defined(direction)) {\r\n    throw new DeveloperError(\"direction is required.\");\r\n  }\r\n\r\n  if (!defined(up)) {\r\n    throw new DeveloperError(\"up is required.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const planes = this._cullingVolume.planes;\r\n\r\n  const t = this.top;\r\n  const b = this.bottom;\r\n  const r = this.right;\r\n  const l = this.left;\r\n  const n = this.near;\r\n  const f = this.far;\r\n\r\n  const right = Cartesian3.cross(direction, up, getPlanesRight);\r\n\r\n  const nearCenter = getPlanesNearCenter;\r\n  Cartesian3.multiplyByScalar(direction, n, nearCenter);\r\n  Cartesian3.add(position, nearCenter, nearCenter);\r\n\r\n  const farCenter = getPlanesFarCenter;\r\n  Cartesian3.multiplyByScalar(direction, f, farCenter);\r\n  Cartesian3.add(position, farCenter, farCenter);\r\n\r\n  const normal = getPlanesNormal;\r\n\r\n  //Left plane computation\r\n  Cartesian3.multiplyByScalar(right, l, normal);\r\n  Cartesian3.add(nearCenter, normal, normal);\r\n  Cartesian3.subtract(normal, position, normal);\r\n  Cartesian3.normalize(normal, normal);\r\n  Cartesian3.cross(normal, up, normal);\r\n  Cartesian3.normalize(normal, normal);\r\n\r\n  let plane = planes[0];\r\n  if (!defined(plane)) {\r\n    plane = planes[0] = new Cartesian4();\r\n  }\r\n  plane.x = normal.x;\r\n  plane.y = normal.y;\r\n  plane.z = normal.z;\r\n  plane.w = -Cartesian3.dot(normal, position);\r\n\r\n  //Right plane computation\r\n  Cartesian3.multiplyByScalar(right, r, normal);\r\n  Cartesian3.add(nearCenter, normal, normal);\r\n  Cartesian3.subtract(normal, position, normal);\r\n  Cartesian3.cross(up, normal, normal);\r\n  Cartesian3.normalize(normal, normal);\r\n\r\n  plane = planes[1];\r\n  if (!defined(plane)) {\r\n    plane = planes[1] = new Cartesian4();\r\n  }\r\n  plane.x = normal.x;\r\n  plane.y = normal.y;\r\n  plane.z = normal.z;\r\n  plane.w = -Cartesian3.dot(normal, position);\r\n\r\n  //Bottom plane computation\r\n  Cartesian3.multiplyByScalar(up, b, normal);\r\n  Cartesian3.add(nearCenter, normal, normal);\r\n  Cartesian3.subtract(normal, position, normal);\r\n  Cartesian3.cross(right, normal, normal);\r\n  Cartesian3.normalize(normal, normal);\r\n\r\n  plane = planes[2];\r\n  if (!defined(plane)) {\r\n    plane = planes[2] = new Cartesian4();\r\n  }\r\n  plane.x = normal.x;\r\n  plane.y = normal.y;\r\n  plane.z = normal.z;\r\n  plane.w = -Cartesian3.dot(normal, position);\r\n\r\n  //Top plane computation\r\n  Cartesian3.multiplyByScalar(up, t, normal);\r\n  Cartesian3.add(nearCenter, normal, normal);\r\n  Cartesian3.subtract(normal, position, normal);\r\n  Cartesian3.cross(normal, right, normal);\r\n  Cartesian3.normalize(normal, normal);\r\n\r\n  plane = planes[3];\r\n  if (!defined(plane)) {\r\n    plane = planes[3] = new Cartesian4();\r\n  }\r\n  plane.x = normal.x;\r\n  plane.y = normal.y;\r\n  plane.z = normal.z;\r\n  plane.w = -Cartesian3.dot(normal, position);\r\n\r\n  //Near plane computation\r\n  plane = planes[4];\r\n  if (!defined(plane)) {\r\n    plane = planes[4] = new Cartesian4();\r\n  }\r\n  plane.x = direction.x;\r\n  plane.y = direction.y;\r\n  plane.z = direction.z;\r\n  plane.w = -Cartesian3.dot(direction, nearCenter);\r\n\r\n  //Far plane computation\r\n  Cartesian3.negate(direction, normal);\r\n\r\n  plane = planes[5];\r\n  if (!defined(plane)) {\r\n    plane = planes[5] = new Cartesian4();\r\n  }\r\n  plane.x = normal.x;\r\n  plane.y = normal.y;\r\n  plane.z = normal.z;\r\n  plane.w = -Cartesian3.dot(normal, farCenter);\r\n\r\n  return this._cullingVolume;\r\n};\r\n\r\n/**\r\n * Returns the pixel's width and height in meters.\r\n *\r\n * @param {Number} drawingBufferWidth The width of the drawing buffer.\r\n * @param {Number} drawingBufferHeight The height of the drawing buffer.\r\n * @param {Number} distance The distance to the near plane in meters.\r\n * @param {Number} pixelRatio The scaling factor from pixel space to coordinate space.\r\n * @param {Cartesian2} result The object onto which to store the result.\r\n * @returns {Cartesian2} The modified result parameter or a new instance of {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.\r\n *\r\n * @exception {DeveloperError} drawingBufferWidth must be greater than zero.\r\n * @exception {DeveloperError} drawingBufferHeight must be greater than zero.\r\n * @exception {DeveloperError} pixelRatio must be greater than zero.\r\n *\r\n * @example\r\n * // Example 1\r\n * // Get the width and height of a pixel.\r\n * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 1.0, scene.pixelRatio, new Cesium.Cartesian2());\r\n *\r\n * @example\r\n * // Example 2\r\n * // Get the width and height of a pixel if the near plane was set to 'distance'.\r\n * // For example, get the size of a pixel of an image on a billboard.\r\n * const position = camera.position;\r\n * const direction = camera.direction;\r\n * const toCenter = Cesium.Cartesian3.subtract(primitive.boundingVolume.center, position, new Cesium.Cartesian3());      // vector from camera to a primitive\r\n * const toCenterProj = Cesium.Cartesian3.multiplyByScalar(direction, Cesium.Cartesian3.dot(direction, toCenter), new Cesium.Cartesian3()); // project vector onto camera direction vector\r\n * const distance = Cesium.Cartesian3.magnitude(toCenterProj);\r\n * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, distance, scene.pixelRatio, new Cesium.Cartesian2());\r\n */\r\nPerspectiveOffCenterFrustum.prototype.getPixelDimensions = function (\r\n  drawingBufferWidth,\r\n  drawingBufferHeight,\r\n  distance,\r\n  pixelRatio,\r\n  result\r\n) {\r\n  update(this);\r\n\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(drawingBufferWidth) || !defined(drawingBufferHeight)) {\r\n    throw new DeveloperError(\r\n      \"Both drawingBufferWidth and drawingBufferHeight are required.\"\r\n    );\r\n  }\r\n  if (drawingBufferWidth <= 0) {\r\n    throw new DeveloperError(\"drawingBufferWidth must be greater than zero.\");\r\n  }\r\n  if (drawingBufferHeight <= 0) {\r\n    throw new DeveloperError(\"drawingBufferHeight must be greater than zero.\");\r\n  }\r\n  if (!defined(distance)) {\r\n    throw new DeveloperError(\"distance is required.\");\r\n  }\r\n  if (!defined(pixelRatio)) {\r\n    throw new DeveloperError(\"pixelRatio is required\");\r\n  }\r\n  if (pixelRatio <= 0) {\r\n    throw new DeveloperError(\"pixelRatio must be greater than zero.\");\r\n  }\r\n  if (!defined(result)) {\r\n    throw new DeveloperError(\"A result object is required.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const inverseNear = 1.0 / this.near;\r\n  let tanTheta = this.top * inverseNear;\r\n  const pixelHeight =\r\n    (2.0 * pixelRatio * distance * tanTheta) / drawingBufferHeight;\r\n  tanTheta = this.right * inverseNear;\r\n  const pixelWidth =\r\n    (2.0 * pixelRatio * distance * tanTheta) / drawingBufferWidth;\r\n\r\n  result.x = pixelWidth;\r\n  result.y = pixelHeight;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Returns a duplicate of a PerspectiveOffCenterFrustum instance.\r\n *\r\n * @param {PerspectiveOffCenterFrustum} [result] The object onto which to store the result.\r\n * @returns {PerspectiveOffCenterFrustum} The modified result parameter or a new PerspectiveFrustum instance if one was not provided.\r\n */\r\nPerspectiveOffCenterFrustum.prototype.clone = function (result) {\r\n  if (!defined(result)) {\r\n    result = new PerspectiveOffCenterFrustum();\r\n  }\r\n\r\n  result.right = this.right;\r\n  result.left = this.left;\r\n  result.top = this.top;\r\n  result.bottom = this.bottom;\r\n  result.near = this.near;\r\n  result.far = this.far;\r\n\r\n  // force update of clone to compute matrices\r\n  result._left = undefined;\r\n  result._right = undefined;\r\n  result._top = undefined;\r\n  result._bottom = undefined;\r\n  result._near = undefined;\r\n  result._far = undefined;\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Compares the provided PerspectiveOffCenterFrustum componentwise and returns\r\n * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n *\r\n * @param {PerspectiveOffCenterFrustum} [other] The right hand side PerspectiveOffCenterFrustum.\r\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\r\n */\r\nPerspectiveOffCenterFrustum.prototype.equals = function (other) {\r\n  return (\r\n    defined(other) &&\r\n    other instanceof PerspectiveOffCenterFrustum &&\r\n    this.right === other.right &&\r\n    this.left === other.left &&\r\n    this.top === other.top &&\r\n    this.bottom === other.bottom &&\r\n    this.near === other.near &&\r\n    this.far === other.far\r\n  );\r\n};\r\n\r\n/**\r\n * Compares the provided PerspectiveOffCenterFrustum componentwise and returns\r\n * <code>true</code> if they pass an absolute or relative tolerance test,\r\n * <code>false</code> otherwise.\r\n *\r\n * @param {PerspectiveOffCenterFrustum} other The right hand side PerspectiveOffCenterFrustum.\r\n * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\r\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\r\n * @returns {Boolean} <code>true</code> if this and other are within the provided epsilon, <code>false</code> otherwise.\r\n */\r\nPerspectiveOffCenterFrustum.prototype.equalsEpsilon = function (\r\n  other,\r\n  relativeEpsilon,\r\n  absoluteEpsilon\r\n) {\r\n  return (\r\n    other === this ||\r\n    (defined(other) &&\r\n      other instanceof PerspectiveOffCenterFrustum &&\r\n      CesiumMath.equalsEpsilon(\r\n        this.right,\r\n        other.right,\r\n        relativeEpsilon,\r\n        absoluteEpsilon\r\n      ) &&\r\n      CesiumMath.equalsEpsilon(\r\n        this.left,\r\n        other.left,\r\n        relativeEpsilon,\r\n        absoluteEpsilon\r\n      ) &&\r\n      CesiumMath.equalsEpsilon(\r\n        this.top,\r\n        other.top,\r\n        relativeEpsilon,\r\n        absoluteEpsilon\r\n      ) &&\r\n      CesiumMath.equalsEpsilon(\r\n        this.bottom,\r\n        other.bottom,\r\n        relativeEpsilon,\r\n        absoluteEpsilon\r\n      ) &&\r\n      CesiumMath.equalsEpsilon(\r\n        this.near,\r\n        other.near,\r\n        relativeEpsilon,\r\n        absoluteEpsilon\r\n      ) &&\r\n      CesiumMath.equalsEpsilon(\r\n        this.far,\r\n        other.far,\r\n        relativeEpsilon,\r\n        absoluteEpsilon\r\n      ))\r\n  );\r\n};\r\nexport default PerspectiveOffCenterFrustum;\r\n","import Check from \"./Check.js\";\r\nimport defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\nimport DeveloperError from \"./DeveloperError.js\";\r\nimport CesiumMath from \"./Math.js\";\r\nimport PerspectiveOffCenterFrustum from \"./PerspectiveOffCenterFrustum.js\";\r\n\r\n/**\r\n * The viewing frustum is defined by 6 planes.\r\n * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components\r\n * define the unit vector normal to the plane, and the w component is the distance of the\r\n * plane from the origin/camera position.\r\n *\r\n * @alias PerspectiveFrustum\r\n * @constructor\r\n *\r\n * @param {Object} [options] An object with the following properties:\r\n * @param {Number} [options.fov] The angle of the field of view (FOV), in radians.\r\n * @param {Number} [options.aspectRatio] The aspect ratio of the frustum's width to it's height.\r\n * @param {Number} [options.near=1.0] The distance of the near plane.\r\n * @param {Number} [options.far=500000000.0] The distance of the far plane.\r\n * @param {Number} [options.xOffset=0.0] The offset in the x direction.\r\n * @param {Number} [options.yOffset=0.0] The offset in the y direction.\r\n *\r\n * @example\r\n * const frustum = new Cesium.PerspectiveFrustum({\r\n *     fov : Cesium.Math.PI_OVER_THREE,\r\n *     aspectRatio : canvas.clientWidth / canvas.clientHeight\r\n *     near : 1.0,\r\n *     far : 1000.0\r\n * });\r\n *\r\n * @see PerspectiveOffCenterFrustum\r\n */\r\nfunction PerspectiveFrustum(options) {\r\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n\r\n  this._offCenterFrustum = new PerspectiveOffCenterFrustum();\r\n\r\n  /**\r\n   * The angle of the field of view (FOV), in radians.  This angle will be used\r\n   * as the horizontal FOV if the width is greater than the height, otherwise\r\n   * it will be the vertical FOV.\r\n   * @type {Number}\r\n   * @default undefined\r\n   */\r\n  this.fov = options.fov;\r\n  this._fov = undefined;\r\n  this._fovy = undefined;\r\n\r\n  this._sseDenominator = undefined;\r\n\r\n  /**\r\n   * The aspect ratio of the frustum's width to it's height.\r\n   * @type {Number}\r\n   * @default undefined\r\n   */\r\n  this.aspectRatio = options.aspectRatio;\r\n  this._aspectRatio = undefined;\r\n\r\n  /**\r\n   * The distance of the near plane.\r\n   * @type {Number}\r\n   * @default 1.0\r\n   */\r\n  this.near = defaultValue(options.near, 1.0);\r\n  this._near = this.near;\r\n\r\n  /**\r\n   * The distance of the far plane.\r\n   * @type {Number}\r\n   * @default 500000000.0\r\n   */\r\n  this.far = defaultValue(options.far, 500000000.0);\r\n  this._far = this.far;\r\n\r\n  /**\r\n   * Offsets the frustum in the x direction.\r\n   * @type {Number}\r\n   * @default 0.0\r\n   */\r\n  this.xOffset = defaultValue(options.xOffset, 0.0);\r\n  this._xOffset = this.xOffset;\r\n\r\n  /**\r\n   * Offsets the frustum in the y direction.\r\n   * @type {Number}\r\n   * @default 0.0\r\n   */\r\n  this.yOffset = defaultValue(options.yOffset, 0.0);\r\n  this._yOffset = this.yOffset;\r\n}\r\n\r\n/**\r\n * The number of elements used to pack the object into an array.\r\n * @type {Number}\r\n */\r\nPerspectiveFrustum.packedLength = 6;\r\n\r\n/**\r\n * Stores the provided instance into the provided array.\r\n *\r\n * @param {PerspectiveFrustum} value The value to pack.\r\n * @param {Number[]} array The array to pack into.\r\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n *\r\n * @returns {Number[]} The array that was packed into\r\n */\r\nPerspectiveFrustum.pack = function (value, array, startingIndex) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"value\", value);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  array[startingIndex++] = value.fov;\r\n  array[startingIndex++] = value.aspectRatio;\r\n  array[startingIndex++] = value.near;\r\n  array[startingIndex++] = value.far;\r\n  array[startingIndex++] = value.xOffset;\r\n  array[startingIndex] = value.yOffset;\r\n\r\n  return array;\r\n};\r\n\r\n/**\r\n * Retrieves an instance from a packed array.\r\n *\r\n * @param {Number[]} array The packed array.\r\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n * @param {PerspectiveFrustum} [result] The object into which to store the result.\r\n * @returns {PerspectiveFrustum} The modified result parameter or a new PerspectiveFrustum instance if one was not provided.\r\n */\r\nPerspectiveFrustum.unpack = function (array, startingIndex, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  if (!defined(result)) {\r\n    result = new PerspectiveFrustum();\r\n  }\r\n\r\n  result.fov = array[startingIndex++];\r\n  result.aspectRatio = array[startingIndex++];\r\n  result.near = array[startingIndex++];\r\n  result.far = array[startingIndex++];\r\n  result.xOffset = array[startingIndex++];\r\n  result.yOffset = array[startingIndex];\r\n\r\n  return result;\r\n};\r\n\r\nfunction update(frustum) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (\r\n    !defined(frustum.fov) ||\r\n    !defined(frustum.aspectRatio) ||\r\n    !defined(frustum.near) ||\r\n    !defined(frustum.far)\r\n  ) {\r\n    throw new DeveloperError(\r\n      \"fov, aspectRatio, near, or far parameters are not set.\"\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const f = frustum._offCenterFrustum;\r\n\r\n  if (\r\n    frustum.fov !== frustum._fov ||\r\n    frustum.aspectRatio !== frustum._aspectRatio ||\r\n    frustum.near !== frustum._near ||\r\n    frustum.far !== frustum._far ||\r\n    frustum.xOffset !== frustum._xOffset ||\r\n    frustum.yOffset !== frustum._yOffset\r\n  ) {\r\n    //>>includeStart('debug', pragmas.debug);\r\n    if (frustum.fov < 0 || frustum.fov >= Math.PI) {\r\n      throw new DeveloperError(\"fov must be in the range [0, PI).\");\r\n    }\r\n\r\n    if (frustum.aspectRatio < 0) {\r\n      throw new DeveloperError(\"aspectRatio must be positive.\");\r\n    }\r\n\r\n    if (frustum.near < 0 || frustum.near > frustum.far) {\r\n      throw new DeveloperError(\r\n        \"near must be greater than zero and less than far.\"\r\n      );\r\n    }\r\n    //>>includeEnd('debug');\r\n\r\n    frustum._aspectRatio = frustum.aspectRatio;\r\n    frustum._fov = frustum.fov;\r\n    frustum._fovy =\r\n      frustum.aspectRatio <= 1\r\n        ? frustum.fov\r\n        : Math.atan(Math.tan(frustum.fov * 0.5) / frustum.aspectRatio) * 2.0;\r\n    frustum._near = frustum.near;\r\n    frustum._far = frustum.far;\r\n    frustum._sseDenominator = 2.0 * Math.tan(0.5 * frustum._fovy);\r\n    frustum._xOffset = frustum.xOffset;\r\n    frustum._yOffset = frustum.yOffset;\r\n\r\n    f.top = frustum.near * Math.tan(0.5 * frustum._fovy);\r\n    f.bottom = -f.top;\r\n    f.right = frustum.aspectRatio * f.top;\r\n    f.left = -f.right;\r\n    f.near = frustum.near;\r\n    f.far = frustum.far;\r\n\r\n    f.right += frustum.xOffset;\r\n    f.left += frustum.xOffset;\r\n    f.top += frustum.yOffset;\r\n    f.bottom += frustum.yOffset;\r\n  }\r\n}\r\n\r\nObject.defineProperties(PerspectiveFrustum.prototype, {\r\n  /**\r\n   * Gets the perspective projection matrix computed from the view frustum.\r\n   * @memberof PerspectiveFrustum.prototype\r\n   * @type {Matrix4}\r\n   * @readonly\r\n   *\r\n   * @see PerspectiveFrustum#infiniteProjectionMatrix\r\n   */\r\n  projectionMatrix: {\r\n    get: function () {\r\n      update(this);\r\n      return this._offCenterFrustum.projectionMatrix;\r\n    },\r\n  },\r\n\r\n  /**\r\n   * The perspective projection matrix computed from the view frustum with an infinite far plane.\r\n   * @memberof PerspectiveFrustum.prototype\r\n   * @type {Matrix4}\r\n   * @readonly\r\n   *\r\n   * @see PerspectiveFrustum#projectionMatrix\r\n   */\r\n  infiniteProjectionMatrix: {\r\n    get: function () {\r\n      update(this);\r\n      return this._offCenterFrustum.infiniteProjectionMatrix;\r\n    },\r\n  },\r\n\r\n  /**\r\n   * Gets the angle of the vertical field of view, in radians.\r\n   * @memberof PerspectiveFrustum.prototype\r\n   * @type {Number}\r\n   * @readonly\r\n   * @default undefined\r\n   */\r\n  fovy: {\r\n    get: function () {\r\n      update(this);\r\n      return this._fovy;\r\n    },\r\n  },\r\n\r\n  /**\r\n   * @readonly\r\n   * @private\r\n   */\r\n  sseDenominator: {\r\n    get: function () {\r\n      update(this);\r\n      return this._sseDenominator;\r\n    },\r\n  },\r\n});\r\n\r\n/**\r\n * Creates a culling volume for this frustum.\r\n *\r\n * @param {Cartesian3} position The eye position.\r\n * @param {Cartesian3} direction The view direction.\r\n * @param {Cartesian3} up The up direction.\r\n * @returns {CullingVolume} A culling volume at the given position and orientation.\r\n *\r\n * @example\r\n * // Check if a bounding volume intersects the frustum.\r\n * const cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\r\n * const intersect = cullingVolume.computeVisibility(boundingVolume);\r\n */\r\nPerspectiveFrustum.prototype.computeCullingVolume = function (\r\n  position,\r\n  direction,\r\n  up\r\n) {\r\n  update(this);\r\n  return this._offCenterFrustum.computeCullingVolume(position, direction, up);\r\n};\r\n\r\n/**\r\n * Returns the pixel's width and height in meters.\r\n *\r\n * @param {Number} drawingBufferWidth The width of the drawing buffer.\r\n * @param {Number} drawingBufferHeight The height of the drawing buffer.\r\n * @param {Number} distance The distance to the near plane in meters.\r\n * @param {Number} pixelRatio The scaling factor from pixel space to coordinate space.\r\n * @param {Cartesian2} result The object onto which to store the result.\r\n * @returns {Cartesian2} The modified result parameter or a new instance of {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.\r\n *\r\n * @exception {DeveloperError} drawingBufferWidth must be greater than zero.\r\n * @exception {DeveloperError} drawingBufferHeight must be greater than zero.\r\n * @exception {DeveloperError} pixelRatio must be greater than zero.\r\n *\r\n * @example\r\n * // Example 1\r\n * // Get the width and height of a pixel.\r\n * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 1.0, scene.pixelRatio, new Cesium.Cartesian2());\r\n *\r\n * @example\r\n * // Example 2\r\n * // Get the width and height of a pixel if the near plane was set to 'distance'.\r\n * // For example, get the size of a pixel of an image on a billboard.\r\n * const position = camera.position;\r\n * const direction = camera.direction;\r\n * const toCenter = Cesium.Cartesian3.subtract(primitive.boundingVolume.center, position, new Cesium.Cartesian3());      // vector from camera to a primitive\r\n * const toCenterProj = Cesium.Cartesian3.multiplyByScalar(direction, Cesium.Cartesian3.dot(direction, toCenter), new Cesium.Cartesian3()); // project vector onto camera direction vector\r\n * const distance = Cesium.Cartesian3.magnitude(toCenterProj);\r\n * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, distance, scene.pixelRatio, new Cesium.Cartesian2());\r\n */\r\nPerspectiveFrustum.prototype.getPixelDimensions = function (\r\n  drawingBufferWidth,\r\n  drawingBufferHeight,\r\n  distance,\r\n  pixelRatio,\r\n  result\r\n) {\r\n  update(this);\r\n  return this._offCenterFrustum.getPixelDimensions(\r\n    drawingBufferWidth,\r\n    drawingBufferHeight,\r\n    distance,\r\n    pixelRatio,\r\n    result\r\n  );\r\n};\r\n\r\n/**\r\n * Returns a duplicate of a PerspectiveFrustum instance.\r\n *\r\n * @param {PerspectiveFrustum} [result] The object onto which to store the result.\r\n * @returns {PerspectiveFrustum} The modified result parameter or a new PerspectiveFrustum instance if one was not provided.\r\n */\r\nPerspectiveFrustum.prototype.clone = function (result) {\r\n  if (!defined(result)) {\r\n    result = new PerspectiveFrustum();\r\n  }\r\n\r\n  result.aspectRatio = this.aspectRatio;\r\n  result.fov = this.fov;\r\n  result.near = this.near;\r\n  result.far = this.far;\r\n\r\n  // force update of clone to compute matrices\r\n  result._aspectRatio = undefined;\r\n  result._fov = undefined;\r\n  result._near = undefined;\r\n  result._far = undefined;\r\n\r\n  this._offCenterFrustum.clone(result._offCenterFrustum);\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Compares the provided PerspectiveFrustum componentwise and returns\r\n * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n *\r\n * @param {PerspectiveFrustum} [other] The right hand side PerspectiveFrustum.\r\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\r\n */\r\nPerspectiveFrustum.prototype.equals = function (other) {\r\n  if (!defined(other) || !(other instanceof PerspectiveFrustum)) {\r\n    return false;\r\n  }\r\n\r\n  update(this);\r\n  update(other);\r\n\r\n  return (\r\n    this.fov === other.fov &&\r\n    this.aspectRatio === other.aspectRatio &&\r\n    this._offCenterFrustum.equals(other._offCenterFrustum)\r\n  );\r\n};\r\n\r\n/**\r\n * Compares the provided PerspectiveFrustum componentwise and returns\r\n * <code>true</code> if they pass an absolute or relative tolerance test,\r\n * <code>false</code> otherwise.\r\n *\r\n * @param {PerspectiveFrustum} other The right hand side PerspectiveFrustum.\r\n * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\r\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\r\n * @returns {Boolean} <code>true</code> if this and other are within the provided epsilon, <code>false</code> otherwise.\r\n */\r\nPerspectiveFrustum.prototype.equalsEpsilon = function (\r\n  other,\r\n  relativeEpsilon,\r\n  absoluteEpsilon\r\n) {\r\n  if (!defined(other) || !(other instanceof PerspectiveFrustum)) {\r\n    return false;\r\n  }\r\n\r\n  update(this);\r\n  update(other);\r\n\r\n  return (\r\n    CesiumMath.equalsEpsilon(\r\n      this.fov,\r\n      other.fov,\r\n      relativeEpsilon,\r\n      absoluteEpsilon\r\n    ) &&\r\n    CesiumMath.equalsEpsilon(\r\n      this.aspectRatio,\r\n      other.aspectRatio,\r\n      relativeEpsilon,\r\n      absoluteEpsilon\r\n    ) &&\r\n    this._offCenterFrustum.equalsEpsilon(\r\n      other._offCenterFrustum,\r\n      relativeEpsilon,\r\n      absoluteEpsilon\r\n    )\r\n  );\r\n};\r\nexport default PerspectiveFrustum;\r\n","import BoundingSphere from \"./BoundingSphere.js\";\r\nimport Cartesian3 from \"./Cartesian3.js\";\r\nimport Cartesian4 from \"./Cartesian4.js\";\r\nimport Check from \"./Check.js\";\r\nimport ComponentDatatype from \"./ComponentDatatype.js\";\r\nimport defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\nimport Geometry from \"./Geometry.js\";\r\nimport GeometryAttribute from \"./GeometryAttribute.js\";\r\nimport GeometryAttributes from \"./GeometryAttributes.js\";\r\nimport Matrix3 from \"./Matrix3.js\";\r\nimport Matrix4 from \"./Matrix4.js\";\r\nimport OrthographicFrustum from \"./OrthographicFrustum.js\";\r\nimport PerspectiveFrustum from \"./PerspectiveFrustum.js\";\r\nimport PrimitiveType from \"./PrimitiveType.js\";\r\nimport Quaternion from \"./Quaternion.js\";\r\nimport VertexFormat from \"./VertexFormat.js\";\r\n\r\nconst PERSPECTIVE = 0;\r\nconst ORTHOGRAPHIC = 1;\r\n\r\n/**\r\n * Describes a frustum at the given the origin and orientation.\r\n *\r\n * @alias FrustumGeometry\r\n * @constructor\r\n *\r\n * @param {Object} options Object with the following properties:\r\n * @param {PerspectiveFrustum|OrthographicFrustum} options.frustum The frustum.\r\n * @param {Cartesian3} options.origin The origin of the frustum.\r\n * @param {Quaternion} options.orientation The orientation of the frustum.\r\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\r\n */\r\nfunction FrustumGeometry(options) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"options\", options);\r\n  Check.typeOf.object(\"options.frustum\", options.frustum);\r\n  Check.typeOf.object(\"options.origin\", options.origin);\r\n  Check.typeOf.object(\"options.orientation\", options.orientation);\r\n  //>>includeEnd('debug');\r\n\r\n  const frustum = options.frustum;\r\n  const orientation = options.orientation;\r\n  const origin = options.origin;\r\n  const vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\r\n\r\n  // This is private because it is used by DebugCameraPrimitive to draw a multi-frustum by\r\n  // creating multiple FrustumGeometrys. This way the near plane of one frustum doesn't overlap\r\n  // the far plane of another.\r\n  const drawNearPlane = defaultValue(options._drawNearPlane, true);\r\n\r\n  let frustumType;\r\n  let frustumPackedLength;\r\n  if (frustum instanceof PerspectiveFrustum) {\r\n    frustumType = PERSPECTIVE;\r\n    frustumPackedLength = PerspectiveFrustum.packedLength;\r\n  } else if (frustum instanceof OrthographicFrustum) {\r\n    frustumType = ORTHOGRAPHIC;\r\n    frustumPackedLength = OrthographicFrustum.packedLength;\r\n  }\r\n\r\n  this._frustumType = frustumType;\r\n  this._frustum = frustum.clone();\r\n  this._origin = Cartesian3.clone(origin);\r\n  this._orientation = Quaternion.clone(orientation);\r\n  this._drawNearPlane = drawNearPlane;\r\n  this._vertexFormat = vertexFormat;\r\n  this._workerName = \"createFrustumGeometry\";\r\n\r\n  /**\r\n   * The number of elements used to pack the object into an array.\r\n   * @type {Number}\r\n   */\r\n  this.packedLength =\r\n    2 +\r\n    frustumPackedLength +\r\n    Cartesian3.packedLength +\r\n    Quaternion.packedLength +\r\n    VertexFormat.packedLength;\r\n}\r\n\r\n/**\r\n * Stores the provided instance into the provided array.\r\n *\r\n * @param {FrustumGeometry} value The value to pack.\r\n * @param {Number[]} array The array to pack into.\r\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n *\r\n * @returns {Number[]} The array that was packed into\r\n */\r\nFrustumGeometry.pack = function (value, array, startingIndex) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"value\", value);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  const frustumType = value._frustumType;\r\n  const frustum = value._frustum;\r\n\r\n  array[startingIndex++] = frustumType;\r\n\r\n  if (frustumType === PERSPECTIVE) {\r\n    PerspectiveFrustum.pack(frustum, array, startingIndex);\r\n    startingIndex += PerspectiveFrustum.packedLength;\r\n  } else {\r\n    OrthographicFrustum.pack(frustum, array, startingIndex);\r\n    startingIndex += OrthographicFrustum.packedLength;\r\n  }\r\n\r\n  Cartesian3.pack(value._origin, array, startingIndex);\r\n  startingIndex += Cartesian3.packedLength;\r\n  Quaternion.pack(value._orientation, array, startingIndex);\r\n  startingIndex += Quaternion.packedLength;\r\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\r\n  startingIndex += VertexFormat.packedLength;\r\n  array[startingIndex] = value._drawNearPlane ? 1.0 : 0.0;\r\n\r\n  return array;\r\n};\r\n\r\nconst scratchPackPerspective = new PerspectiveFrustum();\r\nconst scratchPackOrthographic = new OrthographicFrustum();\r\nconst scratchPackQuaternion = new Quaternion();\r\nconst scratchPackorigin = new Cartesian3();\r\nconst scratchVertexFormat = new VertexFormat();\r\n\r\n/**\r\n * Retrieves an instance from a packed array.\r\n *\r\n * @param {Number[]} array The packed array.\r\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n * @param {FrustumGeometry} [result] The object into which to store the result.\r\n */\r\nFrustumGeometry.unpack = function (array, startingIndex, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  const frustumType = array[startingIndex++];\r\n\r\n  let frustum;\r\n  if (frustumType === PERSPECTIVE) {\r\n    frustum = PerspectiveFrustum.unpack(\r\n      array,\r\n      startingIndex,\r\n      scratchPackPerspective\r\n    );\r\n    startingIndex += PerspectiveFrustum.packedLength;\r\n  } else {\r\n    frustum = OrthographicFrustum.unpack(\r\n      array,\r\n      startingIndex,\r\n      scratchPackOrthographic\r\n    );\r\n    startingIndex += OrthographicFrustum.packedLength;\r\n  }\r\n\r\n  const origin = Cartesian3.unpack(array, startingIndex, scratchPackorigin);\r\n  startingIndex += Cartesian3.packedLength;\r\n  const orientation = Quaternion.unpack(\r\n    array,\r\n    startingIndex,\r\n    scratchPackQuaternion\r\n  );\r\n  startingIndex += Quaternion.packedLength;\r\n  const vertexFormat = VertexFormat.unpack(\r\n    array,\r\n    startingIndex,\r\n    scratchVertexFormat\r\n  );\r\n  startingIndex += VertexFormat.packedLength;\r\n  const drawNearPlane = array[startingIndex] === 1.0;\r\n\r\n  if (!defined(result)) {\r\n    return new FrustumGeometry({\r\n      frustum: frustum,\r\n      origin: origin,\r\n      orientation: orientation,\r\n      vertexFormat: vertexFormat,\r\n      _drawNearPlane: drawNearPlane,\r\n    });\r\n  }\r\n\r\n  const frustumResult =\r\n    frustumType === result._frustumType ? result._frustum : undefined;\r\n  result._frustum = frustum.clone(frustumResult);\r\n\r\n  result._frustumType = frustumType;\r\n  result._origin = Cartesian3.clone(origin, result._origin);\r\n  result._orientation = Quaternion.clone(orientation, result._orientation);\r\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\r\n  result._drawNearPlane = drawNearPlane;\r\n\r\n  return result;\r\n};\r\n\r\nfunction getAttributes(\r\n  offset,\r\n  normals,\r\n  tangents,\r\n  bitangents,\r\n  st,\r\n  normal,\r\n  tangent,\r\n  bitangent\r\n) {\r\n  const stOffset = (offset / 3) * 2;\r\n\r\n  for (let i = 0; i < 4; ++i) {\r\n    if (defined(normals)) {\r\n      normals[offset] = normal.x;\r\n      normals[offset + 1] = normal.y;\r\n      normals[offset + 2] = normal.z;\r\n    }\r\n    if (defined(tangents)) {\r\n      tangents[offset] = tangent.x;\r\n      tangents[offset + 1] = tangent.y;\r\n      tangents[offset + 2] = tangent.z;\r\n    }\r\n    if (defined(bitangents)) {\r\n      bitangents[offset] = bitangent.x;\r\n      bitangents[offset + 1] = bitangent.y;\r\n      bitangents[offset + 2] = bitangent.z;\r\n    }\r\n    offset += 3;\r\n  }\r\n\r\n  st[stOffset] = 0.0;\r\n  st[stOffset + 1] = 0.0;\r\n  st[stOffset + 2] = 1.0;\r\n  st[stOffset + 3] = 0.0;\r\n  st[stOffset + 4] = 1.0;\r\n  st[stOffset + 5] = 1.0;\r\n  st[stOffset + 6] = 0.0;\r\n  st[stOffset + 7] = 1.0;\r\n}\r\n\r\nconst scratchRotationMatrix = new Matrix3();\r\nconst scratchViewMatrix = new Matrix4();\r\nconst scratchInverseMatrix = new Matrix4();\r\n\r\nconst scratchXDirection = new Cartesian3();\r\nconst scratchYDirection = new Cartesian3();\r\nconst scratchZDirection = new Cartesian3();\r\nconst scratchNegativeX = new Cartesian3();\r\nconst scratchNegativeY = new Cartesian3();\r\nconst scratchNegativeZ = new Cartesian3();\r\n\r\nconst frustumSplits = new Array(3);\r\n\r\nconst frustumCornersNDC = new Array(4);\r\nfrustumCornersNDC[0] = new Cartesian4(-1.0, -1.0, 1.0, 1.0);\r\nfrustumCornersNDC[1] = new Cartesian4(1.0, -1.0, 1.0, 1.0);\r\nfrustumCornersNDC[2] = new Cartesian4(1.0, 1.0, 1.0, 1.0);\r\nfrustumCornersNDC[3] = new Cartesian4(-1.0, 1.0, 1.0, 1.0);\r\n\r\nconst scratchFrustumCorners = new Array(4);\r\nfor (let i = 0; i < 4; ++i) {\r\n  scratchFrustumCorners[i] = new Cartesian4();\r\n}\r\n\r\nFrustumGeometry._computeNearFarPlanes = function (\r\n  origin,\r\n  orientation,\r\n  frustumType,\r\n  frustum,\r\n  positions,\r\n  xDirection,\r\n  yDirection,\r\n  zDirection\r\n) {\r\n  const rotationMatrix = Matrix3.fromQuaternion(\r\n    orientation,\r\n    scratchRotationMatrix\r\n  );\r\n  let x = defaultValue(xDirection, scratchXDirection);\r\n  let y = defaultValue(yDirection, scratchYDirection);\r\n  let z = defaultValue(zDirection, scratchZDirection);\r\n\r\n  x = Matrix3.getColumn(rotationMatrix, 0, x);\r\n  y = Matrix3.getColumn(rotationMatrix, 1, y);\r\n  z = Matrix3.getColumn(rotationMatrix, 2, z);\r\n\r\n  Cartesian3.normalize(x, x);\r\n  Cartesian3.normalize(y, y);\r\n  Cartesian3.normalize(z, z);\r\n\r\n  Cartesian3.negate(x, x);\r\n\r\n  const view = Matrix4.computeView(origin, z, y, x, scratchViewMatrix);\r\n\r\n  let inverseView;\r\n  let inverseViewProjection;\r\n  if (frustumType === PERSPECTIVE) {\r\n    const projection = frustum.projectionMatrix;\r\n    const viewProjection = Matrix4.multiply(\r\n      projection,\r\n      view,\r\n      scratchInverseMatrix\r\n    );\r\n    inverseViewProjection = Matrix4.inverse(\r\n      viewProjection,\r\n      scratchInverseMatrix\r\n    );\r\n  } else {\r\n    inverseView = Matrix4.inverseTransformation(view, scratchInverseMatrix);\r\n  }\r\n\r\n  if (defined(inverseViewProjection)) {\r\n    frustumSplits[0] = frustum.near;\r\n    frustumSplits[1] = frustum.far;\r\n  } else {\r\n    frustumSplits[0] = 0.0;\r\n    frustumSplits[1] = frustum.near;\r\n    frustumSplits[2] = frustum.far;\r\n  }\r\n\r\n  for (let i = 0; i < 2; ++i) {\r\n    for (let j = 0; j < 4; ++j) {\r\n      let corner = Cartesian4.clone(\r\n        frustumCornersNDC[j],\r\n        scratchFrustumCorners[j]\r\n      );\r\n\r\n      if (!defined(inverseViewProjection)) {\r\n        if (defined(frustum._offCenterFrustum)) {\r\n          frustum = frustum._offCenterFrustum;\r\n        }\r\n\r\n        const near = frustumSplits[i];\r\n        const far = frustumSplits[i + 1];\r\n\r\n        corner.x =\r\n          (corner.x * (frustum.right - frustum.left) +\r\n            frustum.left +\r\n            frustum.right) *\r\n          0.5;\r\n        corner.y =\r\n          (corner.y * (frustum.top - frustum.bottom) +\r\n            frustum.bottom +\r\n            frustum.top) *\r\n          0.5;\r\n        corner.z = (corner.z * (near - far) - near - far) * 0.5;\r\n        corner.w = 1.0;\r\n\r\n        Matrix4.multiplyByVector(inverseView, corner, corner);\r\n      } else {\r\n        corner = Matrix4.multiplyByVector(\r\n          inverseViewProjection,\r\n          corner,\r\n          corner\r\n        );\r\n\r\n        // Reverse perspective divide\r\n        const w = 1.0 / corner.w;\r\n        Cartesian3.multiplyByScalar(corner, w, corner);\r\n\r\n        Cartesian3.subtract(corner, origin, corner);\r\n        Cartesian3.normalize(corner, corner);\r\n\r\n        const fac = Cartesian3.dot(z, corner);\r\n        Cartesian3.multiplyByScalar(corner, frustumSplits[i] / fac, corner);\r\n        Cartesian3.add(corner, origin, corner);\r\n      }\r\n\r\n      positions[12 * i + j * 3] = corner.x;\r\n      positions[12 * i + j * 3 + 1] = corner.y;\r\n      positions[12 * i + j * 3 + 2] = corner.z;\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Computes the geometric representation of a frustum, including its vertices, indices, and a bounding sphere.\r\n *\r\n * @param {FrustumGeometry} frustumGeometry A description of the frustum.\r\n * @returns {Geometry|undefined} The computed vertices and indices.\r\n */\r\nFrustumGeometry.createGeometry = function (frustumGeometry) {\r\n  const frustumType = frustumGeometry._frustumType;\r\n  const frustum = frustumGeometry._frustum;\r\n  const origin = frustumGeometry._origin;\r\n  const orientation = frustumGeometry._orientation;\r\n  const drawNearPlane = frustumGeometry._drawNearPlane;\r\n  const vertexFormat = frustumGeometry._vertexFormat;\r\n\r\n  const numberOfPlanes = drawNearPlane ? 6 : 5;\r\n  let positions = new Float64Array(3 * 4 * 6);\r\n  FrustumGeometry._computeNearFarPlanes(\r\n    origin,\r\n    orientation,\r\n    frustumType,\r\n    frustum,\r\n    positions\r\n  );\r\n\r\n  // -x plane\r\n  let offset = 3 * 4 * 2;\r\n  positions[offset] = positions[3 * 4];\r\n  positions[offset + 1] = positions[3 * 4 + 1];\r\n  positions[offset + 2] = positions[3 * 4 + 2];\r\n  positions[offset + 3] = positions[0];\r\n  positions[offset + 4] = positions[1];\r\n  positions[offset + 5] = positions[2];\r\n  positions[offset + 6] = positions[3 * 3];\r\n  positions[offset + 7] = positions[3 * 3 + 1];\r\n  positions[offset + 8] = positions[3 * 3 + 2];\r\n  positions[offset + 9] = positions[3 * 7];\r\n  positions[offset + 10] = positions[3 * 7 + 1];\r\n  positions[offset + 11] = positions[3 * 7 + 2];\r\n\r\n  // -y plane\r\n  offset += 3 * 4;\r\n  positions[offset] = positions[3 * 5];\r\n  positions[offset + 1] = positions[3 * 5 + 1];\r\n  positions[offset + 2] = positions[3 * 5 + 2];\r\n  positions[offset + 3] = positions[3];\r\n  positions[offset + 4] = positions[3 + 1];\r\n  positions[offset + 5] = positions[3 + 2];\r\n  positions[offset + 6] = positions[0];\r\n  positions[offset + 7] = positions[1];\r\n  positions[offset + 8] = positions[2];\r\n  positions[offset + 9] = positions[3 * 4];\r\n  positions[offset + 10] = positions[3 * 4 + 1];\r\n  positions[offset + 11] = positions[3 * 4 + 2];\r\n\r\n  // +x plane\r\n  offset += 3 * 4;\r\n  positions[offset] = positions[3];\r\n  positions[offset + 1] = positions[3 + 1];\r\n  positions[offset + 2] = positions[3 + 2];\r\n  positions[offset + 3] = positions[3 * 5];\r\n  positions[offset + 4] = positions[3 * 5 + 1];\r\n  positions[offset + 5] = positions[3 * 5 + 2];\r\n  positions[offset + 6] = positions[3 * 6];\r\n  positions[offset + 7] = positions[3 * 6 + 1];\r\n  positions[offset + 8] = positions[3 * 6 + 2];\r\n  positions[offset + 9] = positions[3 * 2];\r\n  positions[offset + 10] = positions[3 * 2 + 1];\r\n  positions[offset + 11] = positions[3 * 2 + 2];\r\n\r\n  // +y plane\r\n  offset += 3 * 4;\r\n  positions[offset] = positions[3 * 2];\r\n  positions[offset + 1] = positions[3 * 2 + 1];\r\n  positions[offset + 2] = positions[3 * 2 + 2];\r\n  positions[offset + 3] = positions[3 * 6];\r\n  positions[offset + 4] = positions[3 * 6 + 1];\r\n  positions[offset + 5] = positions[3 * 6 + 2];\r\n  positions[offset + 6] = positions[3 * 7];\r\n  positions[offset + 7] = positions[3 * 7 + 1];\r\n  positions[offset + 8] = positions[3 * 7 + 2];\r\n  positions[offset + 9] = positions[3 * 3];\r\n  positions[offset + 10] = positions[3 * 3 + 1];\r\n  positions[offset + 11] = positions[3 * 3 + 2];\r\n\r\n  if (!drawNearPlane) {\r\n    positions = positions.subarray(3 * 4);\r\n  }\r\n\r\n  const attributes = new GeometryAttributes({\r\n    position: new GeometryAttribute({\r\n      componentDatatype: ComponentDatatype.DOUBLE,\r\n      componentsPerAttribute: 3,\r\n      values: positions,\r\n    }),\r\n  });\r\n\r\n  if (\r\n    defined(vertexFormat.normal) ||\r\n    defined(vertexFormat.tangent) ||\r\n    defined(vertexFormat.bitangent) ||\r\n    defined(vertexFormat.st)\r\n  ) {\r\n    const normals = defined(vertexFormat.normal)\r\n      ? new Float32Array(3 * 4 * numberOfPlanes)\r\n      : undefined;\r\n    const tangents = defined(vertexFormat.tangent)\r\n      ? new Float32Array(3 * 4 * numberOfPlanes)\r\n      : undefined;\r\n    const bitangents = defined(vertexFormat.bitangent)\r\n      ? new Float32Array(3 * 4 * numberOfPlanes)\r\n      : undefined;\r\n    const st = defined(vertexFormat.st)\r\n      ? new Float32Array(2 * 4 * numberOfPlanes)\r\n      : undefined;\r\n\r\n    const x = scratchXDirection;\r\n    const y = scratchYDirection;\r\n    const z = scratchZDirection;\r\n\r\n    const negativeX = Cartesian3.negate(x, scratchNegativeX);\r\n    const negativeY = Cartesian3.negate(y, scratchNegativeY);\r\n    const negativeZ = Cartesian3.negate(z, scratchNegativeZ);\r\n\r\n    offset = 0;\r\n    if (drawNearPlane) {\r\n      getAttributes(offset, normals, tangents, bitangents, st, negativeZ, x, y); // near\r\n      offset += 3 * 4;\r\n    }\r\n    getAttributes(offset, normals, tangents, bitangents, st, z, negativeX, y); // far\r\n    offset += 3 * 4;\r\n    getAttributes(\r\n      offset,\r\n      normals,\r\n      tangents,\r\n      bitangents,\r\n      st,\r\n      negativeX,\r\n      negativeZ,\r\n      y\r\n    ); // -x\r\n    offset += 3 * 4;\r\n    getAttributes(\r\n      offset,\r\n      normals,\r\n      tangents,\r\n      bitangents,\r\n      st,\r\n      negativeY,\r\n      negativeZ,\r\n      negativeX\r\n    ); // -y\r\n    offset += 3 * 4;\r\n    getAttributes(offset, normals, tangents, bitangents, st, x, z, y); // +x\r\n    offset += 3 * 4;\r\n    getAttributes(offset, normals, tangents, bitangents, st, y, z, negativeX); // +y\r\n\r\n    if (defined(normals)) {\r\n      attributes.normal = new GeometryAttribute({\r\n        componentDatatype: ComponentDatatype.FLOAT,\r\n        componentsPerAttribute: 3,\r\n        values: normals,\r\n      });\r\n    }\r\n    if (defined(tangents)) {\r\n      attributes.tangent = new GeometryAttribute({\r\n        componentDatatype: ComponentDatatype.FLOAT,\r\n        componentsPerAttribute: 3,\r\n        values: tangents,\r\n      });\r\n    }\r\n    if (defined(bitangents)) {\r\n      attributes.bitangent = new GeometryAttribute({\r\n        componentDatatype: ComponentDatatype.FLOAT,\r\n        componentsPerAttribute: 3,\r\n        values: bitangents,\r\n      });\r\n    }\r\n    if (defined(st)) {\r\n      attributes.st = new GeometryAttribute({\r\n        componentDatatype: ComponentDatatype.FLOAT,\r\n        componentsPerAttribute: 2,\r\n        values: st,\r\n      });\r\n    }\r\n  }\r\n\r\n  const indices = new Uint16Array(6 * numberOfPlanes);\r\n  for (let i = 0; i < numberOfPlanes; ++i) {\r\n    const indexOffset = i * 6;\r\n    const index = i * 4;\r\n\r\n    indices[indexOffset] = index;\r\n    indices[indexOffset + 1] = index + 1;\r\n    indices[indexOffset + 2] = index + 2;\r\n    indices[indexOffset + 3] = index;\r\n    indices[indexOffset + 4] = index + 2;\r\n    indices[indexOffset + 5] = index + 3;\r\n  }\r\n\r\n  return new Geometry({\r\n    attributes: attributes,\r\n    indices: indices,\r\n    primitiveType: PrimitiveType.TRIANGLES,\r\n    boundingSphere: BoundingSphere.fromVertices(positions),\r\n  });\r\n};\r\nexport default FrustumGeometry;\r\n"],"names":["CullingVolume","planes","this","defaultValue","faces","Cartesian3","clone","UNIT_X","UNIT_Y","UNIT_Z","scratchPlaneCenter","scratchPlaneNormal","scratchPlane","Plane","OrthographicOffCenterFrustum","options","EMPTY_OBJECT","left","_left","undefined","right","_right","top","_top","bottom","_bottom","near","_near","far","_far","_cullingVolume","_orthographicMatrix","Matrix4","update","frustum","defined","DeveloperError","computeOrthographicOffCenter","fromBoundingSphere","boundingSphere","result","length","center","radius","planeIndex","i","faceNormal","plane0","plane1","Cartesian4","multiplyByScalar","add","x","y","z","w","dot","negate","prototype","computeVisibility","boundingVolume","intersecting","k","len","intersectPlane","fromCartesian4","Intersect","OUTSIDE","INTERSECTING","INSIDE","computeVisibilityWithPlaneMask","parentPlaneMask","MASK_OUTSIDE","MASK_INSIDE","mask","flag","MASK_INDETERMINATE","Object","defineProperties","projectionMatrix","get","getPlanesRight","getPlanesNearCenter","getPlanesPoint","negateScratch","OrthographicFrustum","_offCenterFrustum","width","_width","aspectRatio","_aspectRatio","f","ratio","PerspectiveOffCenterFrustum","_perspectiveMatrix","_infinitePerspective","t","b","r","l","n","computePerspectiveOffCenter","computeInfinitePerspectiveOffCenter","computeCullingVolume","position","direction","up","cross","normalize","nearCenter","point","plane","getPixelDimensions","drawingBufferWidth","drawingBufferHeight","distance","pixelRatio","pixelWidth","pixelHeight","equals","other","equalsEpsilon","relativeEpsilon","absoluteEpsilon","CesiumMath","packedLength","pack","value","array","startingIndex","Check","typeOf","object","unpack","infiniteProjectionMatrix","getPlanesFarCenter","getPlanesNormal","PerspectiveFrustum","fov","_fov","_fovy","_sseDenominator","xOffset","_xOffset","yOffset","_yOffset","Math","PI","atan","tan","farCenter","normal","subtract","inverseNear","tanTheta","fovy","sseDenominator","FrustumGeometry","origin","orientation","vertexFormat","VertexFormat","DEFAULT","drawNearPlane","_drawNearPlane","frustumType","frustumPackedLength","_frustumType","_frustum","_origin","_orientation","Quaternion","_vertexFormat","_workerName","scratchPackPerspective","scratchPackOrthographic","scratchPackQuaternion","scratchPackorigin","scratchVertexFormat","getAttributes","offset","normals","tangents","bitangents","st","tangent","bitangent","stOffset","frustumResult","scratchRotationMatrix","Matrix3","scratchViewMatrix","scratchInverseMatrix","scratchXDirection","scratchYDirection","scratchZDirection","scratchNegativeX","scratchNegativeY","scratchNegativeZ","frustumSplits","Array","frustumCornersNDC","scratchFrustumCorners","_computeNearFarPlanes","positions","xDirection","yDirection","zDirection","rotationMatrix","fromQuaternion","getColumn","view","computeView","inverseView","inverseViewProjection","projection","viewProjection","multiply","inverse","inverseTransformation","j","corner","multiplyByVector","fac","createGeometry","frustumGeometry","numberOfPlanes","Float64Array","subarray","attributes","GeometryAttributes","GeometryAttribute","componentDatatype","ComponentDatatype","DOUBLE","componentsPerAttribute","values","Float32Array","negativeX","negativeY","negativeZ","FLOAT","indices","Uint16Array","indexOffset","index","Geometry","primitiveType","PrimitiveType","TRIANGLES","BoundingSphere","fromVertices"],"mappings":"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"}