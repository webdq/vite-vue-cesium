{"version":3,"file":"createSimplePolylineGeometry.js","sources":["../../../../Source/Core/SimplePolylineGeometry.js","../../../../Source/WorkersES6/createSimplePolylineGeometry.js"],"sourcesContent":["import ArcType from \"./ArcType.js\";\r\nimport BoundingSphere from \"./BoundingSphere.js\";\r\nimport Cartesian3 from \"./Cartesian3.js\";\r\nimport Color from \"./Color.js\";\r\nimport ComponentDatatype from \"./ComponentDatatype.js\";\r\nimport defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\nimport DeveloperError from \"./DeveloperError.js\";\r\nimport Ellipsoid from \"./Ellipsoid.js\";\r\nimport Geometry from \"./Geometry.js\";\r\nimport GeometryAttribute from \"./GeometryAttribute.js\";\r\nimport GeometryAttributes from \"./GeometryAttributes.js\";\r\nimport IndexDatatype from \"./IndexDatatype.js\";\r\nimport CesiumMath from \"./Math.js\";\r\nimport PolylinePipeline from \"./PolylinePipeline.js\";\r\nimport PrimitiveType from \"./PrimitiveType.js\";\r\n\r\nfunction interpolateColors(p0, p1, color0, color1, minDistance, array, offset) {\r\n  const numPoints = PolylinePipeline.numberOfPoints(p0, p1, minDistance);\r\n  let i;\r\n\r\n  const r0 = color0.red;\r\n  const g0 = color0.green;\r\n  const b0 = color0.blue;\r\n  const a0 = color0.alpha;\r\n\r\n  const r1 = color1.red;\r\n  const g1 = color1.green;\r\n  const b1 = color1.blue;\r\n  const a1 = color1.alpha;\r\n\r\n  if (Color.equals(color0, color1)) {\r\n    for (i = 0; i < numPoints; i++) {\r\n      array[offset++] = Color.floatToByte(r0);\r\n      array[offset++] = Color.floatToByte(g0);\r\n      array[offset++] = Color.floatToByte(b0);\r\n      array[offset++] = Color.floatToByte(a0);\r\n    }\r\n    return offset;\r\n  }\r\n\r\n  const redPerVertex = (r1 - r0) / numPoints;\r\n  const greenPerVertex = (g1 - g0) / numPoints;\r\n  const bluePerVertex = (b1 - b0) / numPoints;\r\n  const alphaPerVertex = (a1 - a0) / numPoints;\r\n\r\n  let index = offset;\r\n  for (i = 0; i < numPoints; i++) {\r\n    array[index++] = Color.floatToByte(r0 + i * redPerVertex);\r\n    array[index++] = Color.floatToByte(g0 + i * greenPerVertex);\r\n    array[index++] = Color.floatToByte(b0 + i * bluePerVertex);\r\n    array[index++] = Color.floatToByte(a0 + i * alphaPerVertex);\r\n  }\r\n\r\n  return index;\r\n}\r\n\r\n/**\r\n * A description of a polyline modeled as a line strip; the first two positions define a line segment,\r\n * and each additional position defines a line segment from the previous position.\r\n *\r\n * @alias SimplePolylineGeometry\r\n * @constructor\r\n *\r\n * @param {Object} options Object with the following properties:\r\n * @param {Cartesian3[]} options.positions An array of {@link Cartesian3} defining the positions in the polyline as a line strip.\r\n * @param {Color[]} [options.colors] An Array of {@link Color} defining the per vertex or per segment colors.\r\n * @param {Boolean} [options.colorsPerVertex=false] A boolean that determines whether the colors will be flat across each segment of the line or interpolated across the vertices.\r\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polyline segments must follow.\r\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude if options.arcType is not ArcType.NONE. Determines the number of positions in the buffer.\r\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\r\n *\r\n * @exception {DeveloperError} At least two positions are required.\r\n * @exception {DeveloperError} colors has an invalid length.\r\n *\r\n * @see SimplePolylineGeometry#createGeometry\r\n *\r\n * @example\r\n * // A polyline with two connected line segments\r\n * const polyline = new Cesium.SimplePolylineGeometry({\r\n *   positions : Cesium.Cartesian3.fromDegreesArray([\r\n *     0.0, 0.0,\r\n *     5.0, 0.0,\r\n *     5.0, 5.0\r\n *   ])\r\n * });\r\n * const geometry = Cesium.SimplePolylineGeometry.createGeometry(polyline);\r\n */\r\nfunction SimplePolylineGeometry(options) {\r\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n  const positions = options.positions;\r\n  const colors = options.colors;\r\n  const colorsPerVertex = defaultValue(options.colorsPerVertex, false);\r\n\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(positions) || positions.length < 2) {\r\n    throw new DeveloperError(\"At least two positions are required.\");\r\n  }\r\n  if (\r\n    defined(colors) &&\r\n    ((colorsPerVertex && colors.length < positions.length) ||\r\n      (!colorsPerVertex && colors.length < positions.length - 1))\r\n  ) {\r\n    throw new DeveloperError(\"colors has an invalid length.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  this._positions = positions;\r\n  this._colors = colors;\r\n  this._colorsPerVertex = colorsPerVertex;\r\n\r\n  this._arcType = defaultValue(options.arcType, ArcType.GEODESIC);\r\n  this._granularity = defaultValue(\r\n    options.granularity,\r\n    CesiumMath.RADIANS_PER_DEGREE\r\n  );\r\n  this._ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\r\n  this._workerName = \"createSimplePolylineGeometry\";\r\n\r\n  let numComponents = 1 + positions.length * Cartesian3.packedLength;\r\n  numComponents += defined(colors) ? 1 + colors.length * Color.packedLength : 1;\r\n\r\n  /**\r\n   * The number of elements used to pack the object into an array.\r\n   * @type {Number}\r\n   */\r\n  this.packedLength = numComponents + Ellipsoid.packedLength + 3;\r\n}\r\n\r\n/**\r\n * Stores the provided instance into the provided array.\r\n *\r\n * @param {SimplePolylineGeometry} value The value to pack.\r\n * @param {Number[]} array The array to pack into.\r\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n *\r\n * @returns {Number[]} The array that was packed into\r\n */\r\nSimplePolylineGeometry.pack = function (value, array, startingIndex) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(value)) {\r\n    throw new DeveloperError(\"value is required\");\r\n  }\r\n  if (!defined(array)) {\r\n    throw new DeveloperError(\"array is required\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  let i;\r\n\r\n  const positions = value._positions;\r\n  let length = positions.length;\r\n  array[startingIndex++] = length;\r\n\r\n  for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\r\n    Cartesian3.pack(positions[i], array, startingIndex);\r\n  }\r\n\r\n  const colors = value._colors;\r\n  length = defined(colors) ? colors.length : 0.0;\r\n  array[startingIndex++] = length;\r\n\r\n  for (i = 0; i < length; ++i, startingIndex += Color.packedLength) {\r\n    Color.pack(colors[i], array, startingIndex);\r\n  }\r\n\r\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\r\n  startingIndex += Ellipsoid.packedLength;\r\n\r\n  array[startingIndex++] = value._colorsPerVertex ? 1.0 : 0.0;\r\n  array[startingIndex++] = value._arcType;\r\n  array[startingIndex] = value._granularity;\r\n\r\n  return array;\r\n};\r\n\r\n/**\r\n * Retrieves an instance from a packed array.\r\n *\r\n * @param {Number[]} array The packed array.\r\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n * @param {SimplePolylineGeometry} [result] The object into which to store the result.\r\n * @returns {SimplePolylineGeometry} The modified result parameter or a new SimplePolylineGeometry instance if one was not provided.\r\n */\r\nSimplePolylineGeometry.unpack = function (array, startingIndex, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(array)) {\r\n    throw new DeveloperError(\"array is required\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  let i;\r\n\r\n  let length = array[startingIndex++];\r\n  const positions = new Array(length);\r\n\r\n  for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\r\n    positions[i] = Cartesian3.unpack(array, startingIndex);\r\n  }\r\n\r\n  length = array[startingIndex++];\r\n  const colors = length > 0 ? new Array(length) : undefined;\r\n\r\n  for (i = 0; i < length; ++i, startingIndex += Color.packedLength) {\r\n    colors[i] = Color.unpack(array, startingIndex);\r\n  }\r\n\r\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex);\r\n  startingIndex += Ellipsoid.packedLength;\r\n\r\n  const colorsPerVertex = array[startingIndex++] === 1.0;\r\n  const arcType = array[startingIndex++];\r\n  const granularity = array[startingIndex];\r\n\r\n  if (!defined(result)) {\r\n    return new SimplePolylineGeometry({\r\n      positions: positions,\r\n      colors: colors,\r\n      ellipsoid: ellipsoid,\r\n      colorsPerVertex: colorsPerVertex,\r\n      arcType: arcType,\r\n      granularity: granularity,\r\n    });\r\n  }\r\n\r\n  result._positions = positions;\r\n  result._colors = colors;\r\n  result._ellipsoid = ellipsoid;\r\n  result._colorsPerVertex = colorsPerVertex;\r\n  result._arcType = arcType;\r\n  result._granularity = granularity;\r\n\r\n  return result;\r\n};\r\n\r\nconst scratchArray1 = new Array(2);\r\nconst scratchArray2 = new Array(2);\r\nconst generateArcOptionsScratch = {\r\n  positions: scratchArray1,\r\n  height: scratchArray2,\r\n  ellipsoid: undefined,\r\n  minDistance: undefined,\r\n  granularity: undefined,\r\n};\r\n\r\n/**\r\n * Computes the geometric representation of a simple polyline, including its vertices, indices, and a bounding sphere.\r\n *\r\n * @param {SimplePolylineGeometry} simplePolylineGeometry A description of the polyline.\r\n * @returns {Geometry|undefined} The computed vertices and indices.\r\n */\r\nSimplePolylineGeometry.createGeometry = function (simplePolylineGeometry) {\r\n  const positions = simplePolylineGeometry._positions;\r\n  const colors = simplePolylineGeometry._colors;\r\n  const colorsPerVertex = simplePolylineGeometry._colorsPerVertex;\r\n  const arcType = simplePolylineGeometry._arcType;\r\n  const granularity = simplePolylineGeometry._granularity;\r\n  const ellipsoid = simplePolylineGeometry._ellipsoid;\r\n\r\n  const minDistance = CesiumMath.chordLength(\r\n    granularity,\r\n    ellipsoid.maximumRadius\r\n  );\r\n  const perSegmentColors = defined(colors) && !colorsPerVertex;\r\n\r\n  let i;\r\n  const length = positions.length;\r\n\r\n  let positionValues;\r\n  let numberOfPositions;\r\n  let colorValues;\r\n  let color;\r\n  let offset = 0;\r\n\r\n  if (arcType === ArcType.GEODESIC || arcType === ArcType.RHUMB) {\r\n    let subdivisionSize;\r\n    let numberOfPointsFunction;\r\n    let generateArcFunction;\r\n    if (arcType === ArcType.GEODESIC) {\r\n      subdivisionSize = CesiumMath.chordLength(\r\n        granularity,\r\n        ellipsoid.maximumRadius\r\n      );\r\n      numberOfPointsFunction = PolylinePipeline.numberOfPoints;\r\n      generateArcFunction = PolylinePipeline.generateArc;\r\n    } else {\r\n      subdivisionSize = granularity;\r\n      numberOfPointsFunction = PolylinePipeline.numberOfPointsRhumbLine;\r\n      generateArcFunction = PolylinePipeline.generateRhumbArc;\r\n    }\r\n\r\n    const heights = PolylinePipeline.extractHeights(positions, ellipsoid);\r\n\r\n    const generateArcOptions = generateArcOptionsScratch;\r\n    if (arcType === ArcType.GEODESIC) {\r\n      generateArcOptions.minDistance = minDistance;\r\n    } else {\r\n      generateArcOptions.granularity = granularity;\r\n    }\r\n    generateArcOptions.ellipsoid = ellipsoid;\r\n\r\n    if (perSegmentColors) {\r\n      let positionCount = 0;\r\n      for (i = 0; i < length - 1; i++) {\r\n        positionCount +=\r\n          numberOfPointsFunction(\r\n            positions[i],\r\n            positions[i + 1],\r\n            subdivisionSize\r\n          ) + 1;\r\n      }\r\n\r\n      positionValues = new Float64Array(positionCount * 3);\r\n      colorValues = new Uint8Array(positionCount * 4);\r\n\r\n      generateArcOptions.positions = scratchArray1;\r\n      generateArcOptions.height = scratchArray2;\r\n\r\n      let ci = 0;\r\n      for (i = 0; i < length - 1; ++i) {\r\n        scratchArray1[0] = positions[i];\r\n        scratchArray1[1] = positions[i + 1];\r\n\r\n        scratchArray2[0] = heights[i];\r\n        scratchArray2[1] = heights[i + 1];\r\n\r\n        const pos = generateArcFunction(generateArcOptions);\r\n\r\n        if (defined(colors)) {\r\n          const segLen = pos.length / 3;\r\n          color = colors[i];\r\n          for (let k = 0; k < segLen; ++k) {\r\n            colorValues[ci++] = Color.floatToByte(color.red);\r\n            colorValues[ci++] = Color.floatToByte(color.green);\r\n            colorValues[ci++] = Color.floatToByte(color.blue);\r\n            colorValues[ci++] = Color.floatToByte(color.alpha);\r\n          }\r\n        }\r\n\r\n        positionValues.set(pos, offset);\r\n        offset += pos.length;\r\n      }\r\n    } else {\r\n      generateArcOptions.positions = positions;\r\n      generateArcOptions.height = heights;\r\n      positionValues = new Float64Array(\r\n        generateArcFunction(generateArcOptions)\r\n      );\r\n\r\n      if (defined(colors)) {\r\n        colorValues = new Uint8Array((positionValues.length / 3) * 4);\r\n\r\n        for (i = 0; i < length - 1; ++i) {\r\n          const p0 = positions[i];\r\n          const p1 = positions[i + 1];\r\n          const c0 = colors[i];\r\n          const c1 = colors[i + 1];\r\n          offset = interpolateColors(\r\n            p0,\r\n            p1,\r\n            c0,\r\n            c1,\r\n            minDistance,\r\n            colorValues,\r\n            offset\r\n          );\r\n        }\r\n\r\n        const lastColor = colors[length - 1];\r\n        colorValues[offset++] = Color.floatToByte(lastColor.red);\r\n        colorValues[offset++] = Color.floatToByte(lastColor.green);\r\n        colorValues[offset++] = Color.floatToByte(lastColor.blue);\r\n        colorValues[offset++] = Color.floatToByte(lastColor.alpha);\r\n      }\r\n    }\r\n  } else {\r\n    numberOfPositions = perSegmentColors ? length * 2 - 2 : length;\r\n    positionValues = new Float64Array(numberOfPositions * 3);\r\n    colorValues = defined(colors)\r\n      ? new Uint8Array(numberOfPositions * 4)\r\n      : undefined;\r\n\r\n    let positionIndex = 0;\r\n    let colorIndex = 0;\r\n\r\n    for (i = 0; i < length; ++i) {\r\n      const p = positions[i];\r\n\r\n      if (perSegmentColors && i > 0) {\r\n        Cartesian3.pack(p, positionValues, positionIndex);\r\n        positionIndex += 3;\r\n\r\n        color = colors[i - 1];\r\n        colorValues[colorIndex++] = Color.floatToByte(color.red);\r\n        colorValues[colorIndex++] = Color.floatToByte(color.green);\r\n        colorValues[colorIndex++] = Color.floatToByte(color.blue);\r\n        colorValues[colorIndex++] = Color.floatToByte(color.alpha);\r\n      }\r\n\r\n      if (perSegmentColors && i === length - 1) {\r\n        break;\r\n      }\r\n\r\n      Cartesian3.pack(p, positionValues, positionIndex);\r\n      positionIndex += 3;\r\n\r\n      if (defined(colors)) {\r\n        color = colors[i];\r\n        colorValues[colorIndex++] = Color.floatToByte(color.red);\r\n        colorValues[colorIndex++] = Color.floatToByte(color.green);\r\n        colorValues[colorIndex++] = Color.floatToByte(color.blue);\r\n        colorValues[colorIndex++] = Color.floatToByte(color.alpha);\r\n      }\r\n    }\r\n  }\r\n\r\n  const attributes = new GeometryAttributes();\r\n  attributes.position = new GeometryAttribute({\r\n    componentDatatype: ComponentDatatype.DOUBLE,\r\n    componentsPerAttribute: 3,\r\n    values: positionValues,\r\n  });\r\n\r\n  if (defined(colors)) {\r\n    attributes.color = new GeometryAttribute({\r\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\r\n      componentsPerAttribute: 4,\r\n      values: colorValues,\r\n      normalize: true,\r\n    });\r\n  }\r\n\r\n  numberOfPositions = positionValues.length / 3;\r\n  const numberOfIndices = (numberOfPositions - 1) * 2;\r\n  const indices = IndexDatatype.createTypedArray(\r\n    numberOfPositions,\r\n    numberOfIndices\r\n  );\r\n\r\n  let index = 0;\r\n  for (i = 0; i < numberOfPositions - 1; ++i) {\r\n    indices[index++] = i;\r\n    indices[index++] = i + 1;\r\n  }\r\n\r\n  return new Geometry({\r\n    attributes: attributes,\r\n    indices: indices,\r\n    primitiveType: PrimitiveType.LINES,\r\n    boundingSphere: BoundingSphere.fromPoints(positions),\r\n  });\r\n};\r\nexport default SimplePolylineGeometry;\r\n","import defined from \"../Core/defined.js\";\r\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\r\nimport SimplePolylineGeometry from \"../Core/SimplePolylineGeometry.js\";\r\n\r\nfunction createSimplePolylineGeometry(simplePolylineGeometry, offset) {\r\n  if (defined(offset)) {\r\n    simplePolylineGeometry = SimplePolylineGeometry.unpack(\r\n      simplePolylineGeometry,\r\n      offset\r\n    );\r\n  }\r\n  simplePolylineGeometry._ellipsoid = Ellipsoid.clone(\r\n    simplePolylineGeometry._ellipsoid\r\n  );\r\n  return SimplePolylineGeometry.createGeometry(simplePolylineGeometry);\r\n}\r\nexport default createSimplePolylineGeometry;\r\n"],"names":["interpolateColors","p0","p1","color0","color1","minDistance","array","offset","numPoints","PolylinePipeline","numberOfPoints","i","r0","red","g0","green","b0","blue","a0","alpha","r1","g1","b1","a1","Color","equals","floatToByte","redPerVertex","greenPerVertex","bluePerVertex","alphaPerVertex","index","SimplePolylineGeometry","options","positions","defaultValue","EMPTY_OBJECT","colors","colorsPerVertex","defined","length","DeveloperError","this","_positions","_colors","_colorsPerVertex","_arcType","arcType","ArcType","GEODESIC","_granularity","granularity","CesiumMath","RADIANS_PER_DEGREE","_ellipsoid","ellipsoid","Ellipsoid","WGS84","_workerName","numComponents","Cartesian3","packedLength","pack","value","startingIndex","unpack","result","Array","undefined","scratchArray1","scratchArray2","generateArcOptionsScratch","height","createGeometry","simplePolylineGeometry","chordLength","maximumRadius","perSegmentColors","positionValues","numberOfPositions","colorValues","color","RHUMB","subdivisionSize","numberOfPointsFunction","generateArcFunction","generateArc","numberOfPointsRhumbLine","generateRhumbArc","heights","extractHeights","generateArcOptions","positionCount","Float64Array","Uint8Array","ci","pos","segLen","k","set","lastColor","positionIndex","colorIndex","p","attributes","GeometryAttributes","position","GeometryAttribute","componentDatatype","ComponentDatatype","DOUBLE","componentsPerAttribute","values","UNSIGNED_BYTE","normalize","numberOfIndices","indices","IndexDatatype","createTypedArray","Geometry","primitiveType","PrimitiveType","LINES","boundingSphere","BoundingSphere","fromPoints","clone"],"mappings":"8iBAiBA,SAASA,EAAkBC,EAAIC,EAAIC,EAAQC,EAAQC,EAAaC,EAAOC,GACrE,MAAMC,EAAYC,EAAAA,iBAAiBC,eAAeT,EAAIC,EAAIG,GAC1D,IAAIM,EAEJ,MAAMC,EAAKT,EAAOU,IACZC,EAAKX,EAAOY,MACZC,EAAKb,EAAOc,KACZC,EAAKf,EAAOgB,MAEZC,EAAKhB,EAAOS,IACZQ,EAAKjB,EAAOW,MACZO,EAAKlB,EAAOa,KACZM,EAAKnB,EAAOe,MAElB,GAAIK,QAAMC,OAAOtB,EAAQC,GAAS,CAChC,IAAKO,EAAI,EAAGA,EAAIH,EAAWG,IACzBL,EAAMC,KAAYiB,EAAKA,MAACE,YAAYd,GACpCN,EAAMC,KAAYiB,EAAKA,MAACE,YAAYZ,GACpCR,EAAMC,KAAYiB,EAAKA,MAACE,YAAYV,GACpCV,EAAMC,KAAYiB,EAAKA,MAACE,YAAYR,GAEtC,OAAOX,EAGT,MAAMoB,GAAgBP,EAAKR,GAAMJ,EAC3BoB,GAAkBP,EAAKP,GAAMN,EAC7BqB,GAAiBP,EAAKN,GAAMR,EAC5BsB,GAAkBP,EAAKL,GAAMV,EAEnC,IAAIuB,EAAQxB,EACZ,IAAKI,EAAI,EAAGA,EAAIH,EAAWG,IACzBL,EAAMyB,KAAWP,EAAKA,MAACE,YAAYd,EAAKD,EAAIgB,GAC5CrB,EAAMyB,KAAWP,EAAKA,MAACE,YAAYZ,EAAKH,EAAIiB,GAC5CtB,EAAMyB,KAAWP,EAAKA,MAACE,YAAYV,EAAKL,EAAIkB,GAC5CvB,EAAMyB,KAAWP,EAAKA,MAACE,YAAYR,EAAKP,EAAImB,GAG9C,OAAOC,EAkCT,SAASC,EAAuBC,GAE9B,MAAMC,GADND,EAAUE,EAAAA,aAAaF,EAASE,EAAYA,aAACC,eACnBF,UACpBG,EAASJ,EAAQI,OACjBC,EAAkBH,EAAYA,aAACF,EAAQK,iBAAiB,GAG9D,IAAKC,EAAOA,QAACL,IAAcA,EAAUM,OAAS,EAC5C,MAAM,IAAIC,EAAAA,eAAe,wCAE3B,GACEF,EAAAA,QAAQF,KACNC,GAAmBD,EAAOG,OAASN,EAAUM,SAC3CF,GAAmBD,EAAOG,OAASN,EAAUM,OAAS,GAE1D,MAAM,IAAIC,EAAAA,eAAe,iCAI3BC,KAAKC,WAAaT,EAClBQ,KAAKE,QAAUP,EACfK,KAAKG,iBAAmBP,EAExBI,KAAKI,SAAWX,eAAaF,EAAQc,QAASC,EAAAA,QAAQC,UACtDP,KAAKQ,aAAef,EAAYA,aAC9BF,EAAQkB,YACRC,EAAAA,WAAWC,oBAEbX,KAAKY,WAAanB,eAAaF,EAAQsB,UAAWC,EAAAA,UAAUC,OAC5Df,KAAKgB,YAAc,+BAEnB,IAAIC,EAAgB,EAAIzB,EAAUM,OAASoB,EAAAA,WAAWC,aACtDF,GAAiBpB,EAAAA,QAAQF,GAAU,EAAIA,EAAOG,OAAShB,EAAAA,MAAMqC,aAAe,EAM5EnB,KAAKmB,aAAeF,EAAgBH,EAAAA,UAAUK,aAAe,EAY/D7B,EAAuB8B,KAAO,SAAUC,EAAOzD,EAAO0D,GAEpD,IAAKzB,EAAAA,QAAQwB,GACX,MAAM,IAAItB,EAAAA,eAAe,qBAE3B,IAAKF,EAAAA,QAAQjC,GACX,MAAM,IAAImC,EAAAA,eAAe,qBAM3B,IAAI9B,EAFJqD,EAAgB7B,EAAYA,aAAC6B,EAAe,GAI5C,MAAM9B,EAAY6B,EAAMpB,WACxB,IAAIH,EAASN,EAAUM,OAGvB,IAFAlC,EAAM0D,KAAmBxB,EAEpB7B,EAAI,EAAGA,EAAI6B,IAAU7B,EAAGqD,GAAiBJ,EAAUA,WAACC,aACvDD,EAAUA,WAACE,KAAK5B,EAAUvB,GAAIL,EAAO0D,GAGvC,MAAM3B,EAAS0B,EAAMnB,QAIrB,IAHAJ,EAASD,EAAOA,QAACF,GAAUA,EAAOG,OAAS,EAC3ClC,EAAM0D,KAAmBxB,EAEpB7B,EAAI,EAAGA,EAAI6B,IAAU7B,EAAGqD,GAAiBxC,EAAKA,MAACqC,aAClDrC,EAAKA,MAACsC,KAAKzB,EAAO1B,GAAIL,EAAO0D,GAU/B,OAPAR,EAASA,UAACM,KAAKC,EAAMT,WAAYhD,EAAO0D,GACxCA,GAAiBR,EAASA,UAACK,aAE3BvD,EAAM0D,KAAmBD,EAAMlB,iBAAmB,EAAM,EACxDvC,EAAM0D,KAAmBD,EAAMjB,SAC/BxC,EAAM0D,GAAiBD,EAAMb,aAEtB5C,GAWT0B,EAAuBiC,OAAS,SAAU3D,EAAO0D,EAAeE,GAE9D,IAAK3B,EAAAA,QAAQjC,GACX,MAAM,IAAImC,EAAAA,eAAe,qBAM3B,IAAI9B,EAFJqD,EAAgB7B,EAAYA,aAAC6B,EAAe,GAI5C,IAAIxB,EAASlC,EAAM0D,KACnB,MAAM9B,EAAY,IAAIiC,MAAM3B,GAE5B,IAAK7B,EAAI,EAAGA,EAAI6B,IAAU7B,EAAGqD,GAAiBJ,EAAUA,WAACC,aACvD3B,EAAUvB,GAAKiD,EAAAA,WAAWK,OAAO3D,EAAO0D,GAG1CxB,EAASlC,EAAM0D,KACf,MAAM3B,EAASG,EAAS,EAAI,IAAI2B,MAAM3B,QAAU4B,EAEhD,IAAKzD,EAAI,EAAGA,EAAI6B,IAAU7B,EAAGqD,GAAiBxC,EAAKA,MAACqC,aAClDxB,EAAO1B,GAAKa,EAAAA,MAAMyC,OAAO3D,EAAO0D,GAGlC,MAAMT,EAAYC,EAASA,UAACS,OAAO3D,EAAO0D,GAC1CA,GAAiBR,EAASA,UAACK,aAE3B,MAAMvB,EAA6C,IAA3BhC,EAAM0D,KACxBjB,EAAUzC,EAAM0D,KAChBb,EAAc7C,EAAM0D,GAE1B,OAAKzB,EAAAA,QAAQ2B,IAWbA,EAAOvB,WAAaT,EACpBgC,EAAOtB,QAAUP,EACjB6B,EAAOZ,WAAaC,EACpBW,EAAOrB,iBAAmBP,EAC1B4B,EAAOpB,SAAWC,EAClBmB,EAAOhB,aAAeC,EAEfe,GAjBE,IAAIlC,EAAuB,CAChCE,UAAWA,EACXG,OAAQA,EACRkB,UAAWA,EACXjB,gBAAiBA,EACjBS,QAASA,EACTI,YAAaA,KAcnB,MAAMkB,EAAgB,IAAIF,MAAM,GAC1BG,EAAgB,IAAIH,MAAM,GAC1BI,EAA4B,CAChCrC,UAAWmC,EACXG,OAAQF,EACRf,eAAWa,EACX/D,iBAAa+D,EACbjB,iBAAaiB,UASfpC,EAAuByC,eAAiB,SAAUC,GAChD,MAAMxC,EAAYwC,EAAuB/B,WACnCN,EAASqC,EAAuB9B,QAChCN,EAAkBoC,EAAuB7B,iBACzCE,EAAU2B,EAAuB5B,SACjCK,EAAcuB,EAAuBxB,aACrCK,EAAYmB,EAAuBpB,WAEnCjD,EAAc+C,EAAAA,WAAWuB,YAC7BxB,EACAI,EAAUqB,eAENC,EAAmBtC,EAAOA,QAACF,KAAYC,EAE7C,IAAI3B,EACJ,MAAM6B,EAASN,EAAUM,OAEzB,IAAIsC,EACAC,EACAC,EACAC,EACA1E,EAAS,EAEb,GAAIwC,IAAYC,EAAAA,QAAQC,UAAYF,IAAYC,EAAAA,QAAQkC,MAAO,CAC7D,IAAIC,EACAC,EACAC,EACAtC,IAAYC,EAAOA,QAACC,UACtBkC,EAAkB/B,EAAUA,WAACuB,YAC3BxB,EACAI,EAAUqB,eAEZQ,EAAyB3E,EAAgBA,iBAACC,eAC1C2E,EAAsB5E,EAAgBA,iBAAC6E,cAEvCH,EAAkBhC,EAClBiC,EAAyB3E,EAAgBA,iBAAC8E,wBAC1CF,EAAsB5E,EAAgBA,iBAAC+E,kBAGzC,MAAMC,EAAUhF,EAAgBA,iBAACiF,eAAexD,EAAWqB,GAErDoC,EAAqBpB,EAQ3B,GAPIxB,IAAYC,EAAOA,QAACC,SACtB0C,EAAmBtF,YAAcA,EAEjCsF,EAAmBxC,YAAcA,EAEnCwC,EAAmBpC,UAAYA,EAE3BsB,EAAkB,CACpB,IAAIe,EAAgB,EACpB,IAAKjF,EAAI,EAAGA,EAAI6B,EAAS,EAAG7B,IAC1BiF,GACER,EACElD,EAAUvB,GACVuB,EAAUvB,EAAI,GACdwE,GACE,EAGRL,EAAiB,IAAIe,aAA6B,EAAhBD,GAClCZ,EAAc,IAAIc,WAA2B,EAAhBF,GAE7BD,EAAmBzD,UAAYmC,EAC/BsB,EAAmBnB,OAASF,EAE5B,IAAIyB,EAAK,EACT,IAAKpF,EAAI,EAAGA,EAAI6B,EAAS,IAAK7B,EAAG,CAC/B0D,EAAc,GAAKnC,EAAUvB,GAC7B0D,EAAc,GAAKnC,EAAUvB,EAAI,GAEjC2D,EAAc,GAAKmB,EAAQ9E,GAC3B2D,EAAc,GAAKmB,EAAQ9E,EAAI,GAE/B,MAAMqF,EAAMX,EAAoBM,GAEhC,GAAIpD,EAAAA,QAAQF,GAAS,CACnB,MAAM4D,EAASD,EAAIxD,OAAS,EAC5ByC,EAAQ5C,EAAO1B,GACf,IAAK,IAAIuF,EAAI,EAAGA,EAAID,IAAUC,EAC5BlB,EAAYe,KAAQvE,EAAAA,MAAME,YAAYuD,EAAMpE,KAC5CmE,EAAYe,KAAQvE,EAAAA,MAAME,YAAYuD,EAAMlE,OAC5CiE,EAAYe,KAAQvE,EAAAA,MAAME,YAAYuD,EAAMhE,MAC5C+D,EAAYe,KAAQvE,EAAAA,MAAME,YAAYuD,EAAM9D,OAIhD2D,EAAeqB,IAAIH,EAAKzF,GACxBA,GAAUyF,EAAIxD,aAShB,GANAmD,EAAmBzD,UAAYA,EAC/ByD,EAAmBnB,OAASiB,EAC5BX,EAAiB,IAAIe,aACnBR,EAAoBM,IAGlBpD,EAAAA,QAAQF,GAAS,CAGnB,IAFA2C,EAAc,IAAIc,WAAYhB,EAAetC,OAAS,EAAK,GAEtD7B,EAAI,EAAGA,EAAI6B,EAAS,IAAK7B,EAAG,CAK/BJ,EAASP,EAJEkC,EAAUvB,GACVuB,EAAUvB,EAAI,GACd0B,EAAO1B,GACP0B,EAAO1B,EAAI,GAMpBN,EACA2E,EACAzE,GAIJ,MAAM6F,EAAY/D,EAAOG,EAAS,GAClCwC,EAAYzE,KAAYiB,EAAAA,MAAME,YAAY0E,EAAUvF,KACpDmE,EAAYzE,KAAYiB,EAAAA,MAAME,YAAY0E,EAAUrF,OACpDiE,EAAYzE,KAAYiB,EAAAA,MAAME,YAAY0E,EAAUnF,MACpD+D,EAAYzE,KAAYiB,EAAAA,MAAME,YAAY0E,EAAUjF,YAGnD,CACL4D,EAAoBF,EAA4B,EAATrC,EAAa,EAAIA,EACxDsC,EAAiB,IAAIe,aAAiC,EAApBd,GAClCC,EAAczC,EAAOA,QAACF,GAClB,IAAIyD,WAA+B,EAApBf,QACfX,EAEJ,IAAIiC,EAAgB,EAChBC,EAAa,EAEjB,IAAK3F,EAAI,EAAGA,EAAI6B,IAAU7B,EAAG,CAC3B,MAAM4F,EAAIrE,EAAUvB,GAapB,GAXIkE,GAAoBlE,EAAI,IAC1BiD,EAAAA,WAAWE,KAAKyC,EAAGzB,EAAgBuB,GACnCA,GAAiB,EAEjBpB,EAAQ5C,EAAO1B,EAAI,GACnBqE,EAAYsB,KAAgB9E,EAAAA,MAAME,YAAYuD,EAAMpE,KACpDmE,EAAYsB,KAAgB9E,EAAAA,MAAME,YAAYuD,EAAMlE,OACpDiE,EAAYsB,KAAgB9E,EAAAA,MAAME,YAAYuD,EAAMhE,MACpD+D,EAAYsB,KAAgB9E,EAAAA,MAAME,YAAYuD,EAAM9D,QAGlD0D,GAAoBlE,IAAM6B,EAAS,EACrC,MAGFoB,EAAAA,WAAWE,KAAKyC,EAAGzB,EAAgBuB,GACnCA,GAAiB,EAEb9D,EAAAA,QAAQF,KACV4C,EAAQ5C,EAAO1B,GACfqE,EAAYsB,KAAgB9E,EAAAA,MAAME,YAAYuD,EAAMpE,KACpDmE,EAAYsB,KAAgB9E,EAAAA,MAAME,YAAYuD,EAAMlE,OACpDiE,EAAYsB,KAAgB9E,EAAAA,MAAME,YAAYuD,EAAMhE,MACpD+D,EAAYsB,KAAgB9E,EAAAA,MAAME,YAAYuD,EAAM9D,SAK1D,MAAMqF,EAAa,IAAIC,EAAAA,mBACvBD,EAAWE,SAAW,IAAIC,oBAAkB,CAC1CC,kBAAmBC,EAAiBA,kBAACC,OACrCC,uBAAwB,EACxBC,OAAQlC,IAGNvC,EAAAA,QAAQF,KACVmE,EAAWvB,MAAQ,IAAI0B,oBAAkB,CACvCC,kBAAmBC,EAAiBA,kBAACI,cACrCF,uBAAwB,EACxBC,OAAQhC,EACRkC,WAAW,KAIfnC,EAAoBD,EAAetC,OAAS,EAC5C,MAAM2E,EAA4C,GAAzBpC,EAAoB,GACvCqC,EAAUC,EAAAA,cAAcC,iBAC5BvC,EACAoC,GAGF,IAAIpF,EAAQ,EACZ,IAAKpB,EAAI,EAAGA,EAAIoE,EAAoB,IAAKpE,EACvCyG,EAAQrF,KAAWpB,EACnByG,EAAQrF,KAAWpB,EAAI,EAGzB,OAAO,IAAI4G,EAAAA,SAAS,CAClBf,WAAYA,EACZY,QAASA,EACTI,cAAeC,EAAaA,cAACC,MAC7BC,eAAgBC,EAAAA,eAAeC,WAAW3F,MCjc9C,SAAsCwC,EAAwBnE,GAU5D,OATIgC,EAAAA,QAAQhC,KACVmE,EAAyB1C,EAAuBiC,OAC9CS,EACAnE,IAGJmE,EAAuBpB,WAAaE,EAAAA,UAAUsE,MAC5CpD,EAAuBpB,YAElBtB,EAAuByC,eAAeC"}