{"version":3,"file":"TerrainEncoding-11ca6f56.js","sources":["../../../../Source/Core/EllipsoidalOccluder.js","../../../../Source/Core/TerrainExaggeration.js","../../../../Source/Core/TerrainQuantization.js","../../../../Source/Core/TerrainEncoding.js"],"sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\r\nimport Cartesian3 from \"./Cartesian3.js\";\r\nimport Check from \"./Check.js\";\r\nimport defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\nimport Ellipsoid from \"./Ellipsoid.js\";\r\nimport Rectangle from \"./Rectangle.js\";\r\n\r\n/**\r\n * Determine whether or not other objects are visible or hidden behind the visible horizon defined by\r\n * an {@link Ellipsoid} and a camera position.  The ellipsoid is assumed to be located at the\r\n * origin of the coordinate system.  This class uses the algorithm described in the\r\n * {@link https://cesium.com/blog/2013/04/25/Horizon-culling/|Horizon Culling} blog post.\r\n *\r\n * @alias EllipsoidalOccluder\r\n *\r\n * @param {Ellipsoid} ellipsoid The ellipsoid to use as an occluder.\r\n * @param {Cartesian3} [cameraPosition] The coordinate of the viewer/camera.  If this parameter is not\r\n *        specified, {@link EllipsoidalOccluder#cameraPosition} must be called before\r\n *        testing visibility.\r\n *\r\n * @constructor\r\n *\r\n * @example\r\n * // Construct an ellipsoidal occluder with radii 1.0, 1.1, and 0.9.\r\n * const cameraPosition = new Cesium.Cartesian3(5.0, 6.0, 7.0);\r\n * const occluderEllipsoid = new Cesium.Ellipsoid(1.0, 1.1, 0.9);\r\n * const occluder = new Cesium.EllipsoidalOccluder(occluderEllipsoid, cameraPosition);\r\n *\r\n * @private\r\n */\r\nfunction EllipsoidalOccluder(ellipsoid, cameraPosition) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"ellipsoid\", ellipsoid);\r\n  //>>includeEnd('debug');\r\n\r\n  this._ellipsoid = ellipsoid;\r\n  this._cameraPosition = new Cartesian3();\r\n  this._cameraPositionInScaledSpace = new Cartesian3();\r\n  this._distanceToLimbInScaledSpaceSquared = 0.0;\r\n\r\n  // cameraPosition fills in the above values\r\n  if (defined(cameraPosition)) {\r\n    this.cameraPosition = cameraPosition;\r\n  }\r\n}\r\n\r\nObject.defineProperties(EllipsoidalOccluder.prototype, {\r\n  /**\r\n   * Gets the occluding ellipsoid.\r\n   * @memberof EllipsoidalOccluder.prototype\r\n   * @type {Ellipsoid}\r\n   */\r\n  ellipsoid: {\r\n    get: function () {\r\n      return this._ellipsoid;\r\n    },\r\n  },\r\n  /**\r\n   * Gets or sets the position of the camera.\r\n   * @memberof EllipsoidalOccluder.prototype\r\n   * @type {Cartesian3}\r\n   */\r\n  cameraPosition: {\r\n    get: function () {\r\n      return this._cameraPosition;\r\n    },\r\n    set: function (cameraPosition) {\r\n      // See https://cesium.com/blog/2013/04/25/Horizon-culling/\r\n      const ellipsoid = this._ellipsoid;\r\n      const cv = ellipsoid.transformPositionToScaledSpace(\r\n        cameraPosition,\r\n        this._cameraPositionInScaledSpace\r\n      );\r\n      const vhMagnitudeSquared = Cartesian3.magnitudeSquared(cv) - 1.0;\r\n\r\n      Cartesian3.clone(cameraPosition, this._cameraPosition);\r\n      this._cameraPositionInScaledSpace = cv;\r\n      this._distanceToLimbInScaledSpaceSquared = vhMagnitudeSquared;\r\n    },\r\n  },\r\n});\r\n\r\nconst scratchCartesian = new Cartesian3();\r\n\r\n/**\r\n * Determines whether or not a point, the <code>occludee</code>, is hidden from view by the occluder.\r\n *\r\n * @param {Cartesian3} occludee The point to test for visibility.\r\n * @returns {Boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.\r\n *\r\n * @example\r\n * const cameraPosition = new Cesium.Cartesian3(0, 0, 2.5);\r\n * const ellipsoid = new Cesium.Ellipsoid(1.0, 1.1, 0.9);\r\n * const occluder = new Cesium.EllipsoidalOccluder(ellipsoid, cameraPosition);\r\n * const point = new Cesium.Cartesian3(0, -3, -3);\r\n * occluder.isPointVisible(point); //returns true\r\n */\r\nEllipsoidalOccluder.prototype.isPointVisible = function (occludee) {\r\n  const ellipsoid = this._ellipsoid;\r\n  const occludeeScaledSpacePosition = ellipsoid.transformPositionToScaledSpace(\r\n    occludee,\r\n    scratchCartesian\r\n  );\r\n  return isScaledSpacePointVisible(\r\n    occludeeScaledSpacePosition,\r\n    this._cameraPositionInScaledSpace,\r\n    this._distanceToLimbInScaledSpaceSquared\r\n  );\r\n};\r\n\r\n/**\r\n * Determines whether or not a point expressed in the ellipsoid scaled space, is hidden from view by the\r\n * occluder.  To transform a Cartesian X, Y, Z position in the coordinate system aligned with the ellipsoid\r\n * into the scaled space, call {@link Ellipsoid#transformPositionToScaledSpace}.\r\n *\r\n * @param {Cartesian3} occludeeScaledSpacePosition The point to test for visibility, represented in the scaled space.\r\n * @returns {Boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.\r\n *\r\n * @example\r\n * const cameraPosition = new Cesium.Cartesian3(0, 0, 2.5);\r\n * const ellipsoid = new Cesium.Ellipsoid(1.0, 1.1, 0.9);\r\n * const occluder = new Cesium.EllipsoidalOccluder(ellipsoid, cameraPosition);\r\n * const point = new Cesium.Cartesian3(0, -3, -3);\r\n * const scaledSpacePoint = ellipsoid.transformPositionToScaledSpace(point);\r\n * occluder.isScaledSpacePointVisible(scaledSpacePoint); //returns true\r\n */\r\nEllipsoidalOccluder.prototype.isScaledSpacePointVisible = function (\r\n  occludeeScaledSpacePosition\r\n) {\r\n  return isScaledSpacePointVisible(\r\n    occludeeScaledSpacePosition,\r\n    this._cameraPositionInScaledSpace,\r\n    this._distanceToLimbInScaledSpaceSquared\r\n  );\r\n};\r\n\r\nconst scratchCameraPositionInScaledSpaceShrunk = new Cartesian3();\r\n\r\n/**\r\n * Similar to {@link EllipsoidalOccluder#isScaledSpacePointVisible} except tests against an\r\n * ellipsoid that has been shrunk by the minimum height when the minimum height is below\r\n * the ellipsoid. This is intended to be used with points generated by\r\n * {@link EllipsoidalOccluder#computeHorizonCullingPointPossiblyUnderEllipsoid} or\r\n * {@link EllipsoidalOccluder#computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid}.\r\n *\r\n * @param {Cartesian3} occludeeScaledSpacePosition The point to test for visibility, represented in the scaled space of the possibly-shrunk ellipsoid.\r\n * @returns {Boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.\r\n */\r\nEllipsoidalOccluder.prototype.isScaledSpacePointVisiblePossiblyUnderEllipsoid = function (\r\n  occludeeScaledSpacePosition,\r\n  minimumHeight\r\n) {\r\n  const ellipsoid = this._ellipsoid;\r\n  let vhMagnitudeSquared;\r\n  let cv;\r\n\r\n  if (\r\n    defined(minimumHeight) &&\r\n    minimumHeight < 0.0 &&\r\n    ellipsoid.minimumRadius > -minimumHeight\r\n  ) {\r\n    // This code is similar to the cameraPosition setter, but unrolled for performance because it will be called a lot.\r\n    cv = scratchCameraPositionInScaledSpaceShrunk;\r\n    cv.x = this._cameraPosition.x / (ellipsoid.radii.x + minimumHeight);\r\n    cv.y = this._cameraPosition.y / (ellipsoid.radii.y + minimumHeight);\r\n    cv.z = this._cameraPosition.z / (ellipsoid.radii.z + minimumHeight);\r\n    vhMagnitudeSquared = cv.x * cv.x + cv.y * cv.y + cv.z * cv.z - 1.0;\r\n  } else {\r\n    cv = this._cameraPositionInScaledSpace;\r\n    vhMagnitudeSquared = this._distanceToLimbInScaledSpaceSquared;\r\n  }\r\n\r\n  return isScaledSpacePointVisible(\r\n    occludeeScaledSpacePosition,\r\n    cv,\r\n    vhMagnitudeSquared\r\n  );\r\n};\r\n\r\n/**\r\n * Computes a point that can be used for horizon culling from a list of positions.  If the point is below\r\n * the horizon, all of the positions are guaranteed to be below the horizon as well.  The returned point\r\n * is expressed in the ellipsoid-scaled space and is suitable for use with\r\n * {@link EllipsoidalOccluder#isScaledSpacePointVisible}.\r\n *\r\n * @param {Cartesian3} directionToPoint The direction that the computed point will lie along.\r\n *                     A reasonable direction to use is the direction from the center of the ellipsoid to\r\n *                     the center of the bounding sphere computed from the positions.  The direction need not\r\n *                     be normalized.\r\n * @param {Cartesian3[]} positions The positions from which to compute the horizon culling point.  The positions\r\n *                       must be expressed in a reference frame centered at the ellipsoid and aligned with the\r\n *                       ellipsoid's axes.\r\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\r\n * @returns {Cartesian3} The computed horizon culling point, expressed in the ellipsoid-scaled space.\r\n */\r\nEllipsoidalOccluder.prototype.computeHorizonCullingPoint = function (\r\n  directionToPoint,\r\n  positions,\r\n  result\r\n) {\r\n  return computeHorizonCullingPointFromPositions(\r\n    this._ellipsoid,\r\n    directionToPoint,\r\n    positions,\r\n    result\r\n  );\r\n};\r\n\r\nconst scratchEllipsoidShrunk = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\r\n\r\n/**\r\n * Similar to {@link EllipsoidalOccluder#computeHorizonCullingPoint} except computes the culling\r\n * point relative to an ellipsoid that has been shrunk by the minimum height when the minimum height is below\r\n * the ellipsoid. The returned point is expressed in the possibly-shrunk ellipsoid-scaled space and is suitable\r\n * for use with {@link EllipsoidalOccluder#isScaledSpacePointVisiblePossiblyUnderEllipsoid}.\r\n *\r\n * @param {Cartesian3} directionToPoint The direction that the computed point will lie along.\r\n *                     A reasonable direction to use is the direction from the center of the ellipsoid to\r\n *                     the center of the bounding sphere computed from the positions.  The direction need not\r\n *                     be normalized.\r\n * @param {Cartesian3[]} positions The positions from which to compute the horizon culling point.  The positions\r\n *                       must be expressed in a reference frame centered at the ellipsoid and aligned with the\r\n *                       ellipsoid's axes.\r\n * @param {Number} [minimumHeight] The minimum height of all positions. If this value is undefined, all positions are assumed to be above the ellipsoid.\r\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\r\n * @returns {Cartesian3} The computed horizon culling point, expressed in the possibly-shrunk ellipsoid-scaled space.\r\n */\r\nEllipsoidalOccluder.prototype.computeHorizonCullingPointPossiblyUnderEllipsoid = function (\r\n  directionToPoint,\r\n  positions,\r\n  minimumHeight,\r\n  result\r\n) {\r\n  const possiblyShrunkEllipsoid = getPossiblyShrunkEllipsoid(\r\n    this._ellipsoid,\r\n    minimumHeight,\r\n    scratchEllipsoidShrunk\r\n  );\r\n  return computeHorizonCullingPointFromPositions(\r\n    possiblyShrunkEllipsoid,\r\n    directionToPoint,\r\n    positions,\r\n    result\r\n  );\r\n};\r\n/**\r\n * Computes a point that can be used for horizon culling from a list of positions.  If the point is below\r\n * the horizon, all of the positions are guaranteed to be below the horizon as well.  The returned point\r\n * is expressed in the ellipsoid-scaled space and is suitable for use with\r\n * {@link EllipsoidalOccluder#isScaledSpacePointVisible}.\r\n *\r\n * @param {Cartesian3} directionToPoint The direction that the computed point will lie along.\r\n *                     A reasonable direction to use is the direction from the center of the ellipsoid to\r\n *                     the center of the bounding sphere computed from the positions.  The direction need not\r\n *                     be normalized.\r\n * @param {Number[]} vertices  The vertices from which to compute the horizon culling point.  The positions\r\n *                   must be expressed in a reference frame centered at the ellipsoid and aligned with the\r\n *                   ellipsoid's axes.\r\n * @param {Number} [stride=3]\r\n * @param {Cartesian3} [center=Cartesian3.ZERO]\r\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\r\n * @returns {Cartesian3} The computed horizon culling point, expressed in the ellipsoid-scaled space.\r\n */\r\nEllipsoidalOccluder.prototype.computeHorizonCullingPointFromVertices = function (\r\n  directionToPoint,\r\n  vertices,\r\n  stride,\r\n  center,\r\n  result\r\n) {\r\n  return computeHorizonCullingPointFromVertices(\r\n    this._ellipsoid,\r\n    directionToPoint,\r\n    vertices,\r\n    stride,\r\n    center,\r\n    result\r\n  );\r\n};\r\n\r\n/**\r\n * Similar to {@link EllipsoidalOccluder#computeHorizonCullingPointFromVertices} except computes the culling\r\n * point relative to an ellipsoid that has been shrunk by the minimum height when the minimum height is below\r\n * the ellipsoid. The returned point is expressed in the possibly-shrunk ellipsoid-scaled space and is suitable\r\n * for use with {@link EllipsoidalOccluder#isScaledSpacePointVisiblePossiblyUnderEllipsoid}.\r\n *\r\n * @param {Cartesian3} directionToPoint The direction that the computed point will lie along.\r\n *                     A reasonable direction to use is the direction from the center of the ellipsoid to\r\n *                     the center of the bounding sphere computed from the positions.  The direction need not\r\n *                     be normalized.\r\n * @param {Number[]} vertices  The vertices from which to compute the horizon culling point.  The positions\r\n *                   must be expressed in a reference frame centered at the ellipsoid and aligned with the\r\n *                   ellipsoid's axes.\r\n * @param {Number} [stride=3]\r\n * @param {Cartesian3} [center=Cartesian3.ZERO]\r\n * @param {Number} [minimumHeight] The minimum height of all vertices. If this value is undefined, all vertices are assumed to be above the ellipsoid.\r\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\r\n * @returns {Cartesian3} The computed horizon culling point, expressed in the possibly-shrunk ellipsoid-scaled space.\r\n */\r\nEllipsoidalOccluder.prototype.computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid = function (\r\n  directionToPoint,\r\n  vertices,\r\n  stride,\r\n  center,\r\n  minimumHeight,\r\n  result\r\n) {\r\n  const possiblyShrunkEllipsoid = getPossiblyShrunkEllipsoid(\r\n    this._ellipsoid,\r\n    minimumHeight,\r\n    scratchEllipsoidShrunk\r\n  );\r\n  return computeHorizonCullingPointFromVertices(\r\n    possiblyShrunkEllipsoid,\r\n    directionToPoint,\r\n    vertices,\r\n    stride,\r\n    center,\r\n    result\r\n  );\r\n};\r\n\r\nconst subsampleScratch = [];\r\n\r\n/**\r\n * Computes a point that can be used for horizon culling of a rectangle.  If the point is below\r\n * the horizon, the ellipsoid-conforming rectangle is guaranteed to be below the horizon as well.\r\n * The returned point is expressed in the ellipsoid-scaled space and is suitable for use with\r\n * {@link EllipsoidalOccluder#isScaledSpacePointVisible}.\r\n *\r\n * @param {Rectangle} rectangle The rectangle for which to compute the horizon culling point.\r\n * @param {Ellipsoid} ellipsoid The ellipsoid on which the rectangle is defined.  This may be different from\r\n *                    the ellipsoid used by this instance for occlusion testing.\r\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\r\n * @returns {Cartesian3} The computed horizon culling point, expressed in the ellipsoid-scaled space.\r\n */\r\nEllipsoidalOccluder.prototype.computeHorizonCullingPointFromRectangle = function (\r\n  rectangle,\r\n  ellipsoid,\r\n  result\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"rectangle\", rectangle);\r\n  //>>includeEnd('debug');\r\n\r\n  const positions = Rectangle.subsample(\r\n    rectangle,\r\n    ellipsoid,\r\n    0.0,\r\n    subsampleScratch\r\n  );\r\n  const bs = BoundingSphere.fromPoints(positions);\r\n\r\n  // If the bounding sphere center is too close to the center of the occluder, it doesn't make\r\n  // sense to try to horizon cull it.\r\n  if (Cartesian3.magnitude(bs.center) < 0.1 * ellipsoid.minimumRadius) {\r\n    return undefined;\r\n  }\r\n\r\n  return this.computeHorizonCullingPoint(bs.center, positions, result);\r\n};\r\n\r\nconst scratchEllipsoidShrunkRadii = new Cartesian3();\r\n\r\nfunction getPossiblyShrunkEllipsoid(ellipsoid, minimumHeight, result) {\r\n  if (\r\n    defined(minimumHeight) &&\r\n    minimumHeight < 0.0 &&\r\n    ellipsoid.minimumRadius > -minimumHeight\r\n  ) {\r\n    const ellipsoidShrunkRadii = Cartesian3.fromElements(\r\n      ellipsoid.radii.x + minimumHeight,\r\n      ellipsoid.radii.y + minimumHeight,\r\n      ellipsoid.radii.z + minimumHeight,\r\n      scratchEllipsoidShrunkRadii\r\n    );\r\n    ellipsoid = Ellipsoid.fromCartesian3(ellipsoidShrunkRadii, result);\r\n  }\r\n  return ellipsoid;\r\n}\r\n\r\nfunction computeHorizonCullingPointFromPositions(\r\n  ellipsoid,\r\n  directionToPoint,\r\n  positions,\r\n  result\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"directionToPoint\", directionToPoint);\r\n  Check.defined(\"positions\", positions);\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    result = new Cartesian3();\r\n  }\r\n\r\n  const scaledSpaceDirectionToPoint = computeScaledSpaceDirectionToPoint(\r\n    ellipsoid,\r\n    directionToPoint\r\n  );\r\n  let resultMagnitude = 0.0;\r\n\r\n  for (let i = 0, len = positions.length; i < len; ++i) {\r\n    const position = positions[i];\r\n    const candidateMagnitude = computeMagnitude(\r\n      ellipsoid,\r\n      position,\r\n      scaledSpaceDirectionToPoint\r\n    );\r\n    if (candidateMagnitude < 0.0) {\r\n      // all points should face the same direction, but this one doesn't, so return undefined\r\n      return undefined;\r\n    }\r\n    resultMagnitude = Math.max(resultMagnitude, candidateMagnitude);\r\n  }\r\n\r\n  return magnitudeToPoint(scaledSpaceDirectionToPoint, resultMagnitude, result);\r\n}\r\n\r\nconst positionScratch = new Cartesian3();\r\n\r\nfunction computeHorizonCullingPointFromVertices(\r\n  ellipsoid,\r\n  directionToPoint,\r\n  vertices,\r\n  stride,\r\n  center,\r\n  result\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"directionToPoint\", directionToPoint);\r\n  Check.defined(\"vertices\", vertices);\r\n  Check.typeOf.number(\"stride\", stride);\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    result = new Cartesian3();\r\n  }\r\n\r\n  stride = defaultValue(stride, 3);\r\n  center = defaultValue(center, Cartesian3.ZERO);\r\n  const scaledSpaceDirectionToPoint = computeScaledSpaceDirectionToPoint(\r\n    ellipsoid,\r\n    directionToPoint\r\n  );\r\n  let resultMagnitude = 0.0;\r\n\r\n  for (let i = 0, len = vertices.length; i < len; i += stride) {\r\n    positionScratch.x = vertices[i] + center.x;\r\n    positionScratch.y = vertices[i + 1] + center.y;\r\n    positionScratch.z = vertices[i + 2] + center.z;\r\n\r\n    const candidateMagnitude = computeMagnitude(\r\n      ellipsoid,\r\n      positionScratch,\r\n      scaledSpaceDirectionToPoint\r\n    );\r\n    if (candidateMagnitude < 0.0) {\r\n      // all points should face the same direction, but this one doesn't, so return undefined\r\n      return undefined;\r\n    }\r\n    resultMagnitude = Math.max(resultMagnitude, candidateMagnitude);\r\n  }\r\n\r\n  return magnitudeToPoint(scaledSpaceDirectionToPoint, resultMagnitude, result);\r\n}\r\n\r\nfunction isScaledSpacePointVisible(\r\n  occludeeScaledSpacePosition,\r\n  cameraPositionInScaledSpace,\r\n  distanceToLimbInScaledSpaceSquared\r\n) {\r\n  // See https://cesium.com/blog/2013/04/25/Horizon-culling/\r\n  const cv = cameraPositionInScaledSpace;\r\n  const vhMagnitudeSquared = distanceToLimbInScaledSpaceSquared;\r\n  const vt = Cartesian3.subtract(\r\n    occludeeScaledSpacePosition,\r\n    cv,\r\n    scratchCartesian\r\n  );\r\n  const vtDotVc = -Cartesian3.dot(vt, cv);\r\n  // If vhMagnitudeSquared < 0 then we are below the surface of the ellipsoid and\r\n  // in this case, set the culling plane to be on V.\r\n  const isOccluded =\r\n    vhMagnitudeSquared < 0\r\n      ? vtDotVc > 0\r\n      : vtDotVc > vhMagnitudeSquared &&\r\n        (vtDotVc * vtDotVc) / Cartesian3.magnitudeSquared(vt) >\r\n          vhMagnitudeSquared;\r\n  return !isOccluded;\r\n}\r\n\r\nconst scaledSpaceScratch = new Cartesian3();\r\nconst directionScratch = new Cartesian3();\r\n\r\nfunction computeMagnitude(ellipsoid, position, scaledSpaceDirectionToPoint) {\r\n  const scaledSpacePosition = ellipsoid.transformPositionToScaledSpace(\r\n    position,\r\n    scaledSpaceScratch\r\n  );\r\n  let magnitudeSquared = Cartesian3.magnitudeSquared(scaledSpacePosition);\r\n  let magnitude = Math.sqrt(magnitudeSquared);\r\n  const direction = Cartesian3.divideByScalar(\r\n    scaledSpacePosition,\r\n    magnitude,\r\n    directionScratch\r\n  );\r\n\r\n  // For the purpose of this computation, points below the ellipsoid are consider to be on it instead.\r\n  magnitudeSquared = Math.max(1.0, magnitudeSquared);\r\n  magnitude = Math.max(1.0, magnitude);\r\n\r\n  const cosAlpha = Cartesian3.dot(direction, scaledSpaceDirectionToPoint);\r\n  const sinAlpha = Cartesian3.magnitude(\r\n    Cartesian3.cross(direction, scaledSpaceDirectionToPoint, direction)\r\n  );\r\n  const cosBeta = 1.0 / magnitude;\r\n  const sinBeta = Math.sqrt(magnitudeSquared - 1.0) * cosBeta;\r\n\r\n  return 1.0 / (cosAlpha * cosBeta - sinAlpha * sinBeta);\r\n}\r\n\r\nfunction magnitudeToPoint(\r\n  scaledSpaceDirectionToPoint,\r\n  resultMagnitude,\r\n  result\r\n) {\r\n  // The horizon culling point is undefined if there were no positions from which to compute it,\r\n  // the directionToPoint is pointing opposite all of the positions,  or if we computed NaN or infinity.\r\n  if (\r\n    resultMagnitude <= 0.0 ||\r\n    resultMagnitude === 1.0 / 0.0 ||\r\n    resultMagnitude !== resultMagnitude\r\n  ) {\r\n    return undefined;\r\n  }\r\n\r\n  return Cartesian3.multiplyByScalar(\r\n    scaledSpaceDirectionToPoint,\r\n    resultMagnitude,\r\n    result\r\n  );\r\n}\r\n\r\nconst directionToPointScratch = new Cartesian3();\r\n\r\nfunction computeScaledSpaceDirectionToPoint(ellipsoid, directionToPoint) {\r\n  if (Cartesian3.equals(directionToPoint, Cartesian3.ZERO)) {\r\n    return directionToPoint;\r\n  }\r\n\r\n  ellipsoid.transformPositionToScaledSpace(\r\n    directionToPoint,\r\n    directionToPointScratch\r\n  );\r\n  return Cartesian3.normalize(directionToPointScratch, directionToPointScratch);\r\n}\r\nexport default EllipsoidalOccluder;\r\n","import Cartesian3 from \"./Cartesian3.js\";\r\n\r\n/**\r\n * @private\r\n */\r\nconst TerrainExaggeration = {};\r\n\r\n/**\r\n * Scales a height relative to an offset.\r\n *\r\n * @param {Number} height The height.\r\n * @param {Number} scale A scalar used to exaggerate the terrain. If the value is 1.0 there will be no effect.\r\n * @param {Number} relativeHeight The height relative to which terrain is exaggerated. If the value is 0.0 terrain will be exaggerated relative to the ellipsoid surface.\r\n */\r\nTerrainExaggeration.getHeight = function (height, scale, relativeHeight) {\r\n  return (height - relativeHeight) * scale + relativeHeight;\r\n};\r\n\r\nconst scratchCartographic = new Cartesian3();\r\n\r\n/**\r\n * Scales a position by exaggeration.\r\n */\r\nTerrainExaggeration.getPosition = function (\r\n  position,\r\n  ellipsoid,\r\n  terrainExaggeration,\r\n  terrainExaggerationRelativeHeight,\r\n  result\r\n) {\r\n  const cartographic = ellipsoid.cartesianToCartographic(\r\n    position,\r\n    scratchCartographic\r\n  );\r\n  const newHeight = TerrainExaggeration.getHeight(\r\n    cartographic.height,\r\n    terrainExaggeration,\r\n    terrainExaggerationRelativeHeight\r\n  );\r\n  return Cartesian3.fromRadians(\r\n    cartographic.longitude,\r\n    cartographic.latitude,\r\n    newHeight,\r\n    ellipsoid,\r\n    result\r\n  );\r\n};\r\n\r\nexport default TerrainExaggeration;\r\n","/**\r\n * This enumerated type is used to determine how the vertices of the terrain mesh are compressed.\r\n *\r\n * @enum {Number}\r\n *\r\n * @private\r\n */\r\nconst TerrainQuantization = {\r\n  /**\r\n   * The vertices are not compressed.\r\n   *\r\n   * @type {Number}\r\n   * @constant\r\n   */\r\n  NONE: 0,\r\n\r\n  /**\r\n   * The vertices are compressed to 12 bits.\r\n   *\r\n   * @type {Number}\r\n   * @constant\r\n   */\r\n  BITS12: 1,\r\n};\r\nexport default Object.freeze(TerrainQuantization);\r\n","import AttributeCompression from \"./AttributeCompression.js\";\r\nimport Cartesian2 from \"./Cartesian2.js\";\r\nimport Cartesian3 from \"./Cartesian3.js\";\r\nimport ComponentDatatype from \"./ComponentDatatype.js\";\r\nimport defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\nimport CesiumMath from \"./Math.js\";\r\nimport Matrix4 from \"./Matrix4.js\";\r\nimport TerrainExaggeration from \"./TerrainExaggeration.js\";\r\nimport TerrainQuantization from \"./TerrainQuantization.js\";\r\n\r\nconst cartesian3Scratch = new Cartesian3();\r\nconst cartesian3DimScratch = new Cartesian3();\r\nconst cartesian2Scratch = new Cartesian2();\r\nconst matrix4Scratch = new Matrix4();\r\nconst matrix4Scratch2 = new Matrix4();\r\n\r\nconst SHIFT_LEFT_12 = Math.pow(2.0, 12.0);\r\n\r\n/**\r\n * Data used to quantize and pack the terrain mesh. The position can be unpacked for picking and all attributes\r\n * are unpacked in the vertex shader.\r\n *\r\n * @alias TerrainEncoding\r\n * @constructor\r\n *\r\n * @param {Cartesian3} center The center point of the vertices.\r\n * @param {AxisAlignedBoundingBox} axisAlignedBoundingBox The bounds of the tile in the east-north-up coordinates at the tiles center.\r\n * @param {Number} minimumHeight The minimum height.\r\n * @param {Number} maximumHeight The maximum height.\r\n * @param {Matrix4} fromENU The east-north-up to fixed frame matrix at the center of the terrain mesh.\r\n * @param {Boolean} hasVertexNormals If the mesh has vertex normals.\r\n * @param {Boolean} [hasWebMercatorT=false] true if the terrain data includes a Web Mercator texture coordinate; otherwise, false.\r\n * @param {Boolean} [hasGeodeticSurfaceNormals=false] true if the terrain data includes geodetic surface normals; otherwise, false.\r\n * @param {Number} [exaggeration=1.0] A scalar used to exaggerate terrain.\r\n * @param {Number} [exaggerationRelativeHeight=0.0] The relative height from which terrain is exaggerated.\r\n *\r\n * @private\r\n */\r\nfunction TerrainEncoding(\r\n  center,\r\n  axisAlignedBoundingBox,\r\n  minimumHeight,\r\n  maximumHeight,\r\n  fromENU,\r\n  hasVertexNormals,\r\n  hasWebMercatorT,\r\n  hasGeodeticSurfaceNormals,\r\n  exaggeration,\r\n  exaggerationRelativeHeight\r\n) {\r\n  let quantization = TerrainQuantization.NONE;\r\n  let toENU;\r\n  let matrix;\r\n\r\n  if (\r\n    defined(axisAlignedBoundingBox) &&\r\n    defined(minimumHeight) &&\r\n    defined(maximumHeight) &&\r\n    defined(fromENU)\r\n  ) {\r\n    const minimum = axisAlignedBoundingBox.minimum;\r\n    const maximum = axisAlignedBoundingBox.maximum;\r\n\r\n    const dimensions = Cartesian3.subtract(\r\n      maximum,\r\n      minimum,\r\n      cartesian3DimScratch\r\n    );\r\n    const hDim = maximumHeight - minimumHeight;\r\n    const maxDim = Math.max(Cartesian3.maximumComponent(dimensions), hDim);\r\n\r\n    if (maxDim < SHIFT_LEFT_12 - 1.0) {\r\n      quantization = TerrainQuantization.BITS12;\r\n    } else {\r\n      quantization = TerrainQuantization.NONE;\r\n    }\r\n\r\n    toENU = Matrix4.inverseTransformation(fromENU, new Matrix4());\r\n\r\n    const translation = Cartesian3.negate(minimum, cartesian3Scratch);\r\n    Matrix4.multiply(\r\n      Matrix4.fromTranslation(translation, matrix4Scratch),\r\n      toENU,\r\n      toENU\r\n    );\r\n\r\n    const scale = cartesian3Scratch;\r\n    scale.x = 1.0 / dimensions.x;\r\n    scale.y = 1.0 / dimensions.y;\r\n    scale.z = 1.0 / dimensions.z;\r\n    Matrix4.multiply(Matrix4.fromScale(scale, matrix4Scratch), toENU, toENU);\r\n\r\n    matrix = Matrix4.clone(fromENU);\r\n    Matrix4.setTranslation(matrix, Cartesian3.ZERO, matrix);\r\n\r\n    fromENU = Matrix4.clone(fromENU, new Matrix4());\r\n\r\n    const translationMatrix = Matrix4.fromTranslation(minimum, matrix4Scratch);\r\n    const scaleMatrix = Matrix4.fromScale(dimensions, matrix4Scratch2);\r\n    const st = Matrix4.multiply(translationMatrix, scaleMatrix, matrix4Scratch);\r\n\r\n    Matrix4.multiply(fromENU, st, fromENU);\r\n    Matrix4.multiply(matrix, st, matrix);\r\n  }\r\n\r\n  /**\r\n   * How the vertices of the mesh were compressed.\r\n   * @type {TerrainQuantization}\r\n   */\r\n  this.quantization = quantization;\r\n\r\n  /**\r\n   * The minimum height of the tile including the skirts.\r\n   * @type {Number}\r\n   */\r\n  this.minimumHeight = minimumHeight;\r\n\r\n  /**\r\n   * The maximum height of the tile.\r\n   * @type {Number}\r\n   */\r\n  this.maximumHeight = maximumHeight;\r\n\r\n  /**\r\n   * The center of the tile.\r\n   * @type {Cartesian3}\r\n   */\r\n  this.center = Cartesian3.clone(center);\r\n\r\n  /**\r\n   * A matrix that takes a vertex from the tile, transforms it to east-north-up at the center and scales\r\n   * it so each component is in the [0, 1] range.\r\n   * @type {Matrix4}\r\n   */\r\n  this.toScaledENU = toENU;\r\n\r\n  /**\r\n   * A matrix that restores a vertex transformed with toScaledENU back to the earth fixed reference frame\r\n   * @type {Matrix4}\r\n   */\r\n  this.fromScaledENU = fromENU;\r\n\r\n  /**\r\n   * The matrix used to decompress the terrain vertices in the shader for RTE rendering.\r\n   * @type {Matrix4}\r\n   */\r\n  this.matrix = matrix;\r\n\r\n  /**\r\n   * The terrain mesh contains normals.\r\n   * @type {Boolean}\r\n   */\r\n  this.hasVertexNormals = hasVertexNormals;\r\n\r\n  /**\r\n   * The terrain mesh contains a vertical texture coordinate following the Web Mercator projection.\r\n   * @type {Boolean}\r\n   */\r\n  this.hasWebMercatorT = defaultValue(hasWebMercatorT, false);\r\n\r\n  /**\r\n   * The terrain mesh contains geodetic surface normals, used for terrain exaggeration.\r\n   * @type {Boolean}\r\n   */\r\n  this.hasGeodeticSurfaceNormals = defaultValue(\r\n    hasGeodeticSurfaceNormals,\r\n    false\r\n  );\r\n\r\n  /**\r\n   * A scalar used to exaggerate terrain.\r\n   * @type {Number}\r\n   */\r\n  this.exaggeration = defaultValue(exaggeration, 1.0);\r\n\r\n  /**\r\n   * The relative height from which terrain is exaggerated.\r\n   */\r\n  this.exaggerationRelativeHeight = defaultValue(\r\n    exaggerationRelativeHeight,\r\n    0.0\r\n  );\r\n\r\n  /**\r\n   * The number of components in each vertex. This value can differ with different quantizations.\r\n   * @type {Number}\r\n   */\r\n  this.stride = 0;\r\n\r\n  this._offsetGeodeticSurfaceNormal = 0;\r\n  this._offsetVertexNormal = 0;\r\n\r\n  // Calculate the stride and offsets declared above\r\n  this._calculateStrideAndOffsets();\r\n}\r\n\r\nTerrainEncoding.prototype.encode = function (\r\n  vertexBuffer,\r\n  bufferIndex,\r\n  position,\r\n  uv,\r\n  height,\r\n  normalToPack,\r\n  webMercatorT,\r\n  geodeticSurfaceNormal\r\n) {\r\n  const u = uv.x;\r\n  const v = uv.y;\r\n\r\n  if (this.quantization === TerrainQuantization.BITS12) {\r\n    position = Matrix4.multiplyByPoint(\r\n      this.toScaledENU,\r\n      position,\r\n      cartesian3Scratch\r\n    );\r\n\r\n    position.x = CesiumMath.clamp(position.x, 0.0, 1.0);\r\n    position.y = CesiumMath.clamp(position.y, 0.0, 1.0);\r\n    position.z = CesiumMath.clamp(position.z, 0.0, 1.0);\r\n\r\n    const hDim = this.maximumHeight - this.minimumHeight;\r\n    const h = CesiumMath.clamp((height - this.minimumHeight) / hDim, 0.0, 1.0);\r\n\r\n    Cartesian2.fromElements(position.x, position.y, cartesian2Scratch);\r\n    const compressed0 = AttributeCompression.compressTextureCoordinates(\r\n      cartesian2Scratch\r\n    );\r\n\r\n    Cartesian2.fromElements(position.z, h, cartesian2Scratch);\r\n    const compressed1 = AttributeCompression.compressTextureCoordinates(\r\n      cartesian2Scratch\r\n    );\r\n\r\n    Cartesian2.fromElements(u, v, cartesian2Scratch);\r\n    const compressed2 = AttributeCompression.compressTextureCoordinates(\r\n      cartesian2Scratch\r\n    );\r\n\r\n    vertexBuffer[bufferIndex++] = compressed0;\r\n    vertexBuffer[bufferIndex++] = compressed1;\r\n    vertexBuffer[bufferIndex++] = compressed2;\r\n\r\n    if (this.hasWebMercatorT) {\r\n      Cartesian2.fromElements(webMercatorT, 0.0, cartesian2Scratch);\r\n      const compressed3 = AttributeCompression.compressTextureCoordinates(\r\n        cartesian2Scratch\r\n      );\r\n      vertexBuffer[bufferIndex++] = compressed3;\r\n    }\r\n  } else {\r\n    Cartesian3.subtract(position, this.center, cartesian3Scratch);\r\n\r\n    vertexBuffer[bufferIndex++] = cartesian3Scratch.x;\r\n    vertexBuffer[bufferIndex++] = cartesian3Scratch.y;\r\n    vertexBuffer[bufferIndex++] = cartesian3Scratch.z;\r\n    vertexBuffer[bufferIndex++] = height;\r\n    vertexBuffer[bufferIndex++] = u;\r\n    vertexBuffer[bufferIndex++] = v;\r\n\r\n    if (this.hasWebMercatorT) {\r\n      vertexBuffer[bufferIndex++] = webMercatorT;\r\n    }\r\n  }\r\n\r\n  if (this.hasVertexNormals) {\r\n    vertexBuffer[bufferIndex++] = AttributeCompression.octPackFloat(\r\n      normalToPack\r\n    );\r\n  }\r\n\r\n  if (this.hasGeodeticSurfaceNormals) {\r\n    vertexBuffer[bufferIndex++] = geodeticSurfaceNormal.x;\r\n    vertexBuffer[bufferIndex++] = geodeticSurfaceNormal.y;\r\n    vertexBuffer[bufferIndex++] = geodeticSurfaceNormal.z;\r\n  }\r\n\r\n  return bufferIndex;\r\n};\r\n\r\nconst scratchPosition = new Cartesian3();\r\nconst scratchGeodeticSurfaceNormal = new Cartesian3();\r\n\r\nTerrainEncoding.prototype.addGeodeticSurfaceNormals = function (\r\n  oldBuffer,\r\n  newBuffer,\r\n  ellipsoid\r\n) {\r\n  if (this.hasGeodeticSurfaceNormals) {\r\n    return;\r\n  }\r\n\r\n  const oldStride = this.stride;\r\n  const vertexCount = oldBuffer.length / oldStride;\r\n  this.hasGeodeticSurfaceNormals = true;\r\n  this._calculateStrideAndOffsets();\r\n  const newStride = this.stride;\r\n\r\n  for (let index = 0; index < vertexCount; index++) {\r\n    for (let offset = 0; offset < oldStride; offset++) {\r\n      const oldIndex = index * oldStride + offset;\r\n      const newIndex = index * newStride + offset;\r\n      newBuffer[newIndex] = oldBuffer[oldIndex];\r\n    }\r\n    const position = this.decodePosition(newBuffer, index, scratchPosition);\r\n    const geodeticSurfaceNormal = ellipsoid.geodeticSurfaceNormal(\r\n      position,\r\n      scratchGeodeticSurfaceNormal\r\n    );\r\n\r\n    const bufferIndex = index * newStride + this._offsetGeodeticSurfaceNormal;\r\n    newBuffer[bufferIndex] = geodeticSurfaceNormal.x;\r\n    newBuffer[bufferIndex + 1] = geodeticSurfaceNormal.y;\r\n    newBuffer[bufferIndex + 2] = geodeticSurfaceNormal.z;\r\n  }\r\n};\r\n\r\nTerrainEncoding.prototype.removeGeodeticSurfaceNormals = function (\r\n  oldBuffer,\r\n  newBuffer\r\n) {\r\n  if (!this.hasGeodeticSurfaceNormals) {\r\n    return;\r\n  }\r\n\r\n  const oldStride = this.stride;\r\n  const vertexCount = oldBuffer.length / oldStride;\r\n  this.hasGeodeticSurfaceNormals = false;\r\n  this._calculateStrideAndOffsets();\r\n  const newStride = this.stride;\r\n\r\n  for (let index = 0; index < vertexCount; index++) {\r\n    for (let offset = 0; offset < newStride; offset++) {\r\n      const oldIndex = index * oldStride + offset;\r\n      const newIndex = index * newStride + offset;\r\n      newBuffer[newIndex] = oldBuffer[oldIndex];\r\n    }\r\n  }\r\n};\r\n\r\nTerrainEncoding.prototype.decodePosition = function (buffer, index, result) {\r\n  if (!defined(result)) {\r\n    result = new Cartesian3();\r\n  }\r\n\r\n  index *= this.stride;\r\n\r\n  if (this.quantization === TerrainQuantization.BITS12) {\r\n    const xy = AttributeCompression.decompressTextureCoordinates(\r\n      buffer[index],\r\n      cartesian2Scratch\r\n    );\r\n    result.x = xy.x;\r\n    result.y = xy.y;\r\n\r\n    const zh = AttributeCompression.decompressTextureCoordinates(\r\n      buffer[index + 1],\r\n      cartesian2Scratch\r\n    );\r\n    result.z = zh.x;\r\n\r\n    return Matrix4.multiplyByPoint(this.fromScaledENU, result, result);\r\n  }\r\n\r\n  result.x = buffer[index];\r\n  result.y = buffer[index + 1];\r\n  result.z = buffer[index + 2];\r\n  return Cartesian3.add(result, this.center, result);\r\n};\r\n\r\nTerrainEncoding.prototype.getExaggeratedPosition = function (\r\n  buffer,\r\n  index,\r\n  result\r\n) {\r\n  result = this.decodePosition(buffer, index, result);\r\n\r\n  const exaggeration = this.exaggeration;\r\n  const exaggerationRelativeHeight = this.exaggerationRelativeHeight;\r\n  const hasExaggeration = exaggeration !== 1.0;\r\n  if (hasExaggeration && this.hasGeodeticSurfaceNormals) {\r\n    const geodeticSurfaceNormal = this.decodeGeodeticSurfaceNormal(\r\n      buffer,\r\n      index,\r\n      scratchGeodeticSurfaceNormal\r\n    );\r\n    const rawHeight = this.decodeHeight(buffer, index);\r\n    const heightDifference =\r\n      TerrainExaggeration.getHeight(\r\n        rawHeight,\r\n        exaggeration,\r\n        exaggerationRelativeHeight\r\n      ) - rawHeight;\r\n\r\n    // some math is unrolled for better performance\r\n    result.x += geodeticSurfaceNormal.x * heightDifference;\r\n    result.y += geodeticSurfaceNormal.y * heightDifference;\r\n    result.z += geodeticSurfaceNormal.z * heightDifference;\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\nTerrainEncoding.prototype.decodeTextureCoordinates = function (\r\n  buffer,\r\n  index,\r\n  result\r\n) {\r\n  if (!defined(result)) {\r\n    result = new Cartesian2();\r\n  }\r\n\r\n  index *= this.stride;\r\n\r\n  if (this.quantization === TerrainQuantization.BITS12) {\r\n    return AttributeCompression.decompressTextureCoordinates(\r\n      buffer[index + 2],\r\n      result\r\n    );\r\n  }\r\n\r\n  return Cartesian2.fromElements(buffer[index + 4], buffer[index + 5], result);\r\n};\r\n\r\nTerrainEncoding.prototype.decodeHeight = function (buffer, index) {\r\n  index *= this.stride;\r\n\r\n  if (this.quantization === TerrainQuantization.BITS12) {\r\n    const zh = AttributeCompression.decompressTextureCoordinates(\r\n      buffer[index + 1],\r\n      cartesian2Scratch\r\n    );\r\n    return (\r\n      zh.y * (this.maximumHeight - this.minimumHeight) + this.minimumHeight\r\n    );\r\n  }\r\n\r\n  return buffer[index + 3];\r\n};\r\n\r\nTerrainEncoding.prototype.decodeWebMercatorT = function (buffer, index) {\r\n  index *= this.stride;\r\n\r\n  if (this.quantization === TerrainQuantization.BITS12) {\r\n    return AttributeCompression.decompressTextureCoordinates(\r\n      buffer[index + 3],\r\n      cartesian2Scratch\r\n    ).x;\r\n  }\r\n\r\n  return buffer[index + 6];\r\n};\r\n\r\nTerrainEncoding.prototype.getOctEncodedNormal = function (\r\n  buffer,\r\n  index,\r\n  result\r\n) {\r\n  index = index * this.stride + this._offsetVertexNormal;\r\n\r\n  const temp = buffer[index] / 256.0;\r\n  const x = Math.floor(temp);\r\n  const y = (temp - x) * 256.0;\r\n\r\n  return Cartesian2.fromElements(x, y, result);\r\n};\r\n\r\nTerrainEncoding.prototype.decodeGeodeticSurfaceNormal = function (\r\n  buffer,\r\n  index,\r\n  result\r\n) {\r\n  index = index * this.stride + this._offsetGeodeticSurfaceNormal;\r\n\r\n  result.x = buffer[index];\r\n  result.y = buffer[index + 1];\r\n  result.z = buffer[index + 2];\r\n  return result;\r\n};\r\n\r\nTerrainEncoding.prototype._calculateStrideAndOffsets = function () {\r\n  let vertexStride = 0;\r\n\r\n  switch (this.quantization) {\r\n    case TerrainQuantization.BITS12:\r\n      vertexStride += 3;\r\n      break;\r\n    default:\r\n      vertexStride += 6;\r\n  }\r\n  if (this.hasWebMercatorT) {\r\n    vertexStride += 1;\r\n  }\r\n  if (this.hasVertexNormals) {\r\n    this._offsetVertexNormal = vertexStride;\r\n    vertexStride += 1;\r\n  }\r\n  if (this.hasGeodeticSurfaceNormals) {\r\n    this._offsetGeodeticSurfaceNormal = vertexStride;\r\n    vertexStride += 3;\r\n  }\r\n\r\n  this.stride = vertexStride;\r\n};\r\n\r\nconst attributesIndicesNone = {\r\n  position3DAndHeight: 0,\r\n  textureCoordAndEncodedNormals: 1,\r\n  geodeticSurfaceNormal: 2,\r\n};\r\nconst attributesIndicesBits12 = {\r\n  compressed0: 0,\r\n  compressed1: 1,\r\n  geodeticSurfaceNormal: 2,\r\n};\r\n\r\nTerrainEncoding.prototype.getAttributes = function (buffer) {\r\n  const datatype = ComponentDatatype.FLOAT;\r\n  const sizeInBytes = ComponentDatatype.getSizeInBytes(datatype);\r\n  const strideInBytes = this.stride * sizeInBytes;\r\n  let offsetInBytes = 0;\r\n\r\n  const attributes = [];\r\n  function addAttribute(index, componentsPerAttribute) {\r\n    attributes.push({\r\n      index: index,\r\n      vertexBuffer: buffer,\r\n      componentDatatype: datatype,\r\n      componentsPerAttribute: componentsPerAttribute,\r\n      offsetInBytes: offsetInBytes,\r\n      strideInBytes: strideInBytes,\r\n    });\r\n    offsetInBytes += componentsPerAttribute * sizeInBytes;\r\n  }\r\n\r\n  if (this.quantization === TerrainQuantization.NONE) {\r\n    addAttribute(attributesIndicesNone.position3DAndHeight, 4);\r\n\r\n    let componentsTexCoordAndNormals = 2;\r\n    componentsTexCoordAndNormals += this.hasWebMercatorT ? 1 : 0;\r\n    componentsTexCoordAndNormals += this.hasVertexNormals ? 1 : 0;\r\n    addAttribute(\r\n      attributesIndicesNone.textureCoordAndEncodedNormals,\r\n      componentsTexCoordAndNormals\r\n    );\r\n\r\n    if (this.hasGeodeticSurfaceNormals) {\r\n      addAttribute(attributesIndicesNone.geodeticSurfaceNormal, 3);\r\n    }\r\n  } else {\r\n    // When there is no webMercatorT or vertex normals, the attribute only needs 3 components: x/y, z/h, u/v.\r\n    // WebMercatorT and vertex normals each take up one component, so if only one of them is present the first\r\n    // attribute gets a 4th component. If both are present, we need an additional attribute that has 1 component.\r\n    const usingAttribute0Component4 =\r\n      this.hasWebMercatorT || this.hasVertexNormals;\r\n    const usingAttribute1Component1 =\r\n      this.hasWebMercatorT && this.hasVertexNormals;\r\n    addAttribute(\r\n      attributesIndicesBits12.compressed0,\r\n      usingAttribute0Component4 ? 4 : 3\r\n    );\r\n\r\n    if (usingAttribute1Component1) {\r\n      addAttribute(attributesIndicesBits12.compressed1, 1);\r\n    }\r\n\r\n    if (this.hasGeodeticSurfaceNormals) {\r\n      addAttribute(attributesIndicesBits12.geodeticSurfaceNormal, 3);\r\n    }\r\n  }\r\n\r\n  return attributes;\r\n};\r\n\r\nTerrainEncoding.prototype.getAttributeLocations = function () {\r\n  if (this.quantization === TerrainQuantization.NONE) {\r\n    return attributesIndicesNone;\r\n  }\r\n  return attributesIndicesBits12;\r\n};\r\n\r\nTerrainEncoding.clone = function (encoding, result) {\r\n  if (!defined(encoding)) {\r\n    return undefined;\r\n  }\r\n  if (!defined(result)) {\r\n    result = new TerrainEncoding();\r\n  }\r\n\r\n  result.quantization = encoding.quantization;\r\n  result.minimumHeight = encoding.minimumHeight;\r\n  result.maximumHeight = encoding.maximumHeight;\r\n  result.center = Cartesian3.clone(encoding.center);\r\n  result.toScaledENU = Matrix4.clone(encoding.toScaledENU);\r\n  result.fromScaledENU = Matrix4.clone(encoding.fromScaledENU);\r\n  result.matrix = Matrix4.clone(encoding.matrix);\r\n  result.hasVertexNormals = encoding.hasVertexNormals;\r\n  result.hasWebMercatorT = encoding.hasWebMercatorT;\r\n  result.hasGeodeticSurfaceNormals = encoding.hasGeodeticSurfaceNormals;\r\n  result.exaggeration = encoding.exaggeration;\r\n  result.exaggerationRelativeHeight = encoding.exaggerationRelativeHeight;\r\n\r\n  result._calculateStrideAndOffsets();\r\n\r\n  return result;\r\n};\r\nexport default TerrainEncoding;\r\n"],"names":["EllipsoidalOccluder","ellipsoid","cameraPosition","Check","typeOf","object","this","_ellipsoid","_cameraPosition","Cartesian3","_cameraPositionInScaledSpace","_distanceToLimbInScaledSpaceSquared","defined","Object","defineProperties","prototype","get","set","cv","transformPositionToScaledSpace","vhMagnitudeSquared","magnitudeSquared","clone","scratchCartesian","isPointVisible","occludee","isScaledSpacePointVisible","occludeeScaledSpacePosition","scratchCameraPositionInScaledSpaceShrunk","isScaledSpacePointVisiblePossiblyUnderEllipsoid","minimumHeight","minimumRadius","x","radii","y","z","computeHorizonCullingPoint","directionToPoint","positions","result","computeHorizonCullingPointFromPositions","scratchEllipsoidShrunk","Ellipsoid","UNIT_SPHERE","computeHorizonCullingPointPossiblyUnderEllipsoid","getPossiblyShrunkEllipsoid","computeHorizonCullingPointFromVertices","vertices","stride","center","computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid","subsampleScratch","computeHorizonCullingPointFromRectangle","rectangle","Rectangle","subsample","bs","BoundingSphere","fromPoints","magnitude","scratchEllipsoidShrunkRadii","ellipsoidShrunkRadii","fromElements","fromCartesian3","scaledSpaceDirectionToPoint","computeScaledSpaceDirectionToPoint","resultMagnitude","i","len","length","candidateMagnitude","computeMagnitude","Math","max","magnitudeToPoint","positionScratch","number","defaultValue","ZERO","cameraPositionInScaledSpace","distanceToLimbInScaledSpaceSquared","vt","subtract","vtDotVc","dot","scaledSpaceScratch","directionScratch","position","scaledSpacePosition","sqrt","direction","divideByScalar","cosBeta","cross","multiplyByScalar","directionToPointScratch","equals","normalize","TerrainExaggeration","height","scale","relativeHeight","scratchCartographic","getPosition","terrainExaggeration","terrainExaggerationRelativeHeight","cartographic","cartesianToCartographic","newHeight","getHeight","fromRadians","longitude","latitude","TerrainQuantization$1","freeze","NONE","BITS12","cartesian3Scratch","cartesian3DimScratch","cartesian2Scratch","Cartesian2","matrix4Scratch","Matrix4","matrix4Scratch2","SHIFT_LEFT_12","pow","TerrainEncoding","axisAlignedBoundingBox","maximumHeight","fromENU","hasVertexNormals","hasWebMercatorT","hasGeodeticSurfaceNormals","exaggeration","exaggerationRelativeHeight","toENU","matrix","quantization","TerrainQuantization","minimum","maximum","dimensions","hDim","maximumComponent","inverseTransformation","translation","negate","multiply","fromTranslation","fromScale","setTranslation","translationMatrix","scaleMatrix","st","toScaledENU","fromScaledENU","_offsetGeodeticSurfaceNormal","_offsetVertexNormal","_calculateStrideAndOffsets","encode","vertexBuffer","bufferIndex","uv","normalToPack","webMercatorT","geodeticSurfaceNormal","u","v","multiplyByPoint","CesiumMath","clamp","h","compressed0","AttributeCompression","compressTextureCoordinates","compressed1","compressed2","compressed3","octPackFloat","scratchPosition","scratchGeodeticSurfaceNormal","addGeodeticSurfaceNormals","oldBuffer","newBuffer","oldStride","vertexCount","newStride","index","offset","oldIndex","decodePosition","removeGeodeticSurfaceNormals","buffer","xy","decompressTextureCoordinates","zh","add","getExaggeratedPosition","decodeGeodeticSurfaceNormal","rawHeight","decodeHeight","heightDifference","decodeTextureCoordinates","decodeWebMercatorT","getOctEncodedNormal","temp","floor","vertexStride","attributesIndicesNone","position3DAndHeight","textureCoordAndEncodedNormals","attributesIndicesBits12","getAttributes","datatype","ComponentDatatype","FLOAT","sizeInBytes","getSizeInBytes","strideInBytes","offsetInBytes","attributes","addAttribute","componentsPerAttribute","push","componentDatatype","componentsTexCoordAndNormals","usingAttribute0Component4","usingAttribute1Component1","getAttributeLocations","encoding"],"mappings":"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"}