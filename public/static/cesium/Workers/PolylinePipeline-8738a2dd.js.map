{"version":3,"file":"PolylinePipeline-8738a2dd.js","sources":["../../../../Source/Core/PolylinePipeline.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\r\nimport Cartographic from \"./Cartographic.js\";\r\nimport defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\nimport DeveloperError from \"./DeveloperError.js\";\r\nimport Ellipsoid from \"./Ellipsoid.js\";\r\nimport EllipsoidGeodesic from \"./EllipsoidGeodesic.js\";\r\nimport EllipsoidRhumbLine from \"./EllipsoidRhumbLine.js\";\r\nimport IntersectionTests from \"./IntersectionTests.js\";\r\nimport CesiumMath from \"./Math.js\";\r\nimport Matrix4 from \"./Matrix4.js\";\r\nimport Plane from \"./Plane.js\";\r\n\r\n/**\r\n * @private\r\n */\r\nconst PolylinePipeline = {};\r\n\r\nPolylinePipeline.numberOfPoints = function (p0, p1, minDistance) {\r\n  const distance = Cartesian3.distance(p0, p1);\r\n  return Math.ceil(distance / minDistance);\r\n};\r\n\r\nPolylinePipeline.numberOfPointsRhumbLine = function (p0, p1, granularity) {\r\n  const radiansDistanceSquared =\r\n    Math.pow(p0.longitude - p1.longitude, 2) +\r\n    Math.pow(p0.latitude - p1.latitude, 2);\r\n\r\n  return Math.max(\r\n    1,\r\n    Math.ceil(Math.sqrt(radiansDistanceSquared / (granularity * granularity)))\r\n  );\r\n};\r\n\r\nconst cartoScratch = new Cartographic();\r\nPolylinePipeline.extractHeights = function (positions, ellipsoid) {\r\n  const length = positions.length;\r\n  const heights = new Array(length);\r\n  for (let i = 0; i < length; i++) {\r\n    const p = positions[i];\r\n    heights[i] = ellipsoid.cartesianToCartographic(p, cartoScratch).height;\r\n  }\r\n  return heights;\r\n};\r\n\r\nconst wrapLongitudeInversMatrix = new Matrix4();\r\nconst wrapLongitudeOrigin = new Cartesian3();\r\nconst wrapLongitudeXZNormal = new Cartesian3();\r\nconst wrapLongitudeXZPlane = new Plane(Cartesian3.UNIT_X, 0.0);\r\nconst wrapLongitudeYZNormal = new Cartesian3();\r\nconst wrapLongitudeYZPlane = new Plane(Cartesian3.UNIT_X, 0.0);\r\nconst wrapLongitudeIntersection = new Cartesian3();\r\nconst wrapLongitudeOffset = new Cartesian3();\r\n\r\nconst subdivideHeightsScratchArray = [];\r\n\r\nfunction subdivideHeights(numPoints, h0, h1) {\r\n  const heights = subdivideHeightsScratchArray;\r\n  heights.length = numPoints;\r\n\r\n  let i;\r\n  if (h0 === h1) {\r\n    for (i = 0; i < numPoints; i++) {\r\n      heights[i] = h0;\r\n    }\r\n    return heights;\r\n  }\r\n\r\n  const dHeight = h1 - h0;\r\n  const heightPerVertex = dHeight / numPoints;\r\n\r\n  for (i = 0; i < numPoints; i++) {\r\n    const h = h0 + i * heightPerVertex;\r\n    heights[i] = h;\r\n  }\r\n\r\n  return heights;\r\n}\r\n\r\nconst carto1 = new Cartographic();\r\nconst carto2 = new Cartographic();\r\nconst cartesian = new Cartesian3();\r\nconst scaleFirst = new Cartesian3();\r\nconst scaleLast = new Cartesian3();\r\nconst ellipsoidGeodesic = new EllipsoidGeodesic();\r\nlet ellipsoidRhumb = new EllipsoidRhumbLine();\r\n\r\n//Returns subdivided line scaled to ellipsoid surface starting at p1 and ending at p2.\r\n//Result includes p1, but not include p2.  This function is called for a sequence of line segments,\r\n//and this prevents duplication of end point.\r\nfunction generateCartesianArc(\r\n  p0,\r\n  p1,\r\n  minDistance,\r\n  ellipsoid,\r\n  h0,\r\n  h1,\r\n  array,\r\n  offset\r\n) {\r\n  const first = ellipsoid.scaleToGeodeticSurface(p0, scaleFirst);\r\n  const last = ellipsoid.scaleToGeodeticSurface(p1, scaleLast);\r\n  const numPoints = PolylinePipeline.numberOfPoints(p0, p1, minDistance);\r\n  const start = ellipsoid.cartesianToCartographic(first, carto1);\r\n  const end = ellipsoid.cartesianToCartographic(last, carto2);\r\n  const heights = subdivideHeights(numPoints, h0, h1);\r\n\r\n  ellipsoidGeodesic.setEndPoints(start, end);\r\n  const surfaceDistanceBetweenPoints =\r\n    ellipsoidGeodesic.surfaceDistance / numPoints;\r\n\r\n  let index = offset;\r\n  start.height = h0;\r\n  let cart = ellipsoid.cartographicToCartesian(start, cartesian);\r\n  Cartesian3.pack(cart, array, index);\r\n  index += 3;\r\n\r\n  for (let i = 1; i < numPoints; i++) {\r\n    const carto = ellipsoidGeodesic.interpolateUsingSurfaceDistance(\r\n      i * surfaceDistanceBetweenPoints,\r\n      carto2\r\n    );\r\n    carto.height = heights[i];\r\n    cart = ellipsoid.cartographicToCartesian(carto, cartesian);\r\n    Cartesian3.pack(cart, array, index);\r\n    index += 3;\r\n  }\r\n\r\n  return index;\r\n}\r\n\r\n//Returns subdivided line scaled to ellipsoid surface starting at p1 and ending at p2.\r\n//Result includes p1, but not include p2.  This function is called for a sequence of line segments,\r\n//and this prevents duplication of end point.\r\nfunction generateCartesianRhumbArc(\r\n  p0,\r\n  p1,\r\n  granularity,\r\n  ellipsoid,\r\n  h0,\r\n  h1,\r\n  array,\r\n  offset\r\n) {\r\n  const start = ellipsoid.cartesianToCartographic(p0, carto1);\r\n  const end = ellipsoid.cartesianToCartographic(p1, carto2);\r\n  const numPoints = PolylinePipeline.numberOfPointsRhumbLine(\r\n    start,\r\n    end,\r\n    granularity\r\n  );\r\n  start.height = 0.0;\r\n  end.height = 0.0;\r\n  const heights = subdivideHeights(numPoints, h0, h1);\r\n\r\n  if (!ellipsoidRhumb.ellipsoid.equals(ellipsoid)) {\r\n    ellipsoidRhumb = new EllipsoidRhumbLine(undefined, undefined, ellipsoid);\r\n  }\r\n  ellipsoidRhumb.setEndPoints(start, end);\r\n  const surfaceDistanceBetweenPoints =\r\n    ellipsoidRhumb.surfaceDistance / numPoints;\r\n\r\n  let index = offset;\r\n  start.height = h0;\r\n  let cart = ellipsoid.cartographicToCartesian(start, cartesian);\r\n  Cartesian3.pack(cart, array, index);\r\n  index += 3;\r\n\r\n  for (let i = 1; i < numPoints; i++) {\r\n    const carto = ellipsoidRhumb.interpolateUsingSurfaceDistance(\r\n      i * surfaceDistanceBetweenPoints,\r\n      carto2\r\n    );\r\n    carto.height = heights[i];\r\n    cart = ellipsoid.cartographicToCartesian(carto, cartesian);\r\n    Cartesian3.pack(cart, array, index);\r\n    index += 3;\r\n  }\r\n\r\n  return index;\r\n}\r\n\r\n/**\r\n * Breaks a {@link Polyline} into segments such that it does not cross the &plusmn;180 degree meridian of an ellipsoid.\r\n *\r\n * @param {Cartesian3[]} positions The polyline's Cartesian positions.\r\n * @param {Matrix4} [modelMatrix=Matrix4.IDENTITY] The polyline's model matrix. Assumed to be an affine\r\n * transformation matrix, where the upper left 3x3 elements are a rotation matrix, and\r\n * the upper three elements in the fourth column are the translation.  The bottom row is assumed to be [0, 0, 0, 1].\r\n * The matrix is not verified to be in the proper form.\r\n * @returns {Object} An object with a <code>positions</code> property that is an array of positions and a\r\n * <code>segments</code> property.\r\n *\r\n *\r\n * @example\r\n * const polylines = new Cesium.PolylineCollection();\r\n * const polyline = polylines.add(...);\r\n * const positions = polyline.positions;\r\n * const modelMatrix = polylines.modelMatrix;\r\n * const segments = Cesium.PolylinePipeline.wrapLongitude(positions, modelMatrix);\r\n *\r\n * @see PolygonPipeline.wrapLongitude\r\n * @see Polyline\r\n * @see PolylineCollection\r\n */\r\nPolylinePipeline.wrapLongitude = function (positions, modelMatrix) {\r\n  const cartesians = [];\r\n  const segments = [];\r\n\r\n  if (defined(positions) && positions.length > 0) {\r\n    modelMatrix = defaultValue(modelMatrix, Matrix4.IDENTITY);\r\n    const inverseModelMatrix = Matrix4.inverseTransformation(\r\n      modelMatrix,\r\n      wrapLongitudeInversMatrix\r\n    );\r\n\r\n    const origin = Matrix4.multiplyByPoint(\r\n      inverseModelMatrix,\r\n      Cartesian3.ZERO,\r\n      wrapLongitudeOrigin\r\n    );\r\n    const xzNormal = Cartesian3.normalize(\r\n      Matrix4.multiplyByPointAsVector(\r\n        inverseModelMatrix,\r\n        Cartesian3.UNIT_Y,\r\n        wrapLongitudeXZNormal\r\n      ),\r\n      wrapLongitudeXZNormal\r\n    );\r\n    const xzPlane = Plane.fromPointNormal(\r\n      origin,\r\n      xzNormal,\r\n      wrapLongitudeXZPlane\r\n    );\r\n    const yzNormal = Cartesian3.normalize(\r\n      Matrix4.multiplyByPointAsVector(\r\n        inverseModelMatrix,\r\n        Cartesian3.UNIT_X,\r\n        wrapLongitudeYZNormal\r\n      ),\r\n      wrapLongitudeYZNormal\r\n    );\r\n    const yzPlane = Plane.fromPointNormal(\r\n      origin,\r\n      yzNormal,\r\n      wrapLongitudeYZPlane\r\n    );\r\n\r\n    let count = 1;\r\n    cartesians.push(Cartesian3.clone(positions[0]));\r\n    let prev = cartesians[0];\r\n\r\n    const length = positions.length;\r\n    for (let i = 1; i < length; ++i) {\r\n      const cur = positions[i];\r\n\r\n      // intersects the IDL if either endpoint is on the negative side of the yz-plane\r\n      if (\r\n        Plane.getPointDistance(yzPlane, prev) < 0.0 ||\r\n        Plane.getPointDistance(yzPlane, cur) < 0.0\r\n      ) {\r\n        // and intersects the xz-plane\r\n        const intersection = IntersectionTests.lineSegmentPlane(\r\n          prev,\r\n          cur,\r\n          xzPlane,\r\n          wrapLongitudeIntersection\r\n        );\r\n        if (defined(intersection)) {\r\n          // move point on the xz-plane slightly away from the plane\r\n          const offset = Cartesian3.multiplyByScalar(\r\n            xzNormal,\r\n            5.0e-9,\r\n            wrapLongitudeOffset\r\n          );\r\n          if (Plane.getPointDistance(xzPlane, prev) < 0.0) {\r\n            Cartesian3.negate(offset, offset);\r\n          }\r\n\r\n          cartesians.push(\r\n            Cartesian3.add(intersection, offset, new Cartesian3())\r\n          );\r\n          segments.push(count + 1);\r\n\r\n          Cartesian3.negate(offset, offset);\r\n          cartesians.push(\r\n            Cartesian3.add(intersection, offset, new Cartesian3())\r\n          );\r\n          count = 1;\r\n        }\r\n      }\r\n\r\n      cartesians.push(Cartesian3.clone(positions[i]));\r\n      count++;\r\n\r\n      prev = cur;\r\n    }\r\n\r\n    segments.push(count);\r\n  }\r\n\r\n  return {\r\n    positions: cartesians,\r\n    lengths: segments,\r\n  };\r\n};\r\n\r\n/**\r\n * Subdivides polyline and raises all points to the specified height.  Returns an array of numbers to represent the positions.\r\n * @param {Object} options Object with the following properties:\r\n * @param {Cartesian3[]} options.positions The array of type {Cartesian3} representing positions.\r\n * @param {Number|Number[]} [options.height=0.0] A number or array of numbers representing the heights of each position.\r\n * @param {Number} [options.granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\r\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the positions lie.\r\n * @returns {Number[]} A new array of positions of type {Number} that have been subdivided and raised to the surface of the ellipsoid.\r\n *\r\n * @example\r\n * const positions = Cesium.Cartesian3.fromDegreesArray([\r\n *   -105.0, 40.0,\r\n *   -100.0, 38.0,\r\n *   -105.0, 35.0,\r\n *   -100.0, 32.0\r\n * ]);\r\n * const surfacePositions = Cesium.PolylinePipeline.generateArc({\r\n *   positons: positions\r\n * });\r\n */\r\nPolylinePipeline.generateArc = function (options) {\r\n  if (!defined(options)) {\r\n    options = {};\r\n  }\r\n  const positions = options.positions;\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(positions)) {\r\n    throw new DeveloperError(\"options.positions is required.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const length = positions.length;\r\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\r\n  let height = defaultValue(options.height, 0);\r\n  const hasHeightArray = Array.isArray(height);\r\n\r\n  if (length < 1) {\r\n    return [];\r\n  } else if (length === 1) {\r\n    const p = ellipsoid.scaleToGeodeticSurface(positions[0], scaleFirst);\r\n    height = hasHeightArray ? height[0] : height;\r\n    if (height !== 0) {\r\n      const n = ellipsoid.geodeticSurfaceNormal(p, cartesian);\r\n      Cartesian3.multiplyByScalar(n, height, n);\r\n      Cartesian3.add(p, n, p);\r\n    }\r\n\r\n    return [p.x, p.y, p.z];\r\n  }\r\n\r\n  let minDistance = options.minDistance;\r\n  if (!defined(minDistance)) {\r\n    const granularity = defaultValue(\r\n      options.granularity,\r\n      CesiumMath.RADIANS_PER_DEGREE\r\n    );\r\n    minDistance = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\r\n  }\r\n\r\n  let numPoints = 0;\r\n  let i;\r\n\r\n  for (i = 0; i < length - 1; i++) {\r\n    numPoints += PolylinePipeline.numberOfPoints(\r\n      positions[i],\r\n      positions[i + 1],\r\n      minDistance\r\n    );\r\n  }\r\n\r\n  const arrayLength = (numPoints + 1) * 3;\r\n  const newPositions = new Array(arrayLength);\r\n  let offset = 0;\r\n\r\n  for (i = 0; i < length - 1; i++) {\r\n    const p0 = positions[i];\r\n    const p1 = positions[i + 1];\r\n\r\n    const h0 = hasHeightArray ? height[i] : height;\r\n    const h1 = hasHeightArray ? height[i + 1] : height;\r\n\r\n    offset = generateCartesianArc(\r\n      p0,\r\n      p1,\r\n      minDistance,\r\n      ellipsoid,\r\n      h0,\r\n      h1,\r\n      newPositions,\r\n      offset\r\n    );\r\n  }\r\n\r\n  subdivideHeightsScratchArray.length = 0;\r\n\r\n  const lastPoint = positions[length - 1];\r\n  const carto = ellipsoid.cartesianToCartographic(lastPoint, carto1);\r\n  carto.height = hasHeightArray ? height[length - 1] : height;\r\n  const cart = ellipsoid.cartographicToCartesian(carto, cartesian);\r\n  Cartesian3.pack(cart, newPositions, arrayLength - 3);\r\n\r\n  return newPositions;\r\n};\r\n\r\nconst scratchCartographic0 = new Cartographic();\r\nconst scratchCartographic1 = new Cartographic();\r\n\r\n/**\r\n * Subdivides polyline and raises all points to the specified height using Rhumb lines.  Returns an array of numbers to represent the positions.\r\n * @param {Object} options Object with the following properties:\r\n * @param {Cartesian3[]} options.positions The array of type {Cartesian3} representing positions.\r\n * @param {Number|Number[]} [options.height=0.0] A number or array of numbers representing the heights of each position.\r\n * @param {Number} [options.granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\r\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the positions lie.\r\n * @returns {Number[]} A new array of positions of type {Number} that have been subdivided and raised to the surface of the ellipsoid.\r\n *\r\n * @example\r\n * const positions = Cesium.Cartesian3.fromDegreesArray([\r\n *   -105.0, 40.0,\r\n *   -100.0, 38.0,\r\n *   -105.0, 35.0,\r\n *   -100.0, 32.0\r\n * ]);\r\n * const surfacePositions = Cesium.PolylinePipeline.generateRhumbArc({\r\n *   positons: positions\r\n * });\r\n */\r\nPolylinePipeline.generateRhumbArc = function (options) {\r\n  if (!defined(options)) {\r\n    options = {};\r\n  }\r\n  const positions = options.positions;\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(positions)) {\r\n    throw new DeveloperError(\"options.positions is required.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const length = positions.length;\r\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\r\n  let height = defaultValue(options.height, 0);\r\n  const hasHeightArray = Array.isArray(height);\r\n\r\n  if (length < 1) {\r\n    return [];\r\n  } else if (length === 1) {\r\n    const p = ellipsoid.scaleToGeodeticSurface(positions[0], scaleFirst);\r\n    height = hasHeightArray ? height[0] : height;\r\n    if (height !== 0) {\r\n      const n = ellipsoid.geodeticSurfaceNormal(p, cartesian);\r\n      Cartesian3.multiplyByScalar(n, height, n);\r\n      Cartesian3.add(p, n, p);\r\n    }\r\n\r\n    return [p.x, p.y, p.z];\r\n  }\r\n\r\n  const granularity = defaultValue(\r\n    options.granularity,\r\n    CesiumMath.RADIANS_PER_DEGREE\r\n  );\r\n\r\n  let numPoints = 0;\r\n  let i;\r\n\r\n  let c0 = ellipsoid.cartesianToCartographic(\r\n    positions[0],\r\n    scratchCartographic0\r\n  );\r\n  let c1;\r\n  for (i = 0; i < length - 1; i++) {\r\n    c1 = ellipsoid.cartesianToCartographic(\r\n      positions[i + 1],\r\n      scratchCartographic1\r\n    );\r\n    numPoints += PolylinePipeline.numberOfPointsRhumbLine(c0, c1, granularity);\r\n    c0 = Cartographic.clone(c1, scratchCartographic0);\r\n  }\r\n\r\n  const arrayLength = (numPoints + 1) * 3;\r\n  const newPositions = new Array(arrayLength);\r\n  let offset = 0;\r\n\r\n  for (i = 0; i < length - 1; i++) {\r\n    const p0 = positions[i];\r\n    const p1 = positions[i + 1];\r\n\r\n    const h0 = hasHeightArray ? height[i] : height;\r\n    const h1 = hasHeightArray ? height[i + 1] : height;\r\n\r\n    offset = generateCartesianRhumbArc(\r\n      p0,\r\n      p1,\r\n      granularity,\r\n      ellipsoid,\r\n      h0,\r\n      h1,\r\n      newPositions,\r\n      offset\r\n    );\r\n  }\r\n\r\n  subdivideHeightsScratchArray.length = 0;\r\n\r\n  const lastPoint = positions[length - 1];\r\n  const carto = ellipsoid.cartesianToCartographic(lastPoint, carto1);\r\n  carto.height = hasHeightArray ? height[length - 1] : height;\r\n  const cart = ellipsoid.cartographicToCartesian(carto, cartesian);\r\n  Cartesian3.pack(cart, newPositions, arrayLength - 3);\r\n\r\n  return newPositions;\r\n};\r\n\r\n/**\r\n * Subdivides polyline and raises all points to the specified height. Returns an array of new {Cartesian3} positions.\r\n * @param {Object} options Object with the following properties:\r\n * @param {Cartesian3[]} options.positions The array of type {Cartesian3} representing positions.\r\n * @param {Number|Number[]} [options.height=0.0] A number or array of numbers representing the heights of each position.\r\n * @param {Number} [options.granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\r\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the positions lie.\r\n * @returns {Cartesian3[]} A new array of cartesian3 positions that have been subdivided and raised to the surface of the ellipsoid.\r\n *\r\n * @example\r\n * const positions = Cesium.Cartesian3.fromDegreesArray([\r\n *   -105.0, 40.0,\r\n *   -100.0, 38.0,\r\n *   -105.0, 35.0,\r\n *   -100.0, 32.0\r\n * ]);\r\n * const surfacePositions = Cesium.PolylinePipeline.generateCartesianArc({\r\n *   positons: positions\r\n * });\r\n */\r\nPolylinePipeline.generateCartesianArc = function (options) {\r\n  const numberArray = PolylinePipeline.generateArc(options);\r\n  const size = numberArray.length / 3;\r\n  const newPositions = new Array(size);\r\n  for (let i = 0; i < size; i++) {\r\n    newPositions[i] = Cartesian3.unpack(numberArray, i * 3);\r\n  }\r\n  return newPositions;\r\n};\r\n\r\n/**\r\n * Subdivides polyline and raises all points to the specified height using Rhumb Lines. Returns an array of new {Cartesian3} positions.\r\n * @param {Object} options Object with the following properties:\r\n * @param {Cartesian3[]} options.positions The array of type {Cartesian3} representing positions.\r\n * @param {Number|Number[]} [options.height=0.0] A number or array of numbers representing the heights of each position.\r\n * @param {Number} [options.granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\r\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the positions lie.\r\n * @returns {Cartesian3[]} A new array of cartesian3 positions that have been subdivided and raised to the surface of the ellipsoid.\r\n *\r\n * @example\r\n * const positions = Cesium.Cartesian3.fromDegreesArray([\r\n *   -105.0, 40.0,\r\n *   -100.0, 38.0,\r\n *   -105.0, 35.0,\r\n *   -100.0, 32.0\r\n * ]);\r\n * const surfacePositions = Cesium.PolylinePipeline.generateCartesianRhumbArc({\r\n *   positons: positions\r\n * });\r\n */\r\nPolylinePipeline.generateCartesianRhumbArc = function (options) {\r\n  const numberArray = PolylinePipeline.generateRhumbArc(options);\r\n  const size = numberArray.length / 3;\r\n  const newPositions = new Array(size);\r\n  for (let i = 0; i < size; i++) {\r\n    newPositions[i] = Cartesian3.unpack(numberArray, i * 3);\r\n  }\r\n  return newPositions;\r\n};\r\nexport default PolylinePipeline;\r\n"],"names":["PolylinePipeline","p0","p1","minDistance","distance","Cartesian3","Math","ceil","granularity","radiansDistanceSquared","pow","longitude","latitude","max","sqrt","cartoScratch","Cartographic","extractHeights","positions","ellipsoid","length","heights","Array","i","p","cartesianToCartographic","height","wrapLongitudeInversMatrix","Matrix4","wrapLongitudeOrigin","wrapLongitudeXZNormal","wrapLongitudeXZPlane","Plane","UNIT_X","wrapLongitudeYZNormal","wrapLongitudeYZPlane","wrapLongitudeIntersection","wrapLongitudeOffset","subdivideHeightsScratchArray","subdivideHeights","numPoints","h0","h1","heightPerVertex","h","carto1","carto2","cartesian","scaleFirst","scaleLast","ellipsoidGeodesic","EllipsoidGeodesic","ellipsoidRhumb","EllipsoidRhumbLine","generateCartesianArc","array","offset","first","scaleToGeodeticSurface","last","numberOfPoints","start","end","setEndPoints","surfaceDistanceBetweenPoints","surfaceDistance","index","cart","cartographicToCartesian","pack","carto","interpolateUsingSurfaceDistance","generateCartesianRhumbArc","numberOfPointsRhumbLine","equals","undefined","wrapLongitude","modelMatrix","cartesians","segments","defined","defaultValue","IDENTITY","inverseModelMatrix","inverseTransformation","origin","multiplyByPoint","ZERO","xzNormal","normalize","multiplyByPointAsVector","UNIT_Y","xzPlane","fromPointNormal","yzNormal","yzPlane","count","push","clone","prev","cur","getPointDistance","intersection","IntersectionTests","lineSegmentPlane","multiplyByScalar","negate","add","lengths","generateArc","options","DeveloperError","Ellipsoid","WGS84","hasHeightArray","isArray","n","geodeticSurfaceNormal","x","y","z","CesiumMath","RADIANS_PER_DEGREE","chordLength","maximumRadius","arrayLength","newPositions","lastPoint","scratchCartographic0","scratchCartographic1","generateRhumbArc","c1","c0","numberArray","size","unpack"],"mappings":"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"}