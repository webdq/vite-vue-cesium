{"version":3,"file":"Matrix2-fb98ca95.js","sources":["../../../../Source/Core/Cartesian3.js","../../../../Source/Core/scaleToGeodeticSurface.js","../../../../Source/Core/Cartographic.js","../../../../Source/Core/Ellipsoid.js","../../../../Source/Core/Matrix3.js","../../../../Source/Core/Cartesian4.js","../../../../Source/Core/Matrix4.js","../../../../Source/Core/Rectangle.js","../../../../Source/Core/Cartesian2.js","../../../../Source/Core/Matrix2.js"],"sourcesContent":["import Check from \"./Check.js\";\r\nimport defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\nimport DeveloperError from \"./DeveloperError.js\";\r\nimport CesiumMath from \"./Math.js\";\r\n\r\n/**\r\n * A 3D Cartesian point.\r\n * @alias Cartesian3\r\n * @constructor\r\n *\r\n * @param {Number} [x=0.0] The X component.\r\n * @param {Number} [y=0.0] The Y component.\r\n * @param {Number} [z=0.0] The Z component.\r\n *\r\n * @see Cartesian2\r\n * @see Cartesian4\r\n * @see Packable\r\n */\r\nfunction Cartesian3(x, y, z) {\r\n  /**\r\n   * The X component.\r\n   * @type {Number}\r\n   * @default 0.0\r\n   */\r\n  this.x = defaultValue(x, 0.0);\r\n\r\n  /**\r\n   * The Y component.\r\n   * @type {Number}\r\n   * @default 0.0\r\n   */\r\n  this.y = defaultValue(y, 0.0);\r\n\r\n  /**\r\n   * The Z component.\r\n   * @type {Number}\r\n   * @default 0.0\r\n   */\r\n  this.z = defaultValue(z, 0.0);\r\n}\r\n\r\n/**\r\n * Converts the provided Spherical into Cartesian3 coordinates.\r\n *\r\n * @param {Spherical} spherical The Spherical to be converted to Cartesian3.\r\n * @param {Cartesian3} [result] The object onto which to store the result.\r\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\r\n */\r\nCartesian3.fromSpherical = function (spherical, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"spherical\", spherical);\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    result = new Cartesian3();\r\n  }\r\n\r\n  const clock = spherical.clock;\r\n  const cone = spherical.cone;\r\n  const magnitude = defaultValue(spherical.magnitude, 1.0);\r\n  const radial = magnitude * Math.sin(cone);\r\n  result.x = radial * Math.cos(clock);\r\n  result.y = radial * Math.sin(clock);\r\n  result.z = magnitude * Math.cos(cone);\r\n  return result;\r\n};\r\n\r\n/**\r\n * Creates a Cartesian3 instance from x, y and z coordinates.\r\n *\r\n * @param {Number} x The x coordinate.\r\n * @param {Number} y The y coordinate.\r\n * @param {Number} z The z coordinate.\r\n * @param {Cartesian3} [result] The object onto which to store the result.\r\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\r\n */\r\nCartesian3.fromElements = function (x, y, z, result) {\r\n  if (!defined(result)) {\r\n    return new Cartesian3(x, y, z);\r\n  }\r\n\r\n  result.x = x;\r\n  result.y = y;\r\n  result.z = z;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Duplicates a Cartesian3 instance.\r\n *\r\n * @param {Cartesian3} cartesian The Cartesian to duplicate.\r\n * @param {Cartesian3} [result] The object onto which to store the result.\r\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided. (Returns undefined if cartesian is undefined)\r\n */\r\nCartesian3.clone = function (cartesian, result) {\r\n  if (!defined(cartesian)) {\r\n    return undefined;\r\n  }\r\n  if (!defined(result)) {\r\n    return new Cartesian3(cartesian.x, cartesian.y, cartesian.z);\r\n  }\r\n\r\n  result.x = cartesian.x;\r\n  result.y = cartesian.y;\r\n  result.z = cartesian.z;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Creates a Cartesian3 instance from an existing Cartesian4.  This simply takes the\r\n * x, y, and z properties of the Cartesian4 and drops w.\r\n * @function\r\n *\r\n * @param {Cartesian4} cartesian The Cartesian4 instance to create a Cartesian3 instance from.\r\n * @param {Cartesian3} [result] The object onto which to store the result.\r\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\r\n */\r\nCartesian3.fromCartesian4 = Cartesian3.clone;\r\n\r\n/**\r\n * The number of elements used to pack the object into an array.\r\n * @type {Number}\r\n */\r\nCartesian3.packedLength = 3;\r\n\r\n/**\r\n * Stores the provided instance into the provided array.\r\n *\r\n * @param {Cartesian3} value The value to pack.\r\n * @param {Number[]} array The array to pack into.\r\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n *\r\n * @returns {Number[]} The array that was packed into\r\n */\r\nCartesian3.pack = function (value, array, startingIndex) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"value\", value);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  array[startingIndex++] = value.x;\r\n  array[startingIndex++] = value.y;\r\n  array[startingIndex] = value.z;\r\n\r\n  return array;\r\n};\r\n\r\n/**\r\n * Retrieves an instance from a packed array.\r\n *\r\n * @param {Number[]} array The packed array.\r\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n * @param {Cartesian3} [result] The object into which to store the result.\r\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\r\n */\r\nCartesian3.unpack = function (array, startingIndex, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  if (!defined(result)) {\r\n    result = new Cartesian3();\r\n  }\r\n  result.x = array[startingIndex++];\r\n  result.y = array[startingIndex++];\r\n  result.z = array[startingIndex];\r\n  return result;\r\n};\r\n\r\n/**\r\n * Flattens an array of Cartesian3s into an array of components.\r\n *\r\n * @param {Cartesian3[]} array The array of cartesians to pack.\r\n * @param {Number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 3 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 3) elements.\r\n * @returns {Number[]} The packed array.\r\n */\r\nCartesian3.packArray = function (array, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  const length = array.length;\r\n  const resultLength = length * 3;\r\n  if (!defined(result)) {\r\n    result = new Array(resultLength);\r\n  } else if (!Array.isArray(result) && result.length !== resultLength) {\r\n    //>>includeStart('debug', pragmas.debug);\r\n    throw new DeveloperError(\r\n      \"If result is a typed array, it must have exactly array.length * 3 elements\"\r\n    );\r\n    //>>includeEnd('debug');\r\n  } else if (result.length !== resultLength) {\r\n    result.length = resultLength;\r\n  }\r\n\r\n  for (let i = 0; i < length; ++i) {\r\n    Cartesian3.pack(array[i], result, i * 3);\r\n  }\r\n  return result;\r\n};\r\n\r\n/**\r\n * Unpacks an array of cartesian components into an array of Cartesian3s.\r\n *\r\n * @param {Number[]} array The array of components to unpack.\r\n * @param {Cartesian3[]} [result] The array onto which to store the result.\r\n * @returns {Cartesian3[]} The unpacked array.\r\n */\r\nCartesian3.unpackArray = function (array, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"array\", array);\r\n  Check.typeOf.number.greaterThanOrEquals(\"array.length\", array.length, 3);\r\n  if (array.length % 3 !== 0) {\r\n    throw new DeveloperError(\"array length must be a multiple of 3.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const length = array.length;\r\n  if (!defined(result)) {\r\n    result = new Array(length / 3);\r\n  } else {\r\n    result.length = length / 3;\r\n  }\r\n\r\n  for (let i = 0; i < length; i += 3) {\r\n    const index = i / 3;\r\n    result[index] = Cartesian3.unpack(array, i, result[index]);\r\n  }\r\n  return result;\r\n};\r\n\r\n/**\r\n * Creates a Cartesian3 from three consecutive elements in an array.\r\n * @function\r\n *\r\n * @param {Number[]} array The array whose three consecutive elements correspond to the x, y, and z components, respectively.\r\n * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.\r\n * @param {Cartesian3} [result] The object onto which to store the result.\r\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\r\n *\r\n * @example\r\n * // Create a Cartesian3 with (1.0, 2.0, 3.0)\r\n * const v = [1.0, 2.0, 3.0];\r\n * const p = Cesium.Cartesian3.fromArray(v);\r\n *\r\n * // Create a Cartesian3 with (1.0, 2.0, 3.0) using an offset into an array\r\n * const v2 = [0.0, 0.0, 1.0, 2.0, 3.0];\r\n * const p2 = Cesium.Cartesian3.fromArray(v2, 2);\r\n */\r\nCartesian3.fromArray = Cartesian3.unpack;\r\n\r\n/**\r\n * Computes the value of the maximum component for the supplied Cartesian.\r\n *\r\n * @param {Cartesian3} cartesian The cartesian to use.\r\n * @returns {Number} The value of the maximum component.\r\n */\r\nCartesian3.maximumComponent = function (cartesian) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"cartesian\", cartesian);\r\n  //>>includeEnd('debug');\r\n\r\n  return Math.max(cartesian.x, cartesian.y, cartesian.z);\r\n};\r\n\r\n/**\r\n * Computes the value of the minimum component for the supplied Cartesian.\r\n *\r\n * @param {Cartesian3} cartesian The cartesian to use.\r\n * @returns {Number} The value of the minimum component.\r\n */\r\nCartesian3.minimumComponent = function (cartesian) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"cartesian\", cartesian);\r\n  //>>includeEnd('debug');\r\n\r\n  return Math.min(cartesian.x, cartesian.y, cartesian.z);\r\n};\r\n\r\n/**\r\n * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.\r\n *\r\n * @param {Cartesian3} first A cartesian to compare.\r\n * @param {Cartesian3} second A cartesian to compare.\r\n * @param {Cartesian3} result The object into which to store the result.\r\n * @returns {Cartesian3} A cartesian with the minimum components.\r\n */\r\nCartesian3.minimumByComponent = function (first, second, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"first\", first);\r\n  Check.typeOf.object(\"second\", second);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result.x = Math.min(first.x, second.x);\r\n  result.y = Math.min(first.y, second.y);\r\n  result.z = Math.min(first.z, second.z);\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.\r\n *\r\n * @param {Cartesian3} first A cartesian to compare.\r\n * @param {Cartesian3} second A cartesian to compare.\r\n * @param {Cartesian3} result The object into which to store the result.\r\n * @returns {Cartesian3} A cartesian with the maximum components.\r\n */\r\nCartesian3.maximumByComponent = function (first, second, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"first\", first);\r\n  Check.typeOf.object(\"second\", second);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result.x = Math.max(first.x, second.x);\r\n  result.y = Math.max(first.y, second.y);\r\n  result.z = Math.max(first.z, second.z);\r\n  return result;\r\n};\r\n\r\n/**\r\n * Constrain a value to lie between two values.\r\n *\r\n * @param {Cartesian3} cartesian The value to clamp.\r\n * @param {Cartesian3} min The minimum bound.\r\n * @param {Cartesian3} max The maximum bound.\r\n * @param {Cartesian3} result The object into which to store the result.\r\n * @returns {Cartesian3} The clamped value such that min <= value <= max.\r\n */\r\nCartesian3.clamp = function (value, min, max, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"value\", value);\r\n  Check.typeOf.object(\"min\", min);\r\n  Check.typeOf.object(\"max\", max);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  const x = CesiumMath.clamp(value.x, min.x, max.x);\r\n  const y = CesiumMath.clamp(value.y, min.y, max.y);\r\n  const z = CesiumMath.clamp(value.z, min.z, max.z);\r\n\r\n  result.x = x;\r\n  result.y = y;\r\n  result.z = z;\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the provided Cartesian's squared magnitude.\r\n *\r\n * @param {Cartesian3} cartesian The Cartesian instance whose squared magnitude is to be computed.\r\n * @returns {Number} The squared magnitude.\r\n */\r\nCartesian3.magnitudeSquared = function (cartesian) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"cartesian\", cartesian);\r\n  //>>includeEnd('debug');\r\n\r\n  return (\r\n    cartesian.x * cartesian.x +\r\n    cartesian.y * cartesian.y +\r\n    cartesian.z * cartesian.z\r\n  );\r\n};\r\n\r\n/**\r\n * Computes the Cartesian's magnitude (length).\r\n *\r\n * @param {Cartesian3} cartesian The Cartesian instance whose magnitude is to be computed.\r\n * @returns {Number} The magnitude.\r\n */\r\nCartesian3.magnitude = function (cartesian) {\r\n  return Math.sqrt(Cartesian3.magnitudeSquared(cartesian));\r\n};\r\n\r\nconst distanceScratch = new Cartesian3();\r\n\r\n/**\r\n * Computes the distance between two points.\r\n *\r\n * @param {Cartesian3} left The first point to compute the distance from.\r\n * @param {Cartesian3} right The second point to compute the distance to.\r\n * @returns {Number} The distance between two points.\r\n *\r\n * @example\r\n * // Returns 1.0\r\n * const d = Cesium.Cartesian3.distance(new Cesium.Cartesian3(1.0, 0.0, 0.0), new Cesium.Cartesian3(2.0, 0.0, 0.0));\r\n */\r\nCartesian3.distance = function (left, right) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"left\", left);\r\n  Check.typeOf.object(\"right\", right);\r\n  //>>includeEnd('debug');\r\n\r\n  Cartesian3.subtract(left, right, distanceScratch);\r\n  return Cartesian3.magnitude(distanceScratch);\r\n};\r\n\r\n/**\r\n * Computes the squared distance between two points.  Comparing squared distances\r\n * using this function is more efficient than comparing distances using {@link Cartesian3#distance}.\r\n *\r\n * @param {Cartesian3} left The first point to compute the distance from.\r\n * @param {Cartesian3} right The second point to compute the distance to.\r\n * @returns {Number} The distance between two points.\r\n *\r\n * @example\r\n * // Returns 4.0, not 2.0\r\n * const d = Cesium.Cartesian3.distanceSquared(new Cesium.Cartesian3(1.0, 0.0, 0.0), new Cesium.Cartesian3(3.0, 0.0, 0.0));\r\n */\r\nCartesian3.distanceSquared = function (left, right) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"left\", left);\r\n  Check.typeOf.object(\"right\", right);\r\n  //>>includeEnd('debug');\r\n\r\n  Cartesian3.subtract(left, right, distanceScratch);\r\n  return Cartesian3.magnitudeSquared(distanceScratch);\r\n};\r\n\r\n/**\r\n * Computes the normalized form of the supplied Cartesian.\r\n *\r\n * @param {Cartesian3} cartesian The Cartesian to be normalized.\r\n * @param {Cartesian3} result The object onto which to store the result.\r\n * @returns {Cartesian3} The modified result parameter.\r\n */\r\nCartesian3.normalize = function (cartesian, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"cartesian\", cartesian);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  const magnitude = Cartesian3.magnitude(cartesian);\r\n\r\n  result.x = cartesian.x / magnitude;\r\n  result.y = cartesian.y / magnitude;\r\n  result.z = cartesian.z / magnitude;\r\n\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (isNaN(result.x) || isNaN(result.y) || isNaN(result.z)) {\r\n    throw new DeveloperError(\"normalized result is not a number\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the dot (scalar) product of two Cartesians.\r\n *\r\n * @param {Cartesian3} left The first Cartesian.\r\n * @param {Cartesian3} right The second Cartesian.\r\n * @returns {Number} The dot product.\r\n */\r\nCartesian3.dot = function (left, right) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"left\", left);\r\n  Check.typeOf.object(\"right\", right);\r\n  //>>includeEnd('debug');\r\n\r\n  return left.x * right.x + left.y * right.y + left.z * right.z;\r\n};\r\n\r\n/**\r\n * Computes the componentwise product of two Cartesians.\r\n *\r\n * @param {Cartesian3} left The first Cartesian.\r\n * @param {Cartesian3} right The second Cartesian.\r\n * @param {Cartesian3} result The object onto which to store the result.\r\n * @returns {Cartesian3} The modified result parameter.\r\n */\r\nCartesian3.multiplyComponents = function (left, right, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"left\", left);\r\n  Check.typeOf.object(\"right\", right);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result.x = left.x * right.x;\r\n  result.y = left.y * right.y;\r\n  result.z = left.z * right.z;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the componentwise quotient of two Cartesians.\r\n *\r\n * @param {Cartesian3} left The first Cartesian.\r\n * @param {Cartesian3} right The second Cartesian.\r\n * @param {Cartesian3} result The object onto which to store the result.\r\n * @returns {Cartesian3} The modified result parameter.\r\n */\r\nCartesian3.divideComponents = function (left, right, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"left\", left);\r\n  Check.typeOf.object(\"right\", right);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result.x = left.x / right.x;\r\n  result.y = left.y / right.y;\r\n  result.z = left.z / right.z;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the componentwise sum of two Cartesians.\r\n *\r\n * @param {Cartesian3} left The first Cartesian.\r\n * @param {Cartesian3} right The second Cartesian.\r\n * @param {Cartesian3} result The object onto which to store the result.\r\n * @returns {Cartesian3} The modified result parameter.\r\n */\r\nCartesian3.add = function (left, right, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"left\", left);\r\n  Check.typeOf.object(\"right\", right);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result.x = left.x + right.x;\r\n  result.y = left.y + right.y;\r\n  result.z = left.z + right.z;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the componentwise difference of two Cartesians.\r\n *\r\n * @param {Cartesian3} left The first Cartesian.\r\n * @param {Cartesian3} right The second Cartesian.\r\n * @param {Cartesian3} result The object onto which to store the result.\r\n * @returns {Cartesian3} The modified result parameter.\r\n */\r\nCartesian3.subtract = function (left, right, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"left\", left);\r\n  Check.typeOf.object(\"right\", right);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result.x = left.x - right.x;\r\n  result.y = left.y - right.y;\r\n  result.z = left.z - right.z;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Multiplies the provided Cartesian componentwise by the provided scalar.\r\n *\r\n * @param {Cartesian3} cartesian The Cartesian to be scaled.\r\n * @param {Number} scalar The scalar to multiply with.\r\n * @param {Cartesian3} result The object onto which to store the result.\r\n * @returns {Cartesian3} The modified result parameter.\r\n */\r\nCartesian3.multiplyByScalar = function (cartesian, scalar, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"cartesian\", cartesian);\r\n  Check.typeOf.number(\"scalar\", scalar);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result.x = cartesian.x * scalar;\r\n  result.y = cartesian.y * scalar;\r\n  result.z = cartesian.z * scalar;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Divides the provided Cartesian componentwise by the provided scalar.\r\n *\r\n * @param {Cartesian3} cartesian The Cartesian to be divided.\r\n * @param {Number} scalar The scalar to divide by.\r\n * @param {Cartesian3} result The object onto which to store the result.\r\n * @returns {Cartesian3} The modified result parameter.\r\n */\r\nCartesian3.divideByScalar = function (cartesian, scalar, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"cartesian\", cartesian);\r\n  Check.typeOf.number(\"scalar\", scalar);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result.x = cartesian.x / scalar;\r\n  result.y = cartesian.y / scalar;\r\n  result.z = cartesian.z / scalar;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Negates the provided Cartesian.\r\n *\r\n * @param {Cartesian3} cartesian The Cartesian to be negated.\r\n * @param {Cartesian3} result The object onto which to store the result.\r\n * @returns {Cartesian3} The modified result parameter.\r\n */\r\nCartesian3.negate = function (cartesian, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"cartesian\", cartesian);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result.x = -cartesian.x;\r\n  result.y = -cartesian.y;\r\n  result.z = -cartesian.z;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the absolute value of the provided Cartesian.\r\n *\r\n * @param {Cartesian3} cartesian The Cartesian whose absolute value is to be computed.\r\n * @param {Cartesian3} result The object onto which to store the result.\r\n * @returns {Cartesian3} The modified result parameter.\r\n */\r\nCartesian3.abs = function (cartesian, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"cartesian\", cartesian);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result.x = Math.abs(cartesian.x);\r\n  result.y = Math.abs(cartesian.y);\r\n  result.z = Math.abs(cartesian.z);\r\n  return result;\r\n};\r\n\r\nconst lerpScratch = new Cartesian3();\r\n/**\r\n * Computes the linear interpolation or extrapolation at t using the provided cartesians.\r\n *\r\n * @param {Cartesian3} start The value corresponding to t at 0.0.\r\n * @param {Cartesian3} end The value corresponding to t at 1.0.\r\n * @param {Number} t The point along t at which to interpolate.\r\n * @param {Cartesian3} result The object onto which to store the result.\r\n * @returns {Cartesian3} The modified result parameter.\r\n */\r\nCartesian3.lerp = function (start, end, t, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"start\", start);\r\n  Check.typeOf.object(\"end\", end);\r\n  Check.typeOf.number(\"t\", t);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  Cartesian3.multiplyByScalar(end, t, lerpScratch);\r\n  result = Cartesian3.multiplyByScalar(start, 1.0 - t, result);\r\n  return Cartesian3.add(lerpScratch, result, result);\r\n};\r\n\r\nconst angleBetweenScratch = new Cartesian3();\r\nconst angleBetweenScratch2 = new Cartesian3();\r\n/**\r\n * Returns the angle, in radians, between the provided Cartesians.\r\n *\r\n * @param {Cartesian3} left The first Cartesian.\r\n * @param {Cartesian3} right The second Cartesian.\r\n * @returns {Number} The angle between the Cartesians.\r\n */\r\nCartesian3.angleBetween = function (left, right) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"left\", left);\r\n  Check.typeOf.object(\"right\", right);\r\n  //>>includeEnd('debug');\r\n\r\n  Cartesian3.normalize(left, angleBetweenScratch);\r\n  Cartesian3.normalize(right, angleBetweenScratch2);\r\n  const cosine = Cartesian3.dot(angleBetweenScratch, angleBetweenScratch2);\r\n  const sine = Cartesian3.magnitude(\r\n    Cartesian3.cross(\r\n      angleBetweenScratch,\r\n      angleBetweenScratch2,\r\n      angleBetweenScratch\r\n    )\r\n  );\r\n  return Math.atan2(sine, cosine);\r\n};\r\n\r\nconst mostOrthogonalAxisScratch = new Cartesian3();\r\n/**\r\n * Returns the axis that is most orthogonal to the provided Cartesian.\r\n *\r\n * @param {Cartesian3} cartesian The Cartesian on which to find the most orthogonal axis.\r\n * @param {Cartesian3} result The object onto which to store the result.\r\n * @returns {Cartesian3} The most orthogonal axis.\r\n */\r\nCartesian3.mostOrthogonalAxis = function (cartesian, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"cartesian\", cartesian);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  const f = Cartesian3.normalize(cartesian, mostOrthogonalAxisScratch);\r\n  Cartesian3.abs(f, f);\r\n\r\n  if (f.x <= f.y) {\r\n    if (f.x <= f.z) {\r\n      result = Cartesian3.clone(Cartesian3.UNIT_X, result);\r\n    } else {\r\n      result = Cartesian3.clone(Cartesian3.UNIT_Z, result);\r\n    }\r\n  } else if (f.y <= f.z) {\r\n    result = Cartesian3.clone(Cartesian3.UNIT_Y, result);\r\n  } else {\r\n    result = Cartesian3.clone(Cartesian3.UNIT_Z, result);\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Projects vector a onto vector b\r\n * @param {Cartesian3} a The vector that needs projecting\r\n * @param {Cartesian3} b The vector to project onto\r\n * @param {Cartesian3} result The result cartesian\r\n * @returns {Cartesian3} The modified result parameter\r\n */\r\nCartesian3.projectVector = function (a, b, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"a\", a);\r\n  Check.defined(\"b\", b);\r\n  Check.defined(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  const scalar = Cartesian3.dot(a, b) / Cartesian3.dot(b, b);\r\n  return Cartesian3.multiplyByScalar(b, scalar, result);\r\n};\r\n\r\n/**\r\n * Compares the provided Cartesians componentwise and returns\r\n * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n *\r\n * @param {Cartesian3} [left] The first Cartesian.\r\n * @param {Cartesian3} [right] The second Cartesian.\r\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\r\n */\r\nCartesian3.equals = function (left, right) {\r\n  return (\r\n    left === right ||\r\n    (defined(left) &&\r\n      defined(right) &&\r\n      left.x === right.x &&\r\n      left.y === right.y &&\r\n      left.z === right.z)\r\n  );\r\n};\r\n\r\n/**\r\n * @private\r\n */\r\nCartesian3.equalsArray = function (cartesian, array, offset) {\r\n  return (\r\n    cartesian.x === array[offset] &&\r\n    cartesian.y === array[offset + 1] &&\r\n    cartesian.z === array[offset + 2]\r\n  );\r\n};\r\n\r\n/**\r\n * Compares the provided Cartesians componentwise and returns\r\n * <code>true</code> if they pass an absolute or relative tolerance test,\r\n * <code>false</code> otherwise.\r\n *\r\n * @param {Cartesian3} [left] The first Cartesian.\r\n * @param {Cartesian3} [right] The second Cartesian.\r\n * @param {Number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\r\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\r\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\r\n */\r\nCartesian3.equalsEpsilon = function (\r\n  left,\r\n  right,\r\n  relativeEpsilon,\r\n  absoluteEpsilon\r\n) {\r\n  return (\r\n    left === right ||\r\n    (defined(left) &&\r\n      defined(right) &&\r\n      CesiumMath.equalsEpsilon(\r\n        left.x,\r\n        right.x,\r\n        relativeEpsilon,\r\n        absoluteEpsilon\r\n      ) &&\r\n      CesiumMath.equalsEpsilon(\r\n        left.y,\r\n        right.y,\r\n        relativeEpsilon,\r\n        absoluteEpsilon\r\n      ) &&\r\n      CesiumMath.equalsEpsilon(\r\n        left.z,\r\n        right.z,\r\n        relativeEpsilon,\r\n        absoluteEpsilon\r\n      ))\r\n  );\r\n};\r\n\r\n/**\r\n * Computes the cross (outer) product of two Cartesians.\r\n *\r\n * @param {Cartesian3} left The first Cartesian.\r\n * @param {Cartesian3} right The second Cartesian.\r\n * @param {Cartesian3} result The object onto which to store the result.\r\n * @returns {Cartesian3} The cross product.\r\n */\r\nCartesian3.cross = function (left, right, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"left\", left);\r\n  Check.typeOf.object(\"right\", right);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  const leftX = left.x;\r\n  const leftY = left.y;\r\n  const leftZ = left.z;\r\n  const rightX = right.x;\r\n  const rightY = right.y;\r\n  const rightZ = right.z;\r\n\r\n  const x = leftY * rightZ - leftZ * rightY;\r\n  const y = leftZ * rightX - leftX * rightZ;\r\n  const z = leftX * rightY - leftY * rightX;\r\n\r\n  result.x = x;\r\n  result.y = y;\r\n  result.z = z;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the midpoint between the right and left Cartesian.\r\n * @param {Cartesian3} left The first Cartesian.\r\n * @param {Cartesian3} right The second Cartesian.\r\n * @param {Cartesian3} result The object onto which to store the result.\r\n * @returns {Cartesian3} The midpoint.\r\n */\r\nCartesian3.midpoint = function (left, right, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"left\", left);\r\n  Check.typeOf.object(\"right\", right);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result.x = (left.x + right.x) * 0.5;\r\n  result.y = (left.y + right.y) * 0.5;\r\n  result.z = (left.z + right.z) * 0.5;\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Returns a Cartesian3 position from longitude and latitude values given in degrees.\r\n *\r\n * @param {Number} longitude The longitude, in degrees\r\n * @param {Number} latitude The latitude, in degrees\r\n * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.\r\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\r\n * @param {Cartesian3} [result] The object onto which to store the result.\r\n * @returns {Cartesian3} The position\r\n *\r\n * @example\r\n * const position = Cesium.Cartesian3.fromDegrees(-115.0, 37.0);\r\n */\r\nCartesian3.fromDegrees = function (\r\n  longitude,\r\n  latitude,\r\n  height,\r\n  ellipsoid,\r\n  result\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.number(\"longitude\", longitude);\r\n  Check.typeOf.number(\"latitude\", latitude);\r\n  //>>includeEnd('debug');\r\n\r\n  longitude = CesiumMath.toRadians(longitude);\r\n  latitude = CesiumMath.toRadians(latitude);\r\n  return Cartesian3.fromRadians(longitude, latitude, height, ellipsoid, result);\r\n};\r\n\r\nlet scratchN = new Cartesian3();\r\nlet scratchK = new Cartesian3();\r\nconst wgs84RadiiSquared = new Cartesian3(\r\n  6378137.0 * 6378137.0,\r\n  6378137.0 * 6378137.0,\r\n  6356752.3142451793 * 6356752.3142451793\r\n);\r\n\r\n/**\r\n * Returns a Cartesian3 position from longitude and latitude values given in radians.\r\n *\r\n * @param {Number} longitude The longitude, in radians\r\n * @param {Number} latitude The latitude, in radians\r\n * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.\r\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\r\n * @param {Cartesian3} [result] The object onto which to store the result.\r\n * @returns {Cartesian3} The position\r\n *\r\n * @example\r\n * const position = Cesium.Cartesian3.fromRadians(-2.007, 0.645);\r\n */\r\nCartesian3.fromRadians = function (\r\n  longitude,\r\n  latitude,\r\n  height,\r\n  ellipsoid,\r\n  result\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.number(\"longitude\", longitude);\r\n  Check.typeOf.number(\"latitude\", latitude);\r\n  //>>includeEnd('debug');\r\n\r\n  height = defaultValue(height, 0.0);\r\n  const radiiSquared = defined(ellipsoid)\r\n    ? ellipsoid.radiiSquared\r\n    : wgs84RadiiSquared;\r\n\r\n  const cosLatitude = Math.cos(latitude);\r\n  scratchN.x = cosLatitude * Math.cos(longitude);\r\n  scratchN.y = cosLatitude * Math.sin(longitude);\r\n  scratchN.z = Math.sin(latitude);\r\n  scratchN = Cartesian3.normalize(scratchN, scratchN);\r\n\r\n  Cartesian3.multiplyComponents(radiiSquared, scratchN, scratchK);\r\n  const gamma = Math.sqrt(Cartesian3.dot(scratchN, scratchK));\r\n  scratchK = Cartesian3.divideByScalar(scratchK, gamma, scratchK);\r\n  scratchN = Cartesian3.multiplyByScalar(scratchN, height, scratchN);\r\n\r\n  if (!defined(result)) {\r\n    result = new Cartesian3();\r\n  }\r\n  return Cartesian3.add(scratchK, scratchN, result);\r\n};\r\n\r\n/**\r\n * Returns an array of Cartesian3 positions given an array of longitude and latitude values given in degrees.\r\n *\r\n * @param {Number[]} coordinates A list of longitude and latitude values. Values alternate [longitude, latitude, longitude, latitude...].\r\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the coordinates lie.\r\n * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\r\n * @returns {Cartesian3[]} The array of positions.\r\n *\r\n * @example\r\n * const positions = Cesium.Cartesian3.fromDegreesArray([-115.0, 37.0, -107.0, 33.0]);\r\n */\r\nCartesian3.fromDegreesArray = function (coordinates, ellipsoid, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"coordinates\", coordinates);\r\n  if (coordinates.length < 2 || coordinates.length % 2 !== 0) {\r\n    throw new DeveloperError(\r\n      \"the number of coordinates must be a multiple of 2 and at least 2\"\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const length = coordinates.length;\r\n  if (!defined(result)) {\r\n    result = new Array(length / 2);\r\n  } else {\r\n    result.length = length / 2;\r\n  }\r\n\r\n  for (let i = 0; i < length; i += 2) {\r\n    const longitude = coordinates[i];\r\n    const latitude = coordinates[i + 1];\r\n    const index = i / 2;\r\n    result[index] = Cartesian3.fromDegrees(\r\n      longitude,\r\n      latitude,\r\n      0,\r\n      ellipsoid,\r\n      result[index]\r\n    );\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Returns an array of Cartesian3 positions given an array of longitude and latitude values given in radians.\r\n *\r\n * @param {Number[]} coordinates A list of longitude and latitude values. Values alternate [longitude, latitude, longitude, latitude...].\r\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the coordinates lie.\r\n * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\r\n * @returns {Cartesian3[]} The array of positions.\r\n *\r\n * @example\r\n * const positions = Cesium.Cartesian3.fromRadiansArray([-2.007, 0.645, -1.867, .575]);\r\n */\r\nCartesian3.fromRadiansArray = function (coordinates, ellipsoid, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"coordinates\", coordinates);\r\n  if (coordinates.length < 2 || coordinates.length % 2 !== 0) {\r\n    throw new DeveloperError(\r\n      \"the number of coordinates must be a multiple of 2 and at least 2\"\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const length = coordinates.length;\r\n  if (!defined(result)) {\r\n    result = new Array(length / 2);\r\n  } else {\r\n    result.length = length / 2;\r\n  }\r\n\r\n  for (let i = 0; i < length; i += 2) {\r\n    const longitude = coordinates[i];\r\n    const latitude = coordinates[i + 1];\r\n    const index = i / 2;\r\n    result[index] = Cartesian3.fromRadians(\r\n      longitude,\r\n      latitude,\r\n      0,\r\n      ellipsoid,\r\n      result[index]\r\n    );\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Returns an array of Cartesian3 positions given an array of longitude, latitude and height values where longitude and latitude are given in degrees.\r\n *\r\n * @param {Number[]} coordinates A list of longitude, latitude and height values. Values alternate [longitude, latitude, height, longitude, latitude, height...].\r\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\r\n * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\r\n * @returns {Cartesian3[]} The array of positions.\r\n *\r\n * @example\r\n * const positions = Cesium.Cartesian3.fromDegreesArrayHeights([-115.0, 37.0, 100000.0, -107.0, 33.0, 150000.0]);\r\n */\r\nCartesian3.fromDegreesArrayHeights = function (coordinates, ellipsoid, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"coordinates\", coordinates);\r\n  if (coordinates.length < 3 || coordinates.length % 3 !== 0) {\r\n    throw new DeveloperError(\r\n      \"the number of coordinates must be a multiple of 3 and at least 3\"\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const length = coordinates.length;\r\n  if (!defined(result)) {\r\n    result = new Array(length / 3);\r\n  } else {\r\n    result.length = length / 3;\r\n  }\r\n\r\n  for (let i = 0; i < length; i += 3) {\r\n    const longitude = coordinates[i];\r\n    const latitude = coordinates[i + 1];\r\n    const height = coordinates[i + 2];\r\n    const index = i / 3;\r\n    result[index] = Cartesian3.fromDegrees(\r\n      longitude,\r\n      latitude,\r\n      height,\r\n      ellipsoid,\r\n      result[index]\r\n    );\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Returns an array of Cartesian3 positions given an array of longitude, latitude and height values where longitude and latitude are given in radians.\r\n *\r\n * @param {Number[]} coordinates A list of longitude, latitude and height values. Values alternate [longitude, latitude, height, longitude, latitude, height...].\r\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\r\n * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\r\n * @returns {Cartesian3[]} The array of positions.\r\n *\r\n * @example\r\n * const positions = Cesium.Cartesian3.fromRadiansArrayHeights([-2.007, 0.645, 100000.0, -1.867, .575, 150000.0]);\r\n */\r\nCartesian3.fromRadiansArrayHeights = function (coordinates, ellipsoid, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"coordinates\", coordinates);\r\n  if (coordinates.length < 3 || coordinates.length % 3 !== 0) {\r\n    throw new DeveloperError(\r\n      \"the number of coordinates must be a multiple of 3 and at least 3\"\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const length = coordinates.length;\r\n  if (!defined(result)) {\r\n    result = new Array(length / 3);\r\n  } else {\r\n    result.length = length / 3;\r\n  }\r\n\r\n  for (let i = 0; i < length; i += 3) {\r\n    const longitude = coordinates[i];\r\n    const latitude = coordinates[i + 1];\r\n    const height = coordinates[i + 2];\r\n    const index = i / 3;\r\n    result[index] = Cartesian3.fromRadians(\r\n      longitude,\r\n      latitude,\r\n      height,\r\n      ellipsoid,\r\n      result[index]\r\n    );\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * An immutable Cartesian3 instance initialized to (0.0, 0.0, 0.0).\r\n *\r\n * @type {Cartesian3}\r\n * @constant\r\n */\r\nCartesian3.ZERO = Object.freeze(new Cartesian3(0.0, 0.0, 0.0));\r\n\r\n/**\r\n * An immutable Cartesian3 instance initialized to (1.0, 1.0, 1.0).\r\n *\r\n * @type {Cartesian3}\r\n * @constant\r\n */\r\nCartesian3.ONE = Object.freeze(new Cartesian3(1.0, 1.0, 1.0));\r\n\r\n/**\r\n * An immutable Cartesian3 instance initialized to (1.0, 0.0, 0.0).\r\n *\r\n * @type {Cartesian3}\r\n * @constant\r\n */\r\nCartesian3.UNIT_X = Object.freeze(new Cartesian3(1.0, 0.0, 0.0));\r\n\r\n/**\r\n * An immutable Cartesian3 instance initialized to (0.0, 1.0, 0.0).\r\n *\r\n * @type {Cartesian3}\r\n * @constant\r\n */\r\nCartesian3.UNIT_Y = Object.freeze(new Cartesian3(0.0, 1.0, 0.0));\r\n\r\n/**\r\n * An immutable Cartesian3 instance initialized to (0.0, 0.0, 1.0).\r\n *\r\n * @type {Cartesian3}\r\n * @constant\r\n */\r\nCartesian3.UNIT_Z = Object.freeze(new Cartesian3(0.0, 0.0, 1.0));\r\n\r\n/**\r\n * Duplicates this Cartesian3 instance.\r\n *\r\n * @param {Cartesian3} [result] The object onto which to store the result.\r\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\r\n */\r\nCartesian3.prototype.clone = function (result) {\r\n  return Cartesian3.clone(this, result);\r\n};\r\n\r\n/**\r\n * Compares this Cartesian against the provided Cartesian componentwise and returns\r\n * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n *\r\n * @param {Cartesian3} [right] The right hand side Cartesian.\r\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\r\n */\r\nCartesian3.prototype.equals = function (right) {\r\n  return Cartesian3.equals(this, right);\r\n};\r\n\r\n/**\r\n * Compares this Cartesian against the provided Cartesian componentwise and returns\r\n * <code>true</code> if they pass an absolute or relative tolerance test,\r\n * <code>false</code> otherwise.\r\n *\r\n * @param {Cartesian3} [right] The right hand side Cartesian.\r\n * @param {Number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\r\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\r\n * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\r\n */\r\nCartesian3.prototype.equalsEpsilon = function (\r\n  right,\r\n  relativeEpsilon,\r\n  absoluteEpsilon\r\n) {\r\n  return Cartesian3.equalsEpsilon(\r\n    this,\r\n    right,\r\n    relativeEpsilon,\r\n    absoluteEpsilon\r\n  );\r\n};\r\n\r\n/**\r\n * Creates a string representing this Cartesian in the format '(x, y, z)'.\r\n *\r\n * @returns {String} A string representing this Cartesian in the format '(x, y, z)'.\r\n */\r\nCartesian3.prototype.toString = function () {\r\n  return `(${this.x}, ${this.y}, ${this.z})`;\r\n};\r\nexport default Cartesian3;\r\n","import Cartesian3 from \"./Cartesian3.js\";\r\nimport defined from \"./defined.js\";\r\nimport DeveloperError from \"./DeveloperError.js\";\r\nimport CesiumMath from \"./Math.js\";\r\n\r\nconst scaleToGeodeticSurfaceIntersection = new Cartesian3();\r\nconst scaleToGeodeticSurfaceGradient = new Cartesian3();\r\n\r\n/**\r\n * Scales the provided Cartesian position along the geodetic surface normal\r\n * so that it is on the surface of this ellipsoid.  If the position is\r\n * at the center of the ellipsoid, this function returns undefined.\r\n *\r\n * @param {Cartesian3} cartesian The Cartesian position to scale.\r\n * @param {Cartesian3} oneOverRadii One over radii of the ellipsoid.\r\n * @param {Cartesian3} oneOverRadiiSquared One over radii squared of the ellipsoid.\r\n * @param {Number} centerToleranceSquared Tolerance for closeness to the center.\r\n * @param {Cartesian3} [result] The object onto which to store the result.\r\n * @returns {Cartesian3} The modified result parameter, a new Cartesian3 instance if none was provided, or undefined if the position is at the center.\r\n *\r\n * @function scaleToGeodeticSurface\r\n *\r\n * @private\r\n */\r\nfunction scaleToGeodeticSurface(\r\n  cartesian,\r\n  oneOverRadii,\r\n  oneOverRadiiSquared,\r\n  centerToleranceSquared,\r\n  result\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(cartesian)) {\r\n    throw new DeveloperError(\"cartesian is required.\");\r\n  }\r\n  if (!defined(oneOverRadii)) {\r\n    throw new DeveloperError(\"oneOverRadii is required.\");\r\n  }\r\n  if (!defined(oneOverRadiiSquared)) {\r\n    throw new DeveloperError(\"oneOverRadiiSquared is required.\");\r\n  }\r\n  if (!defined(centerToleranceSquared)) {\r\n    throw new DeveloperError(\"centerToleranceSquared is required.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const positionX = cartesian.x;\r\n  const positionY = cartesian.y;\r\n  const positionZ = cartesian.z;\r\n\r\n  const oneOverRadiiX = oneOverRadii.x;\r\n  const oneOverRadiiY = oneOverRadii.y;\r\n  const oneOverRadiiZ = oneOverRadii.z;\r\n\r\n  const x2 = positionX * positionX * oneOverRadiiX * oneOverRadiiX;\r\n  const y2 = positionY * positionY * oneOverRadiiY * oneOverRadiiY;\r\n  const z2 = positionZ * positionZ * oneOverRadiiZ * oneOverRadiiZ;\r\n\r\n  // Compute the squared ellipsoid norm.\r\n  const squaredNorm = x2 + y2 + z2;\r\n  const ratio = Math.sqrt(1.0 / squaredNorm);\r\n\r\n  // As an initial approximation, assume that the radial intersection is the projection point.\r\n  const intersection = Cartesian3.multiplyByScalar(\r\n    cartesian,\r\n    ratio,\r\n    scaleToGeodeticSurfaceIntersection\r\n  );\r\n\r\n  // If the position is near the center, the iteration will not converge.\r\n  if (squaredNorm < centerToleranceSquared) {\r\n    return !isFinite(ratio)\r\n      ? undefined\r\n      : Cartesian3.clone(intersection, result);\r\n  }\r\n\r\n  const oneOverRadiiSquaredX = oneOverRadiiSquared.x;\r\n  const oneOverRadiiSquaredY = oneOverRadiiSquared.y;\r\n  const oneOverRadiiSquaredZ = oneOverRadiiSquared.z;\r\n\r\n  // Use the gradient at the intersection point in place of the true unit normal.\r\n  // The difference in magnitude will be absorbed in the multiplier.\r\n  const gradient = scaleToGeodeticSurfaceGradient;\r\n  gradient.x = intersection.x * oneOverRadiiSquaredX * 2.0;\r\n  gradient.y = intersection.y * oneOverRadiiSquaredY * 2.0;\r\n  gradient.z = intersection.z * oneOverRadiiSquaredZ * 2.0;\r\n\r\n  // Compute the initial guess at the normal vector multiplier, lambda.\r\n  let lambda =\r\n    ((1.0 - ratio) * Cartesian3.magnitude(cartesian)) /\r\n    (0.5 * Cartesian3.magnitude(gradient));\r\n  let correction = 0.0;\r\n\r\n  let func;\r\n  let denominator;\r\n  let xMultiplier;\r\n  let yMultiplier;\r\n  let zMultiplier;\r\n  let xMultiplier2;\r\n  let yMultiplier2;\r\n  let zMultiplier2;\r\n  let xMultiplier3;\r\n  let yMultiplier3;\r\n  let zMultiplier3;\r\n\r\n  do {\r\n    lambda -= correction;\r\n\r\n    xMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredX);\r\n    yMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredY);\r\n    zMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredZ);\r\n\r\n    xMultiplier2 = xMultiplier * xMultiplier;\r\n    yMultiplier2 = yMultiplier * yMultiplier;\r\n    zMultiplier2 = zMultiplier * zMultiplier;\r\n\r\n    xMultiplier3 = xMultiplier2 * xMultiplier;\r\n    yMultiplier3 = yMultiplier2 * yMultiplier;\r\n    zMultiplier3 = zMultiplier2 * zMultiplier;\r\n\r\n    func = x2 * xMultiplier2 + y2 * yMultiplier2 + z2 * zMultiplier2 - 1.0;\r\n\r\n    // \"denominator\" here refers to the use of this expression in the velocity and acceleration\r\n    // computations in the sections to follow.\r\n    denominator =\r\n      x2 * xMultiplier3 * oneOverRadiiSquaredX +\r\n      y2 * yMultiplier3 * oneOverRadiiSquaredY +\r\n      z2 * zMultiplier3 * oneOverRadiiSquaredZ;\r\n\r\n    const derivative = -2.0 * denominator;\r\n\r\n    correction = func / derivative;\r\n  } while (Math.abs(func) > CesiumMath.EPSILON12);\r\n\r\n  if (!defined(result)) {\r\n    return new Cartesian3(\r\n      positionX * xMultiplier,\r\n      positionY * yMultiplier,\r\n      positionZ * zMultiplier\r\n    );\r\n  }\r\n  result.x = positionX * xMultiplier;\r\n  result.y = positionY * yMultiplier;\r\n  result.z = positionZ * zMultiplier;\r\n  return result;\r\n}\r\nexport default scaleToGeodeticSurface;\r\n","import Cartesian3 from \"./Cartesian3.js\";\r\nimport Check from \"./Check.js\";\r\nimport defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\nimport CesiumMath from \"./Math.js\";\r\nimport scaleToGeodeticSurface from \"./scaleToGeodeticSurface.js\";\r\n\r\n/**\r\n * A position defined by longitude, latitude, and height.\r\n * @alias Cartographic\r\n * @constructor\r\n *\r\n * @param {Number} [longitude=0.0] The longitude, in radians.\r\n * @param {Number} [latitude=0.0] The latitude, in radians.\r\n * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.\r\n *\r\n * @see Ellipsoid\r\n */\r\nfunction Cartographic(longitude, latitude, height) {\r\n  /**\r\n   * The longitude, in radians.\r\n   * @type {Number}\r\n   * @default 0.0\r\n   */\r\n  this.longitude = defaultValue(longitude, 0.0);\r\n\r\n  /**\r\n   * The latitude, in radians.\r\n   * @type {Number}\r\n   * @default 0.0\r\n   */\r\n  this.latitude = defaultValue(latitude, 0.0);\r\n\r\n  /**\r\n   * The height, in meters, above the ellipsoid.\r\n   * @type {Number}\r\n   * @default 0.0\r\n   */\r\n  this.height = defaultValue(height, 0.0);\r\n}\r\n\r\n/**\r\n * Creates a new Cartographic instance from longitude and latitude\r\n * specified in radians.\r\n *\r\n * @param {Number} longitude The longitude, in radians.\r\n * @param {Number} latitude The latitude, in radians.\r\n * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.\r\n * @param {Cartographic} [result] The object onto which to store the result.\r\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided.\r\n */\r\nCartographic.fromRadians = function (longitude, latitude, height, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.number(\"longitude\", longitude);\r\n  Check.typeOf.number(\"latitude\", latitude);\r\n  //>>includeEnd('debug');\r\n\r\n  height = defaultValue(height, 0.0);\r\n\r\n  if (!defined(result)) {\r\n    return new Cartographic(longitude, latitude, height);\r\n  }\r\n\r\n  result.longitude = longitude;\r\n  result.latitude = latitude;\r\n  result.height = height;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Creates a new Cartographic instance from longitude and latitude\r\n * specified in degrees.  The values in the resulting object will\r\n * be in radians.\r\n *\r\n * @param {Number} longitude The longitude, in degrees.\r\n * @param {Number} latitude The latitude, in degrees.\r\n * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.\r\n * @param {Cartographic} [result] The object onto which to store the result.\r\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided.\r\n */\r\nCartographic.fromDegrees = function (longitude, latitude, height, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.number(\"longitude\", longitude);\r\n  Check.typeOf.number(\"latitude\", latitude);\r\n  //>>includeEnd('debug');\r\n  longitude = CesiumMath.toRadians(longitude);\r\n  latitude = CesiumMath.toRadians(latitude);\r\n\r\n  return Cartographic.fromRadians(longitude, latitude, height, result);\r\n};\r\n\r\nconst cartesianToCartographicN = new Cartesian3();\r\nconst cartesianToCartographicP = new Cartesian3();\r\nconst cartesianToCartographicH = new Cartesian3();\r\nconst wgs84OneOverRadii = new Cartesian3(\r\n  1.0 / 6378137.0,\r\n  1.0 / 6378137.0,\r\n  1.0 / 6356752.3142451793\r\n);\r\nconst wgs84OneOverRadiiSquared = new Cartesian3(\r\n  1.0 / (6378137.0 * 6378137.0),\r\n  1.0 / (6378137.0 * 6378137.0),\r\n  1.0 / (6356752.3142451793 * 6356752.3142451793)\r\n);\r\nconst wgs84CenterToleranceSquared = CesiumMath.EPSILON1;\r\n\r\n/**\r\n * Creates a new Cartographic instance from a Cartesian position. The values in the\r\n * resulting object will be in radians.\r\n *\r\n * @param {Cartesian3} cartesian The Cartesian position to convert to cartographic representation.\r\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\r\n * @param {Cartographic} [result] The object onto which to store the result.\r\n * @returns {Cartographic} The modified result parameter, new Cartographic instance if none was provided, or undefined if the cartesian is at the center of the ellipsoid.\r\n */\r\nCartographic.fromCartesian = function (cartesian, ellipsoid, result) {\r\n  const oneOverRadii = defined(ellipsoid)\r\n    ? ellipsoid.oneOverRadii\r\n    : wgs84OneOverRadii;\r\n  const oneOverRadiiSquared = defined(ellipsoid)\r\n    ? ellipsoid.oneOverRadiiSquared\r\n    : wgs84OneOverRadiiSquared;\r\n  const centerToleranceSquared = defined(ellipsoid)\r\n    ? ellipsoid._centerToleranceSquared\r\n    : wgs84CenterToleranceSquared;\r\n\r\n  //`cartesian is required.` is thrown from scaleToGeodeticSurface\r\n  const p = scaleToGeodeticSurface(\r\n    cartesian,\r\n    oneOverRadii,\r\n    oneOverRadiiSquared,\r\n    centerToleranceSquared,\r\n    cartesianToCartographicP\r\n  );\r\n\r\n  if (!defined(p)) {\r\n    return undefined;\r\n  }\r\n\r\n  let n = Cartesian3.multiplyComponents(\r\n    p,\r\n    oneOverRadiiSquared,\r\n    cartesianToCartographicN\r\n  );\r\n  n = Cartesian3.normalize(n, n);\r\n\r\n  const h = Cartesian3.subtract(cartesian, p, cartesianToCartographicH);\r\n\r\n  const longitude = Math.atan2(n.y, n.x);\r\n  const latitude = Math.asin(n.z);\r\n  const height =\r\n    CesiumMath.sign(Cartesian3.dot(h, cartesian)) * Cartesian3.magnitude(h);\r\n\r\n  if (!defined(result)) {\r\n    return new Cartographic(longitude, latitude, height);\r\n  }\r\n  result.longitude = longitude;\r\n  result.latitude = latitude;\r\n  result.height = height;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Creates a new Cartesian3 instance from a Cartographic input. The values in the inputted\r\n * object should be in radians.\r\n *\r\n * @param {Cartographic} cartographic Input to be converted into a Cartesian3 output.\r\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\r\n * @param {Cartesian3} [result] The object onto which to store the result.\r\n * @returns {Cartesian3} The position\r\n */\r\nCartographic.toCartesian = function (cartographic, ellipsoid, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"cartographic\", cartographic);\r\n  //>>includeEnd('debug');\r\n\r\n  return Cartesian3.fromRadians(\r\n    cartographic.longitude,\r\n    cartographic.latitude,\r\n    cartographic.height,\r\n    ellipsoid,\r\n    result\r\n  );\r\n};\r\n\r\n/**\r\n * Duplicates a Cartographic instance.\r\n *\r\n * @param {Cartographic} cartographic The cartographic to duplicate.\r\n * @param {Cartographic} [result] The object onto which to store the result.\r\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided. (Returns undefined if cartographic is undefined)\r\n */\r\nCartographic.clone = function (cartographic, result) {\r\n  if (!defined(cartographic)) {\r\n    return undefined;\r\n  }\r\n  if (!defined(result)) {\r\n    return new Cartographic(\r\n      cartographic.longitude,\r\n      cartographic.latitude,\r\n      cartographic.height\r\n    );\r\n  }\r\n  result.longitude = cartographic.longitude;\r\n  result.latitude = cartographic.latitude;\r\n  result.height = cartographic.height;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Compares the provided cartographics componentwise and returns\r\n * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n *\r\n * @param {Cartographic} [left] The first cartographic.\r\n * @param {Cartographic} [right] The second cartographic.\r\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\r\n */\r\nCartographic.equals = function (left, right) {\r\n  return (\r\n    left === right ||\r\n    (defined(left) &&\r\n      defined(right) &&\r\n      left.longitude === right.longitude &&\r\n      left.latitude === right.latitude &&\r\n      left.height === right.height)\r\n  );\r\n};\r\n\r\n/**\r\n * Compares the provided cartographics componentwise and returns\r\n * <code>true</code> if they are within the provided epsilon,\r\n * <code>false</code> otherwise.\r\n *\r\n * @param {Cartographic} [left] The first cartographic.\r\n * @param {Cartographic} [right] The second cartographic.\r\n * @param {Number} [epsilon=0] The epsilon to use for equality testing.\r\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\r\n */\r\nCartographic.equalsEpsilon = function (left, right, epsilon) {\r\n  epsilon = defaultValue(epsilon, 0);\r\n\r\n  return (\r\n    left === right ||\r\n    (defined(left) &&\r\n      defined(right) &&\r\n      Math.abs(left.longitude - right.longitude) <= epsilon &&\r\n      Math.abs(left.latitude - right.latitude) <= epsilon &&\r\n      Math.abs(left.height - right.height) <= epsilon)\r\n  );\r\n};\r\n\r\n/**\r\n * An immutable Cartographic instance initialized to (0.0, 0.0, 0.0).\r\n *\r\n * @type {Cartographic}\r\n * @constant\r\n */\r\nCartographic.ZERO = Object.freeze(new Cartographic(0.0, 0.0, 0.0));\r\n\r\n/**\r\n * Duplicates this instance.\r\n *\r\n * @param {Cartographic} [result] The object onto which to store the result.\r\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided.\r\n */\r\nCartographic.prototype.clone = function (result) {\r\n  return Cartographic.clone(this, result);\r\n};\r\n\r\n/**\r\n * Compares the provided against this cartographic componentwise and returns\r\n * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n *\r\n * @param {Cartographic} [right] The second cartographic.\r\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\r\n */\r\nCartographic.prototype.equals = function (right) {\r\n  return Cartographic.equals(this, right);\r\n};\r\n\r\n/**\r\n * Compares the provided against this cartographic componentwise and returns\r\n * <code>true</code> if they are within the provided epsilon,\r\n * <code>false</code> otherwise.\r\n *\r\n * @param {Cartographic} [right] The second cartographic.\r\n * @param {Number} [epsilon=0] The epsilon to use for equality testing.\r\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\r\n */\r\nCartographic.prototype.equalsEpsilon = function (right, epsilon) {\r\n  return Cartographic.equalsEpsilon(this, right, epsilon);\r\n};\r\n\r\n/**\r\n * Creates a string representing this cartographic in the format '(longitude, latitude, height)'.\r\n *\r\n * @returns {String} A string representing the provided cartographic in the format '(longitude, latitude, height)'.\r\n */\r\nCartographic.prototype.toString = function () {\r\n  return `(${this.longitude}, ${this.latitude}, ${this.height})`;\r\n};\r\nexport default Cartographic;\r\n","import Cartesian3 from \"./Cartesian3.js\";\r\nimport Cartographic from \"./Cartographic.js\";\r\nimport Check from \"./Check.js\";\r\nimport defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\nimport DeveloperError from \"./DeveloperError.js\";\r\nimport CesiumMath from \"./Math.js\";\r\nimport scaleToGeodeticSurface from \"./scaleToGeodeticSurface.js\";\r\n\r\nfunction initialize(ellipsoid, x, y, z) {\r\n  x = defaultValue(x, 0.0);\r\n  y = defaultValue(y, 0.0);\r\n  z = defaultValue(z, 0.0);\r\n\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.number.greaterThanOrEquals(\"x\", x, 0.0);\r\n  Check.typeOf.number.greaterThanOrEquals(\"y\", y, 0.0);\r\n  Check.typeOf.number.greaterThanOrEquals(\"z\", z, 0.0);\r\n  //>>includeEnd('debug');\r\n\r\n  ellipsoid._radii = new Cartesian3(x, y, z);\r\n\r\n  ellipsoid._radiiSquared = new Cartesian3(x * x, y * y, z * z);\r\n\r\n  ellipsoid._radiiToTheFourth = new Cartesian3(\r\n    x * x * x * x,\r\n    y * y * y * y,\r\n    z * z * z * z\r\n  );\r\n\r\n  ellipsoid._oneOverRadii = new Cartesian3(\r\n    x === 0.0 ? 0.0 : 1.0 / x,\r\n    y === 0.0 ? 0.0 : 1.0 / y,\r\n    z === 0.0 ? 0.0 : 1.0 / z\r\n  );\r\n\r\n  ellipsoid._oneOverRadiiSquared = new Cartesian3(\r\n    x === 0.0 ? 0.0 : 1.0 / (x * x),\r\n    y === 0.0 ? 0.0 : 1.0 / (y * y),\r\n    z === 0.0 ? 0.0 : 1.0 / (z * z)\r\n  );\r\n\r\n  ellipsoid._minimumRadius = Math.min(x, y, z);\r\n\r\n  ellipsoid._maximumRadius = Math.max(x, y, z);\r\n\r\n  ellipsoid._centerToleranceSquared = CesiumMath.EPSILON1;\r\n\r\n  if (ellipsoid._radiiSquared.z !== 0) {\r\n    ellipsoid._squaredXOverSquaredZ =\r\n      ellipsoid._radiiSquared.x / ellipsoid._radiiSquared.z;\r\n  }\r\n}\r\n\r\n/**\r\n * A quadratic surface defined in Cartesian coordinates by the equation\r\n * <code>(x / a)^2 + (y / b)^2 + (z / c)^2 = 1</code>.  Primarily used\r\n * by Cesium to represent the shape of planetary bodies.\r\n *\r\n * Rather than constructing this object directly, one of the provided\r\n * constants is normally used.\r\n * @alias Ellipsoid\r\n * @constructor\r\n *\r\n * @param {Number} [x=0] The radius in the x direction.\r\n * @param {Number} [y=0] The radius in the y direction.\r\n * @param {Number} [z=0] The radius in the z direction.\r\n *\r\n * @exception {DeveloperError} All radii components must be greater than or equal to zero.\r\n *\r\n * @see Ellipsoid.fromCartesian3\r\n * @see Ellipsoid.WGS84\r\n * @see Ellipsoid.UNIT_SPHERE\r\n */\r\nfunction Ellipsoid(x, y, z) {\r\n  this._radii = undefined;\r\n  this._radiiSquared = undefined;\r\n  this._radiiToTheFourth = undefined;\r\n  this._oneOverRadii = undefined;\r\n  this._oneOverRadiiSquared = undefined;\r\n  this._minimumRadius = undefined;\r\n  this._maximumRadius = undefined;\r\n  this._centerToleranceSquared = undefined;\r\n  this._squaredXOverSquaredZ = undefined;\r\n\r\n  initialize(this, x, y, z);\r\n}\r\n\r\nObject.defineProperties(Ellipsoid.prototype, {\r\n  /**\r\n   * Gets the radii of the ellipsoid.\r\n   * @memberof Ellipsoid.prototype\r\n   * @type {Cartesian3}\r\n   * @readonly\r\n   */\r\n  radii: {\r\n    get: function () {\r\n      return this._radii;\r\n    },\r\n  },\r\n  /**\r\n   * Gets the squared radii of the ellipsoid.\r\n   * @memberof Ellipsoid.prototype\r\n   * @type {Cartesian3}\r\n   * @readonly\r\n   */\r\n  radiiSquared: {\r\n    get: function () {\r\n      return this._radiiSquared;\r\n    },\r\n  },\r\n  /**\r\n   * Gets the radii of the ellipsoid raise to the fourth power.\r\n   * @memberof Ellipsoid.prototype\r\n   * @type {Cartesian3}\r\n   * @readonly\r\n   */\r\n  radiiToTheFourth: {\r\n    get: function () {\r\n      return this._radiiToTheFourth;\r\n    },\r\n  },\r\n  /**\r\n   * Gets one over the radii of the ellipsoid.\r\n   * @memberof Ellipsoid.prototype\r\n   * @type {Cartesian3}\r\n   * @readonly\r\n   */\r\n  oneOverRadii: {\r\n    get: function () {\r\n      return this._oneOverRadii;\r\n    },\r\n  },\r\n  /**\r\n   * Gets one over the squared radii of the ellipsoid.\r\n   * @memberof Ellipsoid.prototype\r\n   * @type {Cartesian3}\r\n   * @readonly\r\n   */\r\n  oneOverRadiiSquared: {\r\n    get: function () {\r\n      return this._oneOverRadiiSquared;\r\n    },\r\n  },\r\n  /**\r\n   * Gets the minimum radius of the ellipsoid.\r\n   * @memberof Ellipsoid.prototype\r\n   * @type {Number}\r\n   * @readonly\r\n   */\r\n  minimumRadius: {\r\n    get: function () {\r\n      return this._minimumRadius;\r\n    },\r\n  },\r\n  /**\r\n   * Gets the maximum radius of the ellipsoid.\r\n   * @memberof Ellipsoid.prototype\r\n   * @type {Number}\r\n   * @readonly\r\n   */\r\n  maximumRadius: {\r\n    get: function () {\r\n      return this._maximumRadius;\r\n    },\r\n  },\r\n});\r\n\r\n/**\r\n * Duplicates an Ellipsoid instance.\r\n *\r\n * @param {Ellipsoid} ellipsoid The ellipsoid to duplicate.\r\n * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new\r\n *                    instance should be created.\r\n * @returns {Ellipsoid} The cloned Ellipsoid. (Returns undefined if ellipsoid is undefined)\r\n */\r\nEllipsoid.clone = function (ellipsoid, result) {\r\n  if (!defined(ellipsoid)) {\r\n    return undefined;\r\n  }\r\n  const radii = ellipsoid._radii;\r\n\r\n  if (!defined(result)) {\r\n    return new Ellipsoid(radii.x, radii.y, radii.z);\r\n  }\r\n\r\n  Cartesian3.clone(radii, result._radii);\r\n  Cartesian3.clone(ellipsoid._radiiSquared, result._radiiSquared);\r\n  Cartesian3.clone(ellipsoid._radiiToTheFourth, result._radiiToTheFourth);\r\n  Cartesian3.clone(ellipsoid._oneOverRadii, result._oneOverRadii);\r\n  Cartesian3.clone(ellipsoid._oneOverRadiiSquared, result._oneOverRadiiSquared);\r\n  result._minimumRadius = ellipsoid._minimumRadius;\r\n  result._maximumRadius = ellipsoid._maximumRadius;\r\n  result._centerToleranceSquared = ellipsoid._centerToleranceSquared;\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes an Ellipsoid from a Cartesian specifying the radii in x, y, and z directions.\r\n *\r\n * @param {Cartesian3} [cartesian=Cartesian3.ZERO] The ellipsoid's radius in the x, y, and z directions.\r\n * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new\r\n *                    instance should be created.\r\n * @returns {Ellipsoid} A new Ellipsoid instance.\r\n *\r\n * @exception {DeveloperError} All radii components must be greater than or equal to zero.\r\n *\r\n * @see Ellipsoid.WGS84\r\n * @see Ellipsoid.UNIT_SPHERE\r\n */\r\nEllipsoid.fromCartesian3 = function (cartesian, result) {\r\n  if (!defined(result)) {\r\n    result = new Ellipsoid();\r\n  }\r\n\r\n  if (!defined(cartesian)) {\r\n    return result;\r\n  }\r\n\r\n  initialize(result, cartesian.x, cartesian.y, cartesian.z);\r\n  return result;\r\n};\r\n\r\n/**\r\n * An Ellipsoid instance initialized to the WGS84 standard.\r\n *\r\n * @type {Ellipsoid}\r\n * @constant\r\n */\r\nEllipsoid.WGS84 = Object.freeze(\r\n  new Ellipsoid(6378137.0, 6378137.0, 6356752.3142451793)\r\n);\r\n\r\n/**\r\n * An Ellipsoid instance initialized to radii of (1.0, 1.0, 1.0).\r\n *\r\n * @type {Ellipsoid}\r\n * @constant\r\n */\r\nEllipsoid.UNIT_SPHERE = Object.freeze(new Ellipsoid(1.0, 1.0, 1.0));\r\n\r\n/**\r\n * An Ellipsoid instance initialized to a sphere with the lunar radius.\r\n *\r\n * @type {Ellipsoid}\r\n * @constant\r\n */\r\nEllipsoid.MOON = Object.freeze(\r\n  new Ellipsoid(\r\n    CesiumMath.LUNAR_RADIUS,\r\n    CesiumMath.LUNAR_RADIUS,\r\n    CesiumMath.LUNAR_RADIUS\r\n  )\r\n);\r\n\r\n/**\r\n * Duplicates an Ellipsoid instance.\r\n *\r\n * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new\r\n *                    instance should be created.\r\n * @returns {Ellipsoid} The cloned Ellipsoid.\r\n */\r\nEllipsoid.prototype.clone = function (result) {\r\n  return Ellipsoid.clone(this, result);\r\n};\r\n\r\n/**\r\n * The number of elements used to pack the object into an array.\r\n * @type {Number}\r\n */\r\nEllipsoid.packedLength = Cartesian3.packedLength;\r\n\r\n/**\r\n * Stores the provided instance into the provided array.\r\n *\r\n * @param {Ellipsoid} value The value to pack.\r\n * @param {Number[]} array The array to pack into.\r\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n *\r\n * @returns {Number[]} The array that was packed into\r\n */\r\nEllipsoid.pack = function (value, array, startingIndex) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"value\", value);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  Cartesian3.pack(value._radii, array, startingIndex);\r\n\r\n  return array;\r\n};\r\n\r\n/**\r\n * Retrieves an instance from a packed array.\r\n *\r\n * @param {Number[]} array The packed array.\r\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n * @param {Ellipsoid} [result] The object into which to store the result.\r\n * @returns {Ellipsoid} The modified result parameter or a new Ellipsoid instance if one was not provided.\r\n */\r\nEllipsoid.unpack = function (array, startingIndex, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  const radii = Cartesian3.unpack(array, startingIndex);\r\n  return Ellipsoid.fromCartesian3(radii, result);\r\n};\r\n\r\n/**\r\n * Computes the unit vector directed from the center of this ellipsoid toward the provided Cartesian position.\r\n * @function\r\n *\r\n * @param {Cartesian3} cartesian The Cartesian for which to to determine the geocentric normal.\r\n * @param {Cartesian3} [result] The object onto which to store the result.\r\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\r\n */\r\nEllipsoid.prototype.geocentricSurfaceNormal = Cartesian3.normalize;\r\n\r\n/**\r\n * Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.\r\n *\r\n * @param {Cartographic} cartographic The cartographic position for which to to determine the geodetic normal.\r\n * @param {Cartesian3} [result] The object onto which to store the result.\r\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\r\n */\r\nEllipsoid.prototype.geodeticSurfaceNormalCartographic = function (\r\n  cartographic,\r\n  result\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"cartographic\", cartographic);\r\n  //>>includeEnd('debug');\r\n\r\n  const longitude = cartographic.longitude;\r\n  const latitude = cartographic.latitude;\r\n  const cosLatitude = Math.cos(latitude);\r\n\r\n  const x = cosLatitude * Math.cos(longitude);\r\n  const y = cosLatitude * Math.sin(longitude);\r\n  const z = Math.sin(latitude);\r\n\r\n  if (!defined(result)) {\r\n    result = new Cartesian3();\r\n  }\r\n  result.x = x;\r\n  result.y = y;\r\n  result.z = z;\r\n  return Cartesian3.normalize(result, result);\r\n};\r\n\r\n/**\r\n * Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.\r\n *\r\n * @param {Cartesian3} cartesian The Cartesian position for which to to determine the surface normal.\r\n * @param {Cartesian3} [result] The object onto which to store the result.\r\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided, or undefined if a normal cannot be found.\r\n */\r\nEllipsoid.prototype.geodeticSurfaceNormal = function (cartesian, result) {\r\n  if (\r\n    Cartesian3.equalsEpsilon(cartesian, Cartesian3.ZERO, CesiumMath.EPSILON14)\r\n  ) {\r\n    return undefined;\r\n  }\r\n  if (!defined(result)) {\r\n    result = new Cartesian3();\r\n  }\r\n  result = Cartesian3.multiplyComponents(\r\n    cartesian,\r\n    this._oneOverRadiiSquared,\r\n    result\r\n  );\r\n  return Cartesian3.normalize(result, result);\r\n};\r\n\r\nconst cartographicToCartesianNormal = new Cartesian3();\r\nconst cartographicToCartesianK = new Cartesian3();\r\n\r\n/**\r\n * Converts the provided cartographic to Cartesian representation.\r\n *\r\n * @param {Cartographic} cartographic The cartographic position.\r\n * @param {Cartesian3} [result] The object onto which to store the result.\r\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\r\n *\r\n * @example\r\n * //Create a Cartographic and determine it's Cartesian representation on a WGS84 ellipsoid.\r\n * const position = new Cesium.Cartographic(Cesium.Math.toRadians(21), Cesium.Math.toRadians(78), 5000);\r\n * const cartesianPosition = Cesium.Ellipsoid.WGS84.cartographicToCartesian(position);\r\n */\r\nEllipsoid.prototype.cartographicToCartesian = function (cartographic, result) {\r\n  //`cartographic is required` is thrown from geodeticSurfaceNormalCartographic.\r\n  const n = cartographicToCartesianNormal;\r\n  const k = cartographicToCartesianK;\r\n  this.geodeticSurfaceNormalCartographic(cartographic, n);\r\n  Cartesian3.multiplyComponents(this._radiiSquared, n, k);\r\n  const gamma = Math.sqrt(Cartesian3.dot(n, k));\r\n  Cartesian3.divideByScalar(k, gamma, k);\r\n  Cartesian3.multiplyByScalar(n, cartographic.height, n);\r\n\r\n  if (!defined(result)) {\r\n    result = new Cartesian3();\r\n  }\r\n  return Cartesian3.add(k, n, result);\r\n};\r\n\r\n/**\r\n * Converts the provided array of cartographics to an array of Cartesians.\r\n *\r\n * @param {Cartographic[]} cartographics An array of cartographic positions.\r\n * @param {Cartesian3[]} [result] The object onto which to store the result.\r\n * @returns {Cartesian3[]} The modified result parameter or a new Array instance if none was provided.\r\n *\r\n * @example\r\n * //Convert an array of Cartographics and determine their Cartesian representation on a WGS84 ellipsoid.\r\n * const positions = [new Cesium.Cartographic(Cesium.Math.toRadians(21), Cesium.Math.toRadians(78), 0),\r\n *                  new Cesium.Cartographic(Cesium.Math.toRadians(21.321), Cesium.Math.toRadians(78.123), 100),\r\n *                  new Cesium.Cartographic(Cesium.Math.toRadians(21.645), Cesium.Math.toRadians(78.456), 250)];\r\n * const cartesianPositions = Cesium.Ellipsoid.WGS84.cartographicArrayToCartesianArray(positions);\r\n */\r\nEllipsoid.prototype.cartographicArrayToCartesianArray = function (\r\n  cartographics,\r\n  result\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"cartographics\", cartographics);\r\n  //>>includeEnd('debug')\r\n\r\n  const length = cartographics.length;\r\n  if (!defined(result)) {\r\n    result = new Array(length);\r\n  } else {\r\n    result.length = length;\r\n  }\r\n  for (let i = 0; i < length; i++) {\r\n    result[i] = this.cartographicToCartesian(cartographics[i], result[i]);\r\n  }\r\n  return result;\r\n};\r\n\r\nconst cartesianToCartographicN = new Cartesian3();\r\nconst cartesianToCartographicP = new Cartesian3();\r\nconst cartesianToCartographicH = new Cartesian3();\r\n\r\n/**\r\n * Converts the provided cartesian to cartographic representation.\r\n * The cartesian is undefined at the center of the ellipsoid.\r\n *\r\n * @param {Cartesian3} cartesian The Cartesian position to convert to cartographic representation.\r\n * @param {Cartographic} [result] The object onto which to store the result.\r\n * @returns {Cartographic} The modified result parameter, new Cartographic instance if none was provided, or undefined if the cartesian is at the center of the ellipsoid.\r\n *\r\n * @example\r\n * //Create a Cartesian and determine it's Cartographic representation on a WGS84 ellipsoid.\r\n * const position = new Cesium.Cartesian3(17832.12, 83234.52, 952313.73);\r\n * const cartographicPosition = Cesium.Ellipsoid.WGS84.cartesianToCartographic(position);\r\n */\r\nEllipsoid.prototype.cartesianToCartographic = function (cartesian, result) {\r\n  //`cartesian is required.` is thrown from scaleToGeodeticSurface\r\n  const p = this.scaleToGeodeticSurface(cartesian, cartesianToCartographicP);\r\n\r\n  if (!defined(p)) {\r\n    return undefined;\r\n  }\r\n\r\n  const n = this.geodeticSurfaceNormal(p, cartesianToCartographicN);\r\n  const h = Cartesian3.subtract(cartesian, p, cartesianToCartographicH);\r\n\r\n  const longitude = Math.atan2(n.y, n.x);\r\n  const latitude = Math.asin(n.z);\r\n  const height =\r\n    CesiumMath.sign(Cartesian3.dot(h, cartesian)) * Cartesian3.magnitude(h);\r\n\r\n  if (!defined(result)) {\r\n    return new Cartographic(longitude, latitude, height);\r\n  }\r\n  result.longitude = longitude;\r\n  result.latitude = latitude;\r\n  result.height = height;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Converts the provided array of cartesians to an array of cartographics.\r\n *\r\n * @param {Cartesian3[]} cartesians An array of Cartesian positions.\r\n * @param {Cartographic[]} [result] The object onto which to store the result.\r\n * @returns {Cartographic[]} The modified result parameter or a new Array instance if none was provided.\r\n *\r\n * @example\r\n * //Create an array of Cartesians and determine their Cartographic representation on a WGS84 ellipsoid.\r\n * const positions = [new Cesium.Cartesian3(17832.12, 83234.52, 952313.73),\r\n *                  new Cesium.Cartesian3(17832.13, 83234.53, 952313.73),\r\n *                  new Cesium.Cartesian3(17832.14, 83234.54, 952313.73)]\r\n * const cartographicPositions = Cesium.Ellipsoid.WGS84.cartesianArrayToCartographicArray(positions);\r\n */\r\nEllipsoid.prototype.cartesianArrayToCartographicArray = function (\r\n  cartesians,\r\n  result\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"cartesians\", cartesians);\r\n  //>>includeEnd('debug');\r\n\r\n  const length = cartesians.length;\r\n  if (!defined(result)) {\r\n    result = new Array(length);\r\n  } else {\r\n    result.length = length;\r\n  }\r\n  for (let i = 0; i < length; ++i) {\r\n    result[i] = this.cartesianToCartographic(cartesians[i], result[i]);\r\n  }\r\n  return result;\r\n};\r\n\r\n/**\r\n * Scales the provided Cartesian position along the geodetic surface normal\r\n * so that it is on the surface of this ellipsoid.  If the position is\r\n * at the center of the ellipsoid, this function returns undefined.\r\n *\r\n * @param {Cartesian3} cartesian The Cartesian position to scale.\r\n * @param {Cartesian3} [result] The object onto which to store the result.\r\n * @returns {Cartesian3} The modified result parameter, a new Cartesian3 instance if none was provided, or undefined if the position is at the center.\r\n */\r\nEllipsoid.prototype.scaleToGeodeticSurface = function (cartesian, result) {\r\n  return scaleToGeodeticSurface(\r\n    cartesian,\r\n    this._oneOverRadii,\r\n    this._oneOverRadiiSquared,\r\n    this._centerToleranceSquared,\r\n    result\r\n  );\r\n};\r\n\r\n/**\r\n * Scales the provided Cartesian position along the geocentric surface normal\r\n * so that it is on the surface of this ellipsoid.\r\n *\r\n * @param {Cartesian3} cartesian The Cartesian position to scale.\r\n * @param {Cartesian3} [result] The object onto which to store the result.\r\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\r\n */\r\nEllipsoid.prototype.scaleToGeocentricSurface = function (cartesian, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"cartesian\", cartesian);\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    result = new Cartesian3();\r\n  }\r\n\r\n  const positionX = cartesian.x;\r\n  const positionY = cartesian.y;\r\n  const positionZ = cartesian.z;\r\n  const oneOverRadiiSquared = this._oneOverRadiiSquared;\r\n\r\n  const beta =\r\n    1.0 /\r\n    Math.sqrt(\r\n      positionX * positionX * oneOverRadiiSquared.x +\r\n        positionY * positionY * oneOverRadiiSquared.y +\r\n        positionZ * positionZ * oneOverRadiiSquared.z\r\n    );\r\n\r\n  return Cartesian3.multiplyByScalar(cartesian, beta, result);\r\n};\r\n\r\n/**\r\n * Transforms a Cartesian X, Y, Z position to the ellipsoid-scaled space by multiplying\r\n * its components by the result of {@link Ellipsoid#oneOverRadii}.\r\n *\r\n * @param {Cartesian3} position The position to transform.\r\n * @param {Cartesian3} [result] The position to which to copy the result, or undefined to create and\r\n *        return a new instance.\r\n * @returns {Cartesian3} The position expressed in the scaled space.  The returned instance is the\r\n *          one passed as the result parameter if it is not undefined, or a new instance of it is.\r\n */\r\nEllipsoid.prototype.transformPositionToScaledSpace = function (\r\n  position,\r\n  result\r\n) {\r\n  if (!defined(result)) {\r\n    result = new Cartesian3();\r\n  }\r\n\r\n  return Cartesian3.multiplyComponents(position, this._oneOverRadii, result);\r\n};\r\n\r\n/**\r\n * Transforms a Cartesian X, Y, Z position from the ellipsoid-scaled space by multiplying\r\n * its components by the result of {@link Ellipsoid#radii}.\r\n *\r\n * @param {Cartesian3} position The position to transform.\r\n * @param {Cartesian3} [result] The position to which to copy the result, or undefined to create and\r\n *        return a new instance.\r\n * @returns {Cartesian3} The position expressed in the unscaled space.  The returned instance is the\r\n *          one passed as the result parameter if it is not undefined, or a new instance of it is.\r\n */\r\nEllipsoid.prototype.transformPositionFromScaledSpace = function (\r\n  position,\r\n  result\r\n) {\r\n  if (!defined(result)) {\r\n    result = new Cartesian3();\r\n  }\r\n\r\n  return Cartesian3.multiplyComponents(position, this._radii, result);\r\n};\r\n\r\n/**\r\n * Compares this Ellipsoid against the provided Ellipsoid componentwise and returns\r\n * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n *\r\n * @param {Ellipsoid} [right] The other Ellipsoid.\r\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\r\n */\r\nEllipsoid.prototype.equals = function (right) {\r\n  return (\r\n    this === right ||\r\n    (defined(right) && Cartesian3.equals(this._radii, right._radii))\r\n  );\r\n};\r\n\r\n/**\r\n * Creates a string representing this Ellipsoid in the format '(radii.x, radii.y, radii.z)'.\r\n *\r\n * @returns {String} A string representing this ellipsoid in the format '(radii.x, radii.y, radii.z)'.\r\n */\r\nEllipsoid.prototype.toString = function () {\r\n  return this._radii.toString();\r\n};\r\n\r\n/**\r\n * Computes a point which is the intersection of the surface normal with the z-axis.\r\n *\r\n * @param {Cartesian3} position the position. must be on the surface of the ellipsoid.\r\n * @param {Number} [buffer = 0.0] A buffer to subtract from the ellipsoid size when checking if the point is inside the ellipsoid.\r\n *                                In earth case, with common earth datums, there is no need for this buffer since the intersection point is always (relatively) very close to the center.\r\n *                                In WGS84 datum, intersection point is at max z = +-42841.31151331382 (0.673% of z-axis).\r\n *                                Intersection point could be outside the ellipsoid if the ratio of MajorAxis / AxisOfRotation is bigger than the square root of 2\r\n * @param {Cartesian3} [result] The cartesian to which to copy the result, or undefined to create and\r\n *        return a new instance.\r\n * @returns {Cartesian3 | undefined} the intersection point if it's inside the ellipsoid, undefined otherwise\r\n *\r\n * @exception {DeveloperError} position is required.\r\n * @exception {DeveloperError} Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y).\r\n * @exception {DeveloperError} Ellipsoid.radii.z must be greater than 0.\r\n */\r\nEllipsoid.prototype.getSurfaceNormalIntersectionWithZAxis = function (\r\n  position,\r\n  buffer,\r\n  result\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"position\", position);\r\n\r\n  if (\r\n    !CesiumMath.equalsEpsilon(\r\n      this._radii.x,\r\n      this._radii.y,\r\n      CesiumMath.EPSILON15\r\n    )\r\n  ) {\r\n    throw new DeveloperError(\r\n      \"Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)\"\r\n    );\r\n  }\r\n\r\n  Check.typeOf.number.greaterThan(\"Ellipsoid.radii.z\", this._radii.z, 0);\r\n  //>>includeEnd('debug');\r\n\r\n  buffer = defaultValue(buffer, 0.0);\r\n\r\n  const squaredXOverSquaredZ = this._squaredXOverSquaredZ;\r\n\r\n  if (!defined(result)) {\r\n    result = new Cartesian3();\r\n  }\r\n\r\n  result.x = 0.0;\r\n  result.y = 0.0;\r\n  result.z = position.z * (1 - squaredXOverSquaredZ);\r\n\r\n  if (Math.abs(result.z) >= this._radii.z - buffer) {\r\n    return undefined;\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\nconst abscissas = [\r\n  0.14887433898163,\r\n  0.43339539412925,\r\n  0.67940956829902,\r\n  0.86506336668898,\r\n  0.97390652851717,\r\n  0.0,\r\n];\r\nconst weights = [\r\n  0.29552422471475,\r\n  0.26926671930999,\r\n  0.21908636251598,\r\n  0.14945134915058,\r\n  0.066671344308684,\r\n  0.0,\r\n];\r\n\r\n/**\r\n * Compute the 10th order Gauss-Legendre Quadrature of the given definite integral.\r\n *\r\n * @param {Number} a The lower bound for the integration.\r\n * @param {Number} b The upper bound for the integration.\r\n * @param {Ellipsoid~RealValuedScalarFunction} func The function to integrate.\r\n * @returns {Number} The value of the integral of the given function over the given domain.\r\n *\r\n * @private\r\n */\r\nfunction gaussLegendreQuadrature(a, b, func) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.number(\"a\", a);\r\n  Check.typeOf.number(\"b\", b);\r\n  Check.typeOf.func(\"func\", func);\r\n  //>>includeEnd('debug');\r\n\r\n  // The range is half of the normal range since the five weights add to one (ten weights add to two).\r\n  // The values of the abscissas are multiplied by two to account for this.\r\n  const xMean = 0.5 * (b + a);\r\n  const xRange = 0.5 * (b - a);\r\n\r\n  let sum = 0.0;\r\n  for (let i = 0; i < 5; i++) {\r\n    const dx = xRange * abscissas[i];\r\n    sum += weights[i] * (func(xMean + dx) + func(xMean - dx));\r\n  }\r\n\r\n  // Scale the sum to the range of x.\r\n  sum *= xRange;\r\n  return sum;\r\n}\r\n\r\n/**\r\n * A real valued scalar function.\r\n * @callback Ellipsoid~RealValuedScalarFunction\r\n *\r\n * @param {Number} x The value used to evaluate the function.\r\n * @returns {Number} The value of the function at x.\r\n *\r\n * @private\r\n */\r\n\r\n/**\r\n * Computes an approximation of the surface area of a rectangle on the surface of an ellipsoid using\r\n * Gauss-Legendre 10th order quadrature.\r\n *\r\n * @param {Rectangle} rectangle The rectangle used for computing the surface area.\r\n * @returns {Number} The approximate area of the rectangle on the surface of this ellipsoid.\r\n */\r\nEllipsoid.prototype.surfaceArea = function (rectangle) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"rectangle\", rectangle);\r\n  //>>includeEnd('debug');\r\n  const minLongitude = rectangle.west;\r\n  let maxLongitude = rectangle.east;\r\n  const minLatitude = rectangle.south;\r\n  const maxLatitude = rectangle.north;\r\n\r\n  while (maxLongitude < minLongitude) {\r\n    maxLongitude += CesiumMath.TWO_PI;\r\n  }\r\n\r\n  const radiiSquared = this._radiiSquared;\r\n  const a2 = radiiSquared.x;\r\n  const b2 = radiiSquared.y;\r\n  const c2 = radiiSquared.z;\r\n  const a2b2 = a2 * b2;\r\n  return gaussLegendreQuadrature(minLatitude, maxLatitude, function (lat) {\r\n    // phi represents the angle measured from the north pole\r\n    // sin(phi) = sin(pi / 2 - lat) = cos(lat), cos(phi) is similar\r\n    const sinPhi = Math.cos(lat);\r\n    const cosPhi = Math.sin(lat);\r\n    return (\r\n      Math.cos(lat) *\r\n      gaussLegendreQuadrature(minLongitude, maxLongitude, function (lon) {\r\n        const cosTheta = Math.cos(lon);\r\n        const sinTheta = Math.sin(lon);\r\n        return Math.sqrt(\r\n          a2b2 * cosPhi * cosPhi +\r\n            c2 *\r\n              (b2 * cosTheta * cosTheta + a2 * sinTheta * sinTheta) *\r\n              sinPhi *\r\n              sinPhi\r\n        );\r\n      })\r\n    );\r\n  });\r\n};\r\n\r\nexport default Ellipsoid;\r\n","import Cartesian3 from \"./Cartesian3.js\";\r\nimport Check from \"./Check.js\";\r\nimport defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\nimport DeveloperError from \"./DeveloperError.js\";\r\nimport CesiumMath from \"./Math.js\";\r\n\r\n/**\r\n * A 3x3 matrix, indexable as a column-major order array.\r\n * Constructor parameters are in row-major order for code readability.\r\n * @alias Matrix3\r\n * @constructor\r\n * @implements {ArrayLike<number>}\r\n *\r\n * @param {Number} [column0Row0=0.0] The value for column 0, row 0.\r\n * @param {Number} [column1Row0=0.0] The value for column 1, row 0.\r\n * @param {Number} [column2Row0=0.0] The value for column 2, row 0.\r\n * @param {Number} [column0Row1=0.0] The value for column 0, row 1.\r\n * @param {Number} [column1Row1=0.0] The value for column 1, row 1.\r\n * @param {Number} [column2Row1=0.0] The value for column 2, row 1.\r\n * @param {Number} [column0Row2=0.0] The value for column 0, row 2.\r\n * @param {Number} [column1Row2=0.0] The value for column 1, row 2.\r\n * @param {Number} [column2Row2=0.0] The value for column 2, row 2.\r\n *\r\n * @see Matrix3.fromArray\r\n * @see Matrix3.fromColumnMajorArray\r\n * @see Matrix3.fromRowMajorArray\r\n * @see Matrix3.fromQuaternion\r\n * @see Matrix3.fromHeadingPitchRoll\r\n * @see Matrix3.fromScale\r\n * @see Matrix3.fromUniformScale\r\n * @see Matrix3.fromCrossProduct\r\n * @see Matrix3.fromRotationX\r\n * @see Matrix3.fromRotationY\r\n * @see Matrix3.fromRotationZ\r\n * @see Matrix2\r\n * @see Matrix4\r\n */\r\nfunction Matrix3(\r\n  column0Row0,\r\n  column1Row0,\r\n  column2Row0,\r\n  column0Row1,\r\n  column1Row1,\r\n  column2Row1,\r\n  column0Row2,\r\n  column1Row2,\r\n  column2Row2\r\n) {\r\n  this[0] = defaultValue(column0Row0, 0.0);\r\n  this[1] = defaultValue(column0Row1, 0.0);\r\n  this[2] = defaultValue(column0Row2, 0.0);\r\n  this[3] = defaultValue(column1Row0, 0.0);\r\n  this[4] = defaultValue(column1Row1, 0.0);\r\n  this[5] = defaultValue(column1Row2, 0.0);\r\n  this[6] = defaultValue(column2Row0, 0.0);\r\n  this[7] = defaultValue(column2Row1, 0.0);\r\n  this[8] = defaultValue(column2Row2, 0.0);\r\n}\r\n\r\n/**\r\n * The number of elements used to pack the object into an array.\r\n * @type {Number}\r\n */\r\nMatrix3.packedLength = 9;\r\n\r\n/**\r\n * Stores the provided instance into the provided array.\r\n *\r\n * @param {Matrix3} value The value to pack.\r\n * @param {Number[]} array The array to pack into.\r\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n *\r\n * @returns {Number[]} The array that was packed into\r\n */\r\nMatrix3.pack = function (value, array, startingIndex) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"value\", value);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  array[startingIndex++] = value[0];\r\n  array[startingIndex++] = value[1];\r\n  array[startingIndex++] = value[2];\r\n  array[startingIndex++] = value[3];\r\n  array[startingIndex++] = value[4];\r\n  array[startingIndex++] = value[5];\r\n  array[startingIndex++] = value[6];\r\n  array[startingIndex++] = value[7];\r\n  array[startingIndex++] = value[8];\r\n\r\n  return array;\r\n};\r\n\r\n/**\r\n * Retrieves an instance from a packed array.\r\n *\r\n * @param {Number[]} array The packed array.\r\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n * @param {Matrix3} [result] The object into which to store the result.\r\n * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided.\r\n */\r\nMatrix3.unpack = function (array, startingIndex, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  if (!defined(result)) {\r\n    result = new Matrix3();\r\n  }\r\n\r\n  result[0] = array[startingIndex++];\r\n  result[1] = array[startingIndex++];\r\n  result[2] = array[startingIndex++];\r\n  result[3] = array[startingIndex++];\r\n  result[4] = array[startingIndex++];\r\n  result[5] = array[startingIndex++];\r\n  result[6] = array[startingIndex++];\r\n  result[7] = array[startingIndex++];\r\n  result[8] = array[startingIndex++];\r\n  return result;\r\n};\r\n\r\n/**\r\n * Flattens an array of Matrix3s into an array of components. The components\r\n * are stored in column-major order.\r\n *\r\n * @param {Matrix3[]} array The array of matrices to pack.\r\n * @param {Number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 9 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 9) elements.\r\n * @returns {Number[]} The packed array.\r\n */\r\nMatrix3.packArray = function (array, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  const length = array.length;\r\n  const resultLength = length * 9;\r\n  if (!defined(result)) {\r\n    result = new Array(resultLength);\r\n  } else if (!Array.isArray(result) && result.length !== resultLength) {\r\n    //>>includeStart('debug', pragmas.debug);\r\n    throw new DeveloperError(\r\n      \"If result is a typed array, it must have exactly array.length * 9 elements\"\r\n    );\r\n    //>>includeEnd('debug');\r\n  } else if (result.length !== resultLength) {\r\n    result.length = resultLength;\r\n  }\r\n\r\n  for (let i = 0; i < length; ++i) {\r\n    Matrix3.pack(array[i], result, i * 9);\r\n  }\r\n  return result;\r\n};\r\n\r\n/**\r\n * Unpacks an array of column-major matrix components into an array of Matrix3s.\r\n *\r\n * @param {Number[]} array The array of components to unpack.\r\n * @param {Matrix3[]} [result] The array onto which to store the result.\r\n * @returns {Matrix3[]} The unpacked array.\r\n */\r\nMatrix3.unpackArray = function (array, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"array\", array);\r\n  Check.typeOf.number.greaterThanOrEquals(\"array.length\", array.length, 9);\r\n  if (array.length % 9 !== 0) {\r\n    throw new DeveloperError(\"array length must be a multiple of 9.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const length = array.length;\r\n  if (!defined(result)) {\r\n    result = new Array(length / 9);\r\n  } else {\r\n    result.length = length / 9;\r\n  }\r\n\r\n  for (let i = 0; i < length; i += 9) {\r\n    const index = i / 9;\r\n    result[index] = Matrix3.unpack(array, i, result[index]);\r\n  }\r\n  return result;\r\n};\r\n\r\n/**\r\n * Duplicates a Matrix3 instance.\r\n *\r\n * @param {Matrix3} matrix The matrix to duplicate.\r\n * @param {Matrix3} [result] The object onto which to store the result.\r\n * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided. (Returns undefined if matrix is undefined)\r\n */\r\nMatrix3.clone = function (matrix, result) {\r\n  if (!defined(matrix)) {\r\n    return undefined;\r\n  }\r\n  if (!defined(result)) {\r\n    return new Matrix3(\r\n      matrix[0],\r\n      matrix[3],\r\n      matrix[6],\r\n      matrix[1],\r\n      matrix[4],\r\n      matrix[7],\r\n      matrix[2],\r\n      matrix[5],\r\n      matrix[8]\r\n    );\r\n  }\r\n  result[0] = matrix[0];\r\n  result[1] = matrix[1];\r\n  result[2] = matrix[2];\r\n  result[3] = matrix[3];\r\n  result[4] = matrix[4];\r\n  result[5] = matrix[5];\r\n  result[6] = matrix[6];\r\n  result[7] = matrix[7];\r\n  result[8] = matrix[8];\r\n  return result;\r\n};\r\n\r\n/**\r\n * Creates a Matrix3 from 9 consecutive elements in an array.\r\n *\r\n * @function\r\n * @param {Number[]} array The array whose 9 consecutive elements correspond to the positions of the matrix.  Assumes column-major order.\r\n * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to first column first row position in the matrix.\r\n * @param {Matrix3} [result] The object onto which to store the result.\r\n * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided.\r\n *\r\n * @example\r\n * // Create the Matrix3:\r\n * // [1.0, 2.0, 3.0]\r\n * // [1.0, 2.0, 3.0]\r\n * // [1.0, 2.0, 3.0]\r\n *\r\n * const v = [1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0];\r\n * const m = Cesium.Matrix3.fromArray(v);\r\n *\r\n * // Create same Matrix3 with using an offset into an array\r\n * const v2 = [0.0, 0.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0];\r\n * const m2 = Cesium.Matrix3.fromArray(v2, 2);\r\n */\r\nMatrix3.fromArray = Matrix3.unpack;\r\n\r\n/**\r\n * Creates a Matrix3 instance from a column-major order array.\r\n *\r\n * @param {Number[]} values The column-major order array.\r\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\r\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\r\n */\r\nMatrix3.fromColumnMajorArray = function (values, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"values\", values);\r\n  //>>includeEnd('debug');\r\n\r\n  return Matrix3.clone(values, result);\r\n};\r\n\r\n/**\r\n * Creates a Matrix3 instance from a row-major order array.\r\n * The resulting matrix will be in column-major order.\r\n *\r\n * @param {Number[]} values The row-major order array.\r\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\r\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\r\n */\r\nMatrix3.fromRowMajorArray = function (values, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"values\", values);\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    return new Matrix3(\r\n      values[0],\r\n      values[1],\r\n      values[2],\r\n      values[3],\r\n      values[4],\r\n      values[5],\r\n      values[6],\r\n      values[7],\r\n      values[8]\r\n    );\r\n  }\r\n  result[0] = values[0];\r\n  result[1] = values[3];\r\n  result[2] = values[6];\r\n  result[3] = values[1];\r\n  result[4] = values[4];\r\n  result[5] = values[7];\r\n  result[6] = values[2];\r\n  result[7] = values[5];\r\n  result[8] = values[8];\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes a 3x3 rotation matrix from the provided quaternion.\r\n *\r\n * @param {Quaternion} quaternion the quaternion to use.\r\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\r\n * @returns {Matrix3} The 3x3 rotation matrix from this quaternion.\r\n */\r\nMatrix3.fromQuaternion = function (quaternion, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"quaternion\", quaternion);\r\n  //>>includeEnd('debug');\r\n\r\n  const x2 = quaternion.x * quaternion.x;\r\n  const xy = quaternion.x * quaternion.y;\r\n  const xz = quaternion.x * quaternion.z;\r\n  const xw = quaternion.x * quaternion.w;\r\n  const y2 = quaternion.y * quaternion.y;\r\n  const yz = quaternion.y * quaternion.z;\r\n  const yw = quaternion.y * quaternion.w;\r\n  const z2 = quaternion.z * quaternion.z;\r\n  const zw = quaternion.z * quaternion.w;\r\n  const w2 = quaternion.w * quaternion.w;\r\n\r\n  const m00 = x2 - y2 - z2 + w2;\r\n  const m01 = 2.0 * (xy - zw);\r\n  const m02 = 2.0 * (xz + yw);\r\n\r\n  const m10 = 2.0 * (xy + zw);\r\n  const m11 = -x2 + y2 - z2 + w2;\r\n  const m12 = 2.0 * (yz - xw);\r\n\r\n  const m20 = 2.0 * (xz - yw);\r\n  const m21 = 2.0 * (yz + xw);\r\n  const m22 = -x2 - y2 + z2 + w2;\r\n\r\n  if (!defined(result)) {\r\n    return new Matrix3(m00, m01, m02, m10, m11, m12, m20, m21, m22);\r\n  }\r\n  result[0] = m00;\r\n  result[1] = m10;\r\n  result[2] = m20;\r\n  result[3] = m01;\r\n  result[4] = m11;\r\n  result[5] = m21;\r\n  result[6] = m02;\r\n  result[7] = m12;\r\n  result[8] = m22;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes a 3x3 rotation matrix from the provided headingPitchRoll. (see http://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles )\r\n *\r\n * @param {HeadingPitchRoll} headingPitchRoll the headingPitchRoll to use.\r\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\r\n * @returns {Matrix3} The 3x3 rotation matrix from this headingPitchRoll.\r\n */\r\nMatrix3.fromHeadingPitchRoll = function (headingPitchRoll, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"headingPitchRoll\", headingPitchRoll);\r\n  //>>includeEnd('debug');\r\n\r\n  const cosTheta = Math.cos(-headingPitchRoll.pitch);\r\n  const cosPsi = Math.cos(-headingPitchRoll.heading);\r\n  const cosPhi = Math.cos(headingPitchRoll.roll);\r\n  const sinTheta = Math.sin(-headingPitchRoll.pitch);\r\n  const sinPsi = Math.sin(-headingPitchRoll.heading);\r\n  const sinPhi = Math.sin(headingPitchRoll.roll);\r\n\r\n  const m00 = cosTheta * cosPsi;\r\n  const m01 = -cosPhi * sinPsi + sinPhi * sinTheta * cosPsi;\r\n  const m02 = sinPhi * sinPsi + cosPhi * sinTheta * cosPsi;\r\n\r\n  const m10 = cosTheta * sinPsi;\r\n  const m11 = cosPhi * cosPsi + sinPhi * sinTheta * sinPsi;\r\n  const m12 = -sinPhi * cosPsi + cosPhi * sinTheta * sinPsi;\r\n\r\n  const m20 = -sinTheta;\r\n  const m21 = sinPhi * cosTheta;\r\n  const m22 = cosPhi * cosTheta;\r\n\r\n  if (!defined(result)) {\r\n    return new Matrix3(m00, m01, m02, m10, m11, m12, m20, m21, m22);\r\n  }\r\n  result[0] = m00;\r\n  result[1] = m10;\r\n  result[2] = m20;\r\n  result[3] = m01;\r\n  result[4] = m11;\r\n  result[5] = m21;\r\n  result[6] = m02;\r\n  result[7] = m12;\r\n  result[8] = m22;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes a Matrix3 instance representing a non-uniform scale.\r\n *\r\n * @param {Cartesian3} scale The x, y, and z scale factors.\r\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\r\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\r\n *\r\n * @example\r\n * // Creates\r\n * //   [7.0, 0.0, 0.0]\r\n * //   [0.0, 8.0, 0.0]\r\n * //   [0.0, 0.0, 9.0]\r\n * const m = Cesium.Matrix3.fromScale(new Cesium.Cartesian3(7.0, 8.0, 9.0));\r\n */\r\nMatrix3.fromScale = function (scale, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"scale\", scale);\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    return new Matrix3(scale.x, 0.0, 0.0, 0.0, scale.y, 0.0, 0.0, 0.0, scale.z);\r\n  }\r\n\r\n  result[0] = scale.x;\r\n  result[1] = 0.0;\r\n  result[2] = 0.0;\r\n  result[3] = 0.0;\r\n  result[4] = scale.y;\r\n  result[5] = 0.0;\r\n  result[6] = 0.0;\r\n  result[7] = 0.0;\r\n  result[8] = scale.z;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes a Matrix3 instance representing a uniform scale.\r\n *\r\n * @param {Number} scale The uniform scale factor.\r\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\r\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\r\n *\r\n * @example\r\n * // Creates\r\n * //   [2.0, 0.0, 0.0]\r\n * //   [0.0, 2.0, 0.0]\r\n * //   [0.0, 0.0, 2.0]\r\n * const m = Cesium.Matrix3.fromUniformScale(2.0);\r\n */\r\nMatrix3.fromUniformScale = function (scale, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.number(\"scale\", scale);\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    return new Matrix3(scale, 0.0, 0.0, 0.0, scale, 0.0, 0.0, 0.0, scale);\r\n  }\r\n\r\n  result[0] = scale;\r\n  result[1] = 0.0;\r\n  result[2] = 0.0;\r\n  result[3] = 0.0;\r\n  result[4] = scale;\r\n  result[5] = 0.0;\r\n  result[6] = 0.0;\r\n  result[7] = 0.0;\r\n  result[8] = scale;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes a Matrix3 instance representing the cross product equivalent matrix of a Cartesian3 vector.\r\n *\r\n * @param {Cartesian3} vector the vector on the left hand side of the cross product operation.\r\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\r\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\r\n *\r\n * @example\r\n * // Creates\r\n * //   [0.0, -9.0,  8.0]\r\n * //   [9.0,  0.0, -7.0]\r\n * //   [-8.0, 7.0,  0.0]\r\n * const m = Cesium.Matrix3.fromCrossProduct(new Cesium.Cartesian3(7.0, 8.0, 9.0));\r\n */\r\nMatrix3.fromCrossProduct = function (vector, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"vector\", vector);\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    return new Matrix3(\r\n      0.0,\r\n      -vector.z,\r\n      vector.y,\r\n      vector.z,\r\n      0.0,\r\n      -vector.x,\r\n      -vector.y,\r\n      vector.x,\r\n      0.0\r\n    );\r\n  }\r\n\r\n  result[0] = 0.0;\r\n  result[1] = vector.z;\r\n  result[2] = -vector.y;\r\n  result[3] = -vector.z;\r\n  result[4] = 0.0;\r\n  result[5] = vector.x;\r\n  result[6] = vector.y;\r\n  result[7] = -vector.x;\r\n  result[8] = 0.0;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Creates a rotation matrix around the x-axis.\r\n *\r\n * @param {Number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.\r\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\r\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\r\n *\r\n * @example\r\n * // Rotate a point 45 degrees counterclockwise around the x-axis.\r\n * const p = new Cesium.Cartesian3(5, 6, 7);\r\n * const m = Cesium.Matrix3.fromRotationX(Cesium.Math.toRadians(45.0));\r\n * const rotated = Cesium.Matrix3.multiplyByVector(m, p, new Cesium.Cartesian3());\r\n */\r\nMatrix3.fromRotationX = function (angle, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.number(\"angle\", angle);\r\n  //>>includeEnd('debug');\r\n\r\n  const cosAngle = Math.cos(angle);\r\n  const sinAngle = Math.sin(angle);\r\n\r\n  if (!defined(result)) {\r\n    return new Matrix3(\r\n      1.0,\r\n      0.0,\r\n      0.0,\r\n      0.0,\r\n      cosAngle,\r\n      -sinAngle,\r\n      0.0,\r\n      sinAngle,\r\n      cosAngle\r\n    );\r\n  }\r\n\r\n  result[0] = 1.0;\r\n  result[1] = 0.0;\r\n  result[2] = 0.0;\r\n  result[3] = 0.0;\r\n  result[4] = cosAngle;\r\n  result[5] = sinAngle;\r\n  result[6] = 0.0;\r\n  result[7] = -sinAngle;\r\n  result[8] = cosAngle;\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Creates a rotation matrix around the y-axis.\r\n *\r\n * @param {Number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.\r\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\r\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\r\n *\r\n * @example\r\n * // Rotate a point 45 degrees counterclockwise around the y-axis.\r\n * const p = new Cesium.Cartesian3(5, 6, 7);\r\n * const m = Cesium.Matrix3.fromRotationY(Cesium.Math.toRadians(45.0));\r\n * const rotated = Cesium.Matrix3.multiplyByVector(m, p, new Cesium.Cartesian3());\r\n */\r\nMatrix3.fromRotationY = function (angle, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.number(\"angle\", angle);\r\n  //>>includeEnd('debug');\r\n\r\n  const cosAngle = Math.cos(angle);\r\n  const sinAngle = Math.sin(angle);\r\n\r\n  if (!defined(result)) {\r\n    return new Matrix3(\r\n      cosAngle,\r\n      0.0,\r\n      sinAngle,\r\n      0.0,\r\n      1.0,\r\n      0.0,\r\n      -sinAngle,\r\n      0.0,\r\n      cosAngle\r\n    );\r\n  }\r\n\r\n  result[0] = cosAngle;\r\n  result[1] = 0.0;\r\n  result[2] = -sinAngle;\r\n  result[3] = 0.0;\r\n  result[4] = 1.0;\r\n  result[5] = 0.0;\r\n  result[6] = sinAngle;\r\n  result[7] = 0.0;\r\n  result[8] = cosAngle;\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Creates a rotation matrix around the z-axis.\r\n *\r\n * @param {Number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.\r\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\r\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\r\n *\r\n * @example\r\n * // Rotate a point 45 degrees counterclockwise around the z-axis.\r\n * const p = new Cesium.Cartesian3(5, 6, 7);\r\n * const m = Cesium.Matrix3.fromRotationZ(Cesium.Math.toRadians(45.0));\r\n * const rotated = Cesium.Matrix3.multiplyByVector(m, p, new Cesium.Cartesian3());\r\n */\r\nMatrix3.fromRotationZ = function (angle, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.number(\"angle\", angle);\r\n  //>>includeEnd('debug');\r\n\r\n  const cosAngle = Math.cos(angle);\r\n  const sinAngle = Math.sin(angle);\r\n\r\n  if (!defined(result)) {\r\n    return new Matrix3(\r\n      cosAngle,\r\n      -sinAngle,\r\n      0.0,\r\n      sinAngle,\r\n      cosAngle,\r\n      0.0,\r\n      0.0,\r\n      0.0,\r\n      1.0\r\n    );\r\n  }\r\n\r\n  result[0] = cosAngle;\r\n  result[1] = sinAngle;\r\n  result[2] = 0.0;\r\n  result[3] = -sinAngle;\r\n  result[4] = cosAngle;\r\n  result[5] = 0.0;\r\n  result[6] = 0.0;\r\n  result[7] = 0.0;\r\n  result[8] = 1.0;\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Creates an Array from the provided Matrix3 instance.\r\n * The array will be in column-major order.\r\n *\r\n * @param {Matrix3} matrix The matrix to use..\r\n * @param {Number[]} [result] The Array onto which to store the result.\r\n * @returns {Number[]} The modified Array parameter or a new Array instance if one was not provided.\r\n */\r\nMatrix3.toArray = function (matrix, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    return [\r\n      matrix[0],\r\n      matrix[1],\r\n      matrix[2],\r\n      matrix[3],\r\n      matrix[4],\r\n      matrix[5],\r\n      matrix[6],\r\n      matrix[7],\r\n      matrix[8],\r\n    ];\r\n  }\r\n  result[0] = matrix[0];\r\n  result[1] = matrix[1];\r\n  result[2] = matrix[2];\r\n  result[3] = matrix[3];\r\n  result[4] = matrix[4];\r\n  result[5] = matrix[5];\r\n  result[6] = matrix[6];\r\n  result[7] = matrix[7];\r\n  result[8] = matrix[8];\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the array index of the element at the provided row and column.\r\n *\r\n * @param {Number} column The zero-based index of the column.\r\n * @param {Number} row The zero-based index of the row.\r\n * @returns {Number} The index of the element at the provided row and column.\r\n *\r\n * @exception {DeveloperError} row must be 0, 1, or 2.\r\n * @exception {DeveloperError} column must be 0, 1, or 2.\r\n *\r\n * @example\r\n * const myMatrix = new Cesium.Matrix3();\r\n * const column1Row0Index = Cesium.Matrix3.getElementIndex(1, 0);\r\n * const column1Row0 = myMatrix[column1Row0Index]\r\n * myMatrix[column1Row0Index] = 10.0;\r\n */\r\nMatrix3.getElementIndex = function (column, row) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.number.greaterThanOrEquals(\"row\", row, 0);\r\n  Check.typeOf.number.lessThanOrEquals(\"row\", row, 2);\r\n  Check.typeOf.number.greaterThanOrEquals(\"column\", column, 0);\r\n  Check.typeOf.number.lessThanOrEquals(\"column\", column, 2);\r\n  //>>includeEnd('debug');\r\n\r\n  return column * 3 + row;\r\n};\r\n\r\n/**\r\n * Retrieves a copy of the matrix column at the provided index as a Cartesian3 instance.\r\n *\r\n * @param {Matrix3} matrix The matrix to use.\r\n * @param {Number} index The zero-based index of the column to retrieve.\r\n * @param {Cartesian3} result The object onto which to store the result.\r\n * @returns {Cartesian3} The modified result parameter.\r\n *\r\n * @exception {DeveloperError} index must be 0, 1, or 2.\r\n */\r\nMatrix3.getColumn = function (matrix, index, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\r\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 2);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  const startIndex = index * 3;\r\n  const x = matrix[startIndex];\r\n  const y = matrix[startIndex + 1];\r\n  const z = matrix[startIndex + 2];\r\n\r\n  result.x = x;\r\n  result.y = y;\r\n  result.z = z;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian3 instance.\r\n *\r\n * @param {Matrix3} matrix The matrix to use.\r\n * @param {Number} index The zero-based index of the column to set.\r\n * @param {Cartesian3} cartesian The Cartesian whose values will be assigned to the specified column.\r\n * @param {Matrix3} result The object onto which to store the result.\r\n * @returns {Matrix3} The modified result parameter.\r\n *\r\n * @exception {DeveloperError} index must be 0, 1, or 2.\r\n */\r\nMatrix3.setColumn = function (matrix, index, cartesian, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\r\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 2);\r\n  Check.typeOf.object(\"cartesian\", cartesian);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result = Matrix3.clone(matrix, result);\r\n  const startIndex = index * 3;\r\n  result[startIndex] = cartesian.x;\r\n  result[startIndex + 1] = cartesian.y;\r\n  result[startIndex + 2] = cartesian.z;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Retrieves a copy of the matrix row at the provided index as a Cartesian3 instance.\r\n *\r\n * @param {Matrix3} matrix The matrix to use.\r\n * @param {Number} index The zero-based index of the row to retrieve.\r\n * @param {Cartesian3} result The object onto which to store the result.\r\n * @returns {Cartesian3} The modified result parameter.\r\n *\r\n * @exception {DeveloperError} index must be 0, 1, or 2.\r\n */\r\nMatrix3.getRow = function (matrix, index, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\r\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 2);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  const x = matrix[index];\r\n  const y = matrix[index + 3];\r\n  const z = matrix[index + 6];\r\n\r\n  result.x = x;\r\n  result.y = y;\r\n  result.z = z;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian3 instance.\r\n *\r\n * @param {Matrix3} matrix The matrix to use.\r\n * @param {Number} index The zero-based index of the row to set.\r\n * @param {Cartesian3} cartesian The Cartesian whose values will be assigned to the specified row.\r\n * @param {Matrix3} result The object onto which to store the result.\r\n * @returns {Matrix3} The modified result parameter.\r\n *\r\n * @exception {DeveloperError} index must be 0, 1, or 2.\r\n */\r\nMatrix3.setRow = function (matrix, index, cartesian, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\r\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 2);\r\n  Check.typeOf.object(\"cartesian\", cartesian);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result = Matrix3.clone(matrix, result);\r\n  result[index] = cartesian.x;\r\n  result[index + 3] = cartesian.y;\r\n  result[index + 6] = cartesian.z;\r\n  return result;\r\n};\r\n\r\nconst scaleScratch1 = new Cartesian3();\r\n\r\n/**\r\n * Computes a new matrix that replaces the scale with the provided scale.\r\n * This assumes the matrix is an affine transformation.\r\n *\r\n * @param {Matrix3} matrix The matrix to use.\r\n * @param {Cartesian3} scale The scale that replaces the scale of the provided matrix.\r\n * @param {Matrix3} result The object onto which to store the result.\r\n * @returns {Matrix3} The modified result parameter.\r\n *\r\n * @see Matrix3.setUniformScale\r\n * @see Matrix3.fromScale\r\n * @see Matrix3.fromUniformScale\r\n * @see Matrix3.multiplyByScale\r\n * @see Matrix3.multiplyByUniformScale\r\n * @see Matrix3.getScale\r\n */\r\nMatrix3.setScale = function (matrix, scale, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  Check.typeOf.object(\"scale\", scale);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  const existingScale = Matrix3.getScale(matrix, scaleScratch1);\r\n  const scaleRatioX = scale.x / existingScale.x;\r\n  const scaleRatioY = scale.y / existingScale.y;\r\n  const scaleRatioZ = scale.z / existingScale.z;\r\n\r\n  result[0] = matrix[0] * scaleRatioX;\r\n  result[1] = matrix[1] * scaleRatioX;\r\n  result[2] = matrix[2] * scaleRatioX;\r\n  result[3] = matrix[3] * scaleRatioY;\r\n  result[4] = matrix[4] * scaleRatioY;\r\n  result[5] = matrix[5] * scaleRatioY;\r\n  result[6] = matrix[6] * scaleRatioZ;\r\n  result[7] = matrix[7] * scaleRatioZ;\r\n  result[8] = matrix[8] * scaleRatioZ;\r\n\r\n  return result;\r\n};\r\n\r\nconst scaleScratch2 = new Cartesian3();\r\n\r\n/**\r\n * Computes a new matrix that replaces the scale with the provided uniform scale.\r\n * This assumes the matrix is an affine transformation.\r\n *\r\n * @param {Matrix3} matrix The matrix to use.\r\n * @param {Number} scale The uniform scale that replaces the scale of the provided matrix.\r\n * @param {Matrix3} result The object onto which to store the result.\r\n * @returns {Matrix3} The modified result parameter.\r\n *\r\n * @see Matrix3.setScale\r\n * @see Matrix3.fromScale\r\n * @see Matrix3.fromUniformScale\r\n * @see Matrix3.multiplyByScale\r\n * @see Matrix3.multiplyByUniformScale\r\n * @see Matrix3.getScale\r\n */\r\nMatrix3.setUniformScale = function (matrix, scale, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  Check.typeOf.number(\"scale\", scale);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  const existingScale = Matrix3.getScale(matrix, scaleScratch2);\r\n  const scaleRatioX = scale / existingScale.x;\r\n  const scaleRatioY = scale / existingScale.y;\r\n  const scaleRatioZ = scale / existingScale.z;\r\n\r\n  result[0] = matrix[0] * scaleRatioX;\r\n  result[1] = matrix[1] * scaleRatioX;\r\n  result[2] = matrix[2] * scaleRatioX;\r\n  result[3] = matrix[3] * scaleRatioY;\r\n  result[4] = matrix[4] * scaleRatioY;\r\n  result[5] = matrix[5] * scaleRatioY;\r\n  result[6] = matrix[6] * scaleRatioZ;\r\n  result[7] = matrix[7] * scaleRatioZ;\r\n  result[8] = matrix[8] * scaleRatioZ;\r\n\r\n  return result;\r\n};\r\n\r\nconst scratchColumn = new Cartesian3();\r\n\r\n/**\r\n * Extracts the non-uniform scale assuming the matrix is an affine transformation.\r\n *\r\n * @param {Matrix3} matrix The matrix.\r\n * @param {Cartesian3} result The object onto which to store the result.\r\n * @returns {Cartesian3} The modified result parameter.\r\n *\r\n * @see Matrix3.multiplyByScale\r\n * @see Matrix3.multiplyByUniformScale\r\n * @see Matrix3.fromScale\r\n * @see Matrix3.fromUniformScale\r\n * @see Matrix3.setScale\r\n * @see Matrix3.setUniformScale\r\n */\r\nMatrix3.getScale = function (matrix, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result.x = Cartesian3.magnitude(\r\n    Cartesian3.fromElements(matrix[0], matrix[1], matrix[2], scratchColumn)\r\n  );\r\n  result.y = Cartesian3.magnitude(\r\n    Cartesian3.fromElements(matrix[3], matrix[4], matrix[5], scratchColumn)\r\n  );\r\n  result.z = Cartesian3.magnitude(\r\n    Cartesian3.fromElements(matrix[6], matrix[7], matrix[8], scratchColumn)\r\n  );\r\n  return result;\r\n};\r\n\r\nconst scaleScratch3 = new Cartesian3();\r\n\r\n/**\r\n * Computes the maximum scale assuming the matrix is an affine transformation.\r\n * The maximum scale is the maximum length of the column vectors.\r\n *\r\n * @param {Matrix3} matrix The matrix.\r\n * @returns {Number} The maximum scale.\r\n */\r\nMatrix3.getMaximumScale = function (matrix) {\r\n  Matrix3.getScale(matrix, scaleScratch3);\r\n  return Cartesian3.maximumComponent(scaleScratch3);\r\n};\r\n\r\nconst scaleScratch4 = new Cartesian3();\r\n\r\n/**\r\n * Sets the rotation assuming the matrix is an affine transformation.\r\n *\r\n * @param {Matrix3} matrix The matrix.\r\n * @param {Matrix3} rotation The rotation matrix.\r\n * @returns {Matrix3} The modified result parameter.\r\n *\r\n * @see Matrix3.getRotation\r\n */\r\nMatrix3.setRotation = function (matrix, rotation, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  const scale = Matrix3.getScale(matrix, scaleScratch4);\r\n\r\n  result[0] = rotation[0] * scale.x;\r\n  result[1] = rotation[1] * scale.x;\r\n  result[2] = rotation[2] * scale.x;\r\n  result[3] = rotation[3] * scale.y;\r\n  result[4] = rotation[4] * scale.y;\r\n  result[5] = rotation[5] * scale.y;\r\n  result[6] = rotation[6] * scale.z;\r\n  result[7] = rotation[7] * scale.z;\r\n  result[8] = rotation[8] * scale.z;\r\n\r\n  return result;\r\n};\r\n\r\nconst scaleScratch5 = new Cartesian3();\r\n\r\n/**\r\n * Extracts the rotation matrix assuming the matrix is an affine transformation.\r\n *\r\n * @param {Matrix3} matrix The matrix.\r\n * @param {Matrix3} result The object onto which to store the result.\r\n * @returns {Matrix3} The modified result parameter.\r\n *\r\n * @see Matrix3.setRotation\r\n */\r\nMatrix3.getRotation = function (matrix, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  const scale = Matrix3.getScale(matrix, scaleScratch5);\r\n\r\n  result[0] = matrix[0] / scale.x;\r\n  result[1] = matrix[1] / scale.x;\r\n  result[2] = matrix[2] / scale.x;\r\n  result[3] = matrix[3] / scale.y;\r\n  result[4] = matrix[4] / scale.y;\r\n  result[5] = matrix[5] / scale.y;\r\n  result[6] = matrix[6] / scale.z;\r\n  result[7] = matrix[7] / scale.z;\r\n  result[8] = matrix[8] / scale.z;\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the product of two matrices.\r\n *\r\n * @param {Matrix3} left The first matrix.\r\n * @param {Matrix3} right The second matrix.\r\n * @param {Matrix3} result The object onto which to store the result.\r\n * @returns {Matrix3} The modified result parameter.\r\n */\r\nMatrix3.multiply = function (left, right, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"left\", left);\r\n  Check.typeOf.object(\"right\", right);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  const column0Row0 =\r\n    left[0] * right[0] + left[3] * right[1] + left[6] * right[2];\r\n  const column0Row1 =\r\n    left[1] * right[0] + left[4] * right[1] + left[7] * right[2];\r\n  const column0Row2 =\r\n    left[2] * right[0] + left[5] * right[1] + left[8] * right[2];\r\n\r\n  const column1Row0 =\r\n    left[0] * right[3] + left[3] * right[4] + left[6] * right[5];\r\n  const column1Row1 =\r\n    left[1] * right[3] + left[4] * right[4] + left[7] * right[5];\r\n  const column1Row2 =\r\n    left[2] * right[3] + left[5] * right[4] + left[8] * right[5];\r\n\r\n  const column2Row0 =\r\n    left[0] * right[6] + left[3] * right[7] + left[6] * right[8];\r\n  const column2Row1 =\r\n    left[1] * right[6] + left[4] * right[7] + left[7] * right[8];\r\n  const column2Row2 =\r\n    left[2] * right[6] + left[5] * right[7] + left[8] * right[8];\r\n\r\n  result[0] = column0Row0;\r\n  result[1] = column0Row1;\r\n  result[2] = column0Row2;\r\n  result[3] = column1Row0;\r\n  result[4] = column1Row1;\r\n  result[5] = column1Row2;\r\n  result[6] = column2Row0;\r\n  result[7] = column2Row1;\r\n  result[8] = column2Row2;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the sum of two matrices.\r\n *\r\n * @param {Matrix3} left The first matrix.\r\n * @param {Matrix3} right The second matrix.\r\n * @param {Matrix3} result The object onto which to store the result.\r\n * @returns {Matrix3} The modified result parameter.\r\n */\r\nMatrix3.add = function (left, right, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"left\", left);\r\n  Check.typeOf.object(\"right\", right);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result[0] = left[0] + right[0];\r\n  result[1] = left[1] + right[1];\r\n  result[2] = left[2] + right[2];\r\n  result[3] = left[3] + right[3];\r\n  result[4] = left[4] + right[4];\r\n  result[5] = left[5] + right[5];\r\n  result[6] = left[6] + right[6];\r\n  result[7] = left[7] + right[7];\r\n  result[8] = left[8] + right[8];\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the difference of two matrices.\r\n *\r\n * @param {Matrix3} left The first matrix.\r\n * @param {Matrix3} right The second matrix.\r\n * @param {Matrix3} result The object onto which to store the result.\r\n * @returns {Matrix3} The modified result parameter.\r\n */\r\nMatrix3.subtract = function (left, right, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"left\", left);\r\n  Check.typeOf.object(\"right\", right);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result[0] = left[0] - right[0];\r\n  result[1] = left[1] - right[1];\r\n  result[2] = left[2] - right[2];\r\n  result[3] = left[3] - right[3];\r\n  result[4] = left[4] - right[4];\r\n  result[5] = left[5] - right[5];\r\n  result[6] = left[6] - right[6];\r\n  result[7] = left[7] - right[7];\r\n  result[8] = left[8] - right[8];\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the product of a matrix and a column vector.\r\n *\r\n * @param {Matrix3} matrix The matrix.\r\n * @param {Cartesian3} cartesian The column.\r\n * @param {Cartesian3} result The object onto which to store the result.\r\n * @returns {Cartesian3} The modified result parameter.\r\n */\r\nMatrix3.multiplyByVector = function (matrix, cartesian, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  Check.typeOf.object(\"cartesian\", cartesian);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  const vX = cartesian.x;\r\n  const vY = cartesian.y;\r\n  const vZ = cartesian.z;\r\n\r\n  const x = matrix[0] * vX + matrix[3] * vY + matrix[6] * vZ;\r\n  const y = matrix[1] * vX + matrix[4] * vY + matrix[7] * vZ;\r\n  const z = matrix[2] * vX + matrix[5] * vY + matrix[8] * vZ;\r\n\r\n  result.x = x;\r\n  result.y = y;\r\n  result.z = z;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the product of a matrix and a scalar.\r\n *\r\n * @param {Matrix3} matrix The matrix.\r\n * @param {Number} scalar The number to multiply by.\r\n * @param {Matrix3} result The object onto which to store the result.\r\n * @returns {Matrix3} The modified result parameter.\r\n */\r\nMatrix3.multiplyByScalar = function (matrix, scalar, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  Check.typeOf.number(\"scalar\", scalar);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result[0] = matrix[0] * scalar;\r\n  result[1] = matrix[1] * scalar;\r\n  result[2] = matrix[2] * scalar;\r\n  result[3] = matrix[3] * scalar;\r\n  result[4] = matrix[4] * scalar;\r\n  result[5] = matrix[5] * scalar;\r\n  result[6] = matrix[6] * scalar;\r\n  result[7] = matrix[7] * scalar;\r\n  result[8] = matrix[8] * scalar;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the product of a matrix times a (non-uniform) scale, as if the scale were a scale matrix.\r\n *\r\n * @param {Matrix3} matrix The matrix on the left-hand side.\r\n * @param {Number} scale The non-uniform scale on the right-hand side.\r\n * @param {Matrix3} result The object onto which to store the result.\r\n * @returns {Matrix3} The modified result parameter.\r\n *\r\n *\r\n * @example\r\n * // Instead of Cesium.Matrix3.multiply(m, Cesium.Matrix3.fromScale(scale), m);\r\n * Cesium.Matrix3.multiplyByScale(m, scale, m);\r\n *\r\n * @see Matrix3.multiplyByUniformScale\r\n * @see Matrix3.fromScale\r\n * @see Matrix3.fromUniformScale\r\n * @see Matrix3.setScale\r\n * @see Matrix3.setUniformScale\r\n * @see Matrix3.getScale\r\n */\r\nMatrix3.multiplyByScale = function (matrix, scale, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  Check.typeOf.object(\"scale\", scale);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result[0] = matrix[0] * scale.x;\r\n  result[1] = matrix[1] * scale.x;\r\n  result[2] = matrix[2] * scale.x;\r\n  result[3] = matrix[3] * scale.y;\r\n  result[4] = matrix[4] * scale.y;\r\n  result[5] = matrix[5] * scale.y;\r\n  result[6] = matrix[6] * scale.z;\r\n  result[7] = matrix[7] * scale.z;\r\n  result[8] = matrix[8] * scale.z;\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the product of a matrix times a uniform scale, as if the scale were a scale matrix.\r\n *\r\n * @param {Matrix3} matrix The matrix on the left-hand side.\r\n * @param {Number} scale The uniform scale on the right-hand side.\r\n * @param {Matrix3} result The object onto which to store the result.\r\n * @returns {Matrix3} The modified result parameter.\r\n *\r\n * @example\r\n * // Instead of Cesium.Matrix3.multiply(m, Cesium.Matrix3.fromUniformScale(scale), m);\r\n * Cesium.Matrix3.multiplyByUniformScale(m, scale, m);\r\n *\r\n * @see Matrix3.multiplyByScale\r\n * @see Matrix3.fromScale\r\n * @see Matrix3.fromUniformScale\r\n * @see Matrix3.setScale\r\n * @see Matrix3.setUniformScale\r\n * @see Matrix3.getScale\r\n */\r\nMatrix3.multiplyByUniformScale = function (matrix, scale, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  Check.typeOf.number(\"scale\", scale);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result[0] = matrix[0] * scale;\r\n  result[1] = matrix[1] * scale;\r\n  result[2] = matrix[2] * scale;\r\n  result[3] = matrix[3] * scale;\r\n  result[4] = matrix[4] * scale;\r\n  result[5] = matrix[5] * scale;\r\n  result[6] = matrix[6] * scale;\r\n  result[7] = matrix[7] * scale;\r\n  result[8] = matrix[8] * scale;\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Creates a negated copy of the provided matrix.\r\n *\r\n * @param {Matrix3} matrix The matrix to negate.\r\n * @param {Matrix3} result The object onto which to store the result.\r\n * @returns {Matrix3} The modified result parameter.\r\n */\r\nMatrix3.negate = function (matrix, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result[0] = -matrix[0];\r\n  result[1] = -matrix[1];\r\n  result[2] = -matrix[2];\r\n  result[3] = -matrix[3];\r\n  result[4] = -matrix[4];\r\n  result[5] = -matrix[5];\r\n  result[6] = -matrix[6];\r\n  result[7] = -matrix[7];\r\n  result[8] = -matrix[8];\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the transpose of the provided matrix.\r\n *\r\n * @param {Matrix3} matrix The matrix to transpose.\r\n * @param {Matrix3} result The object onto which to store the result.\r\n * @returns {Matrix3} The modified result parameter.\r\n */\r\nMatrix3.transpose = function (matrix, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  const column0Row0 = matrix[0];\r\n  const column0Row1 = matrix[3];\r\n  const column0Row2 = matrix[6];\r\n  const column1Row0 = matrix[1];\r\n  const column1Row1 = matrix[4];\r\n  const column1Row2 = matrix[7];\r\n  const column2Row0 = matrix[2];\r\n  const column2Row1 = matrix[5];\r\n  const column2Row2 = matrix[8];\r\n\r\n  result[0] = column0Row0;\r\n  result[1] = column0Row1;\r\n  result[2] = column0Row2;\r\n  result[3] = column1Row0;\r\n  result[4] = column1Row1;\r\n  result[5] = column1Row2;\r\n  result[6] = column2Row0;\r\n  result[7] = column2Row1;\r\n  result[8] = column2Row2;\r\n  return result;\r\n};\r\n\r\nfunction computeFrobeniusNorm(matrix) {\r\n  let norm = 0.0;\r\n  for (let i = 0; i < 9; ++i) {\r\n    const temp = matrix[i];\r\n    norm += temp * temp;\r\n  }\r\n\r\n  return Math.sqrt(norm);\r\n}\r\n\r\nconst rowVal = [1, 0, 0];\r\nconst colVal = [2, 2, 1];\r\n\r\nfunction offDiagonalFrobeniusNorm(matrix) {\r\n  // Computes the \"off-diagonal\" Frobenius norm.\r\n  // Assumes matrix is symmetric.\r\n\r\n  let norm = 0.0;\r\n  for (let i = 0; i < 3; ++i) {\r\n    const temp = matrix[Matrix3.getElementIndex(colVal[i], rowVal[i])];\r\n    norm += 2.0 * temp * temp;\r\n  }\r\n\r\n  return Math.sqrt(norm);\r\n}\r\n\r\nfunction shurDecomposition(matrix, result) {\r\n  // This routine was created based upon Matrix Computations, 3rd ed., by Golub and Van Loan,\r\n  // section 8.4.2 The 2by2 Symmetric Schur Decomposition.\r\n  //\r\n  // The routine takes a matrix, which is assumed to be symmetric, and\r\n  // finds the largest off-diagonal term, and then creates\r\n  // a matrix (result) which can be used to help reduce it\r\n\r\n  const tolerance = CesiumMath.EPSILON15;\r\n\r\n  let maxDiagonal = 0.0;\r\n  let rotAxis = 1;\r\n\r\n  // find pivot (rotAxis) based on max diagonal of matrix\r\n  for (let i = 0; i < 3; ++i) {\r\n    const temp = Math.abs(\r\n      matrix[Matrix3.getElementIndex(colVal[i], rowVal[i])]\r\n    );\r\n    if (temp > maxDiagonal) {\r\n      rotAxis = i;\r\n      maxDiagonal = temp;\r\n    }\r\n  }\r\n\r\n  let c = 1.0;\r\n  let s = 0.0;\r\n\r\n  const p = rowVal[rotAxis];\r\n  const q = colVal[rotAxis];\r\n\r\n  if (Math.abs(matrix[Matrix3.getElementIndex(q, p)]) > tolerance) {\r\n    const qq = matrix[Matrix3.getElementIndex(q, q)];\r\n    const pp = matrix[Matrix3.getElementIndex(p, p)];\r\n    const qp = matrix[Matrix3.getElementIndex(q, p)];\r\n\r\n    const tau = (qq - pp) / 2.0 / qp;\r\n    let t;\r\n\r\n    if (tau < 0.0) {\r\n      t = -1.0 / (-tau + Math.sqrt(1.0 + tau * tau));\r\n    } else {\r\n      t = 1.0 / (tau + Math.sqrt(1.0 + tau * tau));\r\n    }\r\n\r\n    c = 1.0 / Math.sqrt(1.0 + t * t);\r\n    s = t * c;\r\n  }\r\n\r\n  result = Matrix3.clone(Matrix3.IDENTITY, result);\r\n\r\n  result[Matrix3.getElementIndex(p, p)] = result[\r\n    Matrix3.getElementIndex(q, q)\r\n  ] = c;\r\n  result[Matrix3.getElementIndex(q, p)] = s;\r\n  result[Matrix3.getElementIndex(p, q)] = -s;\r\n\r\n  return result;\r\n}\r\n\r\nconst jMatrix = new Matrix3();\r\nconst jMatrixTranspose = new Matrix3();\r\n\r\n/**\r\n * Computes the eigenvectors and eigenvalues of a symmetric matrix.\r\n * <p>\r\n * Returns a diagonal matrix and unitary matrix such that:\r\n * <code>matrix = unitary matrix * diagonal matrix * transpose(unitary matrix)</code>\r\n * </p>\r\n * <p>\r\n * The values along the diagonal of the diagonal matrix are the eigenvalues. The columns\r\n * of the unitary matrix are the corresponding eigenvectors.\r\n * </p>\r\n *\r\n * @param {Matrix3} matrix The matrix to decompose into diagonal and unitary matrix. Expected to be symmetric.\r\n * @param {Object} [result] An object with unitary and diagonal properties which are matrices onto which to store the result.\r\n * @returns {Object} An object with unitary and diagonal properties which are the unitary and diagonal matrices, respectively.\r\n *\r\n * @example\r\n * const a = //... symetric matrix\r\n * const result = {\r\n *     unitary : new Cesium.Matrix3(),\r\n *     diagonal : new Cesium.Matrix3()\r\n * };\r\n * Cesium.Matrix3.computeEigenDecomposition(a, result);\r\n *\r\n * const unitaryTranspose = Cesium.Matrix3.transpose(result.unitary, new Cesium.Matrix3());\r\n * const b = Cesium.Matrix3.multiply(result.unitary, result.diagonal, new Cesium.Matrix3());\r\n * Cesium.Matrix3.multiply(b, unitaryTranspose, b); // b is now equal to a\r\n *\r\n * const lambda = Cesium.Matrix3.getColumn(result.diagonal, 0, new Cesium.Cartesian3()).x;  // first eigenvalue\r\n * const v = Cesium.Matrix3.getColumn(result.unitary, 0, new Cesium.Cartesian3());          // first eigenvector\r\n * const c = Cesium.Cartesian3.multiplyByScalar(v, lambda, new Cesium.Cartesian3());        // equal to Cesium.Matrix3.multiplyByVector(a, v)\r\n */\r\nMatrix3.computeEigenDecomposition = function (matrix, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  //>>includeEnd('debug');\r\n\r\n  // This routine was created based upon Matrix Computations, 3rd ed., by Golub and Van Loan,\r\n  // section 8.4.3 The Classical Jacobi Algorithm\r\n\r\n  const tolerance = CesiumMath.EPSILON20;\r\n  const maxSweeps = 10;\r\n\r\n  let count = 0;\r\n  let sweep = 0;\r\n\r\n  if (!defined(result)) {\r\n    result = {};\r\n  }\r\n\r\n  const unitaryMatrix = (result.unitary = Matrix3.clone(\r\n    Matrix3.IDENTITY,\r\n    result.unitary\r\n  ));\r\n  const diagMatrix = (result.diagonal = Matrix3.clone(matrix, result.diagonal));\r\n\r\n  const epsilon = tolerance * computeFrobeniusNorm(diagMatrix);\r\n\r\n  while (sweep < maxSweeps && offDiagonalFrobeniusNorm(diagMatrix) > epsilon) {\r\n    shurDecomposition(diagMatrix, jMatrix);\r\n    Matrix3.transpose(jMatrix, jMatrixTranspose);\r\n    Matrix3.multiply(diagMatrix, jMatrix, diagMatrix);\r\n    Matrix3.multiply(jMatrixTranspose, diagMatrix, diagMatrix);\r\n    Matrix3.multiply(unitaryMatrix, jMatrix, unitaryMatrix);\r\n\r\n    if (++count > 2) {\r\n      ++sweep;\r\n      count = 0;\r\n    }\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes a matrix, which contains the absolute (unsigned) values of the provided matrix's elements.\r\n *\r\n * @param {Matrix3} matrix The matrix with signed elements.\r\n * @param {Matrix3} result The object onto which to store the result.\r\n * @returns {Matrix3} The modified result parameter.\r\n */\r\nMatrix3.abs = function (matrix, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result[0] = Math.abs(matrix[0]);\r\n  result[1] = Math.abs(matrix[1]);\r\n  result[2] = Math.abs(matrix[2]);\r\n  result[3] = Math.abs(matrix[3]);\r\n  result[4] = Math.abs(matrix[4]);\r\n  result[5] = Math.abs(matrix[5]);\r\n  result[6] = Math.abs(matrix[6]);\r\n  result[7] = Math.abs(matrix[7]);\r\n  result[8] = Math.abs(matrix[8]);\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the determinant of the provided matrix.\r\n *\r\n * @param {Matrix3} matrix The matrix to use.\r\n * @returns {Number} The value of the determinant of the matrix.\r\n */\r\nMatrix3.determinant = function (matrix) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  //>>includeEnd('debug');\r\n\r\n  const m11 = matrix[0];\r\n  const m21 = matrix[3];\r\n  const m31 = matrix[6];\r\n  const m12 = matrix[1];\r\n  const m22 = matrix[4];\r\n  const m32 = matrix[7];\r\n  const m13 = matrix[2];\r\n  const m23 = matrix[5];\r\n  const m33 = matrix[8];\r\n\r\n  return (\r\n    m11 * (m22 * m33 - m23 * m32) +\r\n    m12 * (m23 * m31 - m21 * m33) +\r\n    m13 * (m21 * m32 - m22 * m31)\r\n  );\r\n};\r\n\r\n/**\r\n * Computes the inverse of the provided matrix.\r\n *\r\n * @param {Matrix3} matrix The matrix to invert.\r\n * @param {Matrix3} result The object onto which to store the result.\r\n * @returns {Matrix3} The modified result parameter.\r\n *\r\n * @exception {DeveloperError} matrix is not invertible.\r\n */\r\nMatrix3.inverse = function (matrix, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  const m11 = matrix[0];\r\n  const m21 = matrix[1];\r\n  const m31 = matrix[2];\r\n  const m12 = matrix[3];\r\n  const m22 = matrix[4];\r\n  const m32 = matrix[5];\r\n  const m13 = matrix[6];\r\n  const m23 = matrix[7];\r\n  const m33 = matrix[8];\r\n\r\n  const determinant = Matrix3.determinant(matrix);\r\n\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (Math.abs(determinant) <= CesiumMath.EPSILON15) {\r\n    throw new DeveloperError(\"matrix is not invertible\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  result[0] = m22 * m33 - m23 * m32;\r\n  result[1] = m23 * m31 - m21 * m33;\r\n  result[2] = m21 * m32 - m22 * m31;\r\n  result[3] = m13 * m32 - m12 * m33;\r\n  result[4] = m11 * m33 - m13 * m31;\r\n  result[5] = m12 * m31 - m11 * m32;\r\n  result[6] = m12 * m23 - m13 * m22;\r\n  result[7] = m13 * m21 - m11 * m23;\r\n  result[8] = m11 * m22 - m12 * m21;\r\n\r\n  const scale = 1.0 / determinant;\r\n  return Matrix3.multiplyByScalar(result, scale, result);\r\n};\r\n\r\nconst scratchTransposeMatrix = new Matrix3();\r\n\r\n/**\r\n * Computes the inverse transpose of a matrix.\r\n *\r\n * @param {Matrix3} matrix The matrix to transpose and invert.\r\n * @param {Matrix3} result The object onto which to store the result.\r\n * @returns {Matrix3} The modified result parameter.\r\n */\r\nMatrix3.inverseTranspose = function (matrix, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  return Matrix3.inverse(\r\n    Matrix3.transpose(matrix, scratchTransposeMatrix),\r\n    result\r\n  );\r\n};\r\n\r\n/**\r\n * Compares the provided matrices componentwise and returns\r\n * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n *\r\n * @param {Matrix3} [left] The first matrix.\r\n * @param {Matrix3} [right] The second matrix.\r\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\r\n */\r\nMatrix3.equals = function (left, right) {\r\n  return (\r\n    left === right ||\r\n    (defined(left) &&\r\n      defined(right) &&\r\n      left[0] === right[0] &&\r\n      left[1] === right[1] &&\r\n      left[2] === right[2] &&\r\n      left[3] === right[3] &&\r\n      left[4] === right[4] &&\r\n      left[5] === right[5] &&\r\n      left[6] === right[6] &&\r\n      left[7] === right[7] &&\r\n      left[8] === right[8])\r\n  );\r\n};\r\n\r\n/**\r\n * Compares the provided matrices componentwise and returns\r\n * <code>true</code> if they are within the provided epsilon,\r\n * <code>false</code> otherwise.\r\n *\r\n * @param {Matrix3} [left] The first matrix.\r\n * @param {Matrix3} [right] The second matrix.\r\n * @param {Number} [epsilon=0] The epsilon to use for equality testing.\r\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\r\n */\r\nMatrix3.equalsEpsilon = function (left, right, epsilon) {\r\n  epsilon = defaultValue(epsilon, 0);\r\n\r\n  return (\r\n    left === right ||\r\n    (defined(left) &&\r\n      defined(right) &&\r\n      Math.abs(left[0] - right[0]) <= epsilon &&\r\n      Math.abs(left[1] - right[1]) <= epsilon &&\r\n      Math.abs(left[2] - right[2]) <= epsilon &&\r\n      Math.abs(left[3] - right[3]) <= epsilon &&\r\n      Math.abs(left[4] - right[4]) <= epsilon &&\r\n      Math.abs(left[5] - right[5]) <= epsilon &&\r\n      Math.abs(left[6] - right[6]) <= epsilon &&\r\n      Math.abs(left[7] - right[7]) <= epsilon &&\r\n      Math.abs(left[8] - right[8]) <= epsilon)\r\n  );\r\n};\r\n\r\n/**\r\n * An immutable Matrix3 instance initialized to the identity matrix.\r\n *\r\n * @type {Matrix3}\r\n * @constant\r\n */\r\nMatrix3.IDENTITY = Object.freeze(\r\n  new Matrix3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0)\r\n);\r\n\r\n/**\r\n * An immutable Matrix3 instance initialized to the zero matrix.\r\n *\r\n * @type {Matrix3}\r\n * @constant\r\n */\r\nMatrix3.ZERO = Object.freeze(\r\n  new Matrix3(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)\r\n);\r\n\r\n/**\r\n * The index into Matrix3 for column 0, row 0.\r\n *\r\n * @type {Number}\r\n * @constant\r\n */\r\nMatrix3.COLUMN0ROW0 = 0;\r\n\r\n/**\r\n * The index into Matrix3 for column 0, row 1.\r\n *\r\n * @type {Number}\r\n * @constant\r\n */\r\nMatrix3.COLUMN0ROW1 = 1;\r\n\r\n/**\r\n * The index into Matrix3 for column 0, row 2.\r\n *\r\n * @type {Number}\r\n * @constant\r\n */\r\nMatrix3.COLUMN0ROW2 = 2;\r\n\r\n/**\r\n * The index into Matrix3 for column 1, row 0.\r\n *\r\n * @type {Number}\r\n * @constant\r\n */\r\nMatrix3.COLUMN1ROW0 = 3;\r\n\r\n/**\r\n * The index into Matrix3 for column 1, row 1.\r\n *\r\n * @type {Number}\r\n * @constant\r\n */\r\nMatrix3.COLUMN1ROW1 = 4;\r\n\r\n/**\r\n * The index into Matrix3 for column 1, row 2.\r\n *\r\n * @type {Number}\r\n * @constant\r\n */\r\nMatrix3.COLUMN1ROW2 = 5;\r\n\r\n/**\r\n * The index into Matrix3 for column 2, row 0.\r\n *\r\n * @type {Number}\r\n * @constant\r\n */\r\nMatrix3.COLUMN2ROW0 = 6;\r\n\r\n/**\r\n * The index into Matrix3 for column 2, row 1.\r\n *\r\n * @type {Number}\r\n * @constant\r\n */\r\nMatrix3.COLUMN2ROW1 = 7;\r\n\r\n/**\r\n * The index into Matrix3 for column 2, row 2.\r\n *\r\n * @type {Number}\r\n * @constant\r\n */\r\nMatrix3.COLUMN2ROW2 = 8;\r\n\r\nObject.defineProperties(Matrix3.prototype, {\r\n  /**\r\n   * Gets the number of items in the collection.\r\n   * @memberof Matrix3.prototype\r\n   *\r\n   * @type {Number}\r\n   */\r\n  length: {\r\n    get: function () {\r\n      return Matrix3.packedLength;\r\n    },\r\n  },\r\n});\r\n\r\n/**\r\n * Duplicates the provided Matrix3 instance.\r\n *\r\n * @param {Matrix3} [result] The object onto which to store the result.\r\n * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided.\r\n */\r\nMatrix3.prototype.clone = function (result) {\r\n  return Matrix3.clone(this, result);\r\n};\r\n\r\n/**\r\n * Compares this matrix to the provided matrix componentwise and returns\r\n * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n *\r\n * @param {Matrix3} [right] The right hand side matrix.\r\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\r\n */\r\nMatrix3.prototype.equals = function (right) {\r\n  return Matrix3.equals(this, right);\r\n};\r\n\r\n/**\r\n * @private\r\n */\r\nMatrix3.equalsArray = function (matrix, array, offset) {\r\n  return (\r\n    matrix[0] === array[offset] &&\r\n    matrix[1] === array[offset + 1] &&\r\n    matrix[2] === array[offset + 2] &&\r\n    matrix[3] === array[offset + 3] &&\r\n    matrix[4] === array[offset + 4] &&\r\n    matrix[5] === array[offset + 5] &&\r\n    matrix[6] === array[offset + 6] &&\r\n    matrix[7] === array[offset + 7] &&\r\n    matrix[8] === array[offset + 8]\r\n  );\r\n};\r\n\r\n/**\r\n * Compares this matrix to the provided matrix componentwise and returns\r\n * <code>true</code> if they are within the provided epsilon,\r\n * <code>false</code> otherwise.\r\n *\r\n * @param {Matrix3} [right] The right hand side matrix.\r\n * @param {Number} [epsilon=0] The epsilon to use for equality testing.\r\n * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\r\n */\r\nMatrix3.prototype.equalsEpsilon = function (right, epsilon) {\r\n  return Matrix3.equalsEpsilon(this, right, epsilon);\r\n};\r\n\r\n/**\r\n * Creates a string representing this Matrix with each row being\r\n * on a separate line and in the format '(column0, column1, column2)'.\r\n *\r\n * @returns {String} A string representing the provided Matrix with each row being on a separate line and in the format '(column0, column1, column2)'.\r\n */\r\nMatrix3.prototype.toString = function () {\r\n  return (\r\n    `(${this[0]}, ${this[3]}, ${this[6]})\\n` +\r\n    `(${this[1]}, ${this[4]}, ${this[7]})\\n` +\r\n    `(${this[2]}, ${this[5]}, ${this[8]})`\r\n  );\r\n};\r\nexport default Matrix3;\r\n","import Check from \"./Check.js\";\r\nimport defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\nimport DeveloperError from \"./DeveloperError.js\";\r\nimport CesiumMath from \"./Math.js\";\r\n\r\n/**\r\n * A 4D Cartesian point.\r\n * @alias Cartesian4\r\n * @constructor\r\n *\r\n * @param {Number} [x=0.0] The X component.\r\n * @param {Number} [y=0.0] The Y component.\r\n * @param {Number} [z=0.0] The Z component.\r\n * @param {Number} [w=0.0] The W component.\r\n *\r\n * @see Cartesian2\r\n * @see Cartesian3\r\n * @see Packable\r\n */\r\nfunction Cartesian4(x, y, z, w) {\r\n  /**\r\n   * The X component.\r\n   * @type {Number}\r\n   * @default 0.0\r\n   */\r\n  this.x = defaultValue(x, 0.0);\r\n\r\n  /**\r\n   * The Y component.\r\n   * @type {Number}\r\n   * @default 0.0\r\n   */\r\n  this.y = defaultValue(y, 0.0);\r\n\r\n  /**\r\n   * The Z component.\r\n   * @type {Number}\r\n   * @default 0.0\r\n   */\r\n  this.z = defaultValue(z, 0.0);\r\n\r\n  /**\r\n   * The W component.\r\n   * @type {Number}\r\n   * @default 0.0\r\n   */\r\n  this.w = defaultValue(w, 0.0);\r\n}\r\n\r\n/**\r\n * Creates a Cartesian4 instance from x, y, z and w coordinates.\r\n *\r\n * @param {Number} x The x coordinate.\r\n * @param {Number} y The y coordinate.\r\n * @param {Number} z The z coordinate.\r\n * @param {Number} w The w coordinate.\r\n * @param {Cartesian4} [result] The object onto which to store the result.\r\n * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.\r\n */\r\nCartesian4.fromElements = function (x, y, z, w, result) {\r\n  if (!defined(result)) {\r\n    return new Cartesian4(x, y, z, w);\r\n  }\r\n\r\n  result.x = x;\r\n  result.y = y;\r\n  result.z = z;\r\n  result.w = w;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Creates a Cartesian4 instance from a {@link Color}. <code>red</code>, <code>green</code>, <code>blue</code>,\r\n * and <code>alpha</code> map to <code>x</code>, <code>y</code>, <code>z</code>, and <code>w</code>, respectively.\r\n *\r\n * @param {Color} color The source color.\r\n * @param {Cartesian4} [result] The object onto which to store the result.\r\n * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.\r\n */\r\nCartesian4.fromColor = function (color, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"color\", color);\r\n  //>>includeEnd('debug');\r\n  if (!defined(result)) {\r\n    return new Cartesian4(color.red, color.green, color.blue, color.alpha);\r\n  }\r\n\r\n  result.x = color.red;\r\n  result.y = color.green;\r\n  result.z = color.blue;\r\n  result.w = color.alpha;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Duplicates a Cartesian4 instance.\r\n *\r\n * @param {Cartesian4} cartesian The Cartesian to duplicate.\r\n * @param {Cartesian4} [result] The object onto which to store the result.\r\n * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided. (Returns undefined if cartesian is undefined)\r\n */\r\nCartesian4.clone = function (cartesian, result) {\r\n  if (!defined(cartesian)) {\r\n    return undefined;\r\n  }\r\n\r\n  if (!defined(result)) {\r\n    return new Cartesian4(cartesian.x, cartesian.y, cartesian.z, cartesian.w);\r\n  }\r\n\r\n  result.x = cartesian.x;\r\n  result.y = cartesian.y;\r\n  result.z = cartesian.z;\r\n  result.w = cartesian.w;\r\n  return result;\r\n};\r\n\r\n/**\r\n * The number of elements used to pack the object into an array.\r\n * @type {Number}\r\n */\r\nCartesian4.packedLength = 4;\r\n\r\n/**\r\n * Stores the provided instance into the provided array.\r\n *\r\n * @param {Cartesian4} value The value to pack.\r\n * @param {Number[]} array The array to pack into.\r\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n *\r\n * @returns {Number[]} The array that was packed into\r\n */\r\nCartesian4.pack = function (value, array, startingIndex) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"value\", value);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  array[startingIndex++] = value.x;\r\n  array[startingIndex++] = value.y;\r\n  array[startingIndex++] = value.z;\r\n  array[startingIndex] = value.w;\r\n\r\n  return array;\r\n};\r\n\r\n/**\r\n * Retrieves an instance from a packed array.\r\n *\r\n * @param {Number[]} array The packed array.\r\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n * @param {Cartesian4} [result] The object into which to store the result.\r\n * @returns {Cartesian4}  The modified result parameter or a new Cartesian4 instance if one was not provided.\r\n */\r\nCartesian4.unpack = function (array, startingIndex, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  if (!defined(result)) {\r\n    result = new Cartesian4();\r\n  }\r\n  result.x = array[startingIndex++];\r\n  result.y = array[startingIndex++];\r\n  result.z = array[startingIndex++];\r\n  result.w = array[startingIndex];\r\n  return result;\r\n};\r\n\r\n/**\r\n * Flattens an array of Cartesian4s into an array of components.\r\n *\r\n * @param {Cartesian4[]} array The array of cartesians to pack.\r\n * @param {Number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 4 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 4) elements.\r\n * @returns {Number[]} The packed array.\r\n */\r\nCartesian4.packArray = function (array, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  const length = array.length;\r\n  const resultLength = length * 4;\r\n  if (!defined(result)) {\r\n    result = new Array(resultLength);\r\n  } else if (!Array.isArray(result) && result.length !== resultLength) {\r\n    //>>includeStart('debug', pragmas.debug);\r\n    throw new DeveloperError(\r\n      \"If result is a typed array, it must have exactly array.length * 4 elements\"\r\n    );\r\n    //>>includeEnd('debug');\r\n  } else if (result.length !== resultLength) {\r\n    result.length = resultLength;\r\n  }\r\n\r\n  for (let i = 0; i < length; ++i) {\r\n    Cartesian4.pack(array[i], result, i * 4);\r\n  }\r\n  return result;\r\n};\r\n\r\n/**\r\n * Unpacks an array of cartesian components into an array of Cartesian4s.\r\n *\r\n * @param {Number[]} array The array of components to unpack.\r\n * @param {Cartesian4[]} [result] The array onto which to store the result.\r\n * @returns {Cartesian4[]} The unpacked array.\r\n */\r\nCartesian4.unpackArray = function (array, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"array\", array);\r\n  Check.typeOf.number.greaterThanOrEquals(\"array.length\", array.length, 4);\r\n  if (array.length % 4 !== 0) {\r\n    throw new DeveloperError(\"array length must be a multiple of 4.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const length = array.length;\r\n  if (!defined(result)) {\r\n    result = new Array(length / 4);\r\n  } else {\r\n    result.length = length / 4;\r\n  }\r\n\r\n  for (let i = 0; i < length; i += 4) {\r\n    const index = i / 4;\r\n    result[index] = Cartesian4.unpack(array, i, result[index]);\r\n  }\r\n  return result;\r\n};\r\n\r\n/**\r\n * Creates a Cartesian4 from four consecutive elements in an array.\r\n * @function\r\n *\r\n * @param {Number[]} array The array whose four consecutive elements correspond to the x, y, z, and w components, respectively.\r\n * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.\r\n * @param {Cartesian4} [result] The object onto which to store the result.\r\n * @returns {Cartesian4}  The modified result parameter or a new Cartesian4 instance if one was not provided.\r\n *\r\n * @example\r\n * // Create a Cartesian4 with (1.0, 2.0, 3.0, 4.0)\r\n * const v = [1.0, 2.0, 3.0, 4.0];\r\n * const p = Cesium.Cartesian4.fromArray(v);\r\n *\r\n * // Create a Cartesian4 with (1.0, 2.0, 3.0, 4.0) using an offset into an array\r\n * const v2 = [0.0, 0.0, 1.0, 2.0, 3.0, 4.0];\r\n * const p2 = Cesium.Cartesian4.fromArray(v2, 2);\r\n */\r\nCartesian4.fromArray = Cartesian4.unpack;\r\n\r\n/**\r\n * Computes the value of the maximum component for the supplied Cartesian.\r\n *\r\n * @param {Cartesian4} cartesian The cartesian to use.\r\n * @returns {Number} The value of the maximum component.\r\n */\r\nCartesian4.maximumComponent = function (cartesian) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"cartesian\", cartesian);\r\n  //>>includeEnd('debug');\r\n\r\n  return Math.max(cartesian.x, cartesian.y, cartesian.z, cartesian.w);\r\n};\r\n\r\n/**\r\n * Computes the value of the minimum component for the supplied Cartesian.\r\n *\r\n * @param {Cartesian4} cartesian The cartesian to use.\r\n * @returns {Number} The value of the minimum component.\r\n */\r\nCartesian4.minimumComponent = function (cartesian) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"cartesian\", cartesian);\r\n  //>>includeEnd('debug');\r\n\r\n  return Math.min(cartesian.x, cartesian.y, cartesian.z, cartesian.w);\r\n};\r\n\r\n/**\r\n * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.\r\n *\r\n * @param {Cartesian4} first A cartesian to compare.\r\n * @param {Cartesian4} second A cartesian to compare.\r\n * @param {Cartesian4} result The object into which to store the result.\r\n * @returns {Cartesian4} A cartesian with the minimum components.\r\n */\r\nCartesian4.minimumByComponent = function (first, second, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"first\", first);\r\n  Check.typeOf.object(\"second\", second);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result.x = Math.min(first.x, second.x);\r\n  result.y = Math.min(first.y, second.y);\r\n  result.z = Math.min(first.z, second.z);\r\n  result.w = Math.min(first.w, second.w);\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.\r\n *\r\n * @param {Cartesian4} first A cartesian to compare.\r\n * @param {Cartesian4} second A cartesian to compare.\r\n * @param {Cartesian4} result The object into which to store the result.\r\n * @returns {Cartesian4} A cartesian with the maximum components.\r\n */\r\nCartesian4.maximumByComponent = function (first, second, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"first\", first);\r\n  Check.typeOf.object(\"second\", second);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result.x = Math.max(first.x, second.x);\r\n  result.y = Math.max(first.y, second.y);\r\n  result.z = Math.max(first.z, second.z);\r\n  result.w = Math.max(first.w, second.w);\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Constrain a value to lie between two values.\r\n *\r\n * @param {Cartesian4} value The value to clamp.\r\n * @param {Cartesian4} min The minimum bound.\r\n * @param {Cartesian4} max The maximum bound.\r\n * @param {Cartesian4} result The object into which to store the result.\r\n * @returns {Cartesian4} The clamped value such that min <= result <= max.\r\n */\r\nCartesian4.clamp = function (value, min, max, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"value\", value);\r\n  Check.typeOf.object(\"min\", min);\r\n  Check.typeOf.object(\"max\", max);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  const x = CesiumMath.clamp(value.x, min.x, max.x);\r\n  const y = CesiumMath.clamp(value.y, min.y, max.y);\r\n  const z = CesiumMath.clamp(value.z, min.z, max.z);\r\n  const w = CesiumMath.clamp(value.w, min.w, max.w);\r\n\r\n  result.x = x;\r\n  result.y = y;\r\n  result.z = z;\r\n  result.w = w;\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the provided Cartesian's squared magnitude.\r\n *\r\n * @param {Cartesian4} cartesian The Cartesian instance whose squared magnitude is to be computed.\r\n * @returns {Number} The squared magnitude.\r\n */\r\nCartesian4.magnitudeSquared = function (cartesian) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"cartesian\", cartesian);\r\n  //>>includeEnd('debug');\r\n\r\n  return (\r\n    cartesian.x * cartesian.x +\r\n    cartesian.y * cartesian.y +\r\n    cartesian.z * cartesian.z +\r\n    cartesian.w * cartesian.w\r\n  );\r\n};\r\n\r\n/**\r\n * Computes the Cartesian's magnitude (length).\r\n *\r\n * @param {Cartesian4} cartesian The Cartesian instance whose magnitude is to be computed.\r\n * @returns {Number} The magnitude.\r\n */\r\nCartesian4.magnitude = function (cartesian) {\r\n  return Math.sqrt(Cartesian4.magnitudeSquared(cartesian));\r\n};\r\n\r\nconst distanceScratch = new Cartesian4();\r\n\r\n/**\r\n * Computes the 4-space distance between two points.\r\n *\r\n * @param {Cartesian4} left The first point to compute the distance from.\r\n * @param {Cartesian4} right The second point to compute the distance to.\r\n * @returns {Number} The distance between two points.\r\n *\r\n * @example\r\n * // Returns 1.0\r\n * const d = Cesium.Cartesian4.distance(\r\n *   new Cesium.Cartesian4(1.0, 0.0, 0.0, 0.0),\r\n *   new Cesium.Cartesian4(2.0, 0.0, 0.0, 0.0));\r\n */\r\nCartesian4.distance = function (left, right) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"left\", left);\r\n  Check.typeOf.object(\"right\", right);\r\n  //>>includeEnd('debug');\r\n\r\n  Cartesian4.subtract(left, right, distanceScratch);\r\n  return Cartesian4.magnitude(distanceScratch);\r\n};\r\n\r\n/**\r\n * Computes the squared distance between two points.  Comparing squared distances\r\n * using this function is more efficient than comparing distances using {@link Cartesian4#distance}.\r\n *\r\n * @param {Cartesian4} left The first point to compute the distance from.\r\n * @param {Cartesian4} right The second point to compute the distance to.\r\n * @returns {Number} The distance between two points.\r\n *\r\n * @example\r\n * // Returns 4.0, not 2.0\r\n * const d = Cesium.Cartesian4.distance(\r\n *   new Cesium.Cartesian4(1.0, 0.0, 0.0, 0.0),\r\n *   new Cesium.Cartesian4(3.0, 0.0, 0.0, 0.0));\r\n */\r\nCartesian4.distanceSquared = function (left, right) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"left\", left);\r\n  Check.typeOf.object(\"right\", right);\r\n  //>>includeEnd('debug');\r\n\r\n  Cartesian4.subtract(left, right, distanceScratch);\r\n  return Cartesian4.magnitudeSquared(distanceScratch);\r\n};\r\n\r\n/**\r\n * Computes the normalized form of the supplied Cartesian.\r\n *\r\n * @param {Cartesian4} cartesian The Cartesian to be normalized.\r\n * @param {Cartesian4} result The object onto which to store the result.\r\n * @returns {Cartesian4} The modified result parameter.\r\n */\r\nCartesian4.normalize = function (cartesian, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"cartesian\", cartesian);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  const magnitude = Cartesian4.magnitude(cartesian);\r\n\r\n  result.x = cartesian.x / magnitude;\r\n  result.y = cartesian.y / magnitude;\r\n  result.z = cartesian.z / magnitude;\r\n  result.w = cartesian.w / magnitude;\r\n\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (\r\n    isNaN(result.x) ||\r\n    isNaN(result.y) ||\r\n    isNaN(result.z) ||\r\n    isNaN(result.w)\r\n  ) {\r\n    throw new DeveloperError(\"normalized result is not a number\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the dot (scalar) product of two Cartesians.\r\n *\r\n * @param {Cartesian4} left The first Cartesian.\r\n * @param {Cartesian4} right The second Cartesian.\r\n * @returns {Number} The dot product.\r\n */\r\nCartesian4.dot = function (left, right) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"left\", left);\r\n  Check.typeOf.object(\"right\", right);\r\n  //>>includeEnd('debug');\r\n\r\n  return (\r\n    left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w\r\n  );\r\n};\r\n\r\n/**\r\n * Computes the componentwise product of two Cartesians.\r\n *\r\n * @param {Cartesian4} left The first Cartesian.\r\n * @param {Cartesian4} right The second Cartesian.\r\n * @param {Cartesian4} result The object onto which to store the result.\r\n * @returns {Cartesian4} The modified result parameter.\r\n */\r\nCartesian4.multiplyComponents = function (left, right, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"left\", left);\r\n  Check.typeOf.object(\"right\", right);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result.x = left.x * right.x;\r\n  result.y = left.y * right.y;\r\n  result.z = left.z * right.z;\r\n  result.w = left.w * right.w;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the componentwise quotient of two Cartesians.\r\n *\r\n * @param {Cartesian4} left The first Cartesian.\r\n * @param {Cartesian4} right The second Cartesian.\r\n * @param {Cartesian4} result The object onto which to store the result.\r\n * @returns {Cartesian4} The modified result parameter.\r\n */\r\nCartesian4.divideComponents = function (left, right, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"left\", left);\r\n  Check.typeOf.object(\"right\", right);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result.x = left.x / right.x;\r\n  result.y = left.y / right.y;\r\n  result.z = left.z / right.z;\r\n  result.w = left.w / right.w;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the componentwise sum of two Cartesians.\r\n *\r\n * @param {Cartesian4} left The first Cartesian.\r\n * @param {Cartesian4} right The second Cartesian.\r\n * @param {Cartesian4} result The object onto which to store the result.\r\n * @returns {Cartesian4} The modified result parameter.\r\n */\r\nCartesian4.add = function (left, right, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"left\", left);\r\n  Check.typeOf.object(\"right\", right);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result.x = left.x + right.x;\r\n  result.y = left.y + right.y;\r\n  result.z = left.z + right.z;\r\n  result.w = left.w + right.w;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the componentwise difference of two Cartesians.\r\n *\r\n * @param {Cartesian4} left The first Cartesian.\r\n * @param {Cartesian4} right The second Cartesian.\r\n * @param {Cartesian4} result The object onto which to store the result.\r\n * @returns {Cartesian4} The modified result parameter.\r\n */\r\nCartesian4.subtract = function (left, right, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"left\", left);\r\n  Check.typeOf.object(\"right\", right);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result.x = left.x - right.x;\r\n  result.y = left.y - right.y;\r\n  result.z = left.z - right.z;\r\n  result.w = left.w - right.w;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Multiplies the provided Cartesian componentwise by the provided scalar.\r\n *\r\n * @param {Cartesian4} cartesian The Cartesian to be scaled.\r\n * @param {Number} scalar The scalar to multiply with.\r\n * @param {Cartesian4} result The object onto which to store the result.\r\n * @returns {Cartesian4} The modified result parameter.\r\n */\r\nCartesian4.multiplyByScalar = function (cartesian, scalar, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"cartesian\", cartesian);\r\n  Check.typeOf.number(\"scalar\", scalar);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result.x = cartesian.x * scalar;\r\n  result.y = cartesian.y * scalar;\r\n  result.z = cartesian.z * scalar;\r\n  result.w = cartesian.w * scalar;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Divides the provided Cartesian componentwise by the provided scalar.\r\n *\r\n * @param {Cartesian4} cartesian The Cartesian to be divided.\r\n * @param {Number} scalar The scalar to divide by.\r\n * @param {Cartesian4} result The object onto which to store the result.\r\n * @returns {Cartesian4} The modified result parameter.\r\n */\r\nCartesian4.divideByScalar = function (cartesian, scalar, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"cartesian\", cartesian);\r\n  Check.typeOf.number(\"scalar\", scalar);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result.x = cartesian.x / scalar;\r\n  result.y = cartesian.y / scalar;\r\n  result.z = cartesian.z / scalar;\r\n  result.w = cartesian.w / scalar;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Negates the provided Cartesian.\r\n *\r\n * @param {Cartesian4} cartesian The Cartesian to be negated.\r\n * @param {Cartesian4} result The object onto which to store the result.\r\n * @returns {Cartesian4} The modified result parameter.\r\n */\r\nCartesian4.negate = function (cartesian, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"cartesian\", cartesian);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result.x = -cartesian.x;\r\n  result.y = -cartesian.y;\r\n  result.z = -cartesian.z;\r\n  result.w = -cartesian.w;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the absolute value of the provided Cartesian.\r\n *\r\n * @param {Cartesian4} cartesian The Cartesian whose absolute value is to be computed.\r\n * @param {Cartesian4} result The object onto which to store the result.\r\n * @returns {Cartesian4} The modified result parameter.\r\n */\r\nCartesian4.abs = function (cartesian, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"cartesian\", cartesian);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result.x = Math.abs(cartesian.x);\r\n  result.y = Math.abs(cartesian.y);\r\n  result.z = Math.abs(cartesian.z);\r\n  result.w = Math.abs(cartesian.w);\r\n  return result;\r\n};\r\n\r\nconst lerpScratch = new Cartesian4();\r\n/**\r\n * Computes the linear interpolation or extrapolation at t using the provided cartesians.\r\n *\r\n * @param {Cartesian4} start The value corresponding to t at 0.0.\r\n * @param {Cartesian4}end The value corresponding to t at 1.0.\r\n * @param {Number} t The point along t at which to interpolate.\r\n * @param {Cartesian4} result The object onto which to store the result.\r\n * @returns {Cartesian4} The modified result parameter.\r\n */\r\nCartesian4.lerp = function (start, end, t, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"start\", start);\r\n  Check.typeOf.object(\"end\", end);\r\n  Check.typeOf.number(\"t\", t);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  Cartesian4.multiplyByScalar(end, t, lerpScratch);\r\n  result = Cartesian4.multiplyByScalar(start, 1.0 - t, result);\r\n  return Cartesian4.add(lerpScratch, result, result);\r\n};\r\n\r\nconst mostOrthogonalAxisScratch = new Cartesian4();\r\n/**\r\n * Returns the axis that is most orthogonal to the provided Cartesian.\r\n *\r\n * @param {Cartesian4} cartesian The Cartesian on which to find the most orthogonal axis.\r\n * @param {Cartesian4} result The object onto which to store the result.\r\n * @returns {Cartesian4} The most orthogonal axis.\r\n */\r\nCartesian4.mostOrthogonalAxis = function (cartesian, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"cartesian\", cartesian);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  const f = Cartesian4.normalize(cartesian, mostOrthogonalAxisScratch);\r\n  Cartesian4.abs(f, f);\r\n\r\n  if (f.x <= f.y) {\r\n    if (f.x <= f.z) {\r\n      if (f.x <= f.w) {\r\n        result = Cartesian4.clone(Cartesian4.UNIT_X, result);\r\n      } else {\r\n        result = Cartesian4.clone(Cartesian4.UNIT_W, result);\r\n      }\r\n    } else if (f.z <= f.w) {\r\n      result = Cartesian4.clone(Cartesian4.UNIT_Z, result);\r\n    } else {\r\n      result = Cartesian4.clone(Cartesian4.UNIT_W, result);\r\n    }\r\n  } else if (f.y <= f.z) {\r\n    if (f.y <= f.w) {\r\n      result = Cartesian4.clone(Cartesian4.UNIT_Y, result);\r\n    } else {\r\n      result = Cartesian4.clone(Cartesian4.UNIT_W, result);\r\n    }\r\n  } else if (f.z <= f.w) {\r\n    result = Cartesian4.clone(Cartesian4.UNIT_Z, result);\r\n  } else {\r\n    result = Cartesian4.clone(Cartesian4.UNIT_W, result);\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Compares the provided Cartesians componentwise and returns\r\n * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n *\r\n * @param {Cartesian4} [left] The first Cartesian.\r\n * @param {Cartesian4} [right] The second Cartesian.\r\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\r\n */\r\nCartesian4.equals = function (left, right) {\r\n  return (\r\n    left === right ||\r\n    (defined(left) &&\r\n      defined(right) &&\r\n      left.x === right.x &&\r\n      left.y === right.y &&\r\n      left.z === right.z &&\r\n      left.w === right.w)\r\n  );\r\n};\r\n\r\n/**\r\n * @private\r\n */\r\nCartesian4.equalsArray = function (cartesian, array, offset) {\r\n  return (\r\n    cartesian.x === array[offset] &&\r\n    cartesian.y === array[offset + 1] &&\r\n    cartesian.z === array[offset + 2] &&\r\n    cartesian.w === array[offset + 3]\r\n  );\r\n};\r\n\r\n/**\r\n * Compares the provided Cartesians componentwise and returns\r\n * <code>true</code> if they pass an absolute or relative tolerance test,\r\n * <code>false</code> otherwise.\r\n *\r\n * @param {Cartesian4} [left] The first Cartesian.\r\n * @param {Cartesian4} [right] The second Cartesian.\r\n * @param {Number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\r\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\r\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\r\n */\r\nCartesian4.equalsEpsilon = function (\r\n  left,\r\n  right,\r\n  relativeEpsilon,\r\n  absoluteEpsilon\r\n) {\r\n  return (\r\n    left === right ||\r\n    (defined(left) &&\r\n      defined(right) &&\r\n      CesiumMath.equalsEpsilon(\r\n        left.x,\r\n        right.x,\r\n        relativeEpsilon,\r\n        absoluteEpsilon\r\n      ) &&\r\n      CesiumMath.equalsEpsilon(\r\n        left.y,\r\n        right.y,\r\n        relativeEpsilon,\r\n        absoluteEpsilon\r\n      ) &&\r\n      CesiumMath.equalsEpsilon(\r\n        left.z,\r\n        right.z,\r\n        relativeEpsilon,\r\n        absoluteEpsilon\r\n      ) &&\r\n      CesiumMath.equalsEpsilon(\r\n        left.w,\r\n        right.w,\r\n        relativeEpsilon,\r\n        absoluteEpsilon\r\n      ))\r\n  );\r\n};\r\n\r\n/**\r\n * An immutable Cartesian4 instance initialized to (0.0, 0.0, 0.0, 0.0).\r\n *\r\n * @type {Cartesian4}\r\n * @constant\r\n */\r\nCartesian4.ZERO = Object.freeze(new Cartesian4(0.0, 0.0, 0.0, 0.0));\r\n\r\n/**\r\n * An immutable Cartesian4 instance initialized to (1.0, 1.0, 1.0, 1.0).\r\n *\r\n * @type {Cartesian4}\r\n * @constant\r\n */\r\nCartesian4.ONE = Object.freeze(new Cartesian4(1.0, 1.0, 1.0, 1.0));\r\n\r\n/**\r\n * An immutable Cartesian4 instance initialized to (1.0, 0.0, 0.0, 0.0).\r\n *\r\n * @type {Cartesian4}\r\n * @constant\r\n */\r\nCartesian4.UNIT_X = Object.freeze(new Cartesian4(1.0, 0.0, 0.0, 0.0));\r\n\r\n/**\r\n * An immutable Cartesian4 instance initialized to (0.0, 1.0, 0.0, 0.0).\r\n *\r\n * @type {Cartesian4}\r\n * @constant\r\n */\r\nCartesian4.UNIT_Y = Object.freeze(new Cartesian4(0.0, 1.0, 0.0, 0.0));\r\n\r\n/**\r\n * An immutable Cartesian4 instance initialized to (0.0, 0.0, 1.0, 0.0).\r\n *\r\n * @type {Cartesian4}\r\n * @constant\r\n */\r\nCartesian4.UNIT_Z = Object.freeze(new Cartesian4(0.0, 0.0, 1.0, 0.0));\r\n\r\n/**\r\n * An immutable Cartesian4 instance initialized to (0.0, 0.0, 0.0, 1.0).\r\n *\r\n * @type {Cartesian4}\r\n * @constant\r\n */\r\nCartesian4.UNIT_W = Object.freeze(new Cartesian4(0.0, 0.0, 0.0, 1.0));\r\n\r\n/**\r\n * Duplicates this Cartesian4 instance.\r\n *\r\n * @param {Cartesian4} [result] The object onto which to store the result.\r\n * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.\r\n */\r\nCartesian4.prototype.clone = function (result) {\r\n  return Cartesian4.clone(this, result);\r\n};\r\n\r\n/**\r\n * Compares this Cartesian against the provided Cartesian componentwise and returns\r\n * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n *\r\n * @param {Cartesian4} [right] The right hand side Cartesian.\r\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\r\n */\r\nCartesian4.prototype.equals = function (right) {\r\n  return Cartesian4.equals(this, right);\r\n};\r\n\r\n/**\r\n * Compares this Cartesian against the provided Cartesian componentwise and returns\r\n * <code>true</code> if they pass an absolute or relative tolerance test,\r\n * <code>false</code> otherwise.\r\n *\r\n * @param {Cartesian4} [right] The right hand side Cartesian.\r\n * @param {Number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\r\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\r\n * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\r\n */\r\nCartesian4.prototype.equalsEpsilon = function (\r\n  right,\r\n  relativeEpsilon,\r\n  absoluteEpsilon\r\n) {\r\n  return Cartesian4.equalsEpsilon(\r\n    this,\r\n    right,\r\n    relativeEpsilon,\r\n    absoluteEpsilon\r\n  );\r\n};\r\n\r\n/**\r\n * Creates a string representing this Cartesian in the format '(x, y, z, w)'.\r\n *\r\n * @returns {String} A string representing the provided Cartesian in the format '(x, y, z, w)'.\r\n */\r\nCartesian4.prototype.toString = function () {\r\n  return `(${this.x}, ${this.y}, ${this.z}, ${this.w})`;\r\n};\r\n\r\n// scratchU8Array and scratchF32Array are views into the same buffer\r\nconst scratchF32Array = new Float32Array(1);\r\nconst scratchU8Array = new Uint8Array(scratchF32Array.buffer);\r\n\r\nconst testU32 = new Uint32Array([0x11223344]);\r\nconst testU8 = new Uint8Array(testU32.buffer);\r\nconst littleEndian = testU8[0] === 0x44;\r\n\r\n/**\r\n * Packs an arbitrary floating point value to 4 values representable using uint8.\r\n *\r\n * @param {Number} value A floating point number.\r\n * @param {Cartesian4} [result] The Cartesian4 that will contain the packed float.\r\n * @returns {Cartesian4} A Cartesian4 representing the float packed to values in x, y, z, and w.\r\n */\r\nCartesian4.packFloat = function (value, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.number(\"value\", value);\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    result = new Cartesian4();\r\n  }\r\n\r\n  // scratchU8Array and scratchF32Array are views into the same buffer\r\n  scratchF32Array[0] = value;\r\n\r\n  if (littleEndian) {\r\n    result.x = scratchU8Array[0];\r\n    result.y = scratchU8Array[1];\r\n    result.z = scratchU8Array[2];\r\n    result.w = scratchU8Array[3];\r\n  } else {\r\n    // convert from big-endian to little-endian\r\n    result.x = scratchU8Array[3];\r\n    result.y = scratchU8Array[2];\r\n    result.z = scratchU8Array[1];\r\n    result.w = scratchU8Array[0];\r\n  }\r\n  return result;\r\n};\r\n\r\n/**\r\n * Unpacks a float packed using Cartesian4.packFloat.\r\n *\r\n * @param {Cartesian4} packedFloat A Cartesian4 containing a float packed to 4 values representable using uint8.\r\n * @returns {Number} The unpacked float.\r\n * @private\r\n */\r\nCartesian4.unpackFloat = function (packedFloat) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"packedFloat\", packedFloat);\r\n  //>>includeEnd('debug');\r\n\r\n  // scratchU8Array and scratchF32Array are views into the same buffer\r\n  if (littleEndian) {\r\n    scratchU8Array[0] = packedFloat.x;\r\n    scratchU8Array[1] = packedFloat.y;\r\n    scratchU8Array[2] = packedFloat.z;\r\n    scratchU8Array[3] = packedFloat.w;\r\n  } else {\r\n    // convert from little-endian to big-endian\r\n    scratchU8Array[0] = packedFloat.w;\r\n    scratchU8Array[1] = packedFloat.z;\r\n    scratchU8Array[2] = packedFloat.y;\r\n    scratchU8Array[3] = packedFloat.x;\r\n  }\r\n  return scratchF32Array[0];\r\n};\r\nexport default Cartesian4;\r\n","import Cartesian3 from \"./Cartesian3.js\";\r\nimport Cartesian4 from \"./Cartesian4.js\";\r\nimport Check from \"./Check.js\";\r\nimport defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\nimport DeveloperError from \"./DeveloperError.js\";\r\nimport CesiumMath from \"./Math.js\";\r\nimport Matrix3 from \"./Matrix3.js\";\r\nimport RuntimeError from \"./RuntimeError.js\";\r\n\r\n/**\r\n * A 4x4 matrix, indexable as a column-major order array.\r\n * Constructor parameters are in row-major order for code readability.\r\n * @alias Matrix4\r\n * @constructor\r\n * @implements {ArrayLike<number>}\r\n *\r\n * @param {Number} [column0Row0=0.0] The value for column 0, row 0.\r\n * @param {Number} [column1Row0=0.0] The value for column 1, row 0.\r\n * @param {Number} [column2Row0=0.0] The value for column 2, row 0.\r\n * @param {Number} [column3Row0=0.0] The value for column 3, row 0.\r\n * @param {Number} [column0Row1=0.0] The value for column 0, row 1.\r\n * @param {Number} [column1Row1=0.0] The value for column 1, row 1.\r\n * @param {Number} [column2Row1=0.0] The value for column 2, row 1.\r\n * @param {Number} [column3Row1=0.0] The value for column 3, row 1.\r\n * @param {Number} [column0Row2=0.0] The value for column 0, row 2.\r\n * @param {Number} [column1Row2=0.0] The value for column 1, row 2.\r\n * @param {Number} [column2Row2=0.0] The value for column 2, row 2.\r\n * @param {Number} [column3Row2=0.0] The value for column 3, row 2.\r\n * @param {Number} [column0Row3=0.0] The value for column 0, row 3.\r\n * @param {Number} [column1Row3=0.0] The value for column 1, row 3.\r\n * @param {Number} [column2Row3=0.0] The value for column 2, row 3.\r\n * @param {Number} [column3Row3=0.0] The value for column 3, row 3.\r\n *\r\n * @see Matrix4.fromArray\r\n * @see Matrix4.fromColumnMajorArray\r\n * @see Matrix4.fromRowMajorArray\r\n * @see Matrix4.fromRotationTranslation\r\n * @see Matrix4.fromTranslationQuaternionRotationScale\r\n * @see Matrix4.fromTranslationRotationScale\r\n * @see Matrix4.fromTranslation\r\n * @see Matrix4.fromScale\r\n * @see Matrix4.fromUniformScale\r\n * @see Matrix4.fromRotation\r\n * @see Matrix4.fromCamera\r\n * @see Matrix4.computePerspectiveFieldOfView\r\n * @see Matrix4.computeOrthographicOffCenter\r\n * @see Matrix4.computePerspectiveOffCenter\r\n * @see Matrix4.computeInfinitePerspectiveOffCenter\r\n * @see Matrix4.computeViewportTransformation\r\n * @see Matrix4.computeView\r\n * @see Matrix2\r\n * @see Matrix3\r\n * @see Packable\r\n */\r\nfunction Matrix4(\r\n  column0Row0,\r\n  column1Row0,\r\n  column2Row0,\r\n  column3Row0,\r\n  column0Row1,\r\n  column1Row1,\r\n  column2Row1,\r\n  column3Row1,\r\n  column0Row2,\r\n  column1Row2,\r\n  column2Row2,\r\n  column3Row2,\r\n  column0Row3,\r\n  column1Row3,\r\n  column2Row3,\r\n  column3Row3\r\n) {\r\n  this[0] = defaultValue(column0Row0, 0.0);\r\n  this[1] = defaultValue(column0Row1, 0.0);\r\n  this[2] = defaultValue(column0Row2, 0.0);\r\n  this[3] = defaultValue(column0Row3, 0.0);\r\n  this[4] = defaultValue(column1Row0, 0.0);\r\n  this[5] = defaultValue(column1Row1, 0.0);\r\n  this[6] = defaultValue(column1Row2, 0.0);\r\n  this[7] = defaultValue(column1Row3, 0.0);\r\n  this[8] = defaultValue(column2Row0, 0.0);\r\n  this[9] = defaultValue(column2Row1, 0.0);\r\n  this[10] = defaultValue(column2Row2, 0.0);\r\n  this[11] = defaultValue(column2Row3, 0.0);\r\n  this[12] = defaultValue(column3Row0, 0.0);\r\n  this[13] = defaultValue(column3Row1, 0.0);\r\n  this[14] = defaultValue(column3Row2, 0.0);\r\n  this[15] = defaultValue(column3Row3, 0.0);\r\n}\r\n\r\n/**\r\n * The number of elements used to pack the object into an array.\r\n * @type {Number}\r\n */\r\nMatrix4.packedLength = 16;\r\n\r\n/**\r\n * Stores the provided instance into the provided array.\r\n *\r\n * @param {Matrix4} value The value to pack.\r\n * @param {Number[]} array The array to pack into.\r\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n *\r\n * @returns {Number[]} The array that was packed into\r\n */\r\nMatrix4.pack = function (value, array, startingIndex) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"value\", value);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  array[startingIndex++] = value[0];\r\n  array[startingIndex++] = value[1];\r\n  array[startingIndex++] = value[2];\r\n  array[startingIndex++] = value[3];\r\n  array[startingIndex++] = value[4];\r\n  array[startingIndex++] = value[5];\r\n  array[startingIndex++] = value[6];\r\n  array[startingIndex++] = value[7];\r\n  array[startingIndex++] = value[8];\r\n  array[startingIndex++] = value[9];\r\n  array[startingIndex++] = value[10];\r\n  array[startingIndex++] = value[11];\r\n  array[startingIndex++] = value[12];\r\n  array[startingIndex++] = value[13];\r\n  array[startingIndex++] = value[14];\r\n  array[startingIndex] = value[15];\r\n\r\n  return array;\r\n};\r\n\r\n/**\r\n * Retrieves an instance from a packed array.\r\n *\r\n * @param {Number[]} array The packed array.\r\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n * @param {Matrix4} [result] The object into which to store the result.\r\n * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if one was not provided.\r\n */\r\nMatrix4.unpack = function (array, startingIndex, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  if (!defined(result)) {\r\n    result = new Matrix4();\r\n  }\r\n\r\n  result[0] = array[startingIndex++];\r\n  result[1] = array[startingIndex++];\r\n  result[2] = array[startingIndex++];\r\n  result[3] = array[startingIndex++];\r\n  result[4] = array[startingIndex++];\r\n  result[5] = array[startingIndex++];\r\n  result[6] = array[startingIndex++];\r\n  result[7] = array[startingIndex++];\r\n  result[8] = array[startingIndex++];\r\n  result[9] = array[startingIndex++];\r\n  result[10] = array[startingIndex++];\r\n  result[11] = array[startingIndex++];\r\n  result[12] = array[startingIndex++];\r\n  result[13] = array[startingIndex++];\r\n  result[14] = array[startingIndex++];\r\n  result[15] = array[startingIndex];\r\n  return result;\r\n};\r\n\r\n/**\r\n * Flattens an array of Matrix4s into an array of components. The components\r\n * are stored in column-major order.\r\n *\r\n * @param {Matrix4[]} array The array of matrices to pack.\r\n * @param {Number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 16 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 16) elements.\r\n * @returns {Number[]} The packed array.\r\n */\r\nMatrix4.packArray = function (array, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  const length = array.length;\r\n  const resultLength = length * 16;\r\n  if (!defined(result)) {\r\n    result = new Array(resultLength);\r\n  } else if (!Array.isArray(result) && result.length !== resultLength) {\r\n    //>>includeStart('debug', pragmas.debug);\r\n    throw new DeveloperError(\r\n      \"If result is a typed array, it must have exactly array.length * 16 elements\"\r\n    );\r\n    //>>includeEnd('debug');\r\n  } else if (result.length !== resultLength) {\r\n    result.length = resultLength;\r\n  }\r\n\r\n  for (let i = 0; i < length; ++i) {\r\n    Matrix4.pack(array[i], result, i * 16);\r\n  }\r\n  return result;\r\n};\r\n\r\n/**\r\n * Unpacks an array of column-major matrix components into an array of Matrix4s.\r\n *\r\n * @param {Number[]} array The array of components to unpack.\r\n * @param {Matrix4[]} [result] The array onto which to store the result.\r\n * @returns {Matrix4[]} The unpacked array.\r\n */\r\nMatrix4.unpackArray = function (array, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"array\", array);\r\n  Check.typeOf.number.greaterThanOrEquals(\"array.length\", array.length, 16);\r\n  if (array.length % 16 !== 0) {\r\n    throw new DeveloperError(\"array length must be a multiple of 16.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const length = array.length;\r\n  if (!defined(result)) {\r\n    result = new Array(length / 16);\r\n  } else {\r\n    result.length = length / 16;\r\n  }\r\n\r\n  for (let i = 0; i < length; i += 16) {\r\n    const index = i / 16;\r\n    result[index] = Matrix4.unpack(array, i, result[index]);\r\n  }\r\n  return result;\r\n};\r\n\r\n/**\r\n * Duplicates a Matrix4 instance.\r\n *\r\n * @param {Matrix4} matrix The matrix to duplicate.\r\n * @param {Matrix4} [result] The object onto which to store the result.\r\n * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if one was not provided. (Returns undefined if matrix is undefined)\r\n */\r\nMatrix4.clone = function (matrix, result) {\r\n  if (!defined(matrix)) {\r\n    return undefined;\r\n  }\r\n  if (!defined(result)) {\r\n    return new Matrix4(\r\n      matrix[0],\r\n      matrix[4],\r\n      matrix[8],\r\n      matrix[12],\r\n      matrix[1],\r\n      matrix[5],\r\n      matrix[9],\r\n      matrix[13],\r\n      matrix[2],\r\n      matrix[6],\r\n      matrix[10],\r\n      matrix[14],\r\n      matrix[3],\r\n      matrix[7],\r\n      matrix[11],\r\n      matrix[15]\r\n    );\r\n  }\r\n  result[0] = matrix[0];\r\n  result[1] = matrix[1];\r\n  result[2] = matrix[2];\r\n  result[3] = matrix[3];\r\n  result[4] = matrix[4];\r\n  result[5] = matrix[5];\r\n  result[6] = matrix[6];\r\n  result[7] = matrix[7];\r\n  result[8] = matrix[8];\r\n  result[9] = matrix[9];\r\n  result[10] = matrix[10];\r\n  result[11] = matrix[11];\r\n  result[12] = matrix[12];\r\n  result[13] = matrix[13];\r\n  result[14] = matrix[14];\r\n  result[15] = matrix[15];\r\n  return result;\r\n};\r\n\r\n/**\r\n * Creates a Matrix4 from 16 consecutive elements in an array.\r\n * @function\r\n *\r\n * @param {Number[]} array The array whose 16 consecutive elements correspond to the positions of the matrix.  Assumes column-major order.\r\n * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to first column first row position in the matrix.\r\n * @param {Matrix4} [result] The object onto which to store the result.\r\n * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if one was not provided.\r\n *\r\n * @example\r\n * // Create the Matrix4:\r\n * // [1.0, 2.0, 3.0, 4.0]\r\n * // [1.0, 2.0, 3.0, 4.0]\r\n * // [1.0, 2.0, 3.0, 4.0]\r\n * // [1.0, 2.0, 3.0, 4.0]\r\n *\r\n * const v = [1.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0, 3.0, 4.0, 4.0, 4.0, 4.0];\r\n * const m = Cesium.Matrix4.fromArray(v);\r\n *\r\n * // Create same Matrix4 with using an offset into an array\r\n * const v2 = [0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0, 3.0, 4.0, 4.0, 4.0, 4.0];\r\n * const m2 = Cesium.Matrix4.fromArray(v2, 2);\r\n */\r\nMatrix4.fromArray = Matrix4.unpack;\r\n\r\n/**\r\n * Computes a Matrix4 instance from a column-major order array.\r\n *\r\n * @param {Number[]} values The column-major order array.\r\n * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.\r\n * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.\r\n */\r\nMatrix4.fromColumnMajorArray = function (values, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"values\", values);\r\n  //>>includeEnd('debug');\r\n\r\n  return Matrix4.clone(values, result);\r\n};\r\n\r\n/**\r\n * Computes a Matrix4 instance from a row-major order array.\r\n * The resulting matrix will be in column-major order.\r\n *\r\n * @param {Number[]} values The row-major order array.\r\n * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.\r\n * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.\r\n */\r\nMatrix4.fromRowMajorArray = function (values, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"values\", values);\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    return new Matrix4(\r\n      values[0],\r\n      values[1],\r\n      values[2],\r\n      values[3],\r\n      values[4],\r\n      values[5],\r\n      values[6],\r\n      values[7],\r\n      values[8],\r\n      values[9],\r\n      values[10],\r\n      values[11],\r\n      values[12],\r\n      values[13],\r\n      values[14],\r\n      values[15]\r\n    );\r\n  }\r\n  result[0] = values[0];\r\n  result[1] = values[4];\r\n  result[2] = values[8];\r\n  result[3] = values[12];\r\n  result[4] = values[1];\r\n  result[5] = values[5];\r\n  result[6] = values[9];\r\n  result[7] = values[13];\r\n  result[8] = values[2];\r\n  result[9] = values[6];\r\n  result[10] = values[10];\r\n  result[11] = values[14];\r\n  result[12] = values[3];\r\n  result[13] = values[7];\r\n  result[14] = values[11];\r\n  result[15] = values[15];\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes a Matrix4 instance from a Matrix3 representing the rotation\r\n * and a Cartesian3 representing the translation.\r\n *\r\n * @param {Matrix3} rotation The upper left portion of the matrix representing the rotation.\r\n * @param {Cartesian3} [translation=Cartesian3.ZERO] The upper right portion of the matrix representing the translation.\r\n * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.\r\n * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.\r\n */\r\nMatrix4.fromRotationTranslation = function (rotation, translation, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"rotation\", rotation);\r\n  //>>includeEnd('debug');\r\n\r\n  translation = defaultValue(translation, Cartesian3.ZERO);\r\n\r\n  if (!defined(result)) {\r\n    return new Matrix4(\r\n      rotation[0],\r\n      rotation[3],\r\n      rotation[6],\r\n      translation.x,\r\n      rotation[1],\r\n      rotation[4],\r\n      rotation[7],\r\n      translation.y,\r\n      rotation[2],\r\n      rotation[5],\r\n      rotation[8],\r\n      translation.z,\r\n      0.0,\r\n      0.0,\r\n      0.0,\r\n      1.0\r\n    );\r\n  }\r\n\r\n  result[0] = rotation[0];\r\n  result[1] = rotation[1];\r\n  result[2] = rotation[2];\r\n  result[3] = 0.0;\r\n  result[4] = rotation[3];\r\n  result[5] = rotation[4];\r\n  result[6] = rotation[5];\r\n  result[7] = 0.0;\r\n  result[8] = rotation[6];\r\n  result[9] = rotation[7];\r\n  result[10] = rotation[8];\r\n  result[11] = 0.0;\r\n  result[12] = translation.x;\r\n  result[13] = translation.y;\r\n  result[14] = translation.z;\r\n  result[15] = 1.0;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes a Matrix4 instance from a translation, rotation, and scale (TRS)\r\n * representation with the rotation represented as a quaternion.\r\n *\r\n * @param {Cartesian3} translation The translation transformation.\r\n * @param {Quaternion} rotation The rotation transformation.\r\n * @param {Cartesian3} scale The non-uniform scale transformation.\r\n * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.\r\n * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.\r\n *\r\n * @example\r\n * const result = Cesium.Matrix4.fromTranslationQuaternionRotationScale(\r\n *   new Cesium.Cartesian3(1.0, 2.0, 3.0), // translation\r\n *   Cesium.Quaternion.IDENTITY,           // rotation\r\n *   new Cesium.Cartesian3(7.0, 8.0, 9.0), // scale\r\n *   result);\r\n */\r\nMatrix4.fromTranslationQuaternionRotationScale = function (\r\n  translation,\r\n  rotation,\r\n  scale,\r\n  result\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"translation\", translation);\r\n  Check.typeOf.object(\"rotation\", rotation);\r\n  Check.typeOf.object(\"scale\", scale);\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    result = new Matrix4();\r\n  }\r\n\r\n  const scaleX = scale.x;\r\n  const scaleY = scale.y;\r\n  const scaleZ = scale.z;\r\n\r\n  const x2 = rotation.x * rotation.x;\r\n  const xy = rotation.x * rotation.y;\r\n  const xz = rotation.x * rotation.z;\r\n  const xw = rotation.x * rotation.w;\r\n  const y2 = rotation.y * rotation.y;\r\n  const yz = rotation.y * rotation.z;\r\n  const yw = rotation.y * rotation.w;\r\n  const z2 = rotation.z * rotation.z;\r\n  const zw = rotation.z * rotation.w;\r\n  const w2 = rotation.w * rotation.w;\r\n\r\n  const m00 = x2 - y2 - z2 + w2;\r\n  const m01 = 2.0 * (xy - zw);\r\n  const m02 = 2.0 * (xz + yw);\r\n\r\n  const m10 = 2.0 * (xy + zw);\r\n  const m11 = -x2 + y2 - z2 + w2;\r\n  const m12 = 2.0 * (yz - xw);\r\n\r\n  const m20 = 2.0 * (xz - yw);\r\n  const m21 = 2.0 * (yz + xw);\r\n  const m22 = -x2 - y2 + z2 + w2;\r\n\r\n  result[0] = m00 * scaleX;\r\n  result[1] = m10 * scaleX;\r\n  result[2] = m20 * scaleX;\r\n  result[3] = 0.0;\r\n  result[4] = m01 * scaleY;\r\n  result[5] = m11 * scaleY;\r\n  result[6] = m21 * scaleY;\r\n  result[7] = 0.0;\r\n  result[8] = m02 * scaleZ;\r\n  result[9] = m12 * scaleZ;\r\n  result[10] = m22 * scaleZ;\r\n  result[11] = 0.0;\r\n  result[12] = translation.x;\r\n  result[13] = translation.y;\r\n  result[14] = translation.z;\r\n  result[15] = 1.0;\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Creates a Matrix4 instance from a {@link TranslationRotationScale} instance.\r\n *\r\n * @param {TranslationRotationScale} translationRotationScale The instance.\r\n * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.\r\n * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.\r\n */\r\nMatrix4.fromTranslationRotationScale = function (\r\n  translationRotationScale,\r\n  result\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"translationRotationScale\", translationRotationScale);\r\n  //>>includeEnd('debug');\r\n\r\n  return Matrix4.fromTranslationQuaternionRotationScale(\r\n    translationRotationScale.translation,\r\n    translationRotationScale.rotation,\r\n    translationRotationScale.scale,\r\n    result\r\n  );\r\n};\r\n\r\n/**\r\n * Creates a Matrix4 instance from a Cartesian3 representing the translation.\r\n *\r\n * @param {Cartesian3} translation The upper right portion of the matrix representing the translation.\r\n * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.\r\n * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.\r\n *\r\n * @see Matrix4.multiplyByTranslation\r\n */\r\nMatrix4.fromTranslation = function (translation, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"translation\", translation);\r\n  //>>includeEnd('debug');\r\n\r\n  return Matrix4.fromRotationTranslation(Matrix3.IDENTITY, translation, result);\r\n};\r\n\r\n/**\r\n * Computes a Matrix4 instance representing a non-uniform scale.\r\n *\r\n * @param {Cartesian3} scale The x, y, and z scale factors.\r\n * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.\r\n * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.\r\n *\r\n * @example\r\n * // Creates\r\n * //   [7.0, 0.0, 0.0, 0.0]\r\n * //   [0.0, 8.0, 0.0, 0.0]\r\n * //   [0.0, 0.0, 9.0, 0.0]\r\n * //   [0.0, 0.0, 0.0, 1.0]\r\n * const m = Cesium.Matrix4.fromScale(new Cesium.Cartesian3(7.0, 8.0, 9.0));\r\n */\r\nMatrix4.fromScale = function (scale, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"scale\", scale);\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    return new Matrix4(\r\n      scale.x,\r\n      0.0,\r\n      0.0,\r\n      0.0,\r\n      0.0,\r\n      scale.y,\r\n      0.0,\r\n      0.0,\r\n      0.0,\r\n      0.0,\r\n      scale.z,\r\n      0.0,\r\n      0.0,\r\n      0.0,\r\n      0.0,\r\n      1.0\r\n    );\r\n  }\r\n\r\n  result[0] = scale.x;\r\n  result[1] = 0.0;\r\n  result[2] = 0.0;\r\n  result[3] = 0.0;\r\n  result[4] = 0.0;\r\n  result[5] = scale.y;\r\n  result[6] = 0.0;\r\n  result[7] = 0.0;\r\n  result[8] = 0.0;\r\n  result[9] = 0.0;\r\n  result[10] = scale.z;\r\n  result[11] = 0.0;\r\n  result[12] = 0.0;\r\n  result[13] = 0.0;\r\n  result[14] = 0.0;\r\n  result[15] = 1.0;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes a Matrix4 instance representing a uniform scale.\r\n *\r\n * @param {Number} scale The uniform scale factor.\r\n * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.\r\n * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.\r\n *\r\n * @example\r\n * // Creates\r\n * //   [2.0, 0.0, 0.0, 0.0]\r\n * //   [0.0, 2.0, 0.0, 0.0]\r\n * //   [0.0, 0.0, 2.0, 0.0]\r\n * //   [0.0, 0.0, 0.0, 1.0]\r\n * const m = Cesium.Matrix4.fromUniformScale(2.0);\r\n */\r\nMatrix4.fromUniformScale = function (scale, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.number(\"scale\", scale);\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    return new Matrix4(\r\n      scale,\r\n      0.0,\r\n      0.0,\r\n      0.0,\r\n      0.0,\r\n      scale,\r\n      0.0,\r\n      0.0,\r\n      0.0,\r\n      0.0,\r\n      scale,\r\n      0.0,\r\n      0.0,\r\n      0.0,\r\n      0.0,\r\n      1.0\r\n    );\r\n  }\r\n\r\n  result[0] = scale;\r\n  result[1] = 0.0;\r\n  result[2] = 0.0;\r\n  result[3] = 0.0;\r\n  result[4] = 0.0;\r\n  result[5] = scale;\r\n  result[6] = 0.0;\r\n  result[7] = 0.0;\r\n  result[8] = 0.0;\r\n  result[9] = 0.0;\r\n  result[10] = scale;\r\n  result[11] = 0.0;\r\n  result[12] = 0.0;\r\n  result[13] = 0.0;\r\n  result[14] = 0.0;\r\n  result[15] = 1.0;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Creates a rotation matrix.\r\n *\r\n * @param {Matrix3} rotation The rotation matrix.\r\n * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.\r\n * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.\r\n */\r\nMatrix4.fromRotation = function (rotation, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"rotation\", rotation);\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    result = new Matrix4();\r\n  }\r\n  result[0] = rotation[0];\r\n  result[1] = rotation[1];\r\n  result[2] = rotation[2];\r\n  result[3] = 0.0;\r\n\r\n  result[4] = rotation[3];\r\n  result[5] = rotation[4];\r\n  result[6] = rotation[5];\r\n  result[7] = 0.0;\r\n\r\n  result[8] = rotation[6];\r\n  result[9] = rotation[7];\r\n  result[10] = rotation[8];\r\n  result[11] = 0.0;\r\n\r\n  result[12] = 0.0;\r\n  result[13] = 0.0;\r\n  result[14] = 0.0;\r\n  result[15] = 1.0;\r\n\r\n  return result;\r\n};\r\n\r\nconst fromCameraF = new Cartesian3();\r\nconst fromCameraR = new Cartesian3();\r\nconst fromCameraU = new Cartesian3();\r\n\r\n/**\r\n * Computes a Matrix4 instance from a Camera.\r\n *\r\n * @param {Camera} camera The camera to use.\r\n * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.\r\n * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.\r\n */\r\nMatrix4.fromCamera = function (camera, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"camera\", camera);\r\n  //>>includeEnd('debug');\r\n\r\n  const position = camera.position;\r\n  const direction = camera.direction;\r\n  const up = camera.up;\r\n\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"camera.position\", position);\r\n  Check.typeOf.object(\"camera.direction\", direction);\r\n  Check.typeOf.object(\"camera.up\", up);\r\n  //>>includeEnd('debug');\r\n\r\n  Cartesian3.normalize(direction, fromCameraF);\r\n  Cartesian3.normalize(\r\n    Cartesian3.cross(fromCameraF, up, fromCameraR),\r\n    fromCameraR\r\n  );\r\n  Cartesian3.normalize(\r\n    Cartesian3.cross(fromCameraR, fromCameraF, fromCameraU),\r\n    fromCameraU\r\n  );\r\n\r\n  const sX = fromCameraR.x;\r\n  const sY = fromCameraR.y;\r\n  const sZ = fromCameraR.z;\r\n  const fX = fromCameraF.x;\r\n  const fY = fromCameraF.y;\r\n  const fZ = fromCameraF.z;\r\n  const uX = fromCameraU.x;\r\n  const uY = fromCameraU.y;\r\n  const uZ = fromCameraU.z;\r\n  const positionX = position.x;\r\n  const positionY = position.y;\r\n  const positionZ = position.z;\r\n  const t0 = sX * -positionX + sY * -positionY + sZ * -positionZ;\r\n  const t1 = uX * -positionX + uY * -positionY + uZ * -positionZ;\r\n  const t2 = fX * positionX + fY * positionY + fZ * positionZ;\r\n\r\n  // The code below this comment is an optimized\r\n  // version of the commented lines.\r\n  // Rather that create two matrices and then multiply,\r\n  // we just bake in the multiplcation as part of creation.\r\n  // const rotation = new Matrix4(\r\n  //                 sX,  sY,  sZ, 0.0,\r\n  //                 uX,  uY,  uZ, 0.0,\r\n  //                -fX, -fY, -fZ, 0.0,\r\n  //                 0.0,  0.0,  0.0, 1.0);\r\n  // const translation = new Matrix4(\r\n  //                 1.0, 0.0, 0.0, -position.x,\r\n  //                 0.0, 1.0, 0.0, -position.y,\r\n  //                 0.0, 0.0, 1.0, -position.z,\r\n  //                 0.0, 0.0, 0.0, 1.0);\r\n  // return rotation.multiply(translation);\r\n  if (!defined(result)) {\r\n    return new Matrix4(\r\n      sX,\r\n      sY,\r\n      sZ,\r\n      t0,\r\n      uX,\r\n      uY,\r\n      uZ,\r\n      t1,\r\n      -fX,\r\n      -fY,\r\n      -fZ,\r\n      t2,\r\n      0.0,\r\n      0.0,\r\n      0.0,\r\n      1.0\r\n    );\r\n  }\r\n  result[0] = sX;\r\n  result[1] = uX;\r\n  result[2] = -fX;\r\n  result[3] = 0.0;\r\n  result[4] = sY;\r\n  result[5] = uY;\r\n  result[6] = -fY;\r\n  result[7] = 0.0;\r\n  result[8] = sZ;\r\n  result[9] = uZ;\r\n  result[10] = -fZ;\r\n  result[11] = 0.0;\r\n  result[12] = t0;\r\n  result[13] = t1;\r\n  result[14] = t2;\r\n  result[15] = 1.0;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes a Matrix4 instance representing a perspective transformation matrix.\r\n *\r\n * @param {Number} fovY The field of view along the Y axis in radians.\r\n * @param {Number} aspectRatio The aspect ratio.\r\n * @param {Number} near The distance to the near plane in meters.\r\n * @param {Number} far The distance to the far plane in meters.\r\n * @param {Matrix4} result The object in which the result will be stored.\r\n * @returns {Matrix4} The modified result parameter.\r\n *\r\n * @exception {DeveloperError} fovY must be in (0, PI].\r\n * @exception {DeveloperError} aspectRatio must be greater than zero.\r\n * @exception {DeveloperError} near must be greater than zero.\r\n * @exception {DeveloperError} far must be greater than zero.\r\n */\r\nMatrix4.computePerspectiveFieldOfView = function (\r\n  fovY,\r\n  aspectRatio,\r\n  near,\r\n  far,\r\n  result\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.number.greaterThan(\"fovY\", fovY, 0.0);\r\n  Check.typeOf.number.lessThan(\"fovY\", fovY, Math.PI);\r\n  Check.typeOf.number.greaterThan(\"near\", near, 0.0);\r\n  Check.typeOf.number.greaterThan(\"far\", far, 0.0);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  const bottom = Math.tan(fovY * 0.5);\r\n\r\n  const column1Row1 = 1.0 / bottom;\r\n  const column0Row0 = column1Row1 / aspectRatio;\r\n  const column2Row2 = (far + near) / (near - far);\r\n  const column3Row2 = (2.0 * far * near) / (near - far);\r\n\r\n  result[0] = column0Row0;\r\n  result[1] = 0.0;\r\n  result[2] = 0.0;\r\n  result[3] = 0.0;\r\n  result[4] = 0.0;\r\n  result[5] = column1Row1;\r\n  result[6] = 0.0;\r\n  result[7] = 0.0;\r\n  result[8] = 0.0;\r\n  result[9] = 0.0;\r\n  result[10] = column2Row2;\r\n  result[11] = -1.0;\r\n  result[12] = 0.0;\r\n  result[13] = 0.0;\r\n  result[14] = column3Row2;\r\n  result[15] = 0.0;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes a Matrix4 instance representing an orthographic transformation matrix.\r\n *\r\n * @param {Number} left The number of meters to the left of the camera that will be in view.\r\n * @param {Number} right The number of meters to the right of the camera that will be in view.\r\n * @param {Number} bottom The number of meters below of the camera that will be in view.\r\n * @param {Number} top The number of meters above of the camera that will be in view.\r\n * @param {Number} near The distance to the near plane in meters.\r\n * @param {Number} far The distance to the far plane in meters.\r\n * @param {Matrix4} result The object in which the result will be stored.\r\n * @returns {Matrix4} The modified result parameter.\r\n */\r\nMatrix4.computeOrthographicOffCenter = function (\r\n  left,\r\n  right,\r\n  bottom,\r\n  top,\r\n  near,\r\n  far,\r\n  result\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.number(\"left\", left);\r\n  Check.typeOf.number(\"right\", right);\r\n  Check.typeOf.number(\"bottom\", bottom);\r\n  Check.typeOf.number(\"top\", top);\r\n  Check.typeOf.number(\"near\", near);\r\n  Check.typeOf.number(\"far\", far);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  let a = 1.0 / (right - left);\r\n  let b = 1.0 / (top - bottom);\r\n  let c = 1.0 / (far - near);\r\n\r\n  const tx = -(right + left) * a;\r\n  const ty = -(top + bottom) * b;\r\n  const tz = -(far + near) * c;\r\n  a *= 2.0;\r\n  b *= 2.0;\r\n  c *= -2.0;\r\n\r\n  result[0] = a;\r\n  result[1] = 0.0;\r\n  result[2] = 0.0;\r\n  result[3] = 0.0;\r\n  result[4] = 0.0;\r\n  result[5] = b;\r\n  result[6] = 0.0;\r\n  result[7] = 0.0;\r\n  result[8] = 0.0;\r\n  result[9] = 0.0;\r\n  result[10] = c;\r\n  result[11] = 0.0;\r\n  result[12] = tx;\r\n  result[13] = ty;\r\n  result[14] = tz;\r\n  result[15] = 1.0;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes a Matrix4 instance representing an off center perspective transformation.\r\n *\r\n * @param {Number} left The number of meters to the left of the camera that will be in view.\r\n * @param {Number} right The number of meters to the right of the camera that will be in view.\r\n * @param {Number} bottom The number of meters below of the camera that will be in view.\r\n * @param {Number} top The number of meters above of the camera that will be in view.\r\n * @param {Number} near The distance to the near plane in meters.\r\n * @param {Number} far The distance to the far plane in meters.\r\n * @param {Matrix4} result The object in which the result will be stored.\r\n * @returns {Matrix4} The modified result parameter.\r\n */\r\nMatrix4.computePerspectiveOffCenter = function (\r\n  left,\r\n  right,\r\n  bottom,\r\n  top,\r\n  near,\r\n  far,\r\n  result\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.number(\"left\", left);\r\n  Check.typeOf.number(\"right\", right);\r\n  Check.typeOf.number(\"bottom\", bottom);\r\n  Check.typeOf.number(\"top\", top);\r\n  Check.typeOf.number(\"near\", near);\r\n  Check.typeOf.number(\"far\", far);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  const column0Row0 = (2.0 * near) / (right - left);\r\n  const column1Row1 = (2.0 * near) / (top - bottom);\r\n  const column2Row0 = (right + left) / (right - left);\r\n  const column2Row1 = (top + bottom) / (top - bottom);\r\n  const column2Row2 = -(far + near) / (far - near);\r\n  const column2Row3 = -1.0;\r\n  const column3Row2 = (-2.0 * far * near) / (far - near);\r\n\r\n  result[0] = column0Row0;\r\n  result[1] = 0.0;\r\n  result[2] = 0.0;\r\n  result[3] = 0.0;\r\n  result[4] = 0.0;\r\n  result[5] = column1Row1;\r\n  result[6] = 0.0;\r\n  result[7] = 0.0;\r\n  result[8] = column2Row0;\r\n  result[9] = column2Row1;\r\n  result[10] = column2Row2;\r\n  result[11] = column2Row3;\r\n  result[12] = 0.0;\r\n  result[13] = 0.0;\r\n  result[14] = column3Row2;\r\n  result[15] = 0.0;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes a Matrix4 instance representing an infinite off center perspective transformation.\r\n *\r\n * @param {Number} left The number of meters to the left of the camera that will be in view.\r\n * @param {Number} right The number of meters to the right of the camera that will be in view.\r\n * @param {Number} bottom The number of meters below of the camera that will be in view.\r\n * @param {Number} top The number of meters above of the camera that will be in view.\r\n * @param {Number} near The distance to the near plane in meters.\r\n * @param {Matrix4} result The object in which the result will be stored.\r\n * @returns {Matrix4} The modified result parameter.\r\n */\r\nMatrix4.computeInfinitePerspectiveOffCenter = function (\r\n  left,\r\n  right,\r\n  bottom,\r\n  top,\r\n  near,\r\n  result\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.number(\"left\", left);\r\n  Check.typeOf.number(\"right\", right);\r\n  Check.typeOf.number(\"bottom\", bottom);\r\n  Check.typeOf.number(\"top\", top);\r\n  Check.typeOf.number(\"near\", near);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  const column0Row0 = (2.0 * near) / (right - left);\r\n  const column1Row1 = (2.0 * near) / (top - bottom);\r\n  const column2Row0 = (right + left) / (right - left);\r\n  const column2Row1 = (top + bottom) / (top - bottom);\r\n  const column2Row2 = -1.0;\r\n  const column2Row3 = -1.0;\r\n  const column3Row2 = -2.0 * near;\r\n\r\n  result[0] = column0Row0;\r\n  result[1] = 0.0;\r\n  result[2] = 0.0;\r\n  result[3] = 0.0;\r\n  result[4] = 0.0;\r\n  result[5] = column1Row1;\r\n  result[6] = 0.0;\r\n  result[7] = 0.0;\r\n  result[8] = column2Row0;\r\n  result[9] = column2Row1;\r\n  result[10] = column2Row2;\r\n  result[11] = column2Row3;\r\n  result[12] = 0.0;\r\n  result[13] = 0.0;\r\n  result[14] = column3Row2;\r\n  result[15] = 0.0;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes a Matrix4 instance that transforms from normalized device coordinates to window coordinates.\r\n *\r\n * @param {Object} [viewport = { x : 0.0, y : 0.0, width : 0.0, height : 0.0 }] The viewport's corners as shown in Example 1.\r\n * @param {Number} [nearDepthRange=0.0] The near plane distance in window coordinates.\r\n * @param {Number} [farDepthRange=1.0] The far plane distance in window coordinates.\r\n * @param {Matrix4} [result] The object in which the result will be stored.\r\n * @returns {Matrix4} The modified result parameter.\r\n *\r\n * @example\r\n * // Create viewport transformation using an explicit viewport and depth range.\r\n * const m = Cesium.Matrix4.computeViewportTransformation({\r\n *     x : 0.0,\r\n *     y : 0.0,\r\n *     width : 1024.0,\r\n *     height : 768.0\r\n * }, 0.0, 1.0, new Cesium.Matrix4());\r\n */\r\nMatrix4.computeViewportTransformation = function (\r\n  viewport,\r\n  nearDepthRange,\r\n  farDepthRange,\r\n  result\r\n) {\r\n  if (!defined(result)) {\r\n    result = new Matrix4();\r\n  }\r\n\r\n  viewport = defaultValue(viewport, defaultValue.EMPTY_OBJECT);\r\n  const x = defaultValue(viewport.x, 0.0);\r\n  const y = defaultValue(viewport.y, 0.0);\r\n  const width = defaultValue(viewport.width, 0.0);\r\n  const height = defaultValue(viewport.height, 0.0);\r\n  nearDepthRange = defaultValue(nearDepthRange, 0.0);\r\n  farDepthRange = defaultValue(farDepthRange, 1.0);\r\n\r\n  const halfWidth = width * 0.5;\r\n  const halfHeight = height * 0.5;\r\n  const halfDepth = (farDepthRange - nearDepthRange) * 0.5;\r\n\r\n  const column0Row0 = halfWidth;\r\n  const column1Row1 = halfHeight;\r\n  const column2Row2 = halfDepth;\r\n  const column3Row0 = x + halfWidth;\r\n  const column3Row1 = y + halfHeight;\r\n  const column3Row2 = nearDepthRange + halfDepth;\r\n  const column3Row3 = 1.0;\r\n\r\n  result[0] = column0Row0;\r\n  result[1] = 0.0;\r\n  result[2] = 0.0;\r\n  result[3] = 0.0;\r\n  result[4] = 0.0;\r\n  result[5] = column1Row1;\r\n  result[6] = 0.0;\r\n  result[7] = 0.0;\r\n  result[8] = 0.0;\r\n  result[9] = 0.0;\r\n  result[10] = column2Row2;\r\n  result[11] = 0.0;\r\n  result[12] = column3Row0;\r\n  result[13] = column3Row1;\r\n  result[14] = column3Row2;\r\n  result[15] = column3Row3;\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes a Matrix4 instance that transforms from world space to view space.\r\n *\r\n * @param {Cartesian3} position The position of the camera.\r\n * @param {Cartesian3} direction The forward direction.\r\n * @param {Cartesian3} up The up direction.\r\n * @param {Cartesian3} right The right direction.\r\n * @param {Matrix4} result The object in which the result will be stored.\r\n * @returns {Matrix4} The modified result parameter.\r\n */\r\nMatrix4.computeView = function (position, direction, up, right, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"position\", position);\r\n  Check.typeOf.object(\"direction\", direction);\r\n  Check.typeOf.object(\"up\", up);\r\n  Check.typeOf.object(\"right\", right);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result[0] = right.x;\r\n  result[1] = up.x;\r\n  result[2] = -direction.x;\r\n  result[3] = 0.0;\r\n  result[4] = right.y;\r\n  result[5] = up.y;\r\n  result[6] = -direction.y;\r\n  result[7] = 0.0;\r\n  result[8] = right.z;\r\n  result[9] = up.z;\r\n  result[10] = -direction.z;\r\n  result[11] = 0.0;\r\n  result[12] = -Cartesian3.dot(right, position);\r\n  result[13] = -Cartesian3.dot(up, position);\r\n  result[14] = Cartesian3.dot(direction, position);\r\n  result[15] = 1.0;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes an Array from the provided Matrix4 instance.\r\n * The array will be in column-major order.\r\n *\r\n * @param {Matrix4} matrix The matrix to use..\r\n * @param {Number[]} [result] The Array onto which to store the result.\r\n * @returns {Number[]} The modified Array parameter or a new Array instance if one was not provided.\r\n *\r\n * @example\r\n * //create an array from an instance of Matrix4\r\n * // m = [10.0, 14.0, 18.0, 22.0]\r\n * //     [11.0, 15.0, 19.0, 23.0]\r\n * //     [12.0, 16.0, 20.0, 24.0]\r\n * //     [13.0, 17.0, 21.0, 25.0]\r\n * const a = Cesium.Matrix4.toArray(m);\r\n *\r\n * // m remains the same\r\n * //creates a = [10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 17.0, 18.0, 19.0, 20.0, 21.0, 22.0, 23.0, 24.0, 25.0]\r\n */\r\nMatrix4.toArray = function (matrix, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    return [\r\n      matrix[0],\r\n      matrix[1],\r\n      matrix[2],\r\n      matrix[3],\r\n      matrix[4],\r\n      matrix[5],\r\n      matrix[6],\r\n      matrix[7],\r\n      matrix[8],\r\n      matrix[9],\r\n      matrix[10],\r\n      matrix[11],\r\n      matrix[12],\r\n      matrix[13],\r\n      matrix[14],\r\n      matrix[15],\r\n    ];\r\n  }\r\n  result[0] = matrix[0];\r\n  result[1] = matrix[1];\r\n  result[2] = matrix[2];\r\n  result[3] = matrix[3];\r\n  result[4] = matrix[4];\r\n  result[5] = matrix[5];\r\n  result[6] = matrix[6];\r\n  result[7] = matrix[7];\r\n  result[8] = matrix[8];\r\n  result[9] = matrix[9];\r\n  result[10] = matrix[10];\r\n  result[11] = matrix[11];\r\n  result[12] = matrix[12];\r\n  result[13] = matrix[13];\r\n  result[14] = matrix[14];\r\n  result[15] = matrix[15];\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the array index of the element at the provided row and column.\r\n *\r\n * @param {Number} row The zero-based index of the row.\r\n * @param {Number} column The zero-based index of the column.\r\n * @returns {Number} The index of the element at the provided row and column.\r\n *\r\n * @exception {DeveloperError} row must be 0, 1, 2, or 3.\r\n * @exception {DeveloperError} column must be 0, 1, 2, or 3.\r\n *\r\n * @example\r\n * const myMatrix = new Cesium.Matrix4();\r\n * const column1Row0Index = Cesium.Matrix4.getElementIndex(1, 0);\r\n * const column1Row0 = myMatrix[column1Row0Index];\r\n * myMatrix[column1Row0Index] = 10.0;\r\n */\r\nMatrix4.getElementIndex = function (column, row) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.number.greaterThanOrEquals(\"row\", row, 0);\r\n  Check.typeOf.number.lessThanOrEquals(\"row\", row, 3);\r\n\r\n  Check.typeOf.number.greaterThanOrEquals(\"column\", column, 0);\r\n  Check.typeOf.number.lessThanOrEquals(\"column\", column, 3);\r\n  //>>includeEnd('debug');\r\n\r\n  return column * 4 + row;\r\n};\r\n\r\n/**\r\n * Retrieves a copy of the matrix column at the provided index as a Cartesian4 instance.\r\n *\r\n * @param {Matrix4} matrix The matrix to use.\r\n * @param {Number} index The zero-based index of the column to retrieve.\r\n * @param {Cartesian4} result The object onto which to store the result.\r\n * @returns {Cartesian4} The modified result parameter.\r\n *\r\n * @exception {DeveloperError} index must be 0, 1, 2, or 3.\r\n *\r\n * @example\r\n * //returns a Cartesian4 instance with values from the specified column\r\n * // m = [10.0, 11.0, 12.0, 13.0]\r\n * //     [14.0, 15.0, 16.0, 17.0]\r\n * //     [18.0, 19.0, 20.0, 21.0]\r\n * //     [22.0, 23.0, 24.0, 25.0]\r\n *\r\n * //Example 1: Creates an instance of Cartesian\r\n * const a = Cesium.Matrix4.getColumn(m, 2, new Cesium.Cartesian4());\r\n *\r\n * @example\r\n * //Example 2: Sets values for Cartesian instance\r\n * const a = new Cesium.Cartesian4();\r\n * Cesium.Matrix4.getColumn(m, 2, a);\r\n *\r\n * // a.x = 12.0; a.y = 16.0; a.z = 20.0; a.w = 24.0;\r\n */\r\nMatrix4.getColumn = function (matrix, index, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n\r\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\r\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 3);\r\n\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  const startIndex = index * 4;\r\n  const x = matrix[startIndex];\r\n  const y = matrix[startIndex + 1];\r\n  const z = matrix[startIndex + 2];\r\n  const w = matrix[startIndex + 3];\r\n\r\n  result.x = x;\r\n  result.y = y;\r\n  result.z = z;\r\n  result.w = w;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian4 instance.\r\n *\r\n * @param {Matrix4} matrix The matrix to use.\r\n * @param {Number} index The zero-based index of the column to set.\r\n * @param {Cartesian4} cartesian The Cartesian whose values will be assigned to the specified column.\r\n * @param {Matrix4} result The object onto which to store the result.\r\n * @returns {Matrix4} The modified result parameter.\r\n *\r\n * @exception {DeveloperError} index must be 0, 1, 2, or 3.\r\n *\r\n * @example\r\n * //creates a new Matrix4 instance with new column values from the Cartesian4 instance\r\n * // m = [10.0, 11.0, 12.0, 13.0]\r\n * //     [14.0, 15.0, 16.0, 17.0]\r\n * //     [18.0, 19.0, 20.0, 21.0]\r\n * //     [22.0, 23.0, 24.0, 25.0]\r\n *\r\n * const a = Cesium.Matrix4.setColumn(m, 2, new Cesium.Cartesian4(99.0, 98.0, 97.0, 96.0), new Cesium.Matrix4());\r\n *\r\n * // m remains the same\r\n * // a = [10.0, 11.0, 99.0, 13.0]\r\n * //     [14.0, 15.0, 98.0, 17.0]\r\n * //     [18.0, 19.0, 97.0, 21.0]\r\n * //     [22.0, 23.0, 96.0, 25.0]\r\n */\r\nMatrix4.setColumn = function (matrix, index, cartesian, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n\r\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\r\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 3);\r\n\r\n  Check.typeOf.object(\"cartesian\", cartesian);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result = Matrix4.clone(matrix, result);\r\n  const startIndex = index * 4;\r\n  result[startIndex] = cartesian.x;\r\n  result[startIndex + 1] = cartesian.y;\r\n  result[startIndex + 2] = cartesian.z;\r\n  result[startIndex + 3] = cartesian.w;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Retrieves a copy of the matrix row at the provided index as a Cartesian4 instance.\r\n *\r\n * @param {Matrix4} matrix The matrix to use.\r\n * @param {Number} index The zero-based index of the row to retrieve.\r\n * @param {Cartesian4} result The object onto which to store the result.\r\n * @returns {Cartesian4} The modified result parameter.\r\n *\r\n * @exception {DeveloperError} index must be 0, 1, 2, or 3.\r\n *\r\n * @example\r\n * //returns a Cartesian4 instance with values from the specified column\r\n * // m = [10.0, 11.0, 12.0, 13.0]\r\n * //     [14.0, 15.0, 16.0, 17.0]\r\n * //     [18.0, 19.0, 20.0, 21.0]\r\n * //     [22.0, 23.0, 24.0, 25.0]\r\n *\r\n * //Example 1: Returns an instance of Cartesian\r\n * const a = Cesium.Matrix4.getRow(m, 2, new Cesium.Cartesian4());\r\n *\r\n * @example\r\n * //Example 2: Sets values for a Cartesian instance\r\n * const a = new Cesium.Cartesian4();\r\n * Cesium.Matrix4.getRow(m, 2, a);\r\n *\r\n * // a.x = 18.0; a.y = 19.0; a.z = 20.0; a.w = 21.0;\r\n */\r\nMatrix4.getRow = function (matrix, index, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n\r\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\r\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 3);\r\n\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  const x = matrix[index];\r\n  const y = matrix[index + 4];\r\n  const z = matrix[index + 8];\r\n  const w = matrix[index + 12];\r\n\r\n  result.x = x;\r\n  result.y = y;\r\n  result.z = z;\r\n  result.w = w;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian4 instance.\r\n *\r\n * @param {Matrix4} matrix The matrix to use.\r\n * @param {Number} index The zero-based index of the row to set.\r\n * @param {Cartesian4} cartesian The Cartesian whose values will be assigned to the specified row.\r\n * @param {Matrix4} result The object onto which to store the result.\r\n * @returns {Matrix4} The modified result parameter.\r\n *\r\n * @exception {DeveloperError} index must be 0, 1, 2, or 3.\r\n *\r\n * @example\r\n * //create a new Matrix4 instance with new row values from the Cartesian4 instance\r\n * // m = [10.0, 11.0, 12.0, 13.0]\r\n * //     [14.0, 15.0, 16.0, 17.0]\r\n * //     [18.0, 19.0, 20.0, 21.0]\r\n * //     [22.0, 23.0, 24.0, 25.0]\r\n *\r\n * const a = Cesium.Matrix4.setRow(m, 2, new Cesium.Cartesian4(99.0, 98.0, 97.0, 96.0), new Cesium.Matrix4());\r\n *\r\n * // m remains the same\r\n * // a = [10.0, 11.0, 12.0, 13.0]\r\n * //     [14.0, 15.0, 16.0, 17.0]\r\n * //     [99.0, 98.0, 97.0, 96.0]\r\n * //     [22.0, 23.0, 24.0, 25.0]\r\n */\r\nMatrix4.setRow = function (matrix, index, cartesian, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n\r\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\r\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 3);\r\n\r\n  Check.typeOf.object(\"cartesian\", cartesian);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result = Matrix4.clone(matrix, result);\r\n  result[index] = cartesian.x;\r\n  result[index + 4] = cartesian.y;\r\n  result[index + 8] = cartesian.z;\r\n  result[index + 12] = cartesian.w;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes a new matrix that replaces the translation in the rightmost column of the provided\r\n * matrix with the provided translation. This assumes the matrix is an affine transformation.\r\n *\r\n * @param {Matrix4} matrix The matrix to use.\r\n * @param {Cartesian3} translation The translation that replaces the translation of the provided matrix.\r\n * @param {Matrix4} result The object onto which to store the result.\r\n * @returns {Matrix4} The modified result parameter.\r\n */\r\nMatrix4.setTranslation = function (matrix, translation, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  Check.typeOf.object(\"translation\", translation);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result[0] = matrix[0];\r\n  result[1] = matrix[1];\r\n  result[2] = matrix[2];\r\n  result[3] = matrix[3];\r\n\r\n  result[4] = matrix[4];\r\n  result[5] = matrix[5];\r\n  result[6] = matrix[6];\r\n  result[7] = matrix[7];\r\n\r\n  result[8] = matrix[8];\r\n  result[9] = matrix[9];\r\n  result[10] = matrix[10];\r\n  result[11] = matrix[11];\r\n\r\n  result[12] = translation.x;\r\n  result[13] = translation.y;\r\n  result[14] = translation.z;\r\n  result[15] = matrix[15];\r\n\r\n  return result;\r\n};\r\n\r\nconst scaleScratch1 = new Cartesian3();\r\n\r\n/**\r\n * Computes a new matrix that replaces the scale with the provided scale.\r\n * This assumes the matrix is an affine transformation.\r\n *\r\n * @param {Matrix4} matrix The matrix to use.\r\n * @param {Cartesian3} scale The scale that replaces the scale of the provided matrix.\r\n * @param {Matrix4} result The object onto which to store the result.\r\n * @returns {Matrix4} The modified result parameter.\r\n *\r\n * @see Matrix4.setUniformScale\r\n * @see Matrix4.fromScale\r\n * @see Matrix4.fromUniformScale\r\n * @see Matrix4.multiplyByScale\r\n * @see Matrix4.multiplyByUniformScale\r\n * @see Matrix4.getScale\r\n */\r\nMatrix4.setScale = function (matrix, scale, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  Check.typeOf.object(\"scale\", scale);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  const existingScale = Matrix4.getScale(matrix, scaleScratch1);\r\n  const scaleRatioX = scale.x / existingScale.x;\r\n  const scaleRatioY = scale.y / existingScale.y;\r\n  const scaleRatioZ = scale.z / existingScale.z;\r\n\r\n  result[0] = matrix[0] * scaleRatioX;\r\n  result[1] = matrix[1] * scaleRatioX;\r\n  result[2] = matrix[2] * scaleRatioX;\r\n  result[3] = matrix[3];\r\n\r\n  result[4] = matrix[4] * scaleRatioY;\r\n  result[5] = matrix[5] * scaleRatioY;\r\n  result[6] = matrix[6] * scaleRatioY;\r\n  result[7] = matrix[7];\r\n\r\n  result[8] = matrix[8] * scaleRatioZ;\r\n  result[9] = matrix[9] * scaleRatioZ;\r\n  result[10] = matrix[10] * scaleRatioZ;\r\n  result[11] = matrix[11];\r\n\r\n  result[12] = matrix[12];\r\n  result[13] = matrix[13];\r\n  result[14] = matrix[14];\r\n  result[15] = matrix[15];\r\n\r\n  return result;\r\n};\r\n\r\nconst scaleScratch2 = new Cartesian3();\r\n\r\n/**\r\n * Computes a new matrix that replaces the scale with the provided uniform scale.\r\n * This assumes the matrix is an affine transformation.\r\n *\r\n * @param {Matrix4} matrix The matrix to use.\r\n * @param {Number} scale The uniform scale that replaces the scale of the provided matrix.\r\n * @param {Matrix4} result The object onto which to store the result.\r\n * @returns {Matrix4} The modified result parameter.\r\n *\r\n * @see Matrix4.setScale\r\n * @see Matrix4.fromScale\r\n * @see Matrix4.fromUniformScale\r\n * @see Matrix4.multiplyByScale\r\n * @see Matrix4.multiplyByUniformScale\r\n * @see Matrix4.getScale\r\n */\r\nMatrix4.setUniformScale = function (matrix, scale, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  Check.typeOf.number(\"scale\", scale);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  const existingScale = Matrix4.getScale(matrix, scaleScratch2);\r\n  const scaleRatioX = scale / existingScale.x;\r\n  const scaleRatioY = scale / existingScale.y;\r\n  const scaleRatioZ = scale / existingScale.z;\r\n\r\n  result[0] = matrix[0] * scaleRatioX;\r\n  result[1] = matrix[1] * scaleRatioX;\r\n  result[2] = matrix[2] * scaleRatioX;\r\n  result[3] = matrix[3];\r\n\r\n  result[4] = matrix[4] * scaleRatioY;\r\n  result[5] = matrix[5] * scaleRatioY;\r\n  result[6] = matrix[6] * scaleRatioY;\r\n  result[7] = matrix[7];\r\n\r\n  result[8] = matrix[8] * scaleRatioZ;\r\n  result[9] = matrix[9] * scaleRatioZ;\r\n  result[10] = matrix[10] * scaleRatioZ;\r\n  result[11] = matrix[11];\r\n\r\n  result[12] = matrix[12];\r\n  result[13] = matrix[13];\r\n  result[14] = matrix[14];\r\n  result[15] = matrix[15];\r\n\r\n  return result;\r\n};\r\n\r\nconst scratchColumn = new Cartesian3();\r\n\r\n/**\r\n * Extracts the non-uniform scale assuming the matrix is an affine transformation.\r\n *\r\n * @param {Matrix4} matrix The matrix.\r\n * @param {Cartesian3} result The object onto which to store the result.\r\n * @returns {Cartesian3} The modified result parameter\r\n *\r\n * @see Matrix4.multiplyByScale\r\n * @see Matrix4.multiplyByUniformScale\r\n * @see Matrix4.fromScale\r\n * @see Matrix4.fromUniformScale\r\n * @see Matrix4.setScale\r\n * @see Matrix4.setUniformScale\r\n */\r\nMatrix4.getScale = function (matrix, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result.x = Cartesian3.magnitude(\r\n    Cartesian3.fromElements(matrix[0], matrix[1], matrix[2], scratchColumn)\r\n  );\r\n  result.y = Cartesian3.magnitude(\r\n    Cartesian3.fromElements(matrix[4], matrix[5], matrix[6], scratchColumn)\r\n  );\r\n  result.z = Cartesian3.magnitude(\r\n    Cartesian3.fromElements(matrix[8], matrix[9], matrix[10], scratchColumn)\r\n  );\r\n  return result;\r\n};\r\n\r\nconst scaleScratch3 = new Cartesian3();\r\n\r\n/**\r\n * Computes the maximum scale assuming the matrix is an affine transformation.\r\n * The maximum scale is the maximum length of the column vectors in the upper-left\r\n * 3x3 matrix.\r\n *\r\n * @param {Matrix4} matrix The matrix.\r\n * @returns {Number} The maximum scale.\r\n */\r\nMatrix4.getMaximumScale = function (matrix) {\r\n  Matrix4.getScale(matrix, scaleScratch3);\r\n  return Cartesian3.maximumComponent(scaleScratch3);\r\n};\r\n\r\nconst scaleScratch4 = new Cartesian3();\r\n\r\n/**\r\n * Sets the rotation assuming the matrix is an affine transformation.\r\n *\r\n * @param {Matrix4} matrix The matrix.\r\n * @param {Matrix4} rotation The rotation matrix.\r\n * @returns {Matrix4} The modified result parameter.\r\n *\r\n * @see Matrix4.fromRotation\r\n * @see Matrix4.getRotation\r\n */\r\nMatrix4.setRotation = function (matrix, rotation, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  const scale = Matrix4.getScale(matrix, scaleScratch4);\r\n\r\n  result[0] = rotation[0] * scale.x;\r\n  result[1] = rotation[1] * scale.x;\r\n  result[2] = rotation[2] * scale.x;\r\n  result[3] = matrix[3];\r\n\r\n  result[4] = rotation[3] * scale.y;\r\n  result[5] = rotation[4] * scale.y;\r\n  result[6] = rotation[5] * scale.y;\r\n  result[7] = matrix[7];\r\n\r\n  result[8] = rotation[6] * scale.z;\r\n  result[9] = rotation[7] * scale.z;\r\n  result[10] = rotation[8] * scale.z;\r\n  result[11] = matrix[11];\r\n\r\n  result[12] = matrix[12];\r\n  result[13] = matrix[13];\r\n  result[14] = matrix[14];\r\n  result[15] = matrix[15];\r\n\r\n  return result;\r\n};\r\n\r\nconst scaleScratch5 = new Cartesian3();\r\n\r\n/**\r\n * Extracts the rotation matrix assuming the matrix is an affine transformation.\r\n *\r\n * @param {Matrix4} matrix The matrix.\r\n * @param {Matrix4} result The object onto which to store the result.\r\n * @returns {Matrix4} The modified result parameter.\r\n *\r\n * @see Matrix4.setRotation\r\n * @see Matrix4.fromRotation\r\n */\r\nMatrix4.getRotation = function (matrix, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  const scale = Matrix4.getScale(matrix, scaleScratch5);\r\n\r\n  result[0] = matrix[0] / scale.x;\r\n  result[1] = matrix[1] / scale.x;\r\n  result[2] = matrix[2] / scale.x;\r\n\r\n  result[3] = matrix[4] / scale.y;\r\n  result[4] = matrix[5] / scale.y;\r\n  result[5] = matrix[6] / scale.y;\r\n\r\n  result[6] = matrix[8] / scale.z;\r\n  result[7] = matrix[9] / scale.z;\r\n  result[8] = matrix[10] / scale.z;\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the product of two matrices.\r\n *\r\n * @param {Matrix4} left The first matrix.\r\n * @param {Matrix4} right The second matrix.\r\n * @param {Matrix4} result The object onto which to store the result.\r\n * @returns {Matrix4} The modified result parameter.\r\n */\r\nMatrix4.multiply = function (left, right, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"left\", left);\r\n  Check.typeOf.object(\"right\", right);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  const left0 = left[0];\r\n  const left1 = left[1];\r\n  const left2 = left[2];\r\n  const left3 = left[3];\r\n  const left4 = left[4];\r\n  const left5 = left[5];\r\n  const left6 = left[6];\r\n  const left7 = left[7];\r\n  const left8 = left[8];\r\n  const left9 = left[9];\r\n  const left10 = left[10];\r\n  const left11 = left[11];\r\n  const left12 = left[12];\r\n  const left13 = left[13];\r\n  const left14 = left[14];\r\n  const left15 = left[15];\r\n\r\n  const right0 = right[0];\r\n  const right1 = right[1];\r\n  const right2 = right[2];\r\n  const right3 = right[3];\r\n  const right4 = right[4];\r\n  const right5 = right[5];\r\n  const right6 = right[6];\r\n  const right7 = right[7];\r\n  const right8 = right[8];\r\n  const right9 = right[9];\r\n  const right10 = right[10];\r\n  const right11 = right[11];\r\n  const right12 = right[12];\r\n  const right13 = right[13];\r\n  const right14 = right[14];\r\n  const right15 = right[15];\r\n\r\n  const column0Row0 =\r\n    left0 * right0 + left4 * right1 + left8 * right2 + left12 * right3;\r\n  const column0Row1 =\r\n    left1 * right0 + left5 * right1 + left9 * right2 + left13 * right3;\r\n  const column0Row2 =\r\n    left2 * right0 + left6 * right1 + left10 * right2 + left14 * right3;\r\n  const column0Row3 =\r\n    left3 * right0 + left7 * right1 + left11 * right2 + left15 * right3;\r\n\r\n  const column1Row0 =\r\n    left0 * right4 + left4 * right5 + left8 * right6 + left12 * right7;\r\n  const column1Row1 =\r\n    left1 * right4 + left5 * right5 + left9 * right6 + left13 * right7;\r\n  const column1Row2 =\r\n    left2 * right4 + left6 * right5 + left10 * right6 + left14 * right7;\r\n  const column1Row3 =\r\n    left3 * right4 + left7 * right5 + left11 * right6 + left15 * right7;\r\n\r\n  const column2Row0 =\r\n    left0 * right8 + left4 * right9 + left8 * right10 + left12 * right11;\r\n  const column2Row1 =\r\n    left1 * right8 + left5 * right9 + left9 * right10 + left13 * right11;\r\n  const column2Row2 =\r\n    left2 * right8 + left6 * right9 + left10 * right10 + left14 * right11;\r\n  const column2Row3 =\r\n    left3 * right8 + left7 * right9 + left11 * right10 + left15 * right11;\r\n\r\n  const column3Row0 =\r\n    left0 * right12 + left4 * right13 + left8 * right14 + left12 * right15;\r\n  const column3Row1 =\r\n    left1 * right12 + left5 * right13 + left9 * right14 + left13 * right15;\r\n  const column3Row2 =\r\n    left2 * right12 + left6 * right13 + left10 * right14 + left14 * right15;\r\n  const column3Row3 =\r\n    left3 * right12 + left7 * right13 + left11 * right14 + left15 * right15;\r\n\r\n  result[0] = column0Row0;\r\n  result[1] = column0Row1;\r\n  result[2] = column0Row2;\r\n  result[3] = column0Row3;\r\n  result[4] = column1Row0;\r\n  result[5] = column1Row1;\r\n  result[6] = column1Row2;\r\n  result[7] = column1Row3;\r\n  result[8] = column2Row0;\r\n  result[9] = column2Row1;\r\n  result[10] = column2Row2;\r\n  result[11] = column2Row3;\r\n  result[12] = column3Row0;\r\n  result[13] = column3Row1;\r\n  result[14] = column3Row2;\r\n  result[15] = column3Row3;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the sum of two matrices.\r\n *\r\n * @param {Matrix4} left The first matrix.\r\n * @param {Matrix4} right The second matrix.\r\n * @param {Matrix4} result The object onto which to store the result.\r\n * @returns {Matrix4} The modified result parameter.\r\n */\r\nMatrix4.add = function (left, right, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"left\", left);\r\n  Check.typeOf.object(\"right\", right);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result[0] = left[0] + right[0];\r\n  result[1] = left[1] + right[1];\r\n  result[2] = left[2] + right[2];\r\n  result[3] = left[3] + right[3];\r\n  result[4] = left[4] + right[4];\r\n  result[5] = left[5] + right[5];\r\n  result[6] = left[6] + right[6];\r\n  result[7] = left[7] + right[7];\r\n  result[8] = left[8] + right[8];\r\n  result[9] = left[9] + right[9];\r\n  result[10] = left[10] + right[10];\r\n  result[11] = left[11] + right[11];\r\n  result[12] = left[12] + right[12];\r\n  result[13] = left[13] + right[13];\r\n  result[14] = left[14] + right[14];\r\n  result[15] = left[15] + right[15];\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the difference of two matrices.\r\n *\r\n * @param {Matrix4} left The first matrix.\r\n * @param {Matrix4} right The second matrix.\r\n * @param {Matrix4} result The object onto which to store the result.\r\n * @returns {Matrix4} The modified result parameter.\r\n */\r\nMatrix4.subtract = function (left, right, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"left\", left);\r\n  Check.typeOf.object(\"right\", right);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result[0] = left[0] - right[0];\r\n  result[1] = left[1] - right[1];\r\n  result[2] = left[2] - right[2];\r\n  result[3] = left[3] - right[3];\r\n  result[4] = left[4] - right[4];\r\n  result[5] = left[5] - right[5];\r\n  result[6] = left[6] - right[6];\r\n  result[7] = left[7] - right[7];\r\n  result[8] = left[8] - right[8];\r\n  result[9] = left[9] - right[9];\r\n  result[10] = left[10] - right[10];\r\n  result[11] = left[11] - right[11];\r\n  result[12] = left[12] - right[12];\r\n  result[13] = left[13] - right[13];\r\n  result[14] = left[14] - right[14];\r\n  result[15] = left[15] - right[15];\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the product of two matrices assuming the matrices are affine transformation matrices,\r\n * where the upper left 3x3 elements are any matrix, and\r\n * the upper three elements in the fourth column are the translation.\r\n * The bottom row is assumed to be [0, 0, 0, 1].\r\n * The matrix is not verified to be in the proper form.\r\n * This method is faster than computing the product for general 4x4\r\n * matrices using {@link Matrix4.multiply}.\r\n *\r\n * @param {Matrix4} left The first matrix.\r\n * @param {Matrix4} right The second matrix.\r\n * @param {Matrix4} result The object onto which to store the result.\r\n * @returns {Matrix4} The modified result parameter.\r\n *\r\n * @example\r\n * const m1 = new Cesium.Matrix4(1.0, 6.0, 7.0, 0.0, 2.0, 5.0, 8.0, 0.0, 3.0, 4.0, 9.0, 0.0, 0.0, 0.0, 0.0, 1.0);\r\n * const m2 = Cesium.Transforms.eastNorthUpToFixedFrame(new Cesium.Cartesian3(1.0, 1.0, 1.0));\r\n * const m3 = Cesium.Matrix4.multiplyTransformation(m1, m2, new Cesium.Matrix4());\r\n */\r\nMatrix4.multiplyTransformation = function (left, right, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"left\", left);\r\n  Check.typeOf.object(\"right\", right);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  const left0 = left[0];\r\n  const left1 = left[1];\r\n  const left2 = left[2];\r\n  const left4 = left[4];\r\n  const left5 = left[5];\r\n  const left6 = left[6];\r\n  const left8 = left[8];\r\n  const left9 = left[9];\r\n  const left10 = left[10];\r\n  const left12 = left[12];\r\n  const left13 = left[13];\r\n  const left14 = left[14];\r\n\r\n  const right0 = right[0];\r\n  const right1 = right[1];\r\n  const right2 = right[2];\r\n  const right4 = right[4];\r\n  const right5 = right[5];\r\n  const right6 = right[6];\r\n  const right8 = right[8];\r\n  const right9 = right[9];\r\n  const right10 = right[10];\r\n  const right12 = right[12];\r\n  const right13 = right[13];\r\n  const right14 = right[14];\r\n\r\n  const column0Row0 = left0 * right0 + left4 * right1 + left8 * right2;\r\n  const column0Row1 = left1 * right0 + left5 * right1 + left9 * right2;\r\n  const column0Row2 = left2 * right0 + left6 * right1 + left10 * right2;\r\n\r\n  const column1Row0 = left0 * right4 + left4 * right5 + left8 * right6;\r\n  const column1Row1 = left1 * right4 + left5 * right5 + left9 * right6;\r\n  const column1Row2 = left2 * right4 + left6 * right5 + left10 * right6;\r\n\r\n  const column2Row0 = left0 * right8 + left4 * right9 + left8 * right10;\r\n  const column2Row1 = left1 * right8 + left5 * right9 + left9 * right10;\r\n  const column2Row2 = left2 * right8 + left6 * right9 + left10 * right10;\r\n\r\n  const column3Row0 =\r\n    left0 * right12 + left4 * right13 + left8 * right14 + left12;\r\n  const column3Row1 =\r\n    left1 * right12 + left5 * right13 + left9 * right14 + left13;\r\n  const column3Row2 =\r\n    left2 * right12 + left6 * right13 + left10 * right14 + left14;\r\n\r\n  result[0] = column0Row0;\r\n  result[1] = column0Row1;\r\n  result[2] = column0Row2;\r\n  result[3] = 0.0;\r\n  result[4] = column1Row0;\r\n  result[5] = column1Row1;\r\n  result[6] = column1Row2;\r\n  result[7] = 0.0;\r\n  result[8] = column2Row0;\r\n  result[9] = column2Row1;\r\n  result[10] = column2Row2;\r\n  result[11] = 0.0;\r\n  result[12] = column3Row0;\r\n  result[13] = column3Row1;\r\n  result[14] = column3Row2;\r\n  result[15] = 1.0;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Multiplies a transformation matrix (with a bottom row of <code>[0.0, 0.0, 0.0, 1.0]</code>)\r\n * by a 3x3 rotation matrix.  This is an optimization\r\n * for <code>Matrix4.multiply(m, Matrix4.fromRotationTranslation(rotation), m);</code> with less allocations and arithmetic operations.\r\n *\r\n * @param {Matrix4} matrix The matrix on the left-hand side.\r\n * @param {Matrix3} rotation The 3x3 rotation matrix on the right-hand side.\r\n * @param {Matrix4} result The object onto which to store the result.\r\n * @returns {Matrix4} The modified result parameter.\r\n *\r\n * @example\r\n * // Instead of Cesium.Matrix4.multiply(m, Cesium.Matrix4.fromRotationTranslation(rotation), m);\r\n * Cesium.Matrix4.multiplyByMatrix3(m, rotation, m);\r\n */\r\nMatrix4.multiplyByMatrix3 = function (matrix, rotation, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  Check.typeOf.object(\"rotation\", rotation);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  const left0 = matrix[0];\r\n  const left1 = matrix[1];\r\n  const left2 = matrix[2];\r\n  const left4 = matrix[4];\r\n  const left5 = matrix[5];\r\n  const left6 = matrix[6];\r\n  const left8 = matrix[8];\r\n  const left9 = matrix[9];\r\n  const left10 = matrix[10];\r\n\r\n  const right0 = rotation[0];\r\n  const right1 = rotation[1];\r\n  const right2 = rotation[2];\r\n  const right4 = rotation[3];\r\n  const right5 = rotation[4];\r\n  const right6 = rotation[5];\r\n  const right8 = rotation[6];\r\n  const right9 = rotation[7];\r\n  const right10 = rotation[8];\r\n\r\n  const column0Row0 = left0 * right0 + left4 * right1 + left8 * right2;\r\n  const column0Row1 = left1 * right0 + left5 * right1 + left9 * right2;\r\n  const column0Row2 = left2 * right0 + left6 * right1 + left10 * right2;\r\n\r\n  const column1Row0 = left0 * right4 + left4 * right5 + left8 * right6;\r\n  const column1Row1 = left1 * right4 + left5 * right5 + left9 * right6;\r\n  const column1Row2 = left2 * right4 + left6 * right5 + left10 * right6;\r\n\r\n  const column2Row0 = left0 * right8 + left4 * right9 + left8 * right10;\r\n  const column2Row1 = left1 * right8 + left5 * right9 + left9 * right10;\r\n  const column2Row2 = left2 * right8 + left6 * right9 + left10 * right10;\r\n\r\n  result[0] = column0Row0;\r\n  result[1] = column0Row1;\r\n  result[2] = column0Row2;\r\n  result[3] = 0.0;\r\n  result[4] = column1Row0;\r\n  result[5] = column1Row1;\r\n  result[6] = column1Row2;\r\n  result[7] = 0.0;\r\n  result[8] = column2Row0;\r\n  result[9] = column2Row1;\r\n  result[10] = column2Row2;\r\n  result[11] = 0.0;\r\n  result[12] = matrix[12];\r\n  result[13] = matrix[13];\r\n  result[14] = matrix[14];\r\n  result[15] = matrix[15];\r\n  return result;\r\n};\r\n\r\n/**\r\n * Multiplies a transformation matrix (with a bottom row of <code>[0.0, 0.0, 0.0, 1.0]</code>)\r\n * by an implicit translation matrix defined by a {@link Cartesian3}.  This is an optimization\r\n * for <code>Matrix4.multiply(m, Matrix4.fromTranslation(position), m);</code> with less allocations and arithmetic operations.\r\n *\r\n * @param {Matrix4} matrix The matrix on the left-hand side.\r\n * @param {Cartesian3} translation The translation on the right-hand side.\r\n * @param {Matrix4} result The object onto which to store the result.\r\n * @returns {Matrix4} The modified result parameter.\r\n *\r\n * @example\r\n * // Instead of Cesium.Matrix4.multiply(m, Cesium.Matrix4.fromTranslation(position), m);\r\n * Cesium.Matrix4.multiplyByTranslation(m, position, m);\r\n */\r\nMatrix4.multiplyByTranslation = function (matrix, translation, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  Check.typeOf.object(\"translation\", translation);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  const x = translation.x;\r\n  const y = translation.y;\r\n  const z = translation.z;\r\n\r\n  const tx = x * matrix[0] + y * matrix[4] + z * matrix[8] + matrix[12];\r\n  const ty = x * matrix[1] + y * matrix[5] + z * matrix[9] + matrix[13];\r\n  const tz = x * matrix[2] + y * matrix[6] + z * matrix[10] + matrix[14];\r\n\r\n  result[0] = matrix[0];\r\n  result[1] = matrix[1];\r\n  result[2] = matrix[2];\r\n  result[3] = matrix[3];\r\n  result[4] = matrix[4];\r\n  result[5] = matrix[5];\r\n  result[6] = matrix[6];\r\n  result[7] = matrix[7];\r\n  result[8] = matrix[8];\r\n  result[9] = matrix[9];\r\n  result[10] = matrix[10];\r\n  result[11] = matrix[11];\r\n  result[12] = tx;\r\n  result[13] = ty;\r\n  result[14] = tz;\r\n  result[15] = matrix[15];\r\n  return result;\r\n};\r\n\r\n/**\r\n * Multiplies an affine transformation matrix (with a bottom row of <code>[0.0, 0.0, 0.0, 1.0]</code>)\r\n * by an implicit non-uniform scale matrix. This is an optimization\r\n * for <code>Matrix4.multiply(m, Matrix4.fromUniformScale(scale), m);</code>, where\r\n * <code>m</code> must be an affine matrix.\r\n * This function performs fewer allocations and arithmetic operations.\r\n *\r\n * @param {Matrix4} matrix The affine matrix on the left-hand side.\r\n * @param {Cartesian3} scale The non-uniform scale on the right-hand side.\r\n * @param {Matrix4} result The object onto which to store the result.\r\n * @returns {Matrix4} The modified result parameter.\r\n *\r\n *\r\n * @example\r\n * // Instead of Cesium.Matrix4.multiply(m, Cesium.Matrix4.fromScale(scale), m);\r\n * Cesium.Matrix4.multiplyByScale(m, scale, m);\r\n *\r\n * @see Matrix4.multiplyByUniformScale\r\n * @see Matrix4.fromScale\r\n * @see Matrix4.fromUniformScale\r\n * @see Matrix4.setScale\r\n * @see Matrix4.setUniformScale\r\n * @see Matrix4.getScale\r\n */\r\nMatrix4.multiplyByScale = function (matrix, scale, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  Check.typeOf.object(\"scale\", scale);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  const scaleX = scale.x;\r\n  const scaleY = scale.y;\r\n  const scaleZ = scale.z;\r\n\r\n  // Faster than Cartesian3.equals\r\n  if (scaleX === 1.0 && scaleY === 1.0 && scaleZ === 1.0) {\r\n    return Matrix4.clone(matrix, result);\r\n  }\r\n\r\n  result[0] = scaleX * matrix[0];\r\n  result[1] = scaleX * matrix[1];\r\n  result[2] = scaleX * matrix[2];\r\n  result[3] = matrix[3];\r\n\r\n  result[4] = scaleY * matrix[4];\r\n  result[5] = scaleY * matrix[5];\r\n  result[6] = scaleY * matrix[6];\r\n  result[7] = matrix[7];\r\n\r\n  result[8] = scaleZ * matrix[8];\r\n  result[9] = scaleZ * matrix[9];\r\n  result[10] = scaleZ * matrix[10];\r\n  result[11] = matrix[11];\r\n\r\n  result[12] = matrix[12];\r\n  result[13] = matrix[13];\r\n  result[14] = matrix[14];\r\n  result[15] = matrix[15];\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the product of a matrix times a uniform scale, as if the scale were a scale matrix.\r\n *\r\n * @param {Matrix4} matrix The matrix on the left-hand side.\r\n * @param {Number} scale The uniform scale on the right-hand side.\r\n * @param {Matrix4} result The object onto which to store the result.\r\n * @returns {Matrix4} The modified result parameter.\r\n *\r\n * @example\r\n * // Instead of Cesium.Matrix4.multiply(m, Cesium.Matrix4.fromUniformScale(scale), m);\r\n * Cesium.Matrix4.multiplyByUniformScale(m, scale, m);\r\n *\r\n * @see Matrix4.multiplyByScale\r\n * @see Matrix4.fromScale\r\n * @see Matrix4.fromUniformScale\r\n * @see Matrix4.setScale\r\n * @see Matrix4.setUniformScale\r\n * @see Matrix4.getScale\r\n */\r\nMatrix4.multiplyByUniformScale = function (matrix, scale, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  Check.typeOf.number(\"scale\", scale);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result[0] = matrix[0] * scale;\r\n  result[1] = matrix[1] * scale;\r\n  result[2] = matrix[2] * scale;\r\n  result[3] = matrix[3];\r\n\r\n  result[4] = matrix[4] * scale;\r\n  result[5] = matrix[5] * scale;\r\n  result[6] = matrix[6] * scale;\r\n  result[7] = matrix[7];\r\n\r\n  result[8] = matrix[8] * scale;\r\n  result[9] = matrix[9] * scale;\r\n  result[10] = matrix[10] * scale;\r\n  result[11] = matrix[11];\r\n\r\n  result[12] = matrix[12];\r\n  result[13] = matrix[13];\r\n  result[14] = matrix[14];\r\n  result[15] = matrix[15];\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the product of a matrix and a column vector.\r\n *\r\n * @param {Matrix4} matrix The matrix.\r\n * @param {Cartesian4} cartesian The vector.\r\n * @param {Cartesian4} result The object onto which to store the result.\r\n * @returns {Cartesian4} The modified result parameter.\r\n */\r\nMatrix4.multiplyByVector = function (matrix, cartesian, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  Check.typeOf.object(\"cartesian\", cartesian);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  const vX = cartesian.x;\r\n  const vY = cartesian.y;\r\n  const vZ = cartesian.z;\r\n  const vW = cartesian.w;\r\n\r\n  const x = matrix[0] * vX + matrix[4] * vY + matrix[8] * vZ + matrix[12] * vW;\r\n  const y = matrix[1] * vX + matrix[5] * vY + matrix[9] * vZ + matrix[13] * vW;\r\n  const z = matrix[2] * vX + matrix[6] * vY + matrix[10] * vZ + matrix[14] * vW;\r\n  const w = matrix[3] * vX + matrix[7] * vY + matrix[11] * vZ + matrix[15] * vW;\r\n\r\n  result.x = x;\r\n  result.y = y;\r\n  result.z = z;\r\n  result.w = w;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the product of a matrix and a {@link Cartesian3}.  This is equivalent to calling {@link Matrix4.multiplyByVector}\r\n * with a {@link Cartesian4} with a <code>w</code> component of zero.\r\n *\r\n * @param {Matrix4} matrix The matrix.\r\n * @param {Cartesian3} cartesian The point.\r\n * @param {Cartesian3} result The object onto which to store the result.\r\n * @returns {Cartesian3} The modified result parameter.\r\n *\r\n * @example\r\n * const p = new Cesium.Cartesian3(1.0, 2.0, 3.0);\r\n * const result = Cesium.Matrix4.multiplyByPointAsVector(matrix, p, new Cesium.Cartesian3());\r\n * // A shortcut for\r\n * //   Cartesian3 p = ...\r\n * //   Cesium.Matrix4.multiplyByVector(matrix, new Cesium.Cartesian4(p.x, p.y, p.z, 0.0), result);\r\n */\r\nMatrix4.multiplyByPointAsVector = function (matrix, cartesian, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  Check.typeOf.object(\"cartesian\", cartesian);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  const vX = cartesian.x;\r\n  const vY = cartesian.y;\r\n  const vZ = cartesian.z;\r\n\r\n  const x = matrix[0] * vX + matrix[4] * vY + matrix[8] * vZ;\r\n  const y = matrix[1] * vX + matrix[5] * vY + matrix[9] * vZ;\r\n  const z = matrix[2] * vX + matrix[6] * vY + matrix[10] * vZ;\r\n\r\n  result.x = x;\r\n  result.y = y;\r\n  result.z = z;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the product of a matrix and a {@link Cartesian3}. This is equivalent to calling {@link Matrix4.multiplyByVector}\r\n * with a {@link Cartesian4} with a <code>w</code> component of 1, but returns a {@link Cartesian3} instead of a {@link Cartesian4}.\r\n *\r\n * @param {Matrix4} matrix The matrix.\r\n * @param {Cartesian3} cartesian The point.\r\n * @param {Cartesian3} result The object onto which to store the result.\r\n * @returns {Cartesian3} The modified result parameter.\r\n *\r\n * @example\r\n * const p = new Cesium.Cartesian3(1.0, 2.0, 3.0);\r\n * const result = Cesium.Matrix4.multiplyByPoint(matrix, p, new Cesium.Cartesian3());\r\n */\r\nMatrix4.multiplyByPoint = function (matrix, cartesian, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  Check.typeOf.object(\"cartesian\", cartesian);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  const vX = cartesian.x;\r\n  const vY = cartesian.y;\r\n  const vZ = cartesian.z;\r\n\r\n  const x = matrix[0] * vX + matrix[4] * vY + matrix[8] * vZ + matrix[12];\r\n  const y = matrix[1] * vX + matrix[5] * vY + matrix[9] * vZ + matrix[13];\r\n  const z = matrix[2] * vX + matrix[6] * vY + matrix[10] * vZ + matrix[14];\r\n\r\n  result.x = x;\r\n  result.y = y;\r\n  result.z = z;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the product of a matrix and a scalar.\r\n *\r\n * @param {Matrix4} matrix The matrix.\r\n * @param {Number} scalar The number to multiply by.\r\n * @param {Matrix4} result The object onto which to store the result.\r\n * @returns {Matrix4} The modified result parameter.\r\n *\r\n * @example\r\n * //create a Matrix4 instance which is a scaled version of the supplied Matrix4\r\n * // m = [10.0, 11.0, 12.0, 13.0]\r\n * //     [14.0, 15.0, 16.0, 17.0]\r\n * //     [18.0, 19.0, 20.0, 21.0]\r\n * //     [22.0, 23.0, 24.0, 25.0]\r\n *\r\n * const a = Cesium.Matrix4.multiplyByScalar(m, -2, new Cesium.Matrix4());\r\n *\r\n * // m remains the same\r\n * // a = [-20.0, -22.0, -24.0, -26.0]\r\n * //     [-28.0, -30.0, -32.0, -34.0]\r\n * //     [-36.0, -38.0, -40.0, -42.0]\r\n * //     [-44.0, -46.0, -48.0, -50.0]\r\n */\r\nMatrix4.multiplyByScalar = function (matrix, scalar, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  Check.typeOf.number(\"scalar\", scalar);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result[0] = matrix[0] * scalar;\r\n  result[1] = matrix[1] * scalar;\r\n  result[2] = matrix[2] * scalar;\r\n  result[3] = matrix[3] * scalar;\r\n  result[4] = matrix[4] * scalar;\r\n  result[5] = matrix[5] * scalar;\r\n  result[6] = matrix[6] * scalar;\r\n  result[7] = matrix[7] * scalar;\r\n  result[8] = matrix[8] * scalar;\r\n  result[9] = matrix[9] * scalar;\r\n  result[10] = matrix[10] * scalar;\r\n  result[11] = matrix[11] * scalar;\r\n  result[12] = matrix[12] * scalar;\r\n  result[13] = matrix[13] * scalar;\r\n  result[14] = matrix[14] * scalar;\r\n  result[15] = matrix[15] * scalar;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes a negated copy of the provided matrix.\r\n *\r\n * @param {Matrix4} matrix The matrix to negate.\r\n * @param {Matrix4} result The object onto which to store the result.\r\n * @returns {Matrix4} The modified result parameter.\r\n *\r\n * @example\r\n * //create a new Matrix4 instance which is a negation of a Matrix4\r\n * // m = [10.0, 11.0, 12.0, 13.0]\r\n * //     [14.0, 15.0, 16.0, 17.0]\r\n * //     [18.0, 19.0, 20.0, 21.0]\r\n * //     [22.0, 23.0, 24.0, 25.0]\r\n *\r\n * const a = Cesium.Matrix4.negate(m, new Cesium.Matrix4());\r\n *\r\n * // m remains the same\r\n * // a = [-10.0, -11.0, -12.0, -13.0]\r\n * //     [-14.0, -15.0, -16.0, -17.0]\r\n * //     [-18.0, -19.0, -20.0, -21.0]\r\n * //     [-22.0, -23.0, -24.0, -25.0]\r\n */\r\nMatrix4.negate = function (matrix, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result[0] = -matrix[0];\r\n  result[1] = -matrix[1];\r\n  result[2] = -matrix[2];\r\n  result[3] = -matrix[3];\r\n  result[4] = -matrix[4];\r\n  result[5] = -matrix[5];\r\n  result[6] = -matrix[6];\r\n  result[7] = -matrix[7];\r\n  result[8] = -matrix[8];\r\n  result[9] = -matrix[9];\r\n  result[10] = -matrix[10];\r\n  result[11] = -matrix[11];\r\n  result[12] = -matrix[12];\r\n  result[13] = -matrix[13];\r\n  result[14] = -matrix[14];\r\n  result[15] = -matrix[15];\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the transpose of the provided matrix.\r\n *\r\n * @param {Matrix4} matrix The matrix to transpose.\r\n * @param {Matrix4} result The object onto which to store the result.\r\n * @returns {Matrix4} The modified result parameter.\r\n *\r\n * @example\r\n * //returns transpose of a Matrix4\r\n * // m = [10.0, 11.0, 12.0, 13.0]\r\n * //     [14.0, 15.0, 16.0, 17.0]\r\n * //     [18.0, 19.0, 20.0, 21.0]\r\n * //     [22.0, 23.0, 24.0, 25.0]\r\n *\r\n * const a = Cesium.Matrix4.transpose(m, new Cesium.Matrix4());\r\n *\r\n * // m remains the same\r\n * // a = [10.0, 14.0, 18.0, 22.0]\r\n * //     [11.0, 15.0, 19.0, 23.0]\r\n * //     [12.0, 16.0, 20.0, 24.0]\r\n * //     [13.0, 17.0, 21.0, 25.0]\r\n */\r\nMatrix4.transpose = function (matrix, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  const matrix1 = matrix[1];\r\n  const matrix2 = matrix[2];\r\n  const matrix3 = matrix[3];\r\n  const matrix6 = matrix[6];\r\n  const matrix7 = matrix[7];\r\n  const matrix11 = matrix[11];\r\n\r\n  result[0] = matrix[0];\r\n  result[1] = matrix[4];\r\n  result[2] = matrix[8];\r\n  result[3] = matrix[12];\r\n  result[4] = matrix1;\r\n  result[5] = matrix[5];\r\n  result[6] = matrix[9];\r\n  result[7] = matrix[13];\r\n  result[8] = matrix2;\r\n  result[9] = matrix6;\r\n  result[10] = matrix[10];\r\n  result[11] = matrix[14];\r\n  result[12] = matrix3;\r\n  result[13] = matrix7;\r\n  result[14] = matrix11;\r\n  result[15] = matrix[15];\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes a matrix, which contains the absolute (unsigned) values of the provided matrix's elements.\r\n *\r\n * @param {Matrix4} matrix The matrix with signed elements.\r\n * @param {Matrix4} result The object onto which to store the result.\r\n * @returns {Matrix4} The modified result parameter.\r\n */\r\nMatrix4.abs = function (matrix, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result[0] = Math.abs(matrix[0]);\r\n  result[1] = Math.abs(matrix[1]);\r\n  result[2] = Math.abs(matrix[2]);\r\n  result[3] = Math.abs(matrix[3]);\r\n  result[4] = Math.abs(matrix[4]);\r\n  result[5] = Math.abs(matrix[5]);\r\n  result[6] = Math.abs(matrix[6]);\r\n  result[7] = Math.abs(matrix[7]);\r\n  result[8] = Math.abs(matrix[8]);\r\n  result[9] = Math.abs(matrix[9]);\r\n  result[10] = Math.abs(matrix[10]);\r\n  result[11] = Math.abs(matrix[11]);\r\n  result[12] = Math.abs(matrix[12]);\r\n  result[13] = Math.abs(matrix[13]);\r\n  result[14] = Math.abs(matrix[14]);\r\n  result[15] = Math.abs(matrix[15]);\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Compares the provided matrices componentwise and returns\r\n * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n *\r\n * @param {Matrix4} [left] The first matrix.\r\n * @param {Matrix4} [right] The second matrix.\r\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\r\n *\r\n * @example\r\n * //compares two Matrix4 instances\r\n *\r\n * // a = [10.0, 14.0, 18.0, 22.0]\r\n * //     [11.0, 15.0, 19.0, 23.0]\r\n * //     [12.0, 16.0, 20.0, 24.0]\r\n * //     [13.0, 17.0, 21.0, 25.0]\r\n *\r\n * // b = [10.0, 14.0, 18.0, 22.0]\r\n * //     [11.0, 15.0, 19.0, 23.0]\r\n * //     [12.0, 16.0, 20.0, 24.0]\r\n * //     [13.0, 17.0, 21.0, 25.0]\r\n *\r\n * if(Cesium.Matrix4.equals(a,b)) {\r\n *      console.log(\"Both matrices are equal\");\r\n * } else {\r\n *      console.log(\"They are not equal\");\r\n * }\r\n *\r\n * //Prints \"Both matrices are equal\" on the console\r\n */\r\nMatrix4.equals = function (left, right) {\r\n  // Given that most matrices will be transformation matrices, the elements\r\n  // are tested in order such that the test is likely to fail as early\r\n  // as possible.  I _think_ this is just as friendly to the L1 cache\r\n  // as testing in index order.  It is certainty faster in practice.\r\n  return (\r\n    left === right ||\r\n    (defined(left) &&\r\n      defined(right) &&\r\n      // Translation\r\n      left[12] === right[12] &&\r\n      left[13] === right[13] &&\r\n      left[14] === right[14] &&\r\n      // Rotation/scale\r\n      left[0] === right[0] &&\r\n      left[1] === right[1] &&\r\n      left[2] === right[2] &&\r\n      left[4] === right[4] &&\r\n      left[5] === right[5] &&\r\n      left[6] === right[6] &&\r\n      left[8] === right[8] &&\r\n      left[9] === right[9] &&\r\n      left[10] === right[10] &&\r\n      // Bottom row\r\n      left[3] === right[3] &&\r\n      left[7] === right[7] &&\r\n      left[11] === right[11] &&\r\n      left[15] === right[15])\r\n  );\r\n};\r\n\r\n/**\r\n * Compares the provided matrices componentwise and returns\r\n * <code>true</code> if they are within the provided epsilon,\r\n * <code>false</code> otherwise.\r\n *\r\n * @param {Matrix4} [left] The first matrix.\r\n * @param {Matrix4} [right] The second matrix.\r\n * @param {Number} [epsilon=0] The epsilon to use for equality testing.\r\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\r\n *\r\n * @example\r\n * //compares two Matrix4 instances\r\n *\r\n * // a = [10.5, 14.5, 18.5, 22.5]\r\n * //     [11.5, 15.5, 19.5, 23.5]\r\n * //     [12.5, 16.5, 20.5, 24.5]\r\n * //     [13.5, 17.5, 21.5, 25.5]\r\n *\r\n * // b = [10.0, 14.0, 18.0, 22.0]\r\n * //     [11.0, 15.0, 19.0, 23.0]\r\n * //     [12.0, 16.0, 20.0, 24.0]\r\n * //     [13.0, 17.0, 21.0, 25.0]\r\n *\r\n * if(Cesium.Matrix4.equalsEpsilon(a,b,0.1)){\r\n *      console.log(\"Difference between both the matrices is less than 0.1\");\r\n * } else {\r\n *      console.log(\"Difference between both the matrices is not less than 0.1\");\r\n * }\r\n *\r\n * //Prints \"Difference between both the matrices is not less than 0.1\" on the console\r\n */\r\nMatrix4.equalsEpsilon = function (left, right, epsilon) {\r\n  epsilon = defaultValue(epsilon, 0);\r\n\r\n  return (\r\n    left === right ||\r\n    (defined(left) &&\r\n      defined(right) &&\r\n      Math.abs(left[0] - right[0]) <= epsilon &&\r\n      Math.abs(left[1] - right[1]) <= epsilon &&\r\n      Math.abs(left[2] - right[2]) <= epsilon &&\r\n      Math.abs(left[3] - right[3]) <= epsilon &&\r\n      Math.abs(left[4] - right[4]) <= epsilon &&\r\n      Math.abs(left[5] - right[5]) <= epsilon &&\r\n      Math.abs(left[6] - right[6]) <= epsilon &&\r\n      Math.abs(left[7] - right[7]) <= epsilon &&\r\n      Math.abs(left[8] - right[8]) <= epsilon &&\r\n      Math.abs(left[9] - right[9]) <= epsilon &&\r\n      Math.abs(left[10] - right[10]) <= epsilon &&\r\n      Math.abs(left[11] - right[11]) <= epsilon &&\r\n      Math.abs(left[12] - right[12]) <= epsilon &&\r\n      Math.abs(left[13] - right[13]) <= epsilon &&\r\n      Math.abs(left[14] - right[14]) <= epsilon &&\r\n      Math.abs(left[15] - right[15]) <= epsilon)\r\n  );\r\n};\r\n\r\n/**\r\n * Gets the translation portion of the provided matrix, assuming the matrix is an affine transformation matrix.\r\n *\r\n * @param {Matrix4} matrix The matrix to use.\r\n * @param {Cartesian3} result The object onto which to store the result.\r\n * @returns {Cartesian3} The modified result parameter.\r\n */\r\nMatrix4.getTranslation = function (matrix, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result.x = matrix[12];\r\n  result.y = matrix[13];\r\n  result.z = matrix[14];\r\n  return result;\r\n};\r\n\r\n/**\r\n * Gets the upper left 3x3 matrix of the provided matrix.\r\n *\r\n * @param {Matrix4} matrix The matrix to use.\r\n * @param {Matrix3} result The object onto which to store the result.\r\n * @returns {Matrix3} The modified result parameter.\r\n *\r\n * @example\r\n * // returns a Matrix3 instance from a Matrix4 instance\r\n *\r\n * // m = [10.0, 14.0, 18.0, 22.0]\r\n * //     [11.0, 15.0, 19.0, 23.0]\r\n * //     [12.0, 16.0, 20.0, 24.0]\r\n * //     [13.0, 17.0, 21.0, 25.0]\r\n *\r\n * const b = new Cesium.Matrix3();\r\n * Cesium.Matrix4.getMatrix3(m,b);\r\n *\r\n * // b = [10.0, 14.0, 18.0]\r\n * //     [11.0, 15.0, 19.0]\r\n * //     [12.0, 16.0, 20.0]\r\n */\r\nMatrix4.getMatrix3 = function (matrix, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result[0] = matrix[0];\r\n  result[1] = matrix[1];\r\n  result[2] = matrix[2];\r\n  result[3] = matrix[4];\r\n  result[4] = matrix[5];\r\n  result[5] = matrix[6];\r\n  result[6] = matrix[8];\r\n  result[7] = matrix[9];\r\n  result[8] = matrix[10];\r\n  return result;\r\n};\r\n\r\nconst scratchInverseRotation = new Matrix3();\r\nconst scratchMatrix3Zero = new Matrix3();\r\nconst scratchBottomRow = new Cartesian4();\r\nconst scratchExpectedBottomRow = new Cartesian4(0.0, 0.0, 0.0, 1.0);\r\n\r\n/**\r\n * Computes the inverse of the provided matrix using Cramers Rule.\r\n * If the determinant is zero, the matrix can not be inverted, and an exception is thrown.\r\n * If the matrix is a proper rigid transformation, it is more efficient\r\n * to invert it with {@link Matrix4.inverseTransformation}.\r\n *\r\n * @param {Matrix4} matrix The matrix to invert.\r\n * @param {Matrix4} result The object onto which to store the result.\r\n * @returns {Matrix4} The modified result parameter.\r\n *\r\n * @exception {RuntimeError} matrix is not invertible because its determinate is zero.\r\n */\r\nMatrix4.inverse = function (matrix, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n  //\r\n  // Ported from:\r\n  //   ftp://download.intel.com/design/PentiumIII/sml/24504301.pdf\r\n  //\r\n  const src0 = matrix[0];\r\n  const src1 = matrix[4];\r\n  const src2 = matrix[8];\r\n  const src3 = matrix[12];\r\n  const src4 = matrix[1];\r\n  const src5 = matrix[5];\r\n  const src6 = matrix[9];\r\n  const src7 = matrix[13];\r\n  const src8 = matrix[2];\r\n  const src9 = matrix[6];\r\n  const src10 = matrix[10];\r\n  const src11 = matrix[14];\r\n  const src12 = matrix[3];\r\n  const src13 = matrix[7];\r\n  const src14 = matrix[11];\r\n  const src15 = matrix[15];\r\n\r\n  // calculate pairs for first 8 elements (cofactors)\r\n  let tmp0 = src10 * src15;\r\n  let tmp1 = src11 * src14;\r\n  let tmp2 = src9 * src15;\r\n  let tmp3 = src11 * src13;\r\n  let tmp4 = src9 * src14;\r\n  let tmp5 = src10 * src13;\r\n  let tmp6 = src8 * src15;\r\n  let tmp7 = src11 * src12;\r\n  let tmp8 = src8 * src14;\r\n  let tmp9 = src10 * src12;\r\n  let tmp10 = src8 * src13;\r\n  let tmp11 = src9 * src12;\r\n\r\n  // calculate first 8 elements (cofactors)\r\n  const dst0 =\r\n    tmp0 * src5 +\r\n    tmp3 * src6 +\r\n    tmp4 * src7 -\r\n    (tmp1 * src5 + tmp2 * src6 + tmp5 * src7);\r\n  const dst1 =\r\n    tmp1 * src4 +\r\n    tmp6 * src6 +\r\n    tmp9 * src7 -\r\n    (tmp0 * src4 + tmp7 * src6 + tmp8 * src7);\r\n  const dst2 =\r\n    tmp2 * src4 +\r\n    tmp7 * src5 +\r\n    tmp10 * src7 -\r\n    (tmp3 * src4 + tmp6 * src5 + tmp11 * src7);\r\n  const dst3 =\r\n    tmp5 * src4 +\r\n    tmp8 * src5 +\r\n    tmp11 * src6 -\r\n    (tmp4 * src4 + tmp9 * src5 + tmp10 * src6);\r\n  const dst4 =\r\n    tmp1 * src1 +\r\n    tmp2 * src2 +\r\n    tmp5 * src3 -\r\n    (tmp0 * src1 + tmp3 * src2 + tmp4 * src3);\r\n  const dst5 =\r\n    tmp0 * src0 +\r\n    tmp7 * src2 +\r\n    tmp8 * src3 -\r\n    (tmp1 * src0 + tmp6 * src2 + tmp9 * src3);\r\n  const dst6 =\r\n    tmp3 * src0 +\r\n    tmp6 * src1 +\r\n    tmp11 * src3 -\r\n    (tmp2 * src0 + tmp7 * src1 + tmp10 * src3);\r\n  const dst7 =\r\n    tmp4 * src0 +\r\n    tmp9 * src1 +\r\n    tmp10 * src2 -\r\n    (tmp5 * src0 + tmp8 * src1 + tmp11 * src2);\r\n\r\n  // calculate pairs for second 8 elements (cofactors)\r\n  tmp0 = src2 * src7;\r\n  tmp1 = src3 * src6;\r\n  tmp2 = src1 * src7;\r\n  tmp3 = src3 * src5;\r\n  tmp4 = src1 * src6;\r\n  tmp5 = src2 * src5;\r\n  tmp6 = src0 * src7;\r\n  tmp7 = src3 * src4;\r\n  tmp8 = src0 * src6;\r\n  tmp9 = src2 * src4;\r\n  tmp10 = src0 * src5;\r\n  tmp11 = src1 * src4;\r\n\r\n  // calculate second 8 elements (cofactors)\r\n  const dst8 =\r\n    tmp0 * src13 +\r\n    tmp3 * src14 +\r\n    tmp4 * src15 -\r\n    (tmp1 * src13 + tmp2 * src14 + tmp5 * src15);\r\n  const dst9 =\r\n    tmp1 * src12 +\r\n    tmp6 * src14 +\r\n    tmp9 * src15 -\r\n    (tmp0 * src12 + tmp7 * src14 + tmp8 * src15);\r\n  const dst10 =\r\n    tmp2 * src12 +\r\n    tmp7 * src13 +\r\n    tmp10 * src15 -\r\n    (tmp3 * src12 + tmp6 * src13 + tmp11 * src15);\r\n  const dst11 =\r\n    tmp5 * src12 +\r\n    tmp8 * src13 +\r\n    tmp11 * src14 -\r\n    (tmp4 * src12 + tmp9 * src13 + tmp10 * src14);\r\n  const dst12 =\r\n    tmp2 * src10 +\r\n    tmp5 * src11 +\r\n    tmp1 * src9 -\r\n    (tmp4 * src11 + tmp0 * src9 + tmp3 * src10);\r\n  const dst13 =\r\n    tmp8 * src11 +\r\n    tmp0 * src8 +\r\n    tmp7 * src10 -\r\n    (tmp6 * src10 + tmp9 * src11 + tmp1 * src8);\r\n  const dst14 =\r\n    tmp6 * src9 +\r\n    tmp11 * src11 +\r\n    tmp3 * src8 -\r\n    (tmp10 * src11 + tmp2 * src8 + tmp7 * src9);\r\n  const dst15 =\r\n    tmp10 * src10 +\r\n    tmp4 * src8 +\r\n    tmp9 * src9 -\r\n    (tmp8 * src9 + tmp11 * src10 + tmp5 * src8);\r\n\r\n  // calculate determinant\r\n  let det = src0 * dst0 + src1 * dst1 + src2 * dst2 + src3 * dst3;\r\n\r\n  if (Math.abs(det) < CesiumMath.EPSILON21) {\r\n    // Special case for a zero scale matrix that can occur, for example,\r\n    // when a model's node has a [0, 0, 0] scale.\r\n    if (\r\n      Matrix3.equalsEpsilon(\r\n        Matrix4.getMatrix3(matrix, scratchInverseRotation),\r\n        scratchMatrix3Zero,\r\n        CesiumMath.EPSILON7\r\n      ) &&\r\n      Cartesian4.equals(\r\n        Matrix4.getRow(matrix, 3, scratchBottomRow),\r\n        scratchExpectedBottomRow\r\n      )\r\n    ) {\r\n      result[0] = 0.0;\r\n      result[1] = 0.0;\r\n      result[2] = 0.0;\r\n      result[3] = 0.0;\r\n      result[4] = 0.0;\r\n      result[5] = 0.0;\r\n      result[6] = 0.0;\r\n      result[7] = 0.0;\r\n      result[8] = 0.0;\r\n      result[9] = 0.0;\r\n      result[10] = 0.0;\r\n      result[11] = 0.0;\r\n      result[12] = -matrix[12];\r\n      result[13] = -matrix[13];\r\n      result[14] = -matrix[14];\r\n      result[15] = 1.0;\r\n      return result;\r\n    }\r\n\r\n    throw new RuntimeError(\r\n      \"matrix is not invertible because its determinate is zero.\"\r\n    );\r\n  }\r\n\r\n  // calculate matrix inverse\r\n  det = 1.0 / det;\r\n\r\n  result[0] = dst0 * det;\r\n  result[1] = dst1 * det;\r\n  result[2] = dst2 * det;\r\n  result[3] = dst3 * det;\r\n  result[4] = dst4 * det;\r\n  result[5] = dst5 * det;\r\n  result[6] = dst6 * det;\r\n  result[7] = dst7 * det;\r\n  result[8] = dst8 * det;\r\n  result[9] = dst9 * det;\r\n  result[10] = dst10 * det;\r\n  result[11] = dst11 * det;\r\n  result[12] = dst12 * det;\r\n  result[13] = dst13 * det;\r\n  result[14] = dst14 * det;\r\n  result[15] = dst15 * det;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the inverse of the provided matrix assuming it is a proper rigid matrix,\r\n * where the upper left 3x3 elements are a rotation matrix,\r\n * and the upper three elements in the fourth column are the translation.\r\n * The bottom row is assumed to be [0, 0, 0, 1].\r\n * The matrix is not verified to be in the proper form.\r\n * This method is faster than computing the inverse for a general 4x4\r\n * matrix using {@link Matrix4.inverse}.\r\n *\r\n * @param {Matrix4} matrix The matrix to invert.\r\n * @param {Matrix4} result The object onto which to store the result.\r\n * @returns {Matrix4} The modified result parameter.\r\n */\r\nMatrix4.inverseTransformation = function (matrix, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  //This function is an optimized version of the below 4 lines.\r\n  //const rT = Matrix3.transpose(Matrix4.getMatrix3(matrix));\r\n  //const rTN = Matrix3.negate(rT);\r\n  //const rTT = Matrix3.multiplyByVector(rTN, Matrix4.getTranslation(matrix));\r\n  //return Matrix4.fromRotationTranslation(rT, rTT, result);\r\n\r\n  const matrix0 = matrix[0];\r\n  const matrix1 = matrix[1];\r\n  const matrix2 = matrix[2];\r\n  const matrix4 = matrix[4];\r\n  const matrix5 = matrix[5];\r\n  const matrix6 = matrix[6];\r\n  const matrix8 = matrix[8];\r\n  const matrix9 = matrix[9];\r\n  const matrix10 = matrix[10];\r\n\r\n  const vX = matrix[12];\r\n  const vY = matrix[13];\r\n  const vZ = matrix[14];\r\n\r\n  const x = -matrix0 * vX - matrix1 * vY - matrix2 * vZ;\r\n  const y = -matrix4 * vX - matrix5 * vY - matrix6 * vZ;\r\n  const z = -matrix8 * vX - matrix9 * vY - matrix10 * vZ;\r\n\r\n  result[0] = matrix0;\r\n  result[1] = matrix4;\r\n  result[2] = matrix8;\r\n  result[3] = 0.0;\r\n  result[4] = matrix1;\r\n  result[5] = matrix5;\r\n  result[6] = matrix9;\r\n  result[7] = 0.0;\r\n  result[8] = matrix2;\r\n  result[9] = matrix6;\r\n  result[10] = matrix10;\r\n  result[11] = 0.0;\r\n  result[12] = x;\r\n  result[13] = y;\r\n  result[14] = z;\r\n  result[15] = 1.0;\r\n  return result;\r\n};\r\n\r\nconst scratchTransposeMatrix = new Matrix4();\r\n\r\n/**\r\n * Computes the inverse transpose of a matrix.\r\n *\r\n * @param {Matrix4} matrix The matrix to transpose and invert.\r\n * @param {Matrix4} result The object onto which to store the result.\r\n * @returns {Matrix4} The modified result parameter.\r\n */\r\nMatrix4.inverseTranspose = function (matrix, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  return Matrix4.inverse(\r\n    Matrix4.transpose(matrix, scratchTransposeMatrix),\r\n    result\r\n  );\r\n};\r\n\r\n/**\r\n * An immutable Matrix4 instance initialized to the identity matrix.\r\n *\r\n * @type {Matrix4}\r\n * @constant\r\n */\r\nMatrix4.IDENTITY = Object.freeze(\r\n  new Matrix4(\r\n    1.0,\r\n    0.0,\r\n    0.0,\r\n    0.0,\r\n    0.0,\r\n    1.0,\r\n    0.0,\r\n    0.0,\r\n    0.0,\r\n    0.0,\r\n    1.0,\r\n    0.0,\r\n    0.0,\r\n    0.0,\r\n    0.0,\r\n    1.0\r\n  )\r\n);\r\n\r\n/**\r\n * An immutable Matrix4 instance initialized to the zero matrix.\r\n *\r\n * @type {Matrix4}\r\n * @constant\r\n */\r\nMatrix4.ZERO = Object.freeze(\r\n  new Matrix4(\r\n    0.0,\r\n    0.0,\r\n    0.0,\r\n    0.0,\r\n    0.0,\r\n    0.0,\r\n    0.0,\r\n    0.0,\r\n    0.0,\r\n    0.0,\r\n    0.0,\r\n    0.0,\r\n    0.0,\r\n    0.0,\r\n    0.0,\r\n    0.0\r\n  )\r\n);\r\n\r\n/**\r\n * The index into Matrix4 for column 0, row 0.\r\n *\r\n * @type {Number}\r\n * @constant\r\n */\r\nMatrix4.COLUMN0ROW0 = 0;\r\n\r\n/**\r\n * The index into Matrix4 for column 0, row 1.\r\n *\r\n * @type {Number}\r\n * @constant\r\n */\r\nMatrix4.COLUMN0ROW1 = 1;\r\n\r\n/**\r\n * The index into Matrix4 for column 0, row 2.\r\n *\r\n * @type {Number}\r\n * @constant\r\n */\r\nMatrix4.COLUMN0ROW2 = 2;\r\n\r\n/**\r\n * The index into Matrix4 for column 0, row 3.\r\n *\r\n * @type {Number}\r\n * @constant\r\n */\r\nMatrix4.COLUMN0ROW3 = 3;\r\n\r\n/**\r\n * The index into Matrix4 for column 1, row 0.\r\n *\r\n * @type {Number}\r\n * @constant\r\n */\r\nMatrix4.COLUMN1ROW0 = 4;\r\n\r\n/**\r\n * The index into Matrix4 for column 1, row 1.\r\n *\r\n * @type {Number}\r\n * @constant\r\n */\r\nMatrix4.COLUMN1ROW1 = 5;\r\n\r\n/**\r\n * The index into Matrix4 for column 1, row 2.\r\n *\r\n * @type {Number}\r\n * @constant\r\n */\r\nMatrix4.COLUMN1ROW2 = 6;\r\n\r\n/**\r\n * The index into Matrix4 for column 1, row 3.\r\n *\r\n * @type {Number}\r\n * @constant\r\n */\r\nMatrix4.COLUMN1ROW3 = 7;\r\n\r\n/**\r\n * The index into Matrix4 for column 2, row 0.\r\n *\r\n * @type {Number}\r\n * @constant\r\n */\r\nMatrix4.COLUMN2ROW0 = 8;\r\n\r\n/**\r\n * The index into Matrix4 for column 2, row 1.\r\n *\r\n * @type {Number}\r\n * @constant\r\n */\r\nMatrix4.COLUMN2ROW1 = 9;\r\n\r\n/**\r\n * The index into Matrix4 for column 2, row 2.\r\n *\r\n * @type {Number}\r\n * @constant\r\n */\r\nMatrix4.COLUMN2ROW2 = 10;\r\n\r\n/**\r\n * The index into Matrix4 for column 2, row 3.\r\n *\r\n * @type {Number}\r\n * @constant\r\n */\r\nMatrix4.COLUMN2ROW3 = 11;\r\n\r\n/**\r\n * The index into Matrix4 for column 3, row 0.\r\n *\r\n * @type {Number}\r\n * @constant\r\n */\r\nMatrix4.COLUMN3ROW0 = 12;\r\n\r\n/**\r\n * The index into Matrix4 for column 3, row 1.\r\n *\r\n * @type {Number}\r\n * @constant\r\n */\r\nMatrix4.COLUMN3ROW1 = 13;\r\n\r\n/**\r\n * The index into Matrix4 for column 3, row 2.\r\n *\r\n * @type {Number}\r\n * @constant\r\n */\r\nMatrix4.COLUMN3ROW2 = 14;\r\n\r\n/**\r\n * The index into Matrix4 for column 3, row 3.\r\n *\r\n * @type {Number}\r\n * @constant\r\n */\r\nMatrix4.COLUMN3ROW3 = 15;\r\n\r\nObject.defineProperties(Matrix4.prototype, {\r\n  /**\r\n   * Gets the number of items in the collection.\r\n   * @memberof Matrix4.prototype\r\n   *\r\n   * @type {Number}\r\n   */\r\n  length: {\r\n    get: function () {\r\n      return Matrix4.packedLength;\r\n    },\r\n  },\r\n});\r\n\r\n/**\r\n * Duplicates the provided Matrix4 instance.\r\n *\r\n * @param {Matrix4} [result] The object onto which to store the result.\r\n * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if one was not provided.\r\n */\r\nMatrix4.prototype.clone = function (result) {\r\n  return Matrix4.clone(this, result);\r\n};\r\n\r\n/**\r\n * Compares this matrix to the provided matrix componentwise and returns\r\n * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n *\r\n * @param {Matrix4} [right] The right hand side matrix.\r\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\r\n */\r\nMatrix4.prototype.equals = function (right) {\r\n  return Matrix4.equals(this, right);\r\n};\r\n\r\n/**\r\n * @private\r\n */\r\nMatrix4.equalsArray = function (matrix, array, offset) {\r\n  return (\r\n    matrix[0] === array[offset] &&\r\n    matrix[1] === array[offset + 1] &&\r\n    matrix[2] === array[offset + 2] &&\r\n    matrix[3] === array[offset + 3] &&\r\n    matrix[4] === array[offset + 4] &&\r\n    matrix[5] === array[offset + 5] &&\r\n    matrix[6] === array[offset + 6] &&\r\n    matrix[7] === array[offset + 7] &&\r\n    matrix[8] === array[offset + 8] &&\r\n    matrix[9] === array[offset + 9] &&\r\n    matrix[10] === array[offset + 10] &&\r\n    matrix[11] === array[offset + 11] &&\r\n    matrix[12] === array[offset + 12] &&\r\n    matrix[13] === array[offset + 13] &&\r\n    matrix[14] === array[offset + 14] &&\r\n    matrix[15] === array[offset + 15]\r\n  );\r\n};\r\n\r\n/**\r\n * Compares this matrix to the provided matrix componentwise and returns\r\n * <code>true</code> if they are within the provided epsilon,\r\n * <code>false</code> otherwise.\r\n *\r\n * @param {Matrix4} [right] The right hand side matrix.\r\n * @param {Number} [epsilon=0] The epsilon to use for equality testing.\r\n * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\r\n */\r\nMatrix4.prototype.equalsEpsilon = function (right, epsilon) {\r\n  return Matrix4.equalsEpsilon(this, right, epsilon);\r\n};\r\n\r\n/**\r\n * Computes a string representing this Matrix with each row being\r\n * on a separate line and in the format '(column0, column1, column2, column3)'.\r\n *\r\n * @returns {String} A string representing the provided Matrix with each row being on a separate line and in the format '(column0, column1, column2, column3)'.\r\n */\r\nMatrix4.prototype.toString = function () {\r\n  return (\r\n    `(${this[0]}, ${this[4]}, ${this[8]}, ${this[12]})\\n` +\r\n    `(${this[1]}, ${this[5]}, ${this[9]}, ${this[13]})\\n` +\r\n    `(${this[2]}, ${this[6]}, ${this[10]}, ${this[14]})\\n` +\r\n    `(${this[3]}, ${this[7]}, ${this[11]}, ${this[15]})`\r\n  );\r\n};\r\nexport default Matrix4;\r\n","import Cartographic from \"./Cartographic.js\";\r\nimport Check from \"./Check.js\";\r\nimport defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\nimport Ellipsoid from \"./Ellipsoid.js\";\r\nimport CesiumMath from \"./Math.js\";\r\n\r\n/**\r\n * A two dimensional region specified as longitude and latitude coordinates.\r\n *\r\n * @alias Rectangle\r\n * @constructor\r\n *\r\n * @param {Number} [west=0.0] The westernmost longitude, in radians, in the range [-Pi, Pi].\r\n * @param {Number} [south=0.0] The southernmost latitude, in radians, in the range [-Pi/2, Pi/2].\r\n * @param {Number} [east=0.0] The easternmost longitude, in radians, in the range [-Pi, Pi].\r\n * @param {Number} [north=0.0] The northernmost latitude, in radians, in the range [-Pi/2, Pi/2].\r\n *\r\n * @see Packable\r\n */\r\nfunction Rectangle(west, south, east, north) {\r\n  /**\r\n   * The westernmost longitude in radians in the range [-Pi, Pi].\r\n   *\r\n   * @type {Number}\r\n   * @default 0.0\r\n   */\r\n  this.west = defaultValue(west, 0.0);\r\n\r\n  /**\r\n   * The southernmost latitude in radians in the range [-Pi/2, Pi/2].\r\n   *\r\n   * @type {Number}\r\n   * @default 0.0\r\n   */\r\n  this.south = defaultValue(south, 0.0);\r\n\r\n  /**\r\n   * The easternmost longitude in radians in the range [-Pi, Pi].\r\n   *\r\n   * @type {Number}\r\n   * @default 0.0\r\n   */\r\n  this.east = defaultValue(east, 0.0);\r\n\r\n  /**\r\n   * The northernmost latitude in radians in the range [-Pi/2, Pi/2].\r\n   *\r\n   * @type {Number}\r\n   * @default 0.0\r\n   */\r\n  this.north = defaultValue(north, 0.0);\r\n}\r\n\r\nObject.defineProperties(Rectangle.prototype, {\r\n  /**\r\n   * Gets the width of the rectangle in radians.\r\n   * @memberof Rectangle.prototype\r\n   * @type {Number}\r\n   * @readonly\r\n   */\r\n  width: {\r\n    get: function () {\r\n      return Rectangle.computeWidth(this);\r\n    },\r\n  },\r\n\r\n  /**\r\n   * Gets the height of the rectangle in radians.\r\n   * @memberof Rectangle.prototype\r\n   * @type {Number}\r\n   * @readonly\r\n   */\r\n  height: {\r\n    get: function () {\r\n      return Rectangle.computeHeight(this);\r\n    },\r\n  },\r\n});\r\n\r\n/**\r\n * The number of elements used to pack the object into an array.\r\n * @type {Number}\r\n */\r\nRectangle.packedLength = 4;\r\n\r\n/**\r\n * Stores the provided instance into the provided array.\r\n *\r\n * @param {Rectangle} value The value to pack.\r\n * @param {Number[]} array The array to pack into.\r\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n *\r\n * @returns {Number[]} The array that was packed into\r\n */\r\nRectangle.pack = function (value, array, startingIndex) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"value\", value);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  array[startingIndex++] = value.west;\r\n  array[startingIndex++] = value.south;\r\n  array[startingIndex++] = value.east;\r\n  array[startingIndex] = value.north;\r\n\r\n  return array;\r\n};\r\n\r\n/**\r\n * Retrieves an instance from a packed array.\r\n *\r\n * @param {Number[]} array The packed array.\r\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n * @param {Rectangle} [result] The object into which to store the result.\r\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if one was not provided.\r\n */\r\nRectangle.unpack = function (array, startingIndex, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  if (!defined(result)) {\r\n    result = new Rectangle();\r\n  }\r\n\r\n  result.west = array[startingIndex++];\r\n  result.south = array[startingIndex++];\r\n  result.east = array[startingIndex++];\r\n  result.north = array[startingIndex];\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the width of a rectangle in radians.\r\n * @param {Rectangle} rectangle The rectangle to compute the width of.\r\n * @returns {Number} The width.\r\n */\r\nRectangle.computeWidth = function (rectangle) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"rectangle\", rectangle);\r\n  //>>includeEnd('debug');\r\n  let east = rectangle.east;\r\n  const west = rectangle.west;\r\n  if (east < west) {\r\n    east += CesiumMath.TWO_PI;\r\n  }\r\n  return east - west;\r\n};\r\n\r\n/**\r\n * Computes the height of a rectangle in radians.\r\n * @param {Rectangle} rectangle The rectangle to compute the height of.\r\n * @returns {Number} The height.\r\n */\r\nRectangle.computeHeight = function (rectangle) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"rectangle\", rectangle);\r\n  //>>includeEnd('debug');\r\n  return rectangle.north - rectangle.south;\r\n};\r\n\r\n/**\r\n * Creates a rectangle given the boundary longitude and latitude in degrees.\r\n *\r\n * @param {Number} [west=0.0] The westernmost longitude in degrees in the range [-180.0, 180.0].\r\n * @param {Number} [south=0.0] The southernmost latitude in degrees in the range [-90.0, 90.0].\r\n * @param {Number} [east=0.0] The easternmost longitude in degrees in the range [-180.0, 180.0].\r\n * @param {Number} [north=0.0] The northernmost latitude in degrees in the range [-90.0, 90.0].\r\n * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\r\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\r\n *\r\n * @example\r\n * const rectangle = Cesium.Rectangle.fromDegrees(0.0, 20.0, 10.0, 30.0);\r\n */\r\nRectangle.fromDegrees = function (west, south, east, north, result) {\r\n  west = CesiumMath.toRadians(defaultValue(west, 0.0));\r\n  south = CesiumMath.toRadians(defaultValue(south, 0.0));\r\n  east = CesiumMath.toRadians(defaultValue(east, 0.0));\r\n  north = CesiumMath.toRadians(defaultValue(north, 0.0));\r\n\r\n  if (!defined(result)) {\r\n    return new Rectangle(west, south, east, north);\r\n  }\r\n\r\n  result.west = west;\r\n  result.south = south;\r\n  result.east = east;\r\n  result.north = north;\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Creates a rectangle given the boundary longitude and latitude in radians.\r\n *\r\n * @param {Number} [west=0.0] The westernmost longitude in radians in the range [-Math.PI, Math.PI].\r\n * @param {Number} [south=0.0] The southernmost latitude in radians in the range [-Math.PI/2, Math.PI/2].\r\n * @param {Number} [east=0.0] The easternmost longitude in radians in the range [-Math.PI, Math.PI].\r\n * @param {Number} [north=0.0] The northernmost latitude in radians in the range [-Math.PI/2, Math.PI/2].\r\n * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\r\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\r\n *\r\n * @example\r\n * const rectangle = Cesium.Rectangle.fromRadians(0.0, Math.PI/4, Math.PI/8, 3*Math.PI/4);\r\n */\r\nRectangle.fromRadians = function (west, south, east, north, result) {\r\n  if (!defined(result)) {\r\n    return new Rectangle(west, south, east, north);\r\n  }\r\n\r\n  result.west = defaultValue(west, 0.0);\r\n  result.south = defaultValue(south, 0.0);\r\n  result.east = defaultValue(east, 0.0);\r\n  result.north = defaultValue(north, 0.0);\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Creates the smallest possible Rectangle that encloses all positions in the provided array.\r\n *\r\n * @param {Cartographic[]} cartographics The list of Cartographic instances.\r\n * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\r\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\r\n */\r\nRectangle.fromCartographicArray = function (cartographics, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"cartographics\", cartographics);\r\n  //>>includeEnd('debug');\r\n\r\n  let west = Number.MAX_VALUE;\r\n  let east = -Number.MAX_VALUE;\r\n  let westOverIDL = Number.MAX_VALUE;\r\n  let eastOverIDL = -Number.MAX_VALUE;\r\n  let south = Number.MAX_VALUE;\r\n  let north = -Number.MAX_VALUE;\r\n\r\n  for (let i = 0, len = cartographics.length; i < len; i++) {\r\n    const position = cartographics[i];\r\n    west = Math.min(west, position.longitude);\r\n    east = Math.max(east, position.longitude);\r\n    south = Math.min(south, position.latitude);\r\n    north = Math.max(north, position.latitude);\r\n\r\n    const lonAdjusted =\r\n      position.longitude >= 0\r\n        ? position.longitude\r\n        : position.longitude + CesiumMath.TWO_PI;\r\n    westOverIDL = Math.min(westOverIDL, lonAdjusted);\r\n    eastOverIDL = Math.max(eastOverIDL, lonAdjusted);\r\n  }\r\n\r\n  if (east - west > eastOverIDL - westOverIDL) {\r\n    west = westOverIDL;\r\n    east = eastOverIDL;\r\n\r\n    if (east > CesiumMath.PI) {\r\n      east = east - CesiumMath.TWO_PI;\r\n    }\r\n    if (west > CesiumMath.PI) {\r\n      west = west - CesiumMath.TWO_PI;\r\n    }\r\n  }\r\n\r\n  if (!defined(result)) {\r\n    return new Rectangle(west, south, east, north);\r\n  }\r\n\r\n  result.west = west;\r\n  result.south = south;\r\n  result.east = east;\r\n  result.north = north;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Creates the smallest possible Rectangle that encloses all positions in the provided array.\r\n *\r\n * @param {Cartesian3[]} cartesians The list of Cartesian instances.\r\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid the cartesians are on.\r\n * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\r\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\r\n */\r\nRectangle.fromCartesianArray = function (cartesians, ellipsoid, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"cartesians\", cartesians);\r\n  //>>includeEnd('debug');\r\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\r\n\r\n  let west = Number.MAX_VALUE;\r\n  let east = -Number.MAX_VALUE;\r\n  let westOverIDL = Number.MAX_VALUE;\r\n  let eastOverIDL = -Number.MAX_VALUE;\r\n  let south = Number.MAX_VALUE;\r\n  let north = -Number.MAX_VALUE;\r\n\r\n  for (let i = 0, len = cartesians.length; i < len; i++) {\r\n    const position = ellipsoid.cartesianToCartographic(cartesians[i]);\r\n    west = Math.min(west, position.longitude);\r\n    east = Math.max(east, position.longitude);\r\n    south = Math.min(south, position.latitude);\r\n    north = Math.max(north, position.latitude);\r\n\r\n    const lonAdjusted =\r\n      position.longitude >= 0\r\n        ? position.longitude\r\n        : position.longitude + CesiumMath.TWO_PI;\r\n    westOverIDL = Math.min(westOverIDL, lonAdjusted);\r\n    eastOverIDL = Math.max(eastOverIDL, lonAdjusted);\r\n  }\r\n\r\n  if (east - west > eastOverIDL - westOverIDL) {\r\n    west = westOverIDL;\r\n    east = eastOverIDL;\r\n\r\n    if (east > CesiumMath.PI) {\r\n      east = east - CesiumMath.TWO_PI;\r\n    }\r\n    if (west > CesiumMath.PI) {\r\n      west = west - CesiumMath.TWO_PI;\r\n    }\r\n  }\r\n\r\n  if (!defined(result)) {\r\n    return new Rectangle(west, south, east, north);\r\n  }\r\n\r\n  result.west = west;\r\n  result.south = south;\r\n  result.east = east;\r\n  result.north = north;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Duplicates a Rectangle.\r\n *\r\n * @param {Rectangle} rectangle The rectangle to clone.\r\n * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\r\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided. (Returns undefined if rectangle is undefined)\r\n */\r\nRectangle.clone = function (rectangle, result) {\r\n  if (!defined(rectangle)) {\r\n    return undefined;\r\n  }\r\n\r\n  if (!defined(result)) {\r\n    return new Rectangle(\r\n      rectangle.west,\r\n      rectangle.south,\r\n      rectangle.east,\r\n      rectangle.north\r\n    );\r\n  }\r\n\r\n  result.west = rectangle.west;\r\n  result.south = rectangle.south;\r\n  result.east = rectangle.east;\r\n  result.north = rectangle.north;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Compares the provided Rectangles componentwise and returns\r\n * <code>true</code> if they pass an absolute or relative tolerance test,\r\n * <code>false</code> otherwise.\r\n *\r\n * @param {Rectangle} [left] The first Rectangle.\r\n * @param {Rectangle} [right] The second Rectangle.\r\n * @param {Number} [absoluteEpsilon=0] The absolute epsilon tolerance to use for equality testing.\r\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\r\n */\r\nRectangle.equalsEpsilon = function (left, right, absoluteEpsilon) {\r\n  absoluteEpsilon = defaultValue(absoluteEpsilon, 0);\r\n\r\n  return (\r\n    left === right ||\r\n    (defined(left) &&\r\n      defined(right) &&\r\n      Math.abs(left.west - right.west) <= absoluteEpsilon &&\r\n      Math.abs(left.south - right.south) <= absoluteEpsilon &&\r\n      Math.abs(left.east - right.east) <= absoluteEpsilon &&\r\n      Math.abs(left.north - right.north) <= absoluteEpsilon)\r\n  );\r\n};\r\n\r\n/**\r\n * Duplicates this Rectangle.\r\n *\r\n * @param {Rectangle} [result] The object onto which to store the result.\r\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\r\n */\r\nRectangle.prototype.clone = function (result) {\r\n  return Rectangle.clone(this, result);\r\n};\r\n\r\n/**\r\n * Compares the provided Rectangle with this Rectangle componentwise and returns\r\n * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n *\r\n * @param {Rectangle} [other] The Rectangle to compare.\r\n * @returns {Boolean} <code>true</code> if the Rectangles are equal, <code>false</code> otherwise.\r\n */\r\nRectangle.prototype.equals = function (other) {\r\n  return Rectangle.equals(this, other);\r\n};\r\n\r\n/**\r\n * Compares the provided rectangles and returns <code>true</code> if they are equal,\r\n * <code>false</code> otherwise.\r\n *\r\n * @param {Rectangle} [left] The first Rectangle.\r\n * @param {Rectangle} [right] The second Rectangle.\r\n * @returns {Boolean} <code>true</code> if left and right are equal; otherwise <code>false</code>.\r\n */\r\nRectangle.equals = function (left, right) {\r\n  return (\r\n    left === right ||\r\n    (defined(left) &&\r\n      defined(right) &&\r\n      left.west === right.west &&\r\n      left.south === right.south &&\r\n      left.east === right.east &&\r\n      left.north === right.north)\r\n  );\r\n};\r\n\r\n/**\r\n * Compares the provided Rectangle with this Rectangle componentwise and returns\r\n * <code>true</code> if they are within the provided epsilon,\r\n * <code>false</code> otherwise.\r\n *\r\n * @param {Rectangle} [other] The Rectangle to compare.\r\n * @param {Number} [epsilon=0] The epsilon to use for equality testing.\r\n * @returns {Boolean} <code>true</code> if the Rectangles are within the provided epsilon, <code>false</code> otherwise.\r\n */\r\nRectangle.prototype.equalsEpsilon = function (other, epsilon) {\r\n  return Rectangle.equalsEpsilon(this, other, epsilon);\r\n};\r\n\r\n/**\r\n * Checks a Rectangle's properties and throws if they are not in valid ranges.\r\n *\r\n * @param {Rectangle} rectangle The rectangle to validate\r\n *\r\n * @exception {DeveloperError} <code>north</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\r\n * @exception {DeveloperError} <code>south</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\r\n * @exception {DeveloperError} <code>east</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\r\n * @exception {DeveloperError} <code>west</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\r\n */\r\nRectangle.validate = function (rectangle) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"rectangle\", rectangle);\r\n\r\n  const north = rectangle.north;\r\n  Check.typeOf.number.greaterThanOrEquals(\r\n    \"north\",\r\n    north,\r\n    -CesiumMath.PI_OVER_TWO\r\n  );\r\n  Check.typeOf.number.lessThanOrEquals(\"north\", north, CesiumMath.PI_OVER_TWO);\r\n\r\n  const south = rectangle.south;\r\n  Check.typeOf.number.greaterThanOrEquals(\r\n    \"south\",\r\n    south,\r\n    -CesiumMath.PI_OVER_TWO\r\n  );\r\n  Check.typeOf.number.lessThanOrEquals(\"south\", south, CesiumMath.PI_OVER_TWO);\r\n\r\n  const west = rectangle.west;\r\n  Check.typeOf.number.greaterThanOrEquals(\"west\", west, -Math.PI);\r\n  Check.typeOf.number.lessThanOrEquals(\"west\", west, Math.PI);\r\n\r\n  const east = rectangle.east;\r\n  Check.typeOf.number.greaterThanOrEquals(\"east\", east, -Math.PI);\r\n  Check.typeOf.number.lessThanOrEquals(\"east\", east, Math.PI);\r\n  //>>includeEnd('debug');\r\n};\r\n\r\n/**\r\n * Computes the southwest corner of a rectangle.\r\n *\r\n * @param {Rectangle} rectangle The rectangle for which to find the corner\r\n * @param {Cartographic} [result] The object onto which to store the result.\r\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\r\n */\r\nRectangle.southwest = function (rectangle, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"rectangle\", rectangle);\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    return new Cartographic(rectangle.west, rectangle.south);\r\n  }\r\n  result.longitude = rectangle.west;\r\n  result.latitude = rectangle.south;\r\n  result.height = 0.0;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the northwest corner of a rectangle.\r\n *\r\n * @param {Rectangle} rectangle The rectangle for which to find the corner\r\n * @param {Cartographic} [result] The object onto which to store the result.\r\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\r\n */\r\nRectangle.northwest = function (rectangle, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"rectangle\", rectangle);\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    return new Cartographic(rectangle.west, rectangle.north);\r\n  }\r\n  result.longitude = rectangle.west;\r\n  result.latitude = rectangle.north;\r\n  result.height = 0.0;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the northeast corner of a rectangle.\r\n *\r\n * @param {Rectangle} rectangle The rectangle for which to find the corner\r\n * @param {Cartographic} [result] The object onto which to store the result.\r\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\r\n */\r\nRectangle.northeast = function (rectangle, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"rectangle\", rectangle);\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    return new Cartographic(rectangle.east, rectangle.north);\r\n  }\r\n  result.longitude = rectangle.east;\r\n  result.latitude = rectangle.north;\r\n  result.height = 0.0;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the southeast corner of a rectangle.\r\n *\r\n * @param {Rectangle} rectangle The rectangle for which to find the corner\r\n * @param {Cartographic} [result] The object onto which to store the result.\r\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\r\n */\r\nRectangle.southeast = function (rectangle, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"rectangle\", rectangle);\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    return new Cartographic(rectangle.east, rectangle.south);\r\n  }\r\n  result.longitude = rectangle.east;\r\n  result.latitude = rectangle.south;\r\n  result.height = 0.0;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the center of a rectangle.\r\n *\r\n * @param {Rectangle} rectangle The rectangle for which to find the center\r\n * @param {Cartographic} [result] The object onto which to store the result.\r\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\r\n */\r\nRectangle.center = function (rectangle, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"rectangle\", rectangle);\r\n  //>>includeEnd('debug');\r\n\r\n  let east = rectangle.east;\r\n  const west = rectangle.west;\r\n\r\n  if (east < west) {\r\n    east += CesiumMath.TWO_PI;\r\n  }\r\n\r\n  const longitude = CesiumMath.negativePiToPi((west + east) * 0.5);\r\n  const latitude = (rectangle.south + rectangle.north) * 0.5;\r\n\r\n  if (!defined(result)) {\r\n    return new Cartographic(longitude, latitude);\r\n  }\r\n\r\n  result.longitude = longitude;\r\n  result.latitude = latitude;\r\n  result.height = 0.0;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the intersection of two rectangles.  This function assumes that the rectangle's coordinates are\r\n * latitude and longitude in radians and produces a correct intersection, taking into account the fact that\r\n * the same angle can be represented with multiple values as well as the wrapping of longitude at the\r\n * anti-meridian.  For a simple intersection that ignores these factors and can be used with projected\r\n * coordinates, see {@link Rectangle.simpleIntersection}.\r\n *\r\n * @param {Rectangle} rectangle On rectangle to find an intersection\r\n * @param {Rectangle} otherRectangle Another rectangle to find an intersection\r\n * @param {Rectangle} [result] The object onto which to store the result.\r\n * @returns {Rectangle|undefined} The modified result parameter, a new Rectangle instance if none was provided or undefined if there is no intersection.\r\n */\r\nRectangle.intersection = function (rectangle, otherRectangle, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"rectangle\", rectangle);\r\n  Check.typeOf.object(\"otherRectangle\", otherRectangle);\r\n  //>>includeEnd('debug');\r\n\r\n  let rectangleEast = rectangle.east;\r\n  let rectangleWest = rectangle.west;\r\n\r\n  let otherRectangleEast = otherRectangle.east;\r\n  let otherRectangleWest = otherRectangle.west;\r\n\r\n  if (rectangleEast < rectangleWest && otherRectangleEast > 0.0) {\r\n    rectangleEast += CesiumMath.TWO_PI;\r\n  } else if (otherRectangleEast < otherRectangleWest && rectangleEast > 0.0) {\r\n    otherRectangleEast += CesiumMath.TWO_PI;\r\n  }\r\n\r\n  if (rectangleEast < rectangleWest && otherRectangleWest < 0.0) {\r\n    otherRectangleWest += CesiumMath.TWO_PI;\r\n  } else if (otherRectangleEast < otherRectangleWest && rectangleWest < 0.0) {\r\n    rectangleWest += CesiumMath.TWO_PI;\r\n  }\r\n\r\n  const west = CesiumMath.negativePiToPi(\r\n    Math.max(rectangleWest, otherRectangleWest)\r\n  );\r\n  const east = CesiumMath.negativePiToPi(\r\n    Math.min(rectangleEast, otherRectangleEast)\r\n  );\r\n\r\n  if (\r\n    (rectangle.west < rectangle.east ||\r\n      otherRectangle.west < otherRectangle.east) &&\r\n    east <= west\r\n  ) {\r\n    return undefined;\r\n  }\r\n\r\n  const south = Math.max(rectangle.south, otherRectangle.south);\r\n  const north = Math.min(rectangle.north, otherRectangle.north);\r\n\r\n  if (south >= north) {\r\n    return undefined;\r\n  }\r\n\r\n  if (!defined(result)) {\r\n    return new Rectangle(west, south, east, north);\r\n  }\r\n  result.west = west;\r\n  result.south = south;\r\n  result.east = east;\r\n  result.north = north;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes a simple intersection of two rectangles.  Unlike {@link Rectangle.intersection}, this function\r\n * does not attempt to put the angular coordinates into a consistent range or to account for crossing the\r\n * anti-meridian.  As such, it can be used for rectangles where the coordinates are not simply latitude\r\n * and longitude (i.e. projected coordinates).\r\n *\r\n * @param {Rectangle} rectangle On rectangle to find an intersection\r\n * @param {Rectangle} otherRectangle Another rectangle to find an intersection\r\n * @param {Rectangle} [result] The object onto which to store the result.\r\n * @returns {Rectangle|undefined} The modified result parameter, a new Rectangle instance if none was provided or undefined if there is no intersection.\r\n */\r\nRectangle.simpleIntersection = function (rectangle, otherRectangle, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"rectangle\", rectangle);\r\n  Check.typeOf.object(\"otherRectangle\", otherRectangle);\r\n  //>>includeEnd('debug');\r\n\r\n  const west = Math.max(rectangle.west, otherRectangle.west);\r\n  const south = Math.max(rectangle.south, otherRectangle.south);\r\n  const east = Math.min(rectangle.east, otherRectangle.east);\r\n  const north = Math.min(rectangle.north, otherRectangle.north);\r\n\r\n  if (south >= north || west >= east) {\r\n    return undefined;\r\n  }\r\n\r\n  if (!defined(result)) {\r\n    return new Rectangle(west, south, east, north);\r\n  }\r\n\r\n  result.west = west;\r\n  result.south = south;\r\n  result.east = east;\r\n  result.north = north;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes a rectangle that is the union of two rectangles.\r\n *\r\n * @param {Rectangle} rectangle A rectangle to enclose in rectangle.\r\n * @param {Rectangle} otherRectangle A rectangle to enclose in a rectangle.\r\n * @param {Rectangle} [result] The object onto which to store the result.\r\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\r\n */\r\nRectangle.union = function (rectangle, otherRectangle, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"rectangle\", rectangle);\r\n  Check.typeOf.object(\"otherRectangle\", otherRectangle);\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    result = new Rectangle();\r\n  }\r\n\r\n  let rectangleEast = rectangle.east;\r\n  let rectangleWest = rectangle.west;\r\n\r\n  let otherRectangleEast = otherRectangle.east;\r\n  let otherRectangleWest = otherRectangle.west;\r\n\r\n  if (rectangleEast < rectangleWest && otherRectangleEast > 0.0) {\r\n    rectangleEast += CesiumMath.TWO_PI;\r\n  } else if (otherRectangleEast < otherRectangleWest && rectangleEast > 0.0) {\r\n    otherRectangleEast += CesiumMath.TWO_PI;\r\n  }\r\n\r\n  if (rectangleEast < rectangleWest && otherRectangleWest < 0.0) {\r\n    otherRectangleWest += CesiumMath.TWO_PI;\r\n  } else if (otherRectangleEast < otherRectangleWest && rectangleWest < 0.0) {\r\n    rectangleWest += CesiumMath.TWO_PI;\r\n  }\r\n\r\n  const west = CesiumMath.negativePiToPi(\r\n    Math.min(rectangleWest, otherRectangleWest)\r\n  );\r\n  const east = CesiumMath.negativePiToPi(\r\n    Math.max(rectangleEast, otherRectangleEast)\r\n  );\r\n\r\n  result.west = west;\r\n  result.south = Math.min(rectangle.south, otherRectangle.south);\r\n  result.east = east;\r\n  result.north = Math.max(rectangle.north, otherRectangle.north);\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes a rectangle by enlarging the provided rectangle until it contains the provided cartographic.\r\n *\r\n * @param {Rectangle} rectangle A rectangle to expand.\r\n * @param {Cartographic} cartographic A cartographic to enclose in a rectangle.\r\n * @param {Rectangle} [result] The object onto which to store the result.\r\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if one was not provided.\r\n */\r\nRectangle.expand = function (rectangle, cartographic, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"rectangle\", rectangle);\r\n  Check.typeOf.object(\"cartographic\", cartographic);\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    result = new Rectangle();\r\n  }\r\n\r\n  result.west = Math.min(rectangle.west, cartographic.longitude);\r\n  result.south = Math.min(rectangle.south, cartographic.latitude);\r\n  result.east = Math.max(rectangle.east, cartographic.longitude);\r\n  result.north = Math.max(rectangle.north, cartographic.latitude);\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Returns true if the cartographic is on or inside the rectangle, false otherwise.\r\n *\r\n * @param {Rectangle} rectangle The rectangle\r\n * @param {Cartographic} cartographic The cartographic to test.\r\n * @returns {Boolean} true if the provided cartographic is inside the rectangle, false otherwise.\r\n */\r\nRectangle.contains = function (rectangle, cartographic) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"rectangle\", rectangle);\r\n  Check.typeOf.object(\"cartographic\", cartographic);\r\n  //>>includeEnd('debug');\r\n\r\n  let longitude = cartographic.longitude;\r\n  const latitude = cartographic.latitude;\r\n\r\n  const west = rectangle.west;\r\n  let east = rectangle.east;\r\n\r\n  if (east < west) {\r\n    east += CesiumMath.TWO_PI;\r\n    if (longitude < 0.0) {\r\n      longitude += CesiumMath.TWO_PI;\r\n    }\r\n  }\r\n  return (\r\n    (longitude > west ||\r\n      CesiumMath.equalsEpsilon(longitude, west, CesiumMath.EPSILON14)) &&\r\n    (longitude < east ||\r\n      CesiumMath.equalsEpsilon(longitude, east, CesiumMath.EPSILON14)) &&\r\n    latitude >= rectangle.south &&\r\n    latitude <= rectangle.north\r\n  );\r\n};\r\n\r\nconst subsampleLlaScratch = new Cartographic();\r\n/**\r\n * Samples a rectangle so that it includes a list of Cartesian points suitable for passing to\r\n * {@link BoundingSphere#fromPoints}.  Sampling is necessary to account\r\n * for rectangles that cover the poles or cross the equator.\r\n *\r\n * @param {Rectangle} rectangle The rectangle to subsample.\r\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid to use.\r\n * @param {Number} [surfaceHeight=0.0] The height of the rectangle above the ellipsoid.\r\n * @param {Cartesian3[]} [result] The array of Cartesians onto which to store the result.\r\n * @returns {Cartesian3[]} The modified result parameter or a new Array of Cartesians instances if none was provided.\r\n */\r\nRectangle.subsample = function (rectangle, ellipsoid, surfaceHeight, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"rectangle\", rectangle);\r\n  //>>includeEnd('debug');\r\n\r\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\r\n  surfaceHeight = defaultValue(surfaceHeight, 0.0);\r\n\r\n  if (!defined(result)) {\r\n    result = [];\r\n  }\r\n  let length = 0;\r\n\r\n  const north = rectangle.north;\r\n  const south = rectangle.south;\r\n  const east = rectangle.east;\r\n  const west = rectangle.west;\r\n\r\n  const lla = subsampleLlaScratch;\r\n  lla.height = surfaceHeight;\r\n\r\n  lla.longitude = west;\r\n  lla.latitude = north;\r\n  result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\r\n  length++;\r\n\r\n  lla.longitude = east;\r\n  result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\r\n  length++;\r\n\r\n  lla.latitude = south;\r\n  result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\r\n  length++;\r\n\r\n  lla.longitude = west;\r\n  result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\r\n  length++;\r\n\r\n  if (north < 0.0) {\r\n    lla.latitude = north;\r\n  } else if (south > 0.0) {\r\n    lla.latitude = south;\r\n  } else {\r\n    lla.latitude = 0.0;\r\n  }\r\n\r\n  for (let i = 1; i < 8; ++i) {\r\n    lla.longitude = -Math.PI + i * CesiumMath.PI_OVER_TWO;\r\n    if (Rectangle.contains(rectangle, lla)) {\r\n      result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\r\n      length++;\r\n    }\r\n  }\r\n\r\n  if (lla.latitude === 0.0) {\r\n    lla.longitude = west;\r\n    result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\r\n    length++;\r\n    lla.longitude = east;\r\n    result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\r\n    length++;\r\n  }\r\n  result.length = length;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes a subsection of a rectangle from normalized coordinates in the range [0.0, 1.0].\r\n *\r\n * @param {Rectangle} rectangle The rectangle to subsection.\r\n * @param {Number} westLerp The west interpolation factor in the range [0.0, 1.0]. Must be less than or equal to eastLerp.\r\n * @param {Number} southLerp The south interpolation factor in the range [0.0, 1.0]. Must be less than or equal to northLerp.\r\n * @param {Number} eastLerp The east interpolation factor in the range [0.0, 1.0]. Must be greater than or equal to westLerp.\r\n * @param {Number} northLerp The north interpolation factor in the range [0.0, 1.0]. Must be greater than or equal to southLerp.\r\n * @param {Rectangle} [result] The object onto which to store the result.\r\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\r\n */\r\nRectangle.subsection = function (\r\n  rectangle,\r\n  westLerp,\r\n  southLerp,\r\n  eastLerp,\r\n  northLerp,\r\n  result\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"rectangle\", rectangle);\r\n  Check.typeOf.number.greaterThanOrEquals(\"westLerp\", westLerp, 0.0);\r\n  Check.typeOf.number.lessThanOrEquals(\"westLerp\", westLerp, 1.0);\r\n  Check.typeOf.number.greaterThanOrEquals(\"southLerp\", southLerp, 0.0);\r\n  Check.typeOf.number.lessThanOrEquals(\"southLerp\", southLerp, 1.0);\r\n  Check.typeOf.number.greaterThanOrEquals(\"eastLerp\", eastLerp, 0.0);\r\n  Check.typeOf.number.lessThanOrEquals(\"eastLerp\", eastLerp, 1.0);\r\n  Check.typeOf.number.greaterThanOrEquals(\"northLerp\", northLerp, 0.0);\r\n  Check.typeOf.number.lessThanOrEquals(\"northLerp\", northLerp, 1.0);\r\n\r\n  Check.typeOf.number.lessThanOrEquals(\"westLerp\", westLerp, eastLerp);\r\n  Check.typeOf.number.lessThanOrEquals(\"southLerp\", southLerp, northLerp);\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    result = new Rectangle();\r\n  }\r\n\r\n  // This function doesn't use CesiumMath.lerp because it has floating point precision problems\r\n  // when the start and end values are the same but the t changes.\r\n\r\n  if (rectangle.west <= rectangle.east) {\r\n    const width = rectangle.east - rectangle.west;\r\n    result.west = rectangle.west + westLerp * width;\r\n    result.east = rectangle.west + eastLerp * width;\r\n  } else {\r\n    const width = CesiumMath.TWO_PI + rectangle.east - rectangle.west;\r\n    result.west = CesiumMath.negativePiToPi(rectangle.west + westLerp * width);\r\n    result.east = CesiumMath.negativePiToPi(rectangle.west + eastLerp * width);\r\n  }\r\n  const height = rectangle.north - rectangle.south;\r\n  result.south = rectangle.south + southLerp * height;\r\n  result.north = rectangle.south + northLerp * height;\r\n\r\n  // Fix floating point precision problems when t = 1\r\n  if (westLerp === 1.0) {\r\n    result.west = rectangle.east;\r\n  }\r\n  if (eastLerp === 1.0) {\r\n    result.east = rectangle.east;\r\n  }\r\n  if (southLerp === 1.0) {\r\n    result.south = rectangle.north;\r\n  }\r\n  if (northLerp === 1.0) {\r\n    result.north = rectangle.north;\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * The largest possible rectangle.\r\n *\r\n * @type {Rectangle}\r\n * @constant\r\n */\r\nRectangle.MAX_VALUE = Object.freeze(\r\n  new Rectangle(\r\n    -Math.PI,\r\n    -CesiumMath.PI_OVER_TWO,\r\n    Math.PI,\r\n    CesiumMath.PI_OVER_TWO\r\n  )\r\n);\r\nexport default Rectangle;\r\n","import Check from \"./Check.js\";\r\nimport defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\nimport DeveloperError from \"./DeveloperError.js\";\r\nimport CesiumMath from \"./Math.js\";\r\n\r\n/**\r\n * A 2D Cartesian point.\r\n * @alias Cartesian2\r\n * @constructor\r\n *\r\n * @param {Number} [x=0.0] The X component.\r\n * @param {Number} [y=0.0] The Y component.\r\n *\r\n * @see Cartesian3\r\n * @see Cartesian4\r\n * @see Packable\r\n */\r\nfunction Cartesian2(x, y) {\r\n  /**\r\n   * The X component.\r\n   * @type {Number}\r\n   * @default 0.0\r\n   */\r\n  this.x = defaultValue(x, 0.0);\r\n\r\n  /**\r\n   * The Y component.\r\n   * @type {Number}\r\n   * @default 0.0\r\n   */\r\n  this.y = defaultValue(y, 0.0);\r\n}\r\n\r\n/**\r\n * Creates a Cartesian2 instance from x and y coordinates.\r\n *\r\n * @param {Number} x The x coordinate.\r\n * @param {Number} y The y coordinate.\r\n * @param {Cartesian2} [result] The object onto which to store the result.\r\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\r\n */\r\nCartesian2.fromElements = function (x, y, result) {\r\n  if (!defined(result)) {\r\n    return new Cartesian2(x, y);\r\n  }\r\n\r\n  result.x = x;\r\n  result.y = y;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Duplicates a Cartesian2 instance.\r\n *\r\n * @param {Cartesian2} cartesian The Cartesian to duplicate.\r\n * @param {Cartesian2} [result] The object onto which to store the result.\r\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided. (Returns undefined if cartesian is undefined)\r\n */\r\nCartesian2.clone = function (cartesian, result) {\r\n  if (!defined(cartesian)) {\r\n    return undefined;\r\n  }\r\n  if (!defined(result)) {\r\n    return new Cartesian2(cartesian.x, cartesian.y);\r\n  }\r\n\r\n  result.x = cartesian.x;\r\n  result.y = cartesian.y;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Creates a Cartesian2 instance from an existing Cartesian3.  This simply takes the\r\n * x and y properties of the Cartesian3 and drops z.\r\n * @function\r\n *\r\n * @param {Cartesian3} cartesian The Cartesian3 instance to create a Cartesian2 instance from.\r\n * @param {Cartesian2} [result] The object onto which to store the result.\r\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\r\n */\r\nCartesian2.fromCartesian3 = Cartesian2.clone;\r\n\r\n/**\r\n * Creates a Cartesian2 instance from an existing Cartesian4.  This simply takes the\r\n * x and y properties of the Cartesian4 and drops z and w.\r\n * @function\r\n *\r\n * @param {Cartesian4} cartesian The Cartesian4 instance to create a Cartesian2 instance from.\r\n * @param {Cartesian2} [result] The object onto which to store the result.\r\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\r\n */\r\nCartesian2.fromCartesian4 = Cartesian2.clone;\r\n\r\n/**\r\n * The number of elements used to pack the object into an array.\r\n * @type {Number}\r\n */\r\nCartesian2.packedLength = 2;\r\n\r\n/**\r\n * Stores the provided instance into the provided array.\r\n *\r\n * @param {Cartesian2} value The value to pack.\r\n * @param {Number[]} array The array to pack into.\r\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n *\r\n * @returns {Number[]} The array that was packed into\r\n */\r\nCartesian2.pack = function (value, array, startingIndex) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"value\", value);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  array[startingIndex++] = value.x;\r\n  array[startingIndex] = value.y;\r\n\r\n  return array;\r\n};\r\n\r\n/**\r\n * Retrieves an instance from a packed array.\r\n *\r\n * @param {Number[]} array The packed array.\r\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n * @param {Cartesian2} [result] The object into which to store the result.\r\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\r\n */\r\nCartesian2.unpack = function (array, startingIndex, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  if (!defined(result)) {\r\n    result = new Cartesian2();\r\n  }\r\n  result.x = array[startingIndex++];\r\n  result.y = array[startingIndex];\r\n  return result;\r\n};\r\n\r\n/**\r\n * Flattens an array of Cartesian2s into an array of components.\r\n *\r\n * @param {Cartesian2[]} array The array of cartesians to pack.\r\n * @param {Number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 2 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 2) elements.\r\n * @returns {Number[]} The packed array.\r\n */\r\nCartesian2.packArray = function (array, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  const length = array.length;\r\n  const resultLength = length * 2;\r\n  if (!defined(result)) {\r\n    result = new Array(resultLength);\r\n  } else if (!Array.isArray(result) && result.length !== resultLength) {\r\n    //>>includeStart('debug', pragmas.debug);\r\n    throw new DeveloperError(\r\n      \"If result is a typed array, it must have exactly array.length * 2 elements\"\r\n    );\r\n    //>>includeEnd('debug');\r\n  } else if (result.length !== resultLength) {\r\n    result.length = resultLength;\r\n  }\r\n\r\n  for (let i = 0; i < length; ++i) {\r\n    Cartesian2.pack(array[i], result, i * 2);\r\n  }\r\n  return result;\r\n};\r\n\r\n/**\r\n * Unpacks an array of cartesian components into an array of Cartesian2s.\r\n *\r\n * @param {Number[]} array The array of components to unpack.\r\n * @param {Cartesian2[]} [result] The array onto which to store the result.\r\n * @returns {Cartesian2[]} The unpacked array.\r\n */\r\nCartesian2.unpackArray = function (array, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"array\", array);\r\n  Check.typeOf.number.greaterThanOrEquals(\"array.length\", array.length, 2);\r\n  if (array.length % 2 !== 0) {\r\n    throw new DeveloperError(\"array length must be a multiple of 2.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const length = array.length;\r\n  if (!defined(result)) {\r\n    result = new Array(length / 2);\r\n  } else {\r\n    result.length = length / 2;\r\n  }\r\n\r\n  for (let i = 0; i < length; i += 2) {\r\n    const index = i / 2;\r\n    result[index] = Cartesian2.unpack(array, i, result[index]);\r\n  }\r\n  return result;\r\n};\r\n\r\n/**\r\n * Creates a Cartesian2 from two consecutive elements in an array.\r\n * @function\r\n *\r\n * @param {Number[]} array The array whose two consecutive elements correspond to the x and y components, respectively.\r\n * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.\r\n * @param {Cartesian2} [result] The object onto which to store the result.\r\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\r\n *\r\n * @example\r\n * // Create a Cartesian2 with (1.0, 2.0)\r\n * const v = [1.0, 2.0];\r\n * const p = Cesium.Cartesian2.fromArray(v);\r\n *\r\n * // Create a Cartesian2 with (1.0, 2.0) using an offset into an array\r\n * const v2 = [0.0, 0.0, 1.0, 2.0];\r\n * const p2 = Cesium.Cartesian2.fromArray(v2, 2);\r\n */\r\nCartesian2.fromArray = Cartesian2.unpack;\r\n\r\n/**\r\n * Computes the value of the maximum component for the supplied Cartesian.\r\n *\r\n * @param {Cartesian2} cartesian The cartesian to use.\r\n * @returns {Number} The value of the maximum component.\r\n */\r\nCartesian2.maximumComponent = function (cartesian) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"cartesian\", cartesian);\r\n  //>>includeEnd('debug');\r\n\r\n  return Math.max(cartesian.x, cartesian.y);\r\n};\r\n\r\n/**\r\n * Computes the value of the minimum component for the supplied Cartesian.\r\n *\r\n * @param {Cartesian2} cartesian The cartesian to use.\r\n * @returns {Number} The value of the minimum component.\r\n */\r\nCartesian2.minimumComponent = function (cartesian) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"cartesian\", cartesian);\r\n  //>>includeEnd('debug');\r\n\r\n  return Math.min(cartesian.x, cartesian.y);\r\n};\r\n\r\n/**\r\n * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.\r\n *\r\n * @param {Cartesian2} first A cartesian to compare.\r\n * @param {Cartesian2} second A cartesian to compare.\r\n * @param {Cartesian2} result The object into which to store the result.\r\n * @returns {Cartesian2} A cartesian with the minimum components.\r\n */\r\nCartesian2.minimumByComponent = function (first, second, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"first\", first);\r\n  Check.typeOf.object(\"second\", second);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result.x = Math.min(first.x, second.x);\r\n  result.y = Math.min(first.y, second.y);\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.\r\n *\r\n * @param {Cartesian2} first A cartesian to compare.\r\n * @param {Cartesian2} second A cartesian to compare.\r\n * @param {Cartesian2} result The object into which to store the result.\r\n * @returns {Cartesian2} A cartesian with the maximum components.\r\n */\r\nCartesian2.maximumByComponent = function (first, second, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"first\", first);\r\n  Check.typeOf.object(\"second\", second);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result.x = Math.max(first.x, second.x);\r\n  result.y = Math.max(first.y, second.y);\r\n  return result;\r\n};\r\n\r\n/**\r\n * Constrain a value to lie between two values.\r\n *\r\n * @param {Cartesian2} value The value to clamp.\r\n * @param {Cartesian2} min The minimum bound.\r\n * @param {Cartesian2} max The maximum bound.\r\n * @param {Cartesian2} result The object into which to store the result.\r\n * @returns {Cartesian2} The clamped value such that min <= result <= max.\r\n */\r\nCartesian2.clamp = function (value, min, max, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"value\", value);\r\n  Check.typeOf.object(\"min\", min);\r\n  Check.typeOf.object(\"max\", max);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  const x = CesiumMath.clamp(value.x, min.x, max.x);\r\n  const y = CesiumMath.clamp(value.y, min.y, max.y);\r\n\r\n  result.x = x;\r\n  result.y = y;\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the provided Cartesian's squared magnitude.\r\n *\r\n * @param {Cartesian2} cartesian The Cartesian instance whose squared magnitude is to be computed.\r\n * @returns {Number} The squared magnitude.\r\n */\r\nCartesian2.magnitudeSquared = function (cartesian) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"cartesian\", cartesian);\r\n  //>>includeEnd('debug');\r\n\r\n  return cartesian.x * cartesian.x + cartesian.y * cartesian.y;\r\n};\r\n\r\n/**\r\n * Computes the Cartesian's magnitude (length).\r\n *\r\n * @param {Cartesian2} cartesian The Cartesian instance whose magnitude is to be computed.\r\n * @returns {Number} The magnitude.\r\n */\r\nCartesian2.magnitude = function (cartesian) {\r\n  return Math.sqrt(Cartesian2.magnitudeSquared(cartesian));\r\n};\r\n\r\nconst distanceScratch = new Cartesian2();\r\n\r\n/**\r\n * Computes the distance between two points.\r\n *\r\n * @param {Cartesian2} left The first point to compute the distance from.\r\n * @param {Cartesian2} right The second point to compute the distance to.\r\n * @returns {Number} The distance between two points.\r\n *\r\n * @example\r\n * // Returns 1.0\r\n * const d = Cesium.Cartesian2.distance(new Cesium.Cartesian2(1.0, 0.0), new Cesium.Cartesian2(2.0, 0.0));\r\n */\r\nCartesian2.distance = function (left, right) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"left\", left);\r\n  Check.typeOf.object(\"right\", right);\r\n  //>>includeEnd('debug');\r\n\r\n  Cartesian2.subtract(left, right, distanceScratch);\r\n  return Cartesian2.magnitude(distanceScratch);\r\n};\r\n\r\n/**\r\n * Computes the squared distance between two points.  Comparing squared distances\r\n * using this function is more efficient than comparing distances using {@link Cartesian2#distance}.\r\n *\r\n * @param {Cartesian2} left The first point to compute the distance from.\r\n * @param {Cartesian2} right The second point to compute the distance to.\r\n * @returns {Number} The distance between two points.\r\n *\r\n * @example\r\n * // Returns 4.0, not 2.0\r\n * const d = Cesium.Cartesian2.distance(new Cesium.Cartesian2(1.0, 0.0), new Cesium.Cartesian2(3.0, 0.0));\r\n */\r\nCartesian2.distanceSquared = function (left, right) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"left\", left);\r\n  Check.typeOf.object(\"right\", right);\r\n  //>>includeEnd('debug');\r\n\r\n  Cartesian2.subtract(left, right, distanceScratch);\r\n  return Cartesian2.magnitudeSquared(distanceScratch);\r\n};\r\n\r\n/**\r\n * Computes the normalized form of the supplied Cartesian.\r\n *\r\n * @param {Cartesian2} cartesian The Cartesian to be normalized.\r\n * @param {Cartesian2} result The object onto which to store the result.\r\n * @returns {Cartesian2} The modified result parameter.\r\n */\r\nCartesian2.normalize = function (cartesian, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"cartesian\", cartesian);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  const magnitude = Cartesian2.magnitude(cartesian);\r\n\r\n  result.x = cartesian.x / magnitude;\r\n  result.y = cartesian.y / magnitude;\r\n\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (isNaN(result.x) || isNaN(result.y)) {\r\n    throw new DeveloperError(\"normalized result is not a number\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the dot (scalar) product of two Cartesians.\r\n *\r\n * @param {Cartesian2} left The first Cartesian.\r\n * @param {Cartesian2} right The second Cartesian.\r\n * @returns {Number} The dot product.\r\n */\r\nCartesian2.dot = function (left, right) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"left\", left);\r\n  Check.typeOf.object(\"right\", right);\r\n  //>>includeEnd('debug');\r\n\r\n  return left.x * right.x + left.y * right.y;\r\n};\r\n\r\n/**\r\n * Computes the magnitude of the cross product that would result from implicitly setting the Z coordinate of the input vectors to 0\r\n *\r\n * @param {Cartesian2} left The first Cartesian.\r\n * @param {Cartesian2} right The second Cartesian.\r\n * @returns {Number} The cross product.\r\n */\r\nCartesian2.cross = function (left, right) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"left\", left);\r\n  Check.typeOf.object(\"right\", right);\r\n  //>>includeEnd('debug');\r\n\r\n  return left.x * right.y - left.y * right.x;\r\n};\r\n\r\n/**\r\n * Computes the componentwise product of two Cartesians.\r\n *\r\n * @param {Cartesian2} left The first Cartesian.\r\n * @param {Cartesian2} right The second Cartesian.\r\n * @param {Cartesian2} result The object onto which to store the result.\r\n * @returns {Cartesian2} The modified result parameter.\r\n */\r\nCartesian2.multiplyComponents = function (left, right, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"left\", left);\r\n  Check.typeOf.object(\"right\", right);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result.x = left.x * right.x;\r\n  result.y = left.y * right.y;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the componentwise quotient of two Cartesians.\r\n *\r\n * @param {Cartesian2} left The first Cartesian.\r\n * @param {Cartesian2} right The second Cartesian.\r\n * @param {Cartesian2} result The object onto which to store the result.\r\n * @returns {Cartesian2} The modified result parameter.\r\n */\r\nCartesian2.divideComponents = function (left, right, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"left\", left);\r\n  Check.typeOf.object(\"right\", right);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result.x = left.x / right.x;\r\n  result.y = left.y / right.y;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the componentwise sum of two Cartesians.\r\n *\r\n * @param {Cartesian2} left The first Cartesian.\r\n * @param {Cartesian2} right The second Cartesian.\r\n * @param {Cartesian2} result The object onto which to store the result.\r\n * @returns {Cartesian2} The modified result parameter.\r\n */\r\nCartesian2.add = function (left, right, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"left\", left);\r\n  Check.typeOf.object(\"right\", right);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result.x = left.x + right.x;\r\n  result.y = left.y + right.y;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the componentwise difference of two Cartesians.\r\n *\r\n * @param {Cartesian2} left The first Cartesian.\r\n * @param {Cartesian2} right The second Cartesian.\r\n * @param {Cartesian2} result The object onto which to store the result.\r\n * @returns {Cartesian2} The modified result parameter.\r\n */\r\nCartesian2.subtract = function (left, right, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"left\", left);\r\n  Check.typeOf.object(\"right\", right);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result.x = left.x - right.x;\r\n  result.y = left.y - right.y;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Multiplies the provided Cartesian componentwise by the provided scalar.\r\n *\r\n * @param {Cartesian2} cartesian The Cartesian to be scaled.\r\n * @param {Number} scalar The scalar to multiply with.\r\n * @param {Cartesian2} result The object onto which to store the result.\r\n * @returns {Cartesian2} The modified result parameter.\r\n */\r\nCartesian2.multiplyByScalar = function (cartesian, scalar, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"cartesian\", cartesian);\r\n  Check.typeOf.number(\"scalar\", scalar);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result.x = cartesian.x * scalar;\r\n  result.y = cartesian.y * scalar;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Divides the provided Cartesian componentwise by the provided scalar.\r\n *\r\n * @param {Cartesian2} cartesian The Cartesian to be divided.\r\n * @param {Number} scalar The scalar to divide by.\r\n * @param {Cartesian2} result The object onto which to store the result.\r\n * @returns {Cartesian2} The modified result parameter.\r\n */\r\nCartesian2.divideByScalar = function (cartesian, scalar, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"cartesian\", cartesian);\r\n  Check.typeOf.number(\"scalar\", scalar);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result.x = cartesian.x / scalar;\r\n  result.y = cartesian.y / scalar;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Negates the provided Cartesian.\r\n *\r\n * @param {Cartesian2} cartesian The Cartesian to be negated.\r\n * @param {Cartesian2} result The object onto which to store the result.\r\n * @returns {Cartesian2} The modified result parameter.\r\n */\r\nCartesian2.negate = function (cartesian, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"cartesian\", cartesian);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result.x = -cartesian.x;\r\n  result.y = -cartesian.y;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the absolute value of the provided Cartesian.\r\n *\r\n * @param {Cartesian2} cartesian The Cartesian whose absolute value is to be computed.\r\n * @param {Cartesian2} result The object onto which to store the result.\r\n * @returns {Cartesian2} The modified result parameter.\r\n */\r\nCartesian2.abs = function (cartesian, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"cartesian\", cartesian);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result.x = Math.abs(cartesian.x);\r\n  result.y = Math.abs(cartesian.y);\r\n  return result;\r\n};\r\n\r\nconst lerpScratch = new Cartesian2();\r\n/**\r\n * Computes the linear interpolation or extrapolation at t using the provided cartesians.\r\n *\r\n * @param {Cartesian2} start The value corresponding to t at 0.0.\r\n * @param {Cartesian2} end The value corresponding to t at 1.0.\r\n * @param {Number} t The point along t at which to interpolate.\r\n * @param {Cartesian2} result The object onto which to store the result.\r\n * @returns {Cartesian2} The modified result parameter.\r\n */\r\nCartesian2.lerp = function (start, end, t, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"start\", start);\r\n  Check.typeOf.object(\"end\", end);\r\n  Check.typeOf.number(\"t\", t);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  Cartesian2.multiplyByScalar(end, t, lerpScratch);\r\n  result = Cartesian2.multiplyByScalar(start, 1.0 - t, result);\r\n  return Cartesian2.add(lerpScratch, result, result);\r\n};\r\n\r\nconst angleBetweenScratch = new Cartesian2();\r\nconst angleBetweenScratch2 = new Cartesian2();\r\n/**\r\n * Returns the angle, in radians, between the provided Cartesians.\r\n *\r\n * @param {Cartesian2} left The first Cartesian.\r\n * @param {Cartesian2} right The second Cartesian.\r\n * @returns {Number} The angle between the Cartesians.\r\n */\r\nCartesian2.angleBetween = function (left, right) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"left\", left);\r\n  Check.typeOf.object(\"right\", right);\r\n  //>>includeEnd('debug');\r\n\r\n  Cartesian2.normalize(left, angleBetweenScratch);\r\n  Cartesian2.normalize(right, angleBetweenScratch2);\r\n  return CesiumMath.acosClamped(\r\n    Cartesian2.dot(angleBetweenScratch, angleBetweenScratch2)\r\n  );\r\n};\r\n\r\nconst mostOrthogonalAxisScratch = new Cartesian2();\r\n/**\r\n * Returns the axis that is most orthogonal to the provided Cartesian.\r\n *\r\n * @param {Cartesian2} cartesian The Cartesian on which to find the most orthogonal axis.\r\n * @param {Cartesian2} result The object onto which to store the result.\r\n * @returns {Cartesian2} The most orthogonal axis.\r\n */\r\nCartesian2.mostOrthogonalAxis = function (cartesian, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"cartesian\", cartesian);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  const f = Cartesian2.normalize(cartesian, mostOrthogonalAxisScratch);\r\n  Cartesian2.abs(f, f);\r\n\r\n  if (f.x <= f.y) {\r\n    result = Cartesian2.clone(Cartesian2.UNIT_X, result);\r\n  } else {\r\n    result = Cartesian2.clone(Cartesian2.UNIT_Y, result);\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Compares the provided Cartesians componentwise and returns\r\n * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n *\r\n * @param {Cartesian2} [left] The first Cartesian.\r\n * @param {Cartesian2} [right] The second Cartesian.\r\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\r\n */\r\nCartesian2.equals = function (left, right) {\r\n  return (\r\n    left === right ||\r\n    (defined(left) &&\r\n      defined(right) &&\r\n      left.x === right.x &&\r\n      left.y === right.y)\r\n  );\r\n};\r\n\r\n/**\r\n * @private\r\n */\r\nCartesian2.equalsArray = function (cartesian, array, offset) {\r\n  return cartesian.x === array[offset] && cartesian.y === array[offset + 1];\r\n};\r\n\r\n/**\r\n * Compares the provided Cartesians componentwise and returns\r\n * <code>true</code> if they pass an absolute or relative tolerance test,\r\n * <code>false</code> otherwise.\r\n *\r\n * @param {Cartesian2} [left] The first Cartesian.\r\n * @param {Cartesian2} [right] The second Cartesian.\r\n * @param {Number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\r\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\r\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\r\n */\r\nCartesian2.equalsEpsilon = function (\r\n  left,\r\n  right,\r\n  relativeEpsilon,\r\n  absoluteEpsilon\r\n) {\r\n  return (\r\n    left === right ||\r\n    (defined(left) &&\r\n      defined(right) &&\r\n      CesiumMath.equalsEpsilon(\r\n        left.x,\r\n        right.x,\r\n        relativeEpsilon,\r\n        absoluteEpsilon\r\n      ) &&\r\n      CesiumMath.equalsEpsilon(\r\n        left.y,\r\n        right.y,\r\n        relativeEpsilon,\r\n        absoluteEpsilon\r\n      ))\r\n  );\r\n};\r\n\r\n/**\r\n * An immutable Cartesian2 instance initialized to (0.0, 0.0).\r\n *\r\n * @type {Cartesian2}\r\n * @constant\r\n */\r\nCartesian2.ZERO = Object.freeze(new Cartesian2(0.0, 0.0));\r\n\r\n/**\r\n * An immutable Cartesian2 instance initialized to (1.0, 1.0).\r\n *\r\n * @type {Cartesian2}\r\n * @constant\r\n */\r\nCartesian2.ONE = Object.freeze(new Cartesian2(1.0, 1.0));\r\n\r\n/**\r\n * An immutable Cartesian2 instance initialized to (1.0, 0.0).\r\n *\r\n * @type {Cartesian2}\r\n * @constant\r\n */\r\nCartesian2.UNIT_X = Object.freeze(new Cartesian2(1.0, 0.0));\r\n\r\n/**\r\n * An immutable Cartesian2 instance initialized to (0.0, 1.0).\r\n *\r\n * @type {Cartesian2}\r\n * @constant\r\n */\r\nCartesian2.UNIT_Y = Object.freeze(new Cartesian2(0.0, 1.0));\r\n\r\n/**\r\n * Duplicates this Cartesian2 instance.\r\n *\r\n * @param {Cartesian2} [result] The object onto which to store the result.\r\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\r\n */\r\nCartesian2.prototype.clone = function (result) {\r\n  return Cartesian2.clone(this, result);\r\n};\r\n\r\n/**\r\n * Compares this Cartesian against the provided Cartesian componentwise and returns\r\n * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n *\r\n * @param {Cartesian2} [right] The right hand side Cartesian.\r\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\r\n */\r\nCartesian2.prototype.equals = function (right) {\r\n  return Cartesian2.equals(this, right);\r\n};\r\n\r\n/**\r\n * Compares this Cartesian against the provided Cartesian componentwise and returns\r\n * <code>true</code> if they pass an absolute or relative tolerance test,\r\n * <code>false</code> otherwise.\r\n *\r\n * @param {Cartesian2} [right] The right hand side Cartesian.\r\n * @param {Number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\r\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\r\n * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\r\n */\r\nCartesian2.prototype.equalsEpsilon = function (\r\n  right,\r\n  relativeEpsilon,\r\n  absoluteEpsilon\r\n) {\r\n  return Cartesian2.equalsEpsilon(\r\n    this,\r\n    right,\r\n    relativeEpsilon,\r\n    absoluteEpsilon\r\n  );\r\n};\r\n\r\n/**\r\n * Creates a string representing this Cartesian in the format '(x, y)'.\r\n *\r\n * @returns {String} A string representing the provided Cartesian in the format '(x, y)'.\r\n */\r\nCartesian2.prototype.toString = function () {\r\n  return `(${this.x}, ${this.y})`;\r\n};\r\nexport default Cartesian2;\r\n","import Cartesian2 from \"./Cartesian2.js\";\r\nimport Check from \"./Check.js\";\r\nimport defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\nimport DeveloperError from \"./DeveloperError.js\";\r\n\r\n/**\r\n * A 2x2 matrix, indexable as a column-major order array.\r\n * Constructor parameters are in row-major order for code readability.\r\n * @alias Matrix2\r\n * @constructor\r\n * @implements {ArrayLike<number>}\r\n *\r\n * @param {Number} [column0Row0=0.0] The value for column 0, row 0.\r\n * @param {Number} [column1Row0=0.0] The value for column 1, row 0.\r\n * @param {Number} [column0Row1=0.0] The value for column 0, row 1.\r\n * @param {Number} [column1Row1=0.0] The value for column 1, row 1.\r\n *\r\n * @see Matrix2.fromArray\r\n * @see Matrix2.fromColumnMajorArray\r\n * @see Matrix2.fromRowMajorArray\r\n * @see Matrix2.fromScale\r\n * @see Matrix2.fromUniformScale\r\n * @see Matrix2.fromRotation\r\n * @see Matrix3\r\n * @see Matrix4\r\n */\r\nfunction Matrix2(column0Row0, column1Row0, column0Row1, column1Row1) {\r\n  this[0] = defaultValue(column0Row0, 0.0);\r\n  this[1] = defaultValue(column0Row1, 0.0);\r\n  this[2] = defaultValue(column1Row0, 0.0);\r\n  this[3] = defaultValue(column1Row1, 0.0);\r\n}\r\n\r\n/**\r\n * The number of elements used to pack the object into an array.\r\n * @type {Number}\r\n */\r\nMatrix2.packedLength = 4;\r\n\r\n/**\r\n * Stores the provided instance into the provided array.\r\n *\r\n * @param {Matrix2} value The value to pack.\r\n * @param {Number[]} array The array to pack into.\r\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n *\r\n * @returns {Number[]} The array that was packed into\r\n */\r\nMatrix2.pack = function (value, array, startingIndex) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"value\", value);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  array[startingIndex++] = value[0];\r\n  array[startingIndex++] = value[1];\r\n  array[startingIndex++] = value[2];\r\n  array[startingIndex++] = value[3];\r\n\r\n  return array;\r\n};\r\n\r\n/**\r\n * Retrieves an instance from a packed array.\r\n *\r\n * @param {Number[]} array The packed array.\r\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n * @param {Matrix2} [result] The object into which to store the result.\r\n * @returns {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided.\r\n */\r\nMatrix2.unpack = function (array, startingIndex, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  if (!defined(result)) {\r\n    result = new Matrix2();\r\n  }\r\n\r\n  result[0] = array[startingIndex++];\r\n  result[1] = array[startingIndex++];\r\n  result[2] = array[startingIndex++];\r\n  result[3] = array[startingIndex++];\r\n  return result;\r\n};\r\n\r\n/**\r\n * Flattens an array of Matrix2s into an array of components. The components\r\n * are stored in column-major order.\r\n *\r\n * @param {Matrix2[]} array The array of matrices to pack.\r\n * @param {Number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 4 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 4) elements.\r\n * @returns {Number[]} The packed array.\r\n */\r\nMatrix2.packArray = function (array, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  const length = array.length;\r\n  const resultLength = length * 4;\r\n  if (!defined(result)) {\r\n    result = new Array(resultLength);\r\n  } else if (!Array.isArray(result) && result.length !== resultLength) {\r\n    //>>includeStart('debug', pragmas.debug);\r\n    throw new DeveloperError(\r\n      \"If result is a typed array, it must have exactly array.length * 4 elements\"\r\n    );\r\n    //>>includeEnd('debug');\r\n  } else if (result.length !== resultLength) {\r\n    result.length = resultLength;\r\n  }\r\n\r\n  for (let i = 0; i < length; ++i) {\r\n    Matrix2.pack(array[i], result, i * 4);\r\n  }\r\n  return result;\r\n};\r\n\r\n/**\r\n * Unpacks an array of column-major matrix components into an array of Matrix2s.\r\n *\r\n * @param {Number[]} array The array of components to unpack.\r\n * @param {Matrix2[]} [result] The array onto which to store the result.\r\n * @returns {Matrix2[]} The unpacked array.\r\n */\r\nMatrix2.unpackArray = function (array, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"array\", array);\r\n  Check.typeOf.number.greaterThanOrEquals(\"array.length\", array.length, 4);\r\n  if (array.length % 4 !== 0) {\r\n    throw new DeveloperError(\"array length must be a multiple of 4.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const length = array.length;\r\n  if (!defined(result)) {\r\n    result = new Array(length / 4);\r\n  } else {\r\n    result.length = length / 4;\r\n  }\r\n\r\n  for (let i = 0; i < length; i += 4) {\r\n    const index = i / 4;\r\n    result[index] = Matrix2.unpack(array, i, result[index]);\r\n  }\r\n  return result;\r\n};\r\n\r\n/**\r\n * Duplicates a Matrix2 instance.\r\n *\r\n * @param {Matrix2} matrix The matrix to duplicate.\r\n * @param {Matrix2} [result] The object onto which to store the result.\r\n * @returns {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided. (Returns undefined if matrix is undefined)\r\n */\r\nMatrix2.clone = function (matrix, result) {\r\n  if (!defined(matrix)) {\r\n    return undefined;\r\n  }\r\n  if (!defined(result)) {\r\n    return new Matrix2(matrix[0], matrix[2], matrix[1], matrix[3]);\r\n  }\r\n  result[0] = matrix[0];\r\n  result[1] = matrix[1];\r\n  result[2] = matrix[2];\r\n  result[3] = matrix[3];\r\n  return result;\r\n};\r\n\r\n/**\r\n * Creates a Matrix2 from 4 consecutive elements in an array.\r\n *\r\n * @function\r\n * @param {Number[]} array The array whose 4 consecutive elements correspond to the positions of the matrix.  Assumes column-major order.\r\n * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to first column first row position in the matrix.\r\n * @param {Matrix2} [result] The object onto which to store the result.\r\n * @returns {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided.\r\n *\r\n * @example\r\n * // Create the Matrix2:\r\n * // [1.0, 2.0]\r\n * // [1.0, 2.0]\r\n *\r\n * const v = [1.0, 1.0, 2.0, 2.0];\r\n * const m = Cesium.Matrix2.fromArray(v);\r\n *\r\n * // Create same Matrix2 with using an offset into an array\r\n * const v2 = [0.0, 0.0, 1.0, 1.0, 2.0, 2.0];\r\n * const m2 = Cesium.Matrix2.fromArray(v2, 2);\r\n */\r\nMatrix2.fromArray = Matrix2.unpack;\r\n/**\r\n * Creates a Matrix2 instance from a column-major order array.\r\n *\r\n * @param {Number[]} values The column-major order array.\r\n * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\r\n * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\r\n */\r\nMatrix2.fromColumnMajorArray = function (values, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"values\", values);\r\n  //>>includeEnd('debug');\r\n\r\n  return Matrix2.clone(values, result);\r\n};\r\n\r\n/**\r\n * Creates a Matrix2 instance from a row-major order array.\r\n * The resulting matrix will be in column-major order.\r\n *\r\n * @param {Number[]} values The row-major order array.\r\n * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\r\n * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\r\n */\r\nMatrix2.fromRowMajorArray = function (values, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"values\", values);\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    return new Matrix2(values[0], values[1], values[2], values[3]);\r\n  }\r\n  result[0] = values[0];\r\n  result[1] = values[2];\r\n  result[2] = values[1];\r\n  result[3] = values[3];\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes a Matrix2 instance representing a non-uniform scale.\r\n *\r\n * @param {Cartesian2} scale The x and y scale factors.\r\n * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\r\n * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\r\n *\r\n * @example\r\n * // Creates\r\n * //   [7.0, 0.0]\r\n * //   [0.0, 8.0]\r\n * const m = Cesium.Matrix2.fromScale(new Cesium.Cartesian2(7.0, 8.0));\r\n */\r\nMatrix2.fromScale = function (scale, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"scale\", scale);\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    return new Matrix2(scale.x, 0.0, 0.0, scale.y);\r\n  }\r\n\r\n  result[0] = scale.x;\r\n  result[1] = 0.0;\r\n  result[2] = 0.0;\r\n  result[3] = scale.y;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes a Matrix2 instance representing a uniform scale.\r\n *\r\n * @param {Number} scale The uniform scale factor.\r\n * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\r\n * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\r\n *\r\n * @example\r\n * // Creates\r\n * //   [2.0, 0.0]\r\n * //   [0.0, 2.0]\r\n * const m = Cesium.Matrix2.fromUniformScale(2.0);\r\n */\r\nMatrix2.fromUniformScale = function (scale, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.number(\"scale\", scale);\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    return new Matrix2(scale, 0.0, 0.0, scale);\r\n  }\r\n\r\n  result[0] = scale;\r\n  result[1] = 0.0;\r\n  result[2] = 0.0;\r\n  result[3] = scale;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Creates a rotation matrix.\r\n *\r\n * @param {Number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.\r\n * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\r\n * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\r\n *\r\n * @example\r\n * // Rotate a point 45 degrees counterclockwise.\r\n * const p = new Cesium.Cartesian2(5, 6);\r\n * const m = Cesium.Matrix2.fromRotation(Cesium.Math.toRadians(45.0));\r\n * const rotated = Cesium.Matrix2.multiplyByVector(m, p, new Cesium.Cartesian2());\r\n */\r\nMatrix2.fromRotation = function (angle, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.number(\"angle\", angle);\r\n  //>>includeEnd('debug');\r\n\r\n  const cosAngle = Math.cos(angle);\r\n  const sinAngle = Math.sin(angle);\r\n\r\n  if (!defined(result)) {\r\n    return new Matrix2(cosAngle, -sinAngle, sinAngle, cosAngle);\r\n  }\r\n  result[0] = cosAngle;\r\n  result[1] = sinAngle;\r\n  result[2] = -sinAngle;\r\n  result[3] = cosAngle;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Creates an Array from the provided Matrix2 instance.\r\n * The array will be in column-major order.\r\n *\r\n * @param {Matrix2} matrix The matrix to use..\r\n * @param {Number[]} [result] The Array onto which to store the result.\r\n * @returns {Number[]} The modified Array parameter or a new Array instance if one was not provided.\r\n */\r\nMatrix2.toArray = function (matrix, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    return [matrix[0], matrix[1], matrix[2], matrix[3]];\r\n  }\r\n  result[0] = matrix[0];\r\n  result[1] = matrix[1];\r\n  result[2] = matrix[2];\r\n  result[3] = matrix[3];\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the array index of the element at the provided row and column.\r\n *\r\n * @param {Number} row The zero-based index of the row.\r\n * @param {Number} column The zero-based index of the column.\r\n * @returns {Number} The index of the element at the provided row and column.\r\n *\r\n * @exception {DeveloperError} row must be 0 or 1.\r\n * @exception {DeveloperError} column must be 0 or 1.\r\n *\r\n * @example\r\n * const myMatrix = new Cesium.Matrix2();\r\n * const column1Row0Index = Cesium.Matrix2.getElementIndex(1, 0);\r\n * const column1Row0 = myMatrix[column1Row0Index]\r\n * myMatrix[column1Row0Index] = 10.0;\r\n */\r\nMatrix2.getElementIndex = function (column, row) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.number.greaterThanOrEquals(\"row\", row, 0);\r\n  Check.typeOf.number.lessThanOrEquals(\"row\", row, 1);\r\n\r\n  Check.typeOf.number.greaterThanOrEquals(\"column\", column, 0);\r\n  Check.typeOf.number.lessThanOrEquals(\"column\", column, 1);\r\n  //>>includeEnd('debug');\r\n\r\n  return column * 2 + row;\r\n};\r\n\r\n/**\r\n * Retrieves a copy of the matrix column at the provided index as a Cartesian2 instance.\r\n *\r\n * @param {Matrix2} matrix The matrix to use.\r\n * @param {Number} index The zero-based index of the column to retrieve.\r\n * @param {Cartesian2} result The object onto which to store the result.\r\n * @returns {Cartesian2} The modified result parameter.\r\n *\r\n * @exception {DeveloperError} index must be 0 or 1.\r\n */\r\nMatrix2.getColumn = function (matrix, index, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n\r\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\r\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 1);\r\n\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  const startIndex = index * 2;\r\n  const x = matrix[startIndex];\r\n  const y = matrix[startIndex + 1];\r\n\r\n  result.x = x;\r\n  result.y = y;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian2 instance.\r\n *\r\n * @param {Matrix2} matrix The matrix to use.\r\n * @param {Number} index The zero-based index of the column to set.\r\n * @param {Cartesian2} cartesian The Cartesian whose values will be assigned to the specified column.\r\n * @param {Cartesian2} result The object onto which to store the result.\r\n * @returns {Matrix2} The modified result parameter.\r\n *\r\n * @exception {DeveloperError} index must be 0 or 1.\r\n */\r\nMatrix2.setColumn = function (matrix, index, cartesian, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n\r\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\r\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 1);\r\n\r\n  Check.typeOf.object(\"cartesian\", cartesian);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result = Matrix2.clone(matrix, result);\r\n  const startIndex = index * 2;\r\n  result[startIndex] = cartesian.x;\r\n  result[startIndex + 1] = cartesian.y;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Retrieves a copy of the matrix row at the provided index as a Cartesian2 instance.\r\n *\r\n * @param {Matrix2} matrix The matrix to use.\r\n * @param {Number} index The zero-based index of the row to retrieve.\r\n * @param {Cartesian2} result The object onto which to store the result.\r\n * @returns {Cartesian2} The modified result parameter.\r\n *\r\n * @exception {DeveloperError} index must be 0 or 1.\r\n */\r\nMatrix2.getRow = function (matrix, index, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n\r\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\r\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 1);\r\n\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  const x = matrix[index];\r\n  const y = matrix[index + 2];\r\n\r\n  result.x = x;\r\n  result.y = y;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian2 instance.\r\n *\r\n * @param {Matrix2} matrix The matrix to use.\r\n * @param {Number} index The zero-based index of the row to set.\r\n * @param {Cartesian2} cartesian The Cartesian whose values will be assigned to the specified row.\r\n * @param {Matrix2} result The object onto which to store the result.\r\n * @returns {Matrix2} The modified result parameter.\r\n *\r\n * @exception {DeveloperError} index must be 0 or 1.\r\n */\r\nMatrix2.setRow = function (matrix, index, cartesian, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n\r\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\r\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 1);\r\n\r\n  Check.typeOf.object(\"cartesian\", cartesian);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result = Matrix2.clone(matrix, result);\r\n  result[index] = cartesian.x;\r\n  result[index + 2] = cartesian.y;\r\n  return result;\r\n};\r\n\r\nconst scaleScratch1 = new Cartesian2();\r\n\r\n/**\r\n * Computes a new matrix that replaces the scale with the provided scale.\r\n * This assumes the matrix is an affine transformation.\r\n *\r\n * @param {Matrix2} matrix The matrix to use.\r\n * @param {Cartesian2} scale The scale that replaces the scale of the provided matrix.\r\n * @param {Matrix2} result The object onto which to store the result.\r\n * @returns {Matrix2} The modified result parameter.\r\n *\r\n * @see Matrix2.setUniformScale\r\n * @see Matrix2.fromScale\r\n * @see Matrix2.fromUniformScale\r\n * @see Matrix2.multiplyByScale\r\n * @see Matrix2.multiplyByUniformScale\r\n * @see Matrix2.getScale\r\n */\r\nMatrix2.setScale = function (matrix, scale, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  Check.typeOf.object(\"scale\", scale);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  const existingScale = Matrix2.getScale(matrix, scaleScratch1);\r\n  const scaleRatioX = scale.x / existingScale.x;\r\n  const scaleRatioY = scale.y / existingScale.y;\r\n\r\n  result[0] = matrix[0] * scaleRatioX;\r\n  result[1] = matrix[1] * scaleRatioX;\r\n  result[2] = matrix[2] * scaleRatioY;\r\n  result[3] = matrix[3] * scaleRatioY;\r\n\r\n  return result;\r\n};\r\n\r\nconst scaleScratch2 = new Cartesian2();\r\n\r\n/**\r\n * Computes a new matrix that replaces the scale with the provided uniform scale.\r\n * This assumes the matrix is an affine transformation.\r\n *\r\n * @param {Matrix2} matrix The matrix to use.\r\n * @param {Number} scale The uniform scale that replaces the scale of the provided matrix.\r\n * @param {Matrix2} result The object onto which to store the result.\r\n * @returns {Matrix2} The modified result parameter.\r\n *\r\n * @see Matrix2.setScale\r\n * @see Matrix2.fromScale\r\n * @see Matrix2.fromUniformScale\r\n * @see Matrix2.multiplyByScale\r\n * @see Matrix2.multiplyByUniformScale\r\n * @see Matrix2.getScale\r\n */\r\nMatrix2.setUniformScale = function (matrix, scale, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  Check.typeOf.number(\"scale\", scale);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  const existingScale = Matrix2.getScale(matrix, scaleScratch2);\r\n  const scaleRatioX = scale / existingScale.x;\r\n  const scaleRatioY = scale / existingScale.y;\r\n\r\n  result[0] = matrix[0] * scaleRatioX;\r\n  result[1] = matrix[1] * scaleRatioX;\r\n  result[2] = matrix[2] * scaleRatioY;\r\n  result[3] = matrix[3] * scaleRatioY;\r\n\r\n  return result;\r\n};\r\n\r\nconst scratchColumn = new Cartesian2();\r\n\r\n/**\r\n * Extracts the non-uniform scale assuming the matrix is an affine transformation.\r\n *\r\n * @param {Matrix2} matrix The matrix.\r\n * @param {Cartesian2} result The object onto which to store the result.\r\n * @returns {Cartesian2} The modified result parameter.\r\n *\r\n * @see Matrix2.multiplyByScale\r\n * @see Matrix2.multiplyByUniformScale\r\n * @see Matrix2.fromScale\r\n * @see Matrix2.fromUniformScale\r\n * @see Matrix2.setScale\r\n * @see Matrix2.setUniformScale\r\n */\r\nMatrix2.getScale = function (matrix, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result.x = Cartesian2.magnitude(\r\n    Cartesian2.fromElements(matrix[0], matrix[1], scratchColumn)\r\n  );\r\n  result.y = Cartesian2.magnitude(\r\n    Cartesian2.fromElements(matrix[2], matrix[3], scratchColumn)\r\n  );\r\n  return result;\r\n};\r\n\r\nconst scaleScratch3 = new Cartesian2();\r\n\r\n/**\r\n * Computes the maximum scale assuming the matrix is an affine transformation.\r\n * The maximum scale is the maximum length of the column vectors.\r\n *\r\n * @param {Matrix2} matrix The matrix.\r\n * @returns {Number} The maximum scale.\r\n */\r\nMatrix2.getMaximumScale = function (matrix) {\r\n  Matrix2.getScale(matrix, scaleScratch3);\r\n  return Cartesian2.maximumComponent(scaleScratch3);\r\n};\r\n\r\nconst scaleScratch4 = new Cartesian2();\r\n\r\n/**\r\n * Sets the rotation assuming the matrix is an affine transformation.\r\n *\r\n * @param {Matrix2} matrix The matrix.\r\n * @param {Matrix2} rotation The rotation matrix.\r\n * @returns {Matrix2} The modified result parameter.\r\n *\r\n * @see Matrix2.fromRotation\r\n * @see Matrix2.getRotation\r\n */\r\nMatrix2.setRotation = function (matrix, rotation, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  const scale = Matrix2.getScale(matrix, scaleScratch4);\r\n\r\n  result[0] = rotation[0] * scale.x;\r\n  result[1] = rotation[1] * scale.x;\r\n  result[2] = rotation[2] * scale.y;\r\n  result[3] = rotation[3] * scale.y;\r\n\r\n  return result;\r\n};\r\n\r\nconst scaleScratch5 = new Cartesian2();\r\n\r\n/**\r\n * Extracts the rotation matrix assuming the matrix is an affine transformation.\r\n *\r\n * @param {Matrix2} matrix The matrix.\r\n * @param {Matrix2} result The object onto which to store the result.\r\n * @returns {Matrix2} The modified result parameter.\r\n *\r\n * @see Matrix2.setRotation\r\n * @see Matrix2.fromRotation\r\n */\r\nMatrix2.getRotation = function (matrix, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  const scale = Matrix2.getScale(matrix, scaleScratch5);\r\n\r\n  result[0] = matrix[0] / scale.x;\r\n  result[1] = matrix[1] / scale.x;\r\n  result[2] = matrix[2] / scale.y;\r\n  result[3] = matrix[3] / scale.y;\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the product of two matrices.\r\n *\r\n * @param {Matrix2} left The first matrix.\r\n * @param {Matrix2} right The second matrix.\r\n * @param {Matrix2} result The object onto which to store the result.\r\n * @returns {Matrix2} The modified result parameter.\r\n */\r\nMatrix2.multiply = function (left, right, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"left\", left);\r\n  Check.typeOf.object(\"right\", right);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  const column0Row0 = left[0] * right[0] + left[2] * right[1];\r\n  const column1Row0 = left[0] * right[2] + left[2] * right[3];\r\n  const column0Row1 = left[1] * right[0] + left[3] * right[1];\r\n  const column1Row1 = left[1] * right[2] + left[3] * right[3];\r\n\r\n  result[0] = column0Row0;\r\n  result[1] = column0Row1;\r\n  result[2] = column1Row0;\r\n  result[3] = column1Row1;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the sum of two matrices.\r\n *\r\n * @param {Matrix2} left The first matrix.\r\n * @param {Matrix2} right The second matrix.\r\n * @param {Matrix2} result The object onto which to store the result.\r\n * @returns {Matrix2} The modified result parameter.\r\n */\r\nMatrix2.add = function (left, right, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"left\", left);\r\n  Check.typeOf.object(\"right\", right);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result[0] = left[0] + right[0];\r\n  result[1] = left[1] + right[1];\r\n  result[2] = left[2] + right[2];\r\n  result[3] = left[3] + right[3];\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the difference of two matrices.\r\n *\r\n * @param {Matrix2} left The first matrix.\r\n * @param {Matrix2} right The second matrix.\r\n * @param {Matrix2} result The object onto which to store the result.\r\n * @returns {Matrix2} The modified result parameter.\r\n */\r\nMatrix2.subtract = function (left, right, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"left\", left);\r\n  Check.typeOf.object(\"right\", right);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result[0] = left[0] - right[0];\r\n  result[1] = left[1] - right[1];\r\n  result[2] = left[2] - right[2];\r\n  result[3] = left[3] - right[3];\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the product of a matrix and a column vector.\r\n *\r\n * @param {Matrix2} matrix The matrix.\r\n * @param {Cartesian2} cartesian The column.\r\n * @param {Cartesian2} result The object onto which to store the result.\r\n * @returns {Cartesian2} The modified result parameter.\r\n */\r\nMatrix2.multiplyByVector = function (matrix, cartesian, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  Check.typeOf.object(\"cartesian\", cartesian);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  const x = matrix[0] * cartesian.x + matrix[2] * cartesian.y;\r\n  const y = matrix[1] * cartesian.x + matrix[3] * cartesian.y;\r\n\r\n  result.x = x;\r\n  result.y = y;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the product of a matrix and a scalar.\r\n *\r\n * @param {Matrix2} matrix The matrix.\r\n * @param {Number} scalar The number to multiply by.\r\n * @param {Matrix2} result The object onto which to store the result.\r\n * @returns {Matrix2} The modified result parameter.\r\n */\r\nMatrix2.multiplyByScalar = function (matrix, scalar, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  Check.typeOf.number(\"scalar\", scalar);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result[0] = matrix[0] * scalar;\r\n  result[1] = matrix[1] * scalar;\r\n  result[2] = matrix[2] * scalar;\r\n  result[3] = matrix[3] * scalar;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the product of a matrix times a (non-uniform) scale, as if the scale were a scale matrix.\r\n *\r\n * @param {Matrix2} matrix The matrix on the left-hand side.\r\n * @param {Number} scale The non-uniform scale on the right-hand side.\r\n * @param {Matrix2} result The object onto which to store the result.\r\n * @returns {Matrix2} The modified result parameter.\r\n *\r\n *\r\n * @example\r\n * // Instead of Cesium.Matrix2.multiply(m, Cesium.Matrix2.fromScale(scale), m);\r\n * Cesium.Matrix2.multiplyByScale(m, scale, m);\r\n *\r\n * @see Matrix2.multiplyByUniformScale\r\n * @see Matrix2.fromScale\r\n * @see Matrix2.fromUniformScale\r\n * @see Matrix2.setScale\r\n * @see Matrix2.setUniformScale\r\n * @see Matrix2.getScale\r\n */\r\nMatrix2.multiplyByScale = function (matrix, scale, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  Check.typeOf.object(\"scale\", scale);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result[0] = matrix[0] * scale.x;\r\n  result[1] = matrix[1] * scale.x;\r\n  result[2] = matrix[2] * scale.y;\r\n  result[3] = matrix[3] * scale.y;\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the product of a matrix times a uniform scale, as if the scale were a scale matrix.\r\n *\r\n * @param {Matrix2} matrix The matrix on the left-hand side.\r\n * @param {Number} scale The uniform scale on the right-hand side.\r\n * @param {Matrix2} result The object onto which to store the result.\r\n * @returns {Matrix2} The modified result parameter.\r\n *\r\n * @example\r\n * // Instead of Cesium.Matrix2.multiply(m, Cesium.Matrix2.fromUniformScale(scale), m);\r\n * Cesium.Matrix2.multiplyByUniformScale(m, scale, m);\r\n *\r\n * @see Matrix2.multiplyByScale\r\n * @see Matrix2.fromScale\r\n * @see Matrix2.fromUniformScale\r\n * @see Matrix2.setScale\r\n * @see Matrix2.setUniformScale\r\n * @see Matrix2.getScale\r\n */\r\nMatrix2.multiplyByUniformScale = function (matrix, scale, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  Check.typeOf.number(\"scale\", scale);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result[0] = matrix[0] * scale;\r\n  result[1] = matrix[1] * scale;\r\n  result[2] = matrix[2] * scale;\r\n  result[3] = matrix[3] * scale;\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Creates a negated copy of the provided matrix.\r\n *\r\n * @param {Matrix2} matrix The matrix to negate.\r\n * @param {Matrix2} result The object onto which to store the result.\r\n * @returns {Matrix2} The modified result parameter.\r\n */\r\nMatrix2.negate = function (matrix, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result[0] = -matrix[0];\r\n  result[1] = -matrix[1];\r\n  result[2] = -matrix[2];\r\n  result[3] = -matrix[3];\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the transpose of the provided matrix.\r\n *\r\n * @param {Matrix2} matrix The matrix to transpose.\r\n * @param {Matrix2} result The object onto which to store the result.\r\n * @returns {Matrix2} The modified result parameter.\r\n */\r\nMatrix2.transpose = function (matrix, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  const column0Row0 = matrix[0];\r\n  const column0Row1 = matrix[2];\r\n  const column1Row0 = matrix[1];\r\n  const column1Row1 = matrix[3];\r\n\r\n  result[0] = column0Row0;\r\n  result[1] = column0Row1;\r\n  result[2] = column1Row0;\r\n  result[3] = column1Row1;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes a matrix, which contains the absolute (unsigned) values of the provided matrix's elements.\r\n *\r\n * @param {Matrix2} matrix The matrix with signed elements.\r\n * @param {Matrix2} result The object onto which to store the result.\r\n * @returns {Matrix2} The modified result parameter.\r\n */\r\nMatrix2.abs = function (matrix, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"matrix\", matrix);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  result[0] = Math.abs(matrix[0]);\r\n  result[1] = Math.abs(matrix[1]);\r\n  result[2] = Math.abs(matrix[2]);\r\n  result[3] = Math.abs(matrix[3]);\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Compares the provided matrices componentwise and returns\r\n * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n *\r\n * @param {Matrix2} [left] The first matrix.\r\n * @param {Matrix2} [right] The second matrix.\r\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\r\n */\r\nMatrix2.equals = function (left, right) {\r\n  return (\r\n    left === right ||\r\n    (defined(left) &&\r\n      defined(right) &&\r\n      left[0] === right[0] &&\r\n      left[1] === right[1] &&\r\n      left[2] === right[2] &&\r\n      left[3] === right[3])\r\n  );\r\n};\r\n\r\n/**\r\n * @private\r\n */\r\nMatrix2.equalsArray = function (matrix, array, offset) {\r\n  return (\r\n    matrix[0] === array[offset] &&\r\n    matrix[1] === array[offset + 1] &&\r\n    matrix[2] === array[offset + 2] &&\r\n    matrix[3] === array[offset + 3]\r\n  );\r\n};\r\n\r\n/**\r\n * Compares the provided matrices componentwise and returns\r\n * <code>true</code> if they are within the provided epsilon,\r\n * <code>false</code> otherwise.\r\n *\r\n * @param {Matrix2} [left] The first matrix.\r\n * @param {Matrix2} [right] The second matrix.\r\n * @param {Number} [epsilon=0] The epsilon to use for equality testing.\r\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\r\n */\r\nMatrix2.equalsEpsilon = function (left, right, epsilon) {\r\n  epsilon = defaultValue(epsilon, 0);\r\n  return (\r\n    left === right ||\r\n    (defined(left) &&\r\n      defined(right) &&\r\n      Math.abs(left[0] - right[0]) <= epsilon &&\r\n      Math.abs(left[1] - right[1]) <= epsilon &&\r\n      Math.abs(left[2] - right[2]) <= epsilon &&\r\n      Math.abs(left[3] - right[3]) <= epsilon)\r\n  );\r\n};\r\n\r\n/**\r\n * An immutable Matrix2 instance initialized to the identity matrix.\r\n *\r\n * @type {Matrix2}\r\n * @constant\r\n */\r\nMatrix2.IDENTITY = Object.freeze(new Matrix2(1.0, 0.0, 0.0, 1.0));\r\n\r\n/**\r\n * An immutable Matrix2 instance initialized to the zero matrix.\r\n *\r\n * @type {Matrix2}\r\n * @constant\r\n */\r\nMatrix2.ZERO = Object.freeze(new Matrix2(0.0, 0.0, 0.0, 0.0));\r\n\r\n/**\r\n * The index into Matrix2 for column 0, row 0.\r\n *\r\n * @type {Number}\r\n * @constant\r\n *\r\n * @example\r\n * const matrix = new Cesium.Matrix2();\r\n * matrix[Cesium.Matrix2.COLUMN0ROW0] = 5.0; // set column 0, row 0 to 5.0\r\n */\r\nMatrix2.COLUMN0ROW0 = 0;\r\n\r\n/**\r\n * The index into Matrix2 for column 0, row 1.\r\n *\r\n * @type {Number}\r\n * @constant\r\n *\r\n * @example\r\n * const matrix = new Cesium.Matrix2();\r\n * matrix[Cesium.Matrix2.COLUMN0ROW1] = 5.0; // set column 0, row 1 to 5.0\r\n */\r\nMatrix2.COLUMN0ROW1 = 1;\r\n\r\n/**\r\n * The index into Matrix2 for column 1, row 0.\r\n *\r\n * @type {Number}\r\n * @constant\r\n *\r\n * @example\r\n * const matrix = new Cesium.Matrix2();\r\n * matrix[Cesium.Matrix2.COLUMN1ROW0] = 5.0; // set column 1, row 0 to 5.0\r\n */\r\nMatrix2.COLUMN1ROW0 = 2;\r\n\r\n/**\r\n * The index into Matrix2 for column 1, row 1.\r\n *\r\n * @type {Number}\r\n * @constant\r\n *\r\n * @example\r\n * const matrix = new Cesium.Matrix2();\r\n * matrix[Cesium.Matrix2.COLUMN1ROW1] = 5.0; // set column 1, row 1 to 5.0\r\n */\r\nMatrix2.COLUMN1ROW1 = 3;\r\n\r\nObject.defineProperties(Matrix2.prototype, {\r\n  /**\r\n   * Gets the number of items in the collection.\r\n   * @memberof Matrix2.prototype\r\n   *\r\n   * @type {Number}\r\n   */\r\n  length: {\r\n    get: function () {\r\n      return Matrix2.packedLength;\r\n    },\r\n  },\r\n});\r\n\r\n/**\r\n * Duplicates the provided Matrix2 instance.\r\n *\r\n * @param {Matrix2} [result] The object onto which to store the result.\r\n * @returns {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided.\r\n */\r\nMatrix2.prototype.clone = function (result) {\r\n  return Matrix2.clone(this, result);\r\n};\r\n\r\n/**\r\n * Compares this matrix to the provided matrix componentwise and returns\r\n * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n *\r\n * @param {Matrix2} [right] The right hand side matrix.\r\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\r\n */\r\nMatrix2.prototype.equals = function (right) {\r\n  return Matrix2.equals(this, right);\r\n};\r\n\r\n/**\r\n * Compares this matrix to the provided matrix componentwise and returns\r\n * <code>true</code> if they are within the provided epsilon,\r\n * <code>false</code> otherwise.\r\n *\r\n * @param {Matrix2} [right] The right hand side matrix.\r\n * @param {Number} [epsilon=0] The epsilon to use for equality testing.\r\n * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\r\n */\r\nMatrix2.prototype.equalsEpsilon = function (right, epsilon) {\r\n  return Matrix2.equalsEpsilon(this, right, epsilon);\r\n};\r\n\r\n/**\r\n * Creates a string representing this Matrix with each row being\r\n * on a separate line and in the format '(column0, column1)'.\r\n *\r\n * @returns {String} A string representing the provided Matrix with each row being on a separate line and in the format '(column0, column1)'.\r\n */\r\nMatrix2.prototype.toString = function () {\r\n  return `(${this[0]}, ${this[2]})\\n` + `(${this[1]}, ${this[3]})`;\r\n};\r\nexport default Matrix2;\r\n"],"names":["Cartesian3","x","y","z","this","defaultValue","fromSpherical","spherical","result","Check","typeOf","object","defined","clock","cone","magnitude","radial","Math","sin","cos","fromElements","clone","cartesian","fromCartesian4","packedLength","pack","value","array","startingIndex","unpack","packArray","length","resultLength","Array","isArray","DeveloperError","i","unpackArray","number","greaterThanOrEquals","index","fromArray","maximumComponent","max","minimumComponent","min","minimumByComponent","first","second","maximumByComponent","clamp","CesiumMath","magnitudeSquared","sqrt","distanceScratch","distance","left","right","subtract","distanceSquared","normalize","isNaN","dot","multiplyComponents","divideComponents","add","multiplyByScalar","scalar","divideByScalar","negate","abs","lerpScratch","lerp","start","end","t","angleBetweenScratch","angleBetweenScratch2","angleBetween","cosine","sine","cross","atan2","mostOrthogonalAxisScratch","mostOrthogonalAxis","f","UNIT_X","UNIT_Z","UNIT_Y","projectVector","a","b","equals","equalsArray","offset","equalsEpsilon","relativeEpsilon","absoluteEpsilon","leftX","leftY","leftZ","rightX","rightY","rightZ","midpoint","fromDegrees","longitude","latitude","height","ellipsoid","toRadians","fromRadians","scratchN","scratchK","wgs84RadiiSquared","radiiSquared","cosLatitude","gamma","fromDegreesArray","coordinates","fromRadiansArray","fromDegreesArrayHeights","fromRadiansArrayHeights","ZERO","Object","freeze","ONE","prototype","toString","scaleToGeodeticSurfaceIntersection","scaleToGeodeticSurfaceGradient","scaleToGeodeticSurface","oneOverRadii","oneOverRadiiSquared","centerToleranceSquared","positionX","positionY","positionZ","oneOverRadiiX","oneOverRadiiY","oneOverRadiiZ","x2","y2","z2","squaredNorm","ratio","intersection","isFinite","undefined","oneOverRadiiSquaredX","oneOverRadiiSquaredY","oneOverRadiiSquaredZ","gradient","func","denominator","xMultiplier","yMultiplier","zMultiplier","xMultiplier2","yMultiplier2","zMultiplier2","xMultiplier3","yMultiplier3","zMultiplier3","lambda","correction","EPSILON12","Cartographic","cartesianToCartographicN","cartesianToCartographicP","cartesianToCartographicH","wgs84OneOverRadii","wgs84OneOverRadiiSquared","wgs84CenterToleranceSquared","EPSILON1","initialize","_radii","_radiiSquared","_radiiToTheFourth","_oneOverRadii","_oneOverRadiiSquared","_minimumRadius","_maximumRadius","_centerToleranceSquared","_squaredXOverSquaredZ","Ellipsoid","fromCartesian","p","n","h","asin","sign","toCartesian","cartographic","epsilon","defineProperties","radii","get","radiiToTheFourth","minimumRadius","maximumRadius","fromCartesian3","WGS84","UNIT_SPHERE","MOON","LUNAR_RADIUS","geocentricSurfaceNormal","geodeticSurfaceNormalCartographic","geodeticSurfaceNormal","EPSILON14","cartographicToCartesianNormal","cartographicToCartesianK","cartographicToCartesian","k","cartographicArrayToCartesianArray","cartographics","cartesianToCartographic","cartesianArrayToCartographicArray","cartesians","scaleToGeocentricSurface","beta","transformPositionToScaledSpace","position","transformPositionFromScaledSpace","getSurfaceNormalIntersectionWithZAxis","buffer","EPSILON15","greaterThan","squaredXOverSquaredZ","abscissas","weights","gaussLegendreQuadrature","xMean","xRange","sum","dx","Matrix3","column0Row0","column1Row0","column2Row0","column0Row1","column1Row1","column2Row1","column0Row2","column1Row2","column2Row2","surfaceArea","rectangle","minLongitude","west","maxLongitude","east","minLatitude","south","maxLatitude","north","TWO_PI","a2","b2","c2","a2b2","lat","sinPhi","cosPhi","lon","cosTheta","sinTheta","matrix","fromColumnMajorArray","values","fromRowMajorArray","fromQuaternion","quaternion","xy","xz","xw","w","yz","yw","zw","w2","m00","m01","m02","m10","m11","m12","m20","m21","m22","fromHeadingPitchRoll","headingPitchRoll","pitch","cosPsi","heading","roll","sinPsi","fromScale","scale","fromUniformScale","fromCrossProduct","vector","fromRotationX","angle","cosAngle","sinAngle","fromRotationY","fromRotationZ","toArray","getElementIndex","column","row","lessThanOrEquals","getColumn","startIndex","setColumn","getRow","setRow","scaleScratch1","setScale","existingScale","getScale","scaleRatioX","scaleRatioY","scaleRatioZ","scaleScratch2","setUniformScale","scratchColumn","scaleScratch3","getMaximumScale","scaleScratch4","setRotation","rotation","scaleScratch5","getRotation","multiply","multiplyByVector","vX","vY","vZ","multiplyByScale","multiplyByUniformScale","transpose","rowVal","colVal","offDiagonalFrobeniusNorm","norm","temp","shurDecomposition","tolerance","maxDiagonal","rotAxis","c","s","q","tau","IDENTITY","jMatrix","jMatrixTranspose","computeEigenDecomposition","EPSILON20","count","sweep","unitaryMatrix","unitary","diagMatrix","diagonal","computeFrobeniusNorm","determinant","m31","m32","m13","m23","m33","inverse","scratchTransposeMatrix","Cartesian4","inverseTranspose","COLUMN0ROW0","COLUMN0ROW1","COLUMN0ROW2","COLUMN1ROW0","COLUMN1ROW1","COLUMN1ROW2","COLUMN2ROW0","COLUMN2ROW1","COLUMN2ROW2","fromColor","color","red","green","blue","alpha","UNIT_W","scratchF32Array","Float32Array","scratchU8Array","Uint8Array","testU32","Uint32Array","littleEndian","Matrix4","column3Row0","column3Row1","column3Row2","column0Row3","column1Row3","column2Row3","column3Row3","packFloat","unpackFloat","packedFloat","fromRotationTranslation","translation","fromTranslationQuaternionRotationScale","scaleX","scaleY","scaleZ","fromTranslationRotationScale","translationRotationScale","fromTranslation","fromRotation","fromCameraF","fromCameraR","fromCameraU","fromCamera","camera","direction","up","sX","sY","sZ","fX","fY","fZ","uX","uY","uZ","t0","t1","t2","computePerspectiveFieldOfView","fovY","aspectRatio","near","far","lessThan","PI","tan","computeOrthographicOffCenter","bottom","top","tx","ty","tz","computePerspectiveOffCenter","computeInfinitePerspectiveOffCenter","computeViewportTransformation","viewport","nearDepthRange","farDepthRange","EMPTY_OBJECT","width","halfWidth","halfHeight","halfDepth","computeView","setTranslation","left0","left1","left2","left3","left4","left5","left6","left7","left8","left9","left10","left11","left12","left13","left14","left15","right0","right1","right2","right3","right4","right5","right6","right7","right8","right9","right10","right11","right12","right13","right14","right15","multiplyTransformation","multiplyByMatrix3","multiplyByTranslation","vW","multiplyByPointAsVector","multiplyByPoint","matrix1","matrix2","matrix3","matrix6","matrix7","matrix11","getTranslation","getMatrix3","scratchInverseRotation","scratchMatrix3Zero","scratchBottomRow","scratchExpectedBottomRow","src0","src1","src2","src3","src4","src5","src6","src7","src8","src9","src10","src11","src12","src13","src14","src15","tmp0","tmp1","tmp2","tmp3","tmp4","tmp5","tmp6","tmp7","tmp8","tmp9","tmp10","tmp11","dst0","dst1","dst2","dst3","dst4","dst5","dst6","dst7","dst8","dst9","dst10","dst11","dst12","dst13","dst14","dst15","det","EPSILON21","EPSILON7","RuntimeError","inverseTransformation","matrix0","matrix4","matrix5","matrix8","matrix9","matrix10","Rectangle","COLUMN0ROW3","COLUMN1ROW3","COLUMN2ROW3","COLUMN3ROW0","COLUMN3ROW1","COLUMN3ROW2","COLUMN3ROW3","computeWidth","computeHeight","fromCartographicArray","Number","MAX_VALUE","westOverIDL","eastOverIDL","len","lonAdjusted","fromCartesianArray","other","validate","PI_OVER_TWO","southwest","northwest","northeast","southeast","center","negativePiToPi","otherRectangle","rectangleEast","rectangleWest","otherRectangleEast","otherRectangleWest","simpleIntersection","union","expand","contains","subsampleLlaScratch","Cartesian2","subsample","surfaceHeight","lla","subsection","westLerp","southLerp","eastLerp","northLerp","acosClamped","Matrix2"],"mappings":"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"}