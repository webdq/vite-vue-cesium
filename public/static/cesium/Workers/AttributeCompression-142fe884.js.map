{"version":3,"file":"AttributeCompression-142fe884.js","sources":["../../../../Source/Scene/AttributeType.js","../../../../Source/Core/AttributeCompression.js"],"sourcesContent":["import Cartesian2 from \"../Core/Cartesian2.js\";\r\nimport Cartesian3 from \"../Core/Cartesian3.js\";\r\nimport Cartesian4 from \"../Core/Cartesian4.js\";\r\nimport Check from \"../Core/Check.js\";\r\nimport DeveloperError from \"../Core/DeveloperError.js\";\r\nimport Matrix2 from \"../Core/Matrix2.js\";\r\nimport Matrix3 from \"../Core/Matrix3.js\";\r\nimport Matrix4 from \"../Core/Matrix4.js\";\r\n\r\n/**\r\n * An enum describing the attribute type for glTF and 3D Tiles.\r\n *\r\n * @enum {String}\r\n *\r\n * @private\r\n */\r\nconst AttributeType = {\r\n  /**\r\n   * The attribute is a single component.\r\n   *\r\n   * @type {String}\r\n   * @constant\r\n   */\r\n  SCALAR: \"SCALAR\",\r\n\r\n  /**\r\n   * The attribute is a two-component vector.\r\n   *\r\n   * @type {String}\r\n   * @constant\r\n   */\r\n  VEC2: \"VEC2\",\r\n\r\n  /**\r\n   * The attribute is a three-component vector.\r\n   *\r\n   * @type {String}\r\n   * @constant\r\n   */\r\n  VEC3: \"VEC3\",\r\n\r\n  /**\r\n   * The attribute is a four-component vector.\r\n   *\r\n   * @type {String}\r\n   * @constant\r\n   */\r\n  VEC4: \"VEC4\",\r\n\r\n  /**\r\n   * The attribute is a 2x2 matrix.\r\n   *\r\n   * @type {String}\r\n   * @constant\r\n   */\r\n  MAT2: \"MAT2\",\r\n\r\n  /**\r\n   * The attribute is a 3x3 matrix.\r\n   *\r\n   * @type {String}\r\n   * @constant\r\n   */\r\n  MAT3: \"MAT3\",\r\n\r\n  /**\r\n   * The attribute is a 4x4 matrix.\r\n   *\r\n   * @type {String}\r\n   * @constant\r\n   */\r\n  MAT4: \"MAT4\",\r\n};\r\n\r\n/**\r\n * Gets the scalar, vector, or matrix type for the attribute type.\r\n *\r\n * @param {AttributeType} attributeType The attribute type.\r\n * @returns {*} The math type.\r\n *\r\n * @private\r\n */\r\nAttributeType.getMathType = function (attributeType) {\r\n  switch (attributeType) {\r\n    case AttributeType.SCALAR:\r\n      return Number;\r\n    case AttributeType.VEC2:\r\n      return Cartesian2;\r\n    case AttributeType.VEC3:\r\n      return Cartesian3;\r\n    case AttributeType.VEC4:\r\n      return Cartesian4;\r\n    case AttributeType.MAT2:\r\n      return Matrix2;\r\n    case AttributeType.MAT3:\r\n      return Matrix3;\r\n    case AttributeType.MAT4:\r\n      return Matrix4;\r\n    //>>includeStart('debug', pragmas.debug);\r\n    default:\r\n      throw new DeveloperError(\"attributeType is not a valid value.\");\r\n    //>>includeEnd('debug');\r\n  }\r\n};\r\n\r\n/**\r\n * Gets the number of components per attribute.\r\n *\r\n * @param {AttributeType} attributeType The attribute type.\r\n * @returns {Number} The number of components.\r\n *\r\n * @private\r\n */\r\nAttributeType.getNumberOfComponents = function (attributeType) {\r\n  switch (attributeType) {\r\n    case AttributeType.SCALAR:\r\n      return 1;\r\n    case AttributeType.VEC2:\r\n      return 2;\r\n    case AttributeType.VEC3:\r\n      return 3;\r\n    case AttributeType.VEC4:\r\n    case AttributeType.MAT2:\r\n      return 4;\r\n    case AttributeType.MAT3:\r\n      return 9;\r\n    case AttributeType.MAT4:\r\n      return 16;\r\n    //>>includeStart('debug', pragmas.debug);\r\n    default:\r\n      throw new DeveloperError(\"attributeType is not a valid value.\");\r\n    //>>includeEnd('debug');\r\n  }\r\n};\r\n\r\n/**\r\n * Get the number of attribute locations needed to fit this attribute. Most\r\n * types require one, but matrices require multiple attribute locations.\r\n *\r\n * @param {AttributeType} attributeType The attribute type.\r\n * @returns {Number} The number of attribute locations needed in the shader\r\n *\r\n * @private\r\n */\r\nAttributeType.getAttributeLocationCount = function (attributeType) {\r\n  switch (attributeType) {\r\n    case AttributeType.SCALAR:\r\n    case AttributeType.VEC2:\r\n    case AttributeType.VEC3:\r\n    case AttributeType.VEC4:\r\n      return 1;\r\n    case AttributeType.MAT2:\r\n      return 2;\r\n    case AttributeType.MAT3:\r\n      return 3;\r\n    case AttributeType.MAT4:\r\n      return 4;\r\n    //>>includeStart('debug', pragmas.debug);\r\n    default:\r\n      throw new DeveloperError(\"attributeType is not a valid value.\");\r\n    //>>includeEnd('debug');\r\n  }\r\n};\r\n\r\n/**\r\n * Gets the GLSL type for the attribute type.\r\n *\r\n * @param {AttributeType} attributeType The attribute type.\r\n * @returns {String} The GLSL type for the attribute type.\r\n *\r\n * @private\r\n */\r\nAttributeType.getGlslType = function (attributeType) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.string(\"attributeType\", attributeType);\r\n  //>>includeEnd('debug');\r\n\r\n  switch (attributeType) {\r\n    case AttributeType.SCALAR:\r\n      return \"float\";\r\n    case AttributeType.VEC2:\r\n      return \"vec2\";\r\n    case AttributeType.VEC3:\r\n      return \"vec3\";\r\n    case AttributeType.VEC4:\r\n      return \"vec4\";\r\n    case AttributeType.MAT2:\r\n      return \"mat2\";\r\n    case AttributeType.MAT3:\r\n      return \"mat3\";\r\n    case AttributeType.MAT4:\r\n      return \"mat4\";\r\n    //>>includeStart('debug', pragmas.debug);\r\n    default:\r\n      throw new DeveloperError(\"attributeType is not a valid value.\");\r\n    //>>includeEnd('debug');\r\n  }\r\n};\r\n\r\nexport default Object.freeze(AttributeType);\r\n","import Cartesian2 from \"./Cartesian2.js\";\r\nimport Cartesian3 from \"./Cartesian3.js\";\r\nimport ComponentDatatype from \"./ComponentDatatype.js\";\r\nimport Check from \"./Check.js\";\r\nimport defined from \"./defined.js\";\r\nimport DeveloperError from \"./DeveloperError.js\";\r\nimport CesiumMath from \"./Math.js\";\r\nimport AttributeType from \"../Scene/AttributeType.js\";\r\n\r\nconst RIGHT_SHIFT = 1.0 / 256.0;\r\nconst LEFT_SHIFT = 256.0;\r\n\r\n/**\r\n * Attribute compression and decompression functions.\r\n *\r\n * @namespace AttributeCompression\r\n *\r\n * @private\r\n */\r\nconst AttributeCompression = {};\r\n\r\n/**\r\n * Encodes a normalized vector into 2 SNORM values in the range of [0-rangeMax] following the 'oct' encoding.\r\n *\r\n * Oct encoding is a compact representation of unit length vectors.\r\n * The 'oct' encoding is described in \"A Survey of Efficient Representations of Independent Unit Vectors\",\r\n * Cigolle et al 2014: {@link http://jcgt.org/published/0003/02/01/}\r\n *\r\n * @param {Cartesian3} vector The normalized vector to be compressed into 2 component 'oct' encoding.\r\n * @param {Cartesian2} result The 2 component oct-encoded unit length vector.\r\n * @param {Number} rangeMax The maximum value of the SNORM range. The encoded vector is stored in log2(rangeMax+1) bits.\r\n * @returns {Cartesian2} The 2 component oct-encoded unit length vector.\r\n *\r\n * @exception {DeveloperError} vector must be normalized.\r\n *\r\n * @see AttributeCompression.octDecodeInRange\r\n */\r\nAttributeCompression.octEncodeInRange = function (vector, rangeMax, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"vector\", vector);\r\n  Check.defined(\"result\", result);\r\n  const magSquared = Cartesian3.magnitudeSquared(vector);\r\n  if (Math.abs(magSquared - 1.0) > CesiumMath.EPSILON6) {\r\n    throw new DeveloperError(\"vector must be normalized.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  result.x =\r\n    vector.x / (Math.abs(vector.x) + Math.abs(vector.y) + Math.abs(vector.z));\r\n  result.y =\r\n    vector.y / (Math.abs(vector.x) + Math.abs(vector.y) + Math.abs(vector.z));\r\n  if (vector.z < 0) {\r\n    const x = result.x;\r\n    const y = result.y;\r\n    result.x = (1.0 - Math.abs(y)) * CesiumMath.signNotZero(x);\r\n    result.y = (1.0 - Math.abs(x)) * CesiumMath.signNotZero(y);\r\n  }\r\n\r\n  result.x = CesiumMath.toSNorm(result.x, rangeMax);\r\n  result.y = CesiumMath.toSNorm(result.y, rangeMax);\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Encodes a normalized vector into 2 SNORM values in the range of [0-255] following the 'oct' encoding.\r\n *\r\n * @param {Cartesian3} vector The normalized vector to be compressed into 2 byte 'oct' encoding.\r\n * @param {Cartesian2} result The 2 byte oct-encoded unit length vector.\r\n * @returns {Cartesian2} The 2 byte oct-encoded unit length vector.\r\n *\r\n * @exception {DeveloperError} vector must be normalized.\r\n *\r\n * @see AttributeCompression.octEncodeInRange\r\n * @see AttributeCompression.octDecode\r\n */\r\nAttributeCompression.octEncode = function (vector, result) {\r\n  return AttributeCompression.octEncodeInRange(vector, 255, result);\r\n};\r\n\r\nconst octEncodeScratch = new Cartesian2();\r\nconst uint8ForceArray = new Uint8Array(1);\r\nfunction forceUint8(value) {\r\n  uint8ForceArray[0] = value;\r\n  return uint8ForceArray[0];\r\n}\r\n/**\r\n * @param {Cartesian3} vector The normalized vector to be compressed into 4 byte 'oct' encoding.\r\n * @param {Cartesian4} result The 4 byte oct-encoded unit length vector.\r\n * @returns {Cartesian4} The 4 byte oct-encoded unit length vector.\r\n *\r\n * @exception {DeveloperError} vector must be normalized.\r\n *\r\n * @see AttributeCompression.octEncodeInRange\r\n * @see AttributeCompression.octDecodeFromCartesian4\r\n */\r\nAttributeCompression.octEncodeToCartesian4 = function (vector, result) {\r\n  AttributeCompression.octEncodeInRange(vector, 65535, octEncodeScratch);\r\n  result.x = forceUint8(octEncodeScratch.x * RIGHT_SHIFT);\r\n  result.y = forceUint8(octEncodeScratch.x);\r\n  result.z = forceUint8(octEncodeScratch.y * RIGHT_SHIFT);\r\n  result.w = forceUint8(octEncodeScratch.y);\r\n  return result;\r\n};\r\n\r\n/**\r\n * Decodes a unit-length vector in 'oct' encoding to a normalized 3-component vector.\r\n *\r\n * @param {Number} x The x component of the oct-encoded unit length vector.\r\n * @param {Number} y The y component of the oct-encoded unit length vector.\r\n * @param {Number} rangeMax The maximum value of the SNORM range. The encoded vector is stored in log2(rangeMax+1) bits.\r\n * @param {Cartesian3} result The decoded and normalized vector\r\n * @returns {Cartesian3} The decoded and normalized vector.\r\n *\r\n * @exception {DeveloperError} x and y must be unsigned normalized integers between 0 and rangeMax.\r\n *\r\n * @see AttributeCompression.octEncodeInRange\r\n */\r\nAttributeCompression.octDecodeInRange = function (x, y, rangeMax, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"result\", result);\r\n  if (x < 0 || x > rangeMax || y < 0 || y > rangeMax) {\r\n    throw new DeveloperError(\r\n      `x and y must be unsigned normalized integers between 0 and ${rangeMax}`\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  result.x = CesiumMath.fromSNorm(x, rangeMax);\r\n  result.y = CesiumMath.fromSNorm(y, rangeMax);\r\n  result.z = 1.0 - (Math.abs(result.x) + Math.abs(result.y));\r\n\r\n  if (result.z < 0.0) {\r\n    const oldVX = result.x;\r\n    result.x = (1.0 - Math.abs(result.y)) * CesiumMath.signNotZero(oldVX);\r\n    result.y = (1.0 - Math.abs(oldVX)) * CesiumMath.signNotZero(result.y);\r\n  }\r\n\r\n  return Cartesian3.normalize(result, result);\r\n};\r\n\r\n/**\r\n * Decodes a unit-length vector in 2 byte 'oct' encoding to a normalized 3-component vector.\r\n *\r\n * @param {Number} x The x component of the oct-encoded unit length vector.\r\n * @param {Number} y The y component of the oct-encoded unit length vector.\r\n * @param {Cartesian3} result The decoded and normalized vector.\r\n * @returns {Cartesian3} The decoded and normalized vector.\r\n *\r\n * @exception {DeveloperError} x and y must be an unsigned normalized integer between 0 and 255.\r\n *\r\n * @see AttributeCompression.octDecodeInRange\r\n */\r\nAttributeCompression.octDecode = function (x, y, result) {\r\n  return AttributeCompression.octDecodeInRange(x, y, 255, result);\r\n};\r\n\r\n/**\r\n * Decodes a unit-length vector in 4 byte 'oct' encoding to a normalized 3-component vector.\r\n *\r\n * @param {Cartesian4} encoded The oct-encoded unit length vector.\r\n * @param {Cartesian3} result The decoded and normalized vector.\r\n * @returns {Cartesian3} The decoded and normalized vector.\r\n *\r\n * @exception {DeveloperError} x, y, z, and w must be unsigned normalized integers between 0 and 255.\r\n *\r\n * @see AttributeCompression.octDecodeInRange\r\n * @see AttributeCompression.octEncodeToCartesian4\r\n */\r\nAttributeCompression.octDecodeFromCartesian4 = function (encoded, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"encoded\", encoded);\r\n  Check.typeOf.object(\"result\", result);\r\n  //>>includeEnd('debug');\r\n  const x = encoded.x;\r\n  const y = encoded.y;\r\n  const z = encoded.z;\r\n  const w = encoded.w;\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (\r\n    x < 0 ||\r\n    x > 255 ||\r\n    y < 0 ||\r\n    y > 255 ||\r\n    z < 0 ||\r\n    z > 255 ||\r\n    w < 0 ||\r\n    w > 255\r\n  ) {\r\n    throw new DeveloperError(\r\n      \"x, y, z, and w must be unsigned normalized integers between 0 and 255\"\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const xOct16 = x * LEFT_SHIFT + y;\r\n  const yOct16 = z * LEFT_SHIFT + w;\r\n  return AttributeCompression.octDecodeInRange(xOct16, yOct16, 65535, result);\r\n};\r\n\r\n/**\r\n * Packs an oct encoded vector into a single floating-point number.\r\n *\r\n * @param {Cartesian2} encoded The oct encoded vector.\r\n * @returns {Number} The oct encoded vector packed into a single float.\r\n *\r\n */\r\nAttributeCompression.octPackFloat = function (encoded) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"encoded\", encoded);\r\n  //>>includeEnd('debug');\r\n  return 256.0 * encoded.x + encoded.y;\r\n};\r\n\r\nconst scratchEncodeCart2 = new Cartesian2();\r\n\r\n/**\r\n * Encodes a normalized vector into 2 SNORM values in the range of [0-255] following the 'oct' encoding and\r\n * stores those values in a single float-point number.\r\n *\r\n * @param {Cartesian3} vector The normalized vector to be compressed into 2 byte 'oct' encoding.\r\n * @returns {Number} The 2 byte oct-encoded unit length vector.\r\n *\r\n * @exception {DeveloperError} vector must be normalized.\r\n */\r\nAttributeCompression.octEncodeFloat = function (vector) {\r\n  AttributeCompression.octEncode(vector, scratchEncodeCart2);\r\n  return AttributeCompression.octPackFloat(scratchEncodeCart2);\r\n};\r\n\r\n/**\r\n * Decodes a unit-length vector in 'oct' encoding packed in a floating-point number to a normalized 3-component vector.\r\n *\r\n * @param {Number} value The oct-encoded unit length vector stored as a single floating-point number.\r\n * @param {Cartesian3} result The decoded and normalized vector\r\n * @returns {Cartesian3} The decoded and normalized vector.\r\n *\r\n */\r\nAttributeCompression.octDecodeFloat = function (value, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"value\", value);\r\n  //>>includeEnd('debug');\r\n\r\n  const temp = value / 256.0;\r\n  const x = Math.floor(temp);\r\n  const y = (temp - x) * 256.0;\r\n\r\n  return AttributeCompression.octDecode(x, y, result);\r\n};\r\n\r\n/**\r\n * Encodes three normalized vectors into 6 SNORM values in the range of [0-255] following the 'oct' encoding and\r\n * packs those into two floating-point numbers.\r\n *\r\n * @param {Cartesian3} v1 A normalized vector to be compressed.\r\n * @param {Cartesian3} v2 A normalized vector to be compressed.\r\n * @param {Cartesian3} v3 A normalized vector to be compressed.\r\n * @param {Cartesian2} result The 'oct' encoded vectors packed into two floating-point numbers.\r\n * @returns {Cartesian2} The 'oct' encoded vectors packed into two floating-point numbers.\r\n *\r\n */\r\nAttributeCompression.octPack = function (v1, v2, v3, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"v1\", v1);\r\n  Check.defined(\"v2\", v2);\r\n  Check.defined(\"v3\", v3);\r\n  Check.defined(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  const encoded1 = AttributeCompression.octEncodeFloat(v1);\r\n  const encoded2 = AttributeCompression.octEncodeFloat(v2);\r\n\r\n  const encoded3 = AttributeCompression.octEncode(v3, scratchEncodeCart2);\r\n  result.x = 65536.0 * encoded3.x + encoded1;\r\n  result.y = 65536.0 * encoded3.y + encoded2;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Decodes three unit-length vectors in 'oct' encoding packed into a floating-point number to a normalized 3-component vector.\r\n *\r\n * @param {Cartesian2} packed The three oct-encoded unit length vectors stored as two floating-point number.\r\n * @param {Cartesian3} v1 One decoded and normalized vector.\r\n * @param {Cartesian3} v2 One decoded and normalized vector.\r\n * @param {Cartesian3} v3 One decoded and normalized vector.\r\n */\r\nAttributeCompression.octUnpack = function (packed, v1, v2, v3) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"packed\", packed);\r\n  Check.defined(\"v1\", v1);\r\n  Check.defined(\"v2\", v2);\r\n  Check.defined(\"v3\", v3);\r\n  //>>includeEnd('debug');\r\n\r\n  let temp = packed.x / 65536.0;\r\n  const x = Math.floor(temp);\r\n  const encodedFloat1 = (temp - x) * 65536.0;\r\n\r\n  temp = packed.y / 65536.0;\r\n  const y = Math.floor(temp);\r\n  const encodedFloat2 = (temp - y) * 65536.0;\r\n\r\n  AttributeCompression.octDecodeFloat(encodedFloat1, v1);\r\n  AttributeCompression.octDecodeFloat(encodedFloat2, v2);\r\n  AttributeCompression.octDecode(x, y, v3);\r\n};\r\n\r\n/**\r\n * Pack texture coordinates into a single float. The texture coordinates will only preserve 12 bits of precision.\r\n *\r\n * @param {Cartesian2} textureCoordinates The texture coordinates to compress.  Both coordinates must be in the range 0.0-1.0.\r\n * @returns {Number} The packed texture coordinates.\r\n *\r\n */\r\nAttributeCompression.compressTextureCoordinates = function (\r\n  textureCoordinates\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"textureCoordinates\", textureCoordinates);\r\n  //>>includeEnd('debug');\r\n\r\n  // Move x and y to the range 0-4095;\r\n  const x = (textureCoordinates.x * 4095.0) | 0;\r\n  const y = (textureCoordinates.y * 4095.0) | 0;\r\n  return 4096.0 * x + y;\r\n};\r\n\r\n/**\r\n * Decompresses texture coordinates that were packed into a single float.\r\n *\r\n * @param {Number} compressed The compressed texture coordinates.\r\n * @param {Cartesian2} result The decompressed texture coordinates.\r\n * @returns {Cartesian2} The modified result parameter.\r\n *\r\n */\r\nAttributeCompression.decompressTextureCoordinates = function (\r\n  compressed,\r\n  result\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"compressed\", compressed);\r\n  Check.defined(\"result\", result);\r\n  //>>includeEnd('debug');\r\n\r\n  const temp = compressed / 4096.0;\r\n  const xZeroTo4095 = Math.floor(temp);\r\n  result.x = xZeroTo4095 / 4095.0;\r\n  result.y = (compressed - xZeroTo4095 * 4096) / 4095;\r\n  return result;\r\n};\r\n\r\nfunction zigZagDecode(value) {\r\n  return (value >> 1) ^ -(value & 1);\r\n}\r\n\r\n/**\r\n * Decodes delta and ZigZag encoded vertices. This modifies the buffers in place.\r\n *\r\n * @param {Uint16Array} uBuffer The buffer view of u values.\r\n * @param {Uint16Array} vBuffer The buffer view of v values.\r\n * @param {Uint16Array} [heightBuffer] The buffer view of height values.\r\n *\r\n * @see {@link https://github.com/CesiumGS/quantized-mesh|quantized-mesh-1.0 terrain format}\r\n */\r\nAttributeCompression.zigZagDeltaDecode = function (\r\n  uBuffer,\r\n  vBuffer,\r\n  heightBuffer\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"uBuffer\", uBuffer);\r\n  Check.defined(\"vBuffer\", vBuffer);\r\n  Check.typeOf.number.equals(\r\n    \"uBuffer.length\",\r\n    \"vBuffer.length\",\r\n    uBuffer.length,\r\n    vBuffer.length\r\n  );\r\n  if (defined(heightBuffer)) {\r\n    Check.typeOf.number.equals(\r\n      \"uBuffer.length\",\r\n      \"heightBuffer.length\",\r\n      uBuffer.length,\r\n      heightBuffer.length\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const count = uBuffer.length;\r\n\r\n  let u = 0;\r\n  let v = 0;\r\n  let height = 0;\r\n\r\n  for (let i = 0; i < count; ++i) {\r\n    u += zigZagDecode(uBuffer[i]);\r\n    v += zigZagDecode(vBuffer[i]);\r\n\r\n    uBuffer[i] = u;\r\n    vBuffer[i] = v;\r\n\r\n    if (defined(heightBuffer)) {\r\n      height += zigZagDecode(heightBuffer[i]);\r\n      heightBuffer[i] = height;\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Dequantizes a quantized typed array into a floating point typed array.\r\n *\r\n * @see {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data}\r\n *\r\n * @param {Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array} typedArray The typed array for the quantized data.\r\n * @param {ComponentDatatype} componentDatatype The component datatype of the quantized data.\r\n * @param {AttributeType} type The attribute type of the quantized data.\r\n * @param {Number} count The number of attributes referenced in the dequantized array.\r\n *\r\n * @returns {Float32Array} The dequantized array.\r\n */\r\nAttributeCompression.dequantize = function (\r\n  typedArray,\r\n  componentDatatype,\r\n  type,\r\n  count\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"typedArray\", typedArray);\r\n  Check.defined(\"componentDatatype\", componentDatatype);\r\n  Check.defined(\"type\", type);\r\n  Check.defined(\"count\", count);\r\n  //>>includeEnd('debug');\r\n\r\n  const componentsPerAttribute = AttributeType.getNumberOfComponents(type);\r\n\r\n  let divisor;\r\n  switch (componentDatatype) {\r\n    case ComponentDatatype.BYTE:\r\n      divisor = 127.0;\r\n      break;\r\n    case ComponentDatatype.UNSIGNED_BYTE:\r\n      divisor = 255.0;\r\n      break;\r\n    case ComponentDatatype.SHORT:\r\n      divisor = 32767.0;\r\n      break;\r\n    case ComponentDatatype.UNSIGNED_SHORT:\r\n      divisor = 65535.0;\r\n      break;\r\n    case ComponentDatatype.INT:\r\n      divisor = 2147483647.0;\r\n      break;\r\n    case ComponentDatatype.UNSIGNED_INT:\r\n      divisor = 4294967295.0;\r\n      break;\r\n    //>>includeStart('debug', pragmas.debug);\r\n    default:\r\n      throw new DeveloperError(\r\n        `Cannot dequantize component datatype: ${componentDatatype}`\r\n      );\r\n    //>>includeEnd('debug');\r\n  }\r\n\r\n  const dequantizedTypedArray = new Float32Array(\r\n    count * componentsPerAttribute\r\n  );\r\n\r\n  for (let i = 0; i < count; i++) {\r\n    for (let j = 0; j < componentsPerAttribute; j++) {\r\n      const index = i * componentsPerAttribute + j;\r\n      dequantizedTypedArray[index] = Math.max(\r\n        typedArray[index] / divisor,\r\n        -1.0\r\n      );\r\n    }\r\n  }\r\n\r\n  return dequantizedTypedArray;\r\n};\r\n\r\n/**\r\n * Decode RGB565-encoded colors into a floating point typed array containing\r\n * normalized RGB values.\r\n *\r\n * @param {Uint16Array} typedArray Array of RGB565 values\r\n * @param {Float32Array} [result] Array to store the normalized VEC3 result\r\n */\r\nAttributeCompression.decodeRGB565 = function (typedArray, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"typedArray\", typedArray);\r\n\r\n  const expectedLength = typedArray.length * 3;\r\n  if (defined(result)) {\r\n    Check.typeOf.number.equals(\r\n      \"result.length\",\r\n      \"typedArray.length * 3\",\r\n      result.length,\r\n      expectedLength\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const count = typedArray.length;\r\n  if (!defined(result)) {\r\n    result = new Float32Array(count * 3);\r\n  }\r\n\r\n  const mask5 = (1 << 5) - 1;\r\n  const mask6 = (1 << 6) - 1;\r\n  const normalize5 = 1.0 / 31.0;\r\n  const normalize6 = 1.0 / 63.0;\r\n  for (let i = 0; i < count; i++) {\r\n    const value = typedArray[i];\r\n    const red = value >> 11;\r\n    const green = (value >> 5) & mask6;\r\n    const blue = value & mask5;\r\n\r\n    const offset = 3 * i;\r\n    result[offset] = red * normalize5;\r\n    result[offset + 1] = green * normalize6;\r\n    result[offset + 2] = blue * normalize5;\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\nexport default AttributeCompression;\r\n"],"names":["AttributeType","SCALAR","VEC2","VEC3","VEC4","MAT2","MAT3","MAT4","attributeType","Number","Cartesian2","Cartesian3","Cartesian4","Matrix2","Matrix3","Matrix4","DeveloperError","Check","typeOf","string","AttributeType$1","Object","freeze","RIGHT_SHIFT","AttributeCompression","vector","rangeMax","result","defined","magSquared","magnitudeSquared","Math","abs","CesiumMath","EPSILON6","x","y","z","signNotZero","toSNorm","octEncodeInRange","octEncodeScratch","uint8ForceArray","Uint8Array","forceUint8","value","octEncodeToCartesian4","w","octDecodeInRange","fromSNorm","oldVX","normalize","octDecode","octDecodeFromCartesian4","encoded","object","xOct16","yOct16","octPackFloat","scratchEncodeCart2","zigZagDecode","octEncodeFloat","octEncode","octDecodeFloat","temp","floor","octPack","v1","v2","v3","encoded1","encoded2","encoded3","octUnpack","packed","encodedFloat1","encodedFloat2","compressTextureCoordinates","textureCoordinates","decompressTextureCoordinates","compressed","xZeroTo4095","zigZagDeltaDecode","uBuffer","vBuffer","heightBuffer","number","equals","length","count","u","v","height","i","dequantize","typedArray","componentDatatype","type","componentsPerAttribute","getNumberOfComponents","divisor","ComponentDatatype","BYTE","UNSIGNED_BYTE","SHORT","UNSIGNED_SHORT","INT","UNSIGNED_INT","dequantizedTypedArray","Float32Array","j","index","max","decodeRGB565","expectedLength","normalize5","red","green","blue","offset"],"mappings":"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"}