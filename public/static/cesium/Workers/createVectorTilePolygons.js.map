{"version":3,"file":"createVectorTilePolygons.js","sources":["../../../../Source/WorkersES6/createVectorTilePolygons.js"],"sourcesContent":["import AttributeCompression from \"../Core/AttributeCompression.js\";\r\nimport Cartesian3 from \"../Core/Cartesian3.js\";\r\nimport Cartographic from \"../Core/Cartographic.js\";\r\nimport Color from \"../Core/Color.js\";\r\nimport defined from \"../Core/defined.js\";\r\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\r\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\r\nimport CesiumMath from \"../Core/Math.js\";\r\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\r\nimport Rectangle from \"../Core/Rectangle.js\";\r\nimport createTaskProcessorWorker from \"./createTaskProcessorWorker.js\";\r\n\r\nconst scratchCenter = new Cartesian3();\r\nconst scratchEllipsoid = new Ellipsoid();\r\nconst scratchRectangle = new Rectangle();\r\nconst scratchScalars = {\r\n  min: undefined,\r\n  max: undefined,\r\n  indexBytesPerElement: undefined,\r\n};\r\n\r\nfunction unpackBuffer(buffer) {\r\n  const packedBuffer = new Float64Array(buffer);\r\n\r\n  let offset = 0;\r\n  scratchScalars.indexBytesPerElement = packedBuffer[offset++];\r\n\r\n  scratchScalars.min = packedBuffer[offset++];\r\n  scratchScalars.max = packedBuffer[offset++];\r\n\r\n  Cartesian3.unpack(packedBuffer, offset, scratchCenter);\r\n  offset += Cartesian3.packedLength;\r\n\r\n  Ellipsoid.unpack(packedBuffer, offset, scratchEllipsoid);\r\n  offset += Ellipsoid.packedLength;\r\n\r\n  Rectangle.unpack(packedBuffer, offset, scratchRectangle);\r\n}\r\n\r\nfunction packedBatchedIndicesLength(batchedIndices) {\r\n  const length = batchedIndices.length;\r\n  let count = 0;\r\n  for (let i = 0; i < length; ++i) {\r\n    count += Color.packedLength + 3 + batchedIndices[i].batchIds.length;\r\n  }\r\n  return count;\r\n}\r\n\r\nfunction packBuffer(indexDatatype, boundingVolumes, batchedIndices) {\r\n  const numBVs = boundingVolumes.length;\r\n  const length =\r\n    1 +\r\n    1 +\r\n    numBVs * OrientedBoundingBox.packedLength +\r\n    1 +\r\n    packedBatchedIndicesLength(batchedIndices);\r\n\r\n  const packedBuffer = new Float64Array(length);\r\n\r\n  let offset = 0;\r\n  packedBuffer[offset++] = indexDatatype;\r\n  packedBuffer[offset++] = numBVs;\r\n\r\n  for (let i = 0; i < numBVs; ++i) {\r\n    OrientedBoundingBox.pack(boundingVolumes[i], packedBuffer, offset);\r\n    offset += OrientedBoundingBox.packedLength;\r\n  }\r\n\r\n  const indicesLength = batchedIndices.length;\r\n  packedBuffer[offset++] = indicesLength;\r\n\r\n  for (let j = 0; j < indicesLength; ++j) {\r\n    const batchedIndex = batchedIndices[j];\r\n\r\n    Color.pack(batchedIndex.color, packedBuffer, offset);\r\n    offset += Color.packedLength;\r\n\r\n    packedBuffer[offset++] = batchedIndex.offset;\r\n    packedBuffer[offset++] = batchedIndex.count;\r\n\r\n    const batchIds = batchedIndex.batchIds;\r\n    const batchIdsLength = batchIds.length;\r\n    packedBuffer[offset++] = batchIdsLength;\r\n\r\n    for (let k = 0; k < batchIdsLength; ++k) {\r\n      packedBuffer[offset++] = batchIds[k];\r\n    }\r\n  }\r\n\r\n  return packedBuffer;\r\n}\r\n\r\nconst maxShort = 32767;\r\n\r\nconst scratchEncodedPosition = new Cartesian3();\r\nconst scratchNormal = new Cartesian3();\r\nconst scratchScaledNormal = new Cartesian3();\r\nconst scratchMinHeightPosition = new Cartesian3();\r\nconst scratchMaxHeightPosition = new Cartesian3();\r\nconst scratchBVCartographic = new Cartographic();\r\nconst scratchBVRectangle = new Rectangle();\r\n\r\nfunction createVectorTilePolygons(parameters, transferableObjects) {\r\n  unpackBuffer(parameters.packedBuffer);\r\n\r\n  let indices;\r\n  const indexBytesPerElement = scratchScalars.indexBytesPerElement;\r\n  if (indexBytesPerElement === 2) {\r\n    indices = new Uint16Array(parameters.indices);\r\n  } else {\r\n    indices = new Uint32Array(parameters.indices);\r\n  }\r\n\r\n  const positions = new Uint16Array(parameters.positions);\r\n  const counts = new Uint32Array(parameters.counts);\r\n  const indexCounts = new Uint32Array(parameters.indexCounts);\r\n  const batchIds = new Uint32Array(parameters.batchIds);\r\n  const batchTableColors = new Uint32Array(parameters.batchTableColors);\r\n\r\n  const boundingVolumes = new Array(counts.length);\r\n\r\n  const center = scratchCenter;\r\n  const ellipsoid = scratchEllipsoid;\r\n  let rectangle = scratchRectangle;\r\n  const minHeight = scratchScalars.min;\r\n  const maxHeight = scratchScalars.max;\r\n\r\n  let minimumHeights = parameters.minimumHeights;\r\n  let maximumHeights = parameters.maximumHeights;\r\n  if (defined(minimumHeights) && defined(maximumHeights)) {\r\n    minimumHeights = new Float32Array(minimumHeights);\r\n    maximumHeights = new Float32Array(maximumHeights);\r\n  }\r\n\r\n  let i;\r\n  let j;\r\n  let rgba;\r\n\r\n  const positionsLength = positions.length / 2;\r\n  const uBuffer = positions.subarray(0, positionsLength);\r\n  const vBuffer = positions.subarray(positionsLength, 2 * positionsLength);\r\n  AttributeCompression.zigZagDeltaDecode(uBuffer, vBuffer);\r\n\r\n  const decodedPositions = new Float64Array(positionsLength * 3);\r\n  for (i = 0; i < positionsLength; ++i) {\r\n    const u = uBuffer[i];\r\n    const v = vBuffer[i];\r\n\r\n    const x = CesiumMath.lerp(rectangle.west, rectangle.east, u / maxShort);\r\n    const y = CesiumMath.lerp(rectangle.south, rectangle.north, v / maxShort);\r\n\r\n    const cart = Cartographic.fromRadians(x, y, 0.0, scratchBVCartographic);\r\n    const decodedPosition = ellipsoid.cartographicToCartesian(\r\n      cart,\r\n      scratchEncodedPosition\r\n    );\r\n    Cartesian3.pack(decodedPosition, decodedPositions, i * 3);\r\n  }\r\n\r\n  const countsLength = counts.length;\r\n  const offsets = new Array(countsLength);\r\n  const indexOffsets = new Array(countsLength);\r\n  let currentOffset = 0;\r\n  let currentIndexOffset = 0;\r\n  for (i = 0; i < countsLength; ++i) {\r\n    offsets[i] = currentOffset;\r\n    indexOffsets[i] = currentIndexOffset;\r\n\r\n    currentOffset += counts[i];\r\n    currentIndexOffset += indexCounts[i];\r\n  }\r\n\r\n  const batchedPositions = new Float32Array(positionsLength * 3 * 2);\r\n  const batchedIds = new Uint16Array(positionsLength * 2);\r\n  const batchedIndexOffsets = new Uint32Array(indexOffsets.length);\r\n  const batchedIndexCounts = new Uint32Array(indexCounts.length);\r\n  let batchedIndices = [];\r\n\r\n  const colorToBuffers = {};\r\n  for (i = 0; i < countsLength; ++i) {\r\n    rgba = batchTableColors[i];\r\n    if (!defined(colorToBuffers[rgba])) {\r\n      colorToBuffers[rgba] = {\r\n        positionLength: counts[i],\r\n        indexLength: indexCounts[i],\r\n        offset: 0,\r\n        indexOffset: 0,\r\n        batchIds: [i],\r\n      };\r\n    } else {\r\n      colorToBuffers[rgba].positionLength += counts[i];\r\n      colorToBuffers[rgba].indexLength += indexCounts[i];\r\n      colorToBuffers[rgba].batchIds.push(i);\r\n    }\r\n  }\r\n\r\n  // get the offsets and counts for the positions and indices of each primitive\r\n  let buffer;\r\n  let byColorPositionOffset = 0;\r\n  let byColorIndexOffset = 0;\r\n  for (rgba in colorToBuffers) {\r\n    if (colorToBuffers.hasOwnProperty(rgba)) {\r\n      buffer = colorToBuffers[rgba];\r\n      buffer.offset = byColorPositionOffset;\r\n      buffer.indexOffset = byColorIndexOffset;\r\n\r\n      const positionLength = buffer.positionLength * 2;\r\n      const indexLength = buffer.indexLength * 2 + buffer.positionLength * 6;\r\n\r\n      byColorPositionOffset += positionLength;\r\n      byColorIndexOffset += indexLength;\r\n\r\n      buffer.indexLength = indexLength;\r\n    }\r\n  }\r\n\r\n  const batchedDrawCalls = [];\r\n\r\n  for (rgba in colorToBuffers) {\r\n    if (colorToBuffers.hasOwnProperty(rgba)) {\r\n      buffer = colorToBuffers[rgba];\r\n\r\n      batchedDrawCalls.push({\r\n        color: Color.fromRgba(parseInt(rgba)),\r\n        offset: buffer.indexOffset,\r\n        count: buffer.indexLength,\r\n        batchIds: buffer.batchIds,\r\n      });\r\n    }\r\n  }\r\n\r\n  for (i = 0; i < countsLength; ++i) {\r\n    rgba = batchTableColors[i];\r\n\r\n    buffer = colorToBuffers[rgba];\r\n    const positionOffset = buffer.offset;\r\n    let positionIndex = positionOffset * 3;\r\n    let batchIdIndex = positionOffset;\r\n\r\n    const polygonOffset = offsets[i];\r\n    const polygonCount = counts[i];\r\n    const batchId = batchIds[i];\r\n\r\n    let polygonMinimumHeight = minHeight;\r\n    let polygonMaximumHeight = maxHeight;\r\n    if (defined(minimumHeights) && defined(maximumHeights)) {\r\n      polygonMinimumHeight = minimumHeights[i];\r\n      polygonMaximumHeight = maximumHeights[i];\r\n    }\r\n\r\n    let minLat = Number.POSITIVE_INFINITY;\r\n    let maxLat = Number.NEGATIVE_INFINITY;\r\n    let minLon = Number.POSITIVE_INFINITY;\r\n    let maxLon = Number.NEGATIVE_INFINITY;\r\n\r\n    for (j = 0; j < polygonCount; ++j) {\r\n      const position = Cartesian3.unpack(\r\n        decodedPositions,\r\n        polygonOffset * 3 + j * 3,\r\n        scratchEncodedPosition\r\n      );\r\n      ellipsoid.scaleToGeodeticSurface(position, position);\r\n\r\n      const carto = ellipsoid.cartesianToCartographic(\r\n        position,\r\n        scratchBVCartographic\r\n      );\r\n      const lat = carto.latitude;\r\n      const lon = carto.longitude;\r\n\r\n      minLat = Math.min(lat, minLat);\r\n      maxLat = Math.max(lat, maxLat);\r\n      minLon = Math.min(lon, minLon);\r\n      maxLon = Math.max(lon, maxLon);\r\n\r\n      const normal = ellipsoid.geodeticSurfaceNormal(position, scratchNormal);\r\n      let scaledNormal = Cartesian3.multiplyByScalar(\r\n        normal,\r\n        polygonMinimumHeight,\r\n        scratchScaledNormal\r\n      );\r\n      const minHeightPosition = Cartesian3.add(\r\n        position,\r\n        scaledNormal,\r\n        scratchMinHeightPosition\r\n      );\r\n\r\n      scaledNormal = Cartesian3.multiplyByScalar(\r\n        normal,\r\n        polygonMaximumHeight,\r\n        scaledNormal\r\n      );\r\n      const maxHeightPosition = Cartesian3.add(\r\n        position,\r\n        scaledNormal,\r\n        scratchMaxHeightPosition\r\n      );\r\n\r\n      Cartesian3.subtract(maxHeightPosition, center, maxHeightPosition);\r\n      Cartesian3.subtract(minHeightPosition, center, minHeightPosition);\r\n\r\n      Cartesian3.pack(maxHeightPosition, batchedPositions, positionIndex);\r\n      Cartesian3.pack(minHeightPosition, batchedPositions, positionIndex + 3);\r\n\r\n      batchedIds[batchIdIndex] = batchId;\r\n      batchedIds[batchIdIndex + 1] = batchId;\r\n\r\n      positionIndex += 6;\r\n      batchIdIndex += 2;\r\n    }\r\n\r\n    rectangle = scratchBVRectangle;\r\n    rectangle.west = minLon;\r\n    rectangle.east = maxLon;\r\n    rectangle.south = minLat;\r\n    rectangle.north = maxLat;\r\n\r\n    boundingVolumes[i] = OrientedBoundingBox.fromRectangle(\r\n      rectangle,\r\n      minHeight,\r\n      maxHeight,\r\n      ellipsoid\r\n    );\r\n\r\n    let indicesIndex = buffer.indexOffset;\r\n\r\n    const indexOffset = indexOffsets[i];\r\n    const indexCount = indexCounts[i];\r\n\r\n    batchedIndexOffsets[i] = indicesIndex;\r\n\r\n    for (j = 0; j < indexCount; j += 3) {\r\n      const i0 = indices[indexOffset + j] - polygonOffset;\r\n      const i1 = indices[indexOffset + j + 1] - polygonOffset;\r\n      const i2 = indices[indexOffset + j + 2] - polygonOffset;\r\n\r\n      // triangle on the top of the extruded polygon\r\n      batchedIndices[indicesIndex++] = i0 * 2 + positionOffset;\r\n      batchedIndices[indicesIndex++] = i1 * 2 + positionOffset;\r\n      batchedIndices[indicesIndex++] = i2 * 2 + positionOffset;\r\n\r\n      // triangle on the bottom of the extruded polygon\r\n      batchedIndices[indicesIndex++] = i2 * 2 + 1 + positionOffset;\r\n      batchedIndices[indicesIndex++] = i1 * 2 + 1 + positionOffset;\r\n      batchedIndices[indicesIndex++] = i0 * 2 + 1 + positionOffset;\r\n    }\r\n\r\n    // indices for the walls of the extruded polygon\r\n    for (j = 0; j < polygonCount; ++j) {\r\n      const v0 = j;\r\n      const v1 = (j + 1) % polygonCount;\r\n\r\n      batchedIndices[indicesIndex++] = v0 * 2 + 1 + positionOffset;\r\n      batchedIndices[indicesIndex++] = v1 * 2 + positionOffset;\r\n      batchedIndices[indicesIndex++] = v0 * 2 + positionOffset;\r\n\r\n      batchedIndices[indicesIndex++] = v0 * 2 + 1 + positionOffset;\r\n      batchedIndices[indicesIndex++] = v1 * 2 + 1 + positionOffset;\r\n      batchedIndices[indicesIndex++] = v1 * 2 + positionOffset;\r\n    }\r\n\r\n    buffer.offset += polygonCount * 2;\r\n    buffer.indexOffset = indicesIndex;\r\n\r\n    batchedIndexCounts[i] = indicesIndex - batchedIndexOffsets[i];\r\n  }\r\n\r\n  batchedIndices = IndexDatatype.createTypedArray(\r\n    batchedPositions.length / 3,\r\n    batchedIndices\r\n  );\r\n\r\n  const batchedIndicesLength = batchedDrawCalls.length;\r\n  for (let m = 0; m < batchedIndicesLength; ++m) {\r\n    const tempIds = batchedDrawCalls[m].batchIds;\r\n    let count = 0;\r\n    const tempIdsLength = tempIds.length;\r\n    for (let n = 0; n < tempIdsLength; ++n) {\r\n      count += batchedIndexCounts[tempIds[n]];\r\n    }\r\n    batchedDrawCalls[m].count = count;\r\n  }\r\n\r\n  const indexDatatype =\r\n    batchedIndices.BYTES_PER_ELEMENT === 2\r\n      ? IndexDatatype.UNSIGNED_SHORT\r\n      : IndexDatatype.UNSIGNED_INT;\r\n  const packedBuffer = packBuffer(\r\n    indexDatatype,\r\n    boundingVolumes,\r\n    batchedDrawCalls\r\n  );\r\n\r\n  transferableObjects.push(\r\n    batchedPositions.buffer,\r\n    batchedIndices.buffer,\r\n    batchedIndexOffsets.buffer,\r\n    batchedIndexCounts.buffer,\r\n    batchedIds.buffer,\r\n    packedBuffer.buffer\r\n  );\r\n\r\n  return {\r\n    positions: batchedPositions.buffer,\r\n    indices: batchedIndices.buffer,\r\n    indexOffsets: batchedIndexOffsets.buffer,\r\n    indexCounts: batchedIndexCounts.buffer,\r\n    batchIds: batchedIds.buffer,\r\n    packedBuffer: packedBuffer.buffer,\r\n  };\r\n}\r\nexport default createTaskProcessorWorker(createVectorTilePolygons);\r\n"],"names":["scratchCenter","Cartesian3","scratchEllipsoid","Ellipsoid","scratchRectangle","Rectangle","scratchScalars","min","undefined","max","indexBytesPerElement","packBuffer","indexDatatype","boundingVolumes","batchedIndices","numBVs","length","OrientedBoundingBox","packedLength","count","i","Color","batchIds","packedBatchedIndicesLength","packedBuffer","Float64Array","offset","pack","indicesLength","j","batchedIndex","color","batchIdsLength","k","scratchEncodedPosition","scratchNormal","scratchScaledNormal","scratchMinHeightPosition","scratchMaxHeightPosition","scratchBVCartographic","Cartographic","scratchBVRectangle","createTaskProcessorWorker","parameters","transferableObjects","indices","buffer","unpack","unpackBuffer","Uint16Array","Uint32Array","positions","counts","indexCounts","batchTableColors","Array","center","ellipsoid","rectangle","minHeight","maxHeight","rgba","minimumHeights","maximumHeights","defined","Float32Array","positionsLength","uBuffer","subarray","vBuffer","AttributeCompression","zigZagDeltaDecode","decodedPositions","u","v","x","CesiumMath","lerp","west","east","y","south","north","cart","fromRadians","decodedPosition","cartographicToCartesian","countsLength","offsets","indexOffsets","currentOffset","currentIndexOffset","batchedPositions","batchedIds","batchedIndexOffsets","batchedIndexCounts","colorToBuffers","positionLength","indexLength","push","indexOffset","byColorPositionOffset","byColorIndexOffset","hasOwnProperty","batchedDrawCalls","fromRgba","parseInt","positionOffset","positionIndex","batchIdIndex","polygonOffset","polygonCount","batchId","polygonMinimumHeight","polygonMaximumHeight","minLat","Number","POSITIVE_INFINITY","maxLat","NEGATIVE_INFINITY","minLon","maxLon","position","scaleToGeodeticSurface","carto","cartesianToCartographic","lat","latitude","lon","longitude","Math","normal","geodeticSurfaceNormal","scaledNormal","multiplyByScalar","minHeightPosition","add","maxHeightPosition","subtract","fromRectangle","indicesIndex","indexCount","i0","i1","i2","v0","v1","IndexDatatype","createTypedArray","batchedIndicesLength","m","tempIds","tempIdsLength","n","BYTES_PER_ELEMENT","UNSIGNED_SHORT","UNSIGNED_INT"],"mappings":"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"}