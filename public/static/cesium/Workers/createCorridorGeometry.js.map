{"version":3,"file":"createCorridorGeometry.js","sources":["../../../../Source/Core/CorridorGeometry.js","../../../../Source/WorkersES6/createCorridorGeometry.js"],"sourcesContent":["import arrayFill from \"./arrayFill.js\";\r\nimport arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\r\nimport BoundingSphere from \"./BoundingSphere.js\";\r\nimport Cartesian3 from \"./Cartesian3.js\";\r\nimport Cartographic from \"./Cartographic.js\";\r\nimport Check from \"./Check.js\";\r\nimport ComponentDatatype from \"./ComponentDatatype.js\";\r\nimport CornerType from \"./CornerType.js\";\r\nimport CorridorGeometryLibrary from \"./CorridorGeometryLibrary.js\";\r\nimport defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\nimport Ellipsoid from \"./Ellipsoid.js\";\r\nimport Geometry from \"./Geometry.js\";\r\nimport GeometryAttribute from \"./GeometryAttribute.js\";\r\nimport GeometryAttributes from \"./GeometryAttributes.js\";\r\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\r\nimport IndexDatatype from \"./IndexDatatype.js\";\r\nimport CesiumMath from \"./Math.js\";\r\nimport PolygonPipeline from \"./PolygonPipeline.js\";\r\nimport PrimitiveType from \"./PrimitiveType.js\";\r\nimport Rectangle from \"./Rectangle.js\";\r\nimport VertexFormat from \"./VertexFormat.js\";\r\n\r\nconst cartesian1 = new Cartesian3();\r\nconst cartesian2 = new Cartesian3();\r\nconst cartesian3 = new Cartesian3();\r\nconst cartesian4 = new Cartesian3();\r\nconst cartesian5 = new Cartesian3();\r\nconst cartesian6 = new Cartesian3();\r\n\r\nconst scratch1 = new Cartesian3();\r\nconst scratch2 = new Cartesian3();\r\n\r\nfunction scaleToSurface(positions, ellipsoid) {\r\n  for (let i = 0; i < positions.length; i++) {\r\n    positions[i] = ellipsoid.scaleToGeodeticSurface(positions[i], positions[i]);\r\n  }\r\n  return positions;\r\n}\r\n\r\nfunction addNormals(attr, normal, left, front, back, vertexFormat) {\r\n  const normals = attr.normals;\r\n  const tangents = attr.tangents;\r\n  const bitangents = attr.bitangents;\r\n  const forward = Cartesian3.normalize(\r\n    Cartesian3.cross(left, normal, scratch1),\r\n    scratch1\r\n  );\r\n  if (vertexFormat.normal) {\r\n    CorridorGeometryLibrary.addAttribute(normals, normal, front, back);\r\n  }\r\n  if (vertexFormat.tangent) {\r\n    CorridorGeometryLibrary.addAttribute(tangents, forward, front, back);\r\n  }\r\n  if (vertexFormat.bitangent) {\r\n    CorridorGeometryLibrary.addAttribute(bitangents, left, front, back);\r\n  }\r\n}\r\n\r\nfunction combine(computedPositions, vertexFormat, ellipsoid) {\r\n  const positions = computedPositions.positions;\r\n  const corners = computedPositions.corners;\r\n  const endPositions = computedPositions.endPositions;\r\n  const computedLefts = computedPositions.lefts;\r\n  const computedNormals = computedPositions.normals;\r\n  const attributes = new GeometryAttributes();\r\n  let corner;\r\n  let leftCount = 0;\r\n  let rightCount = 0;\r\n  let i;\r\n  let indicesLength = 0;\r\n  let length;\r\n  for (i = 0; i < positions.length; i += 2) {\r\n    length = positions[i].length - 3;\r\n    leftCount += length; //subtracting 3 to account for duplicate points at corners\r\n    indicesLength += length * 2;\r\n    rightCount += positions[i + 1].length - 3;\r\n  }\r\n  leftCount += 3; //add back count for end positions\r\n  rightCount += 3;\r\n  for (i = 0; i < corners.length; i++) {\r\n    corner = corners[i];\r\n    const leftSide = corners[i].leftPositions;\r\n    if (defined(leftSide)) {\r\n      length = leftSide.length;\r\n      leftCount += length;\r\n      indicesLength += length;\r\n    } else {\r\n      length = corners[i].rightPositions.length;\r\n      rightCount += length;\r\n      indicesLength += length;\r\n    }\r\n  }\r\n\r\n  const addEndPositions = defined(endPositions);\r\n  let endPositionLength;\r\n  if (addEndPositions) {\r\n    endPositionLength = endPositions[0].length - 3;\r\n    leftCount += endPositionLength;\r\n    rightCount += endPositionLength;\r\n    endPositionLength /= 3;\r\n    indicesLength += endPositionLength * 6;\r\n  }\r\n  const size = leftCount + rightCount;\r\n  const finalPositions = new Float64Array(size);\r\n  const normals = vertexFormat.normal ? new Float32Array(size) : undefined;\r\n  const tangents = vertexFormat.tangent ? new Float32Array(size) : undefined;\r\n  const bitangents = vertexFormat.bitangent\r\n    ? new Float32Array(size)\r\n    : undefined;\r\n  const attr = {\r\n    normals: normals,\r\n    tangents: tangents,\r\n    bitangents: bitangents,\r\n  };\r\n  let front = 0;\r\n  let back = size - 1;\r\n  let UL, LL, UR, LR;\r\n  let normal = cartesian1;\r\n  let left = cartesian2;\r\n  let rightPos, leftPos;\r\n  const halfLength = endPositionLength / 2;\r\n\r\n  const indices = IndexDatatype.createTypedArray(size / 3, indicesLength);\r\n  let index = 0;\r\n  if (addEndPositions) {\r\n    // add rounded end\r\n    leftPos = cartesian3;\r\n    rightPos = cartesian4;\r\n    const firstEndPositions = endPositions[0];\r\n    normal = Cartesian3.fromArray(computedNormals, 0, normal);\r\n    left = Cartesian3.fromArray(computedLefts, 0, left);\r\n    for (i = 0; i < halfLength; i++) {\r\n      leftPos = Cartesian3.fromArray(\r\n        firstEndPositions,\r\n        (halfLength - 1 - i) * 3,\r\n        leftPos\r\n      );\r\n      rightPos = Cartesian3.fromArray(\r\n        firstEndPositions,\r\n        (halfLength + i) * 3,\r\n        rightPos\r\n      );\r\n      CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);\r\n      CorridorGeometryLibrary.addAttribute(\r\n        finalPositions,\r\n        leftPos,\r\n        undefined,\r\n        back\r\n      );\r\n      addNormals(attr, normal, left, front, back, vertexFormat);\r\n\r\n      LL = front / 3;\r\n      LR = LL + 1;\r\n      UL = (back - 2) / 3;\r\n      UR = UL - 1;\r\n      indices[index++] = UL;\r\n      indices[index++] = LL;\r\n      indices[index++] = UR;\r\n      indices[index++] = UR;\r\n      indices[index++] = LL;\r\n      indices[index++] = LR;\r\n\r\n      front += 3;\r\n      back -= 3;\r\n    }\r\n  }\r\n\r\n  let posIndex = 0;\r\n  let compIndex = 0;\r\n  let rightEdge = positions[posIndex++]; //add first two edges\r\n  let leftEdge = positions[posIndex++];\r\n  finalPositions.set(rightEdge, front);\r\n  finalPositions.set(leftEdge, back - leftEdge.length + 1);\r\n\r\n  left = Cartesian3.fromArray(computedLefts, compIndex, left);\r\n  let rightNormal;\r\n  let leftNormal;\r\n  length = leftEdge.length - 3;\r\n  for (i = 0; i < length; i += 3) {\r\n    rightNormal = ellipsoid.geodeticSurfaceNormal(\r\n      Cartesian3.fromArray(rightEdge, i, scratch1),\r\n      scratch1\r\n    );\r\n    leftNormal = ellipsoid.geodeticSurfaceNormal(\r\n      Cartesian3.fromArray(leftEdge, length - i, scratch2),\r\n      scratch2\r\n    );\r\n    normal = Cartesian3.normalize(\r\n      Cartesian3.add(rightNormal, leftNormal, normal),\r\n      normal\r\n    );\r\n    addNormals(attr, normal, left, front, back, vertexFormat);\r\n\r\n    LL = front / 3;\r\n    LR = LL + 1;\r\n    UL = (back - 2) / 3;\r\n    UR = UL - 1;\r\n    indices[index++] = UL;\r\n    indices[index++] = LL;\r\n    indices[index++] = UR;\r\n    indices[index++] = UR;\r\n    indices[index++] = LL;\r\n    indices[index++] = LR;\r\n\r\n    front += 3;\r\n    back -= 3;\r\n  }\r\n\r\n  rightNormal = ellipsoid.geodeticSurfaceNormal(\r\n    Cartesian3.fromArray(rightEdge, length, scratch1),\r\n    scratch1\r\n  );\r\n  leftNormal = ellipsoid.geodeticSurfaceNormal(\r\n    Cartesian3.fromArray(leftEdge, length, scratch2),\r\n    scratch2\r\n  );\r\n  normal = Cartesian3.normalize(\r\n    Cartesian3.add(rightNormal, leftNormal, normal),\r\n    normal\r\n  );\r\n  compIndex += 3;\r\n  for (i = 0; i < corners.length; i++) {\r\n    let j;\r\n    corner = corners[i];\r\n    const l = corner.leftPositions;\r\n    const r = corner.rightPositions;\r\n    let pivot;\r\n    let start;\r\n    let outsidePoint = cartesian6;\r\n    let previousPoint = cartesian3;\r\n    let nextPoint = cartesian4;\r\n    normal = Cartesian3.fromArray(computedNormals, compIndex, normal);\r\n    if (defined(l)) {\r\n      addNormals(attr, normal, left, undefined, back, vertexFormat);\r\n      back -= 3;\r\n      pivot = LR;\r\n      start = UR;\r\n      for (j = 0; j < l.length / 3; j++) {\r\n        outsidePoint = Cartesian3.fromArray(l, j * 3, outsidePoint);\r\n        indices[index++] = pivot;\r\n        indices[index++] = start - j - 1;\r\n        indices[index++] = start - j;\r\n        CorridorGeometryLibrary.addAttribute(\r\n          finalPositions,\r\n          outsidePoint,\r\n          undefined,\r\n          back\r\n        );\r\n        previousPoint = Cartesian3.fromArray(\r\n          finalPositions,\r\n          (start - j - 1) * 3,\r\n          previousPoint\r\n        );\r\n        nextPoint = Cartesian3.fromArray(finalPositions, pivot * 3, nextPoint);\r\n        left = Cartesian3.normalize(\r\n          Cartesian3.subtract(previousPoint, nextPoint, left),\r\n          left\r\n        );\r\n        addNormals(attr, normal, left, undefined, back, vertexFormat);\r\n        back -= 3;\r\n      }\r\n      outsidePoint = Cartesian3.fromArray(\r\n        finalPositions,\r\n        pivot * 3,\r\n        outsidePoint\r\n      );\r\n      previousPoint = Cartesian3.subtract(\r\n        Cartesian3.fromArray(finalPositions, start * 3, previousPoint),\r\n        outsidePoint,\r\n        previousPoint\r\n      );\r\n      nextPoint = Cartesian3.subtract(\r\n        Cartesian3.fromArray(finalPositions, (start - j) * 3, nextPoint),\r\n        outsidePoint,\r\n        nextPoint\r\n      );\r\n      left = Cartesian3.normalize(\r\n        Cartesian3.add(previousPoint, nextPoint, left),\r\n        left\r\n      );\r\n      addNormals(attr, normal, left, front, undefined, vertexFormat);\r\n      front += 3;\r\n    } else {\r\n      addNormals(attr, normal, left, front, undefined, vertexFormat);\r\n      front += 3;\r\n      pivot = UR;\r\n      start = LR;\r\n      for (j = 0; j < r.length / 3; j++) {\r\n        outsidePoint = Cartesian3.fromArray(r, j * 3, outsidePoint);\r\n        indices[index++] = pivot;\r\n        indices[index++] = start + j;\r\n        indices[index++] = start + j + 1;\r\n        CorridorGeometryLibrary.addAttribute(\r\n          finalPositions,\r\n          outsidePoint,\r\n          front\r\n        );\r\n        previousPoint = Cartesian3.fromArray(\r\n          finalPositions,\r\n          pivot * 3,\r\n          previousPoint\r\n        );\r\n        nextPoint = Cartesian3.fromArray(\r\n          finalPositions,\r\n          (start + j) * 3,\r\n          nextPoint\r\n        );\r\n        left = Cartesian3.normalize(\r\n          Cartesian3.subtract(previousPoint, nextPoint, left),\r\n          left\r\n        );\r\n        addNormals(attr, normal, left, front, undefined, vertexFormat);\r\n        front += 3;\r\n      }\r\n      outsidePoint = Cartesian3.fromArray(\r\n        finalPositions,\r\n        pivot * 3,\r\n        outsidePoint\r\n      );\r\n      previousPoint = Cartesian3.subtract(\r\n        Cartesian3.fromArray(finalPositions, (start + j) * 3, previousPoint),\r\n        outsidePoint,\r\n        previousPoint\r\n      );\r\n      nextPoint = Cartesian3.subtract(\r\n        Cartesian3.fromArray(finalPositions, start * 3, nextPoint),\r\n        outsidePoint,\r\n        nextPoint\r\n      );\r\n      left = Cartesian3.normalize(\r\n        Cartesian3.negate(Cartesian3.add(nextPoint, previousPoint, left), left),\r\n        left\r\n      );\r\n      addNormals(attr, normal, left, undefined, back, vertexFormat);\r\n      back -= 3;\r\n    }\r\n    rightEdge = positions[posIndex++];\r\n    leftEdge = positions[posIndex++];\r\n    rightEdge.splice(0, 3); //remove duplicate points added by corner\r\n    leftEdge.splice(leftEdge.length - 3, 3);\r\n    finalPositions.set(rightEdge, front);\r\n    finalPositions.set(leftEdge, back - leftEdge.length + 1);\r\n    length = leftEdge.length - 3;\r\n\r\n    compIndex += 3;\r\n    left = Cartesian3.fromArray(computedLefts, compIndex, left);\r\n    for (j = 0; j < leftEdge.length; j += 3) {\r\n      rightNormal = ellipsoid.geodeticSurfaceNormal(\r\n        Cartesian3.fromArray(rightEdge, j, scratch1),\r\n        scratch1\r\n      );\r\n      leftNormal = ellipsoid.geodeticSurfaceNormal(\r\n        Cartesian3.fromArray(leftEdge, length - j, scratch2),\r\n        scratch2\r\n      );\r\n      normal = Cartesian3.normalize(\r\n        Cartesian3.add(rightNormal, leftNormal, normal),\r\n        normal\r\n      );\r\n      addNormals(attr, normal, left, front, back, vertexFormat);\r\n\r\n      LR = front / 3;\r\n      LL = LR - 1;\r\n      UR = (back - 2) / 3;\r\n      UL = UR + 1;\r\n      indices[index++] = UL;\r\n      indices[index++] = LL;\r\n      indices[index++] = UR;\r\n      indices[index++] = UR;\r\n      indices[index++] = LL;\r\n      indices[index++] = LR;\r\n\r\n      front += 3;\r\n      back -= 3;\r\n    }\r\n    front -= 3;\r\n    back += 3;\r\n  }\r\n  normal = Cartesian3.fromArray(\r\n    computedNormals,\r\n    computedNormals.length - 3,\r\n    normal\r\n  );\r\n  addNormals(attr, normal, left, front, back, vertexFormat);\r\n\r\n  if (addEndPositions) {\r\n    // add rounded end\r\n    front += 3;\r\n    back -= 3;\r\n    leftPos = cartesian3;\r\n    rightPos = cartesian4;\r\n    const lastEndPositions = endPositions[1];\r\n    for (i = 0; i < halfLength; i++) {\r\n      leftPos = Cartesian3.fromArray(\r\n        lastEndPositions,\r\n        (endPositionLength - i - 1) * 3,\r\n        leftPos\r\n      );\r\n      rightPos = Cartesian3.fromArray(lastEndPositions, i * 3, rightPos);\r\n      CorridorGeometryLibrary.addAttribute(\r\n        finalPositions,\r\n        leftPos,\r\n        undefined,\r\n        back\r\n      );\r\n      CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);\r\n      addNormals(attr, normal, left, front, back, vertexFormat);\r\n\r\n      LR = front / 3;\r\n      LL = LR - 1;\r\n      UR = (back - 2) / 3;\r\n      UL = UR + 1;\r\n      indices[index++] = UL;\r\n      indices[index++] = LL;\r\n      indices[index++] = UR;\r\n      indices[index++] = UR;\r\n      indices[index++] = LL;\r\n      indices[index++] = LR;\r\n\r\n      front += 3;\r\n      back -= 3;\r\n    }\r\n  }\r\n\r\n  attributes.position = new GeometryAttribute({\r\n    componentDatatype: ComponentDatatype.DOUBLE,\r\n    componentsPerAttribute: 3,\r\n    values: finalPositions,\r\n  });\r\n\r\n  if (vertexFormat.st) {\r\n    const st = new Float32Array((size / 3) * 2);\r\n    let rightSt;\r\n    let leftSt;\r\n    let stIndex = 0;\r\n    if (addEndPositions) {\r\n      leftCount /= 3;\r\n      rightCount /= 3;\r\n      const theta = Math.PI / (endPositionLength + 1);\r\n      leftSt = 1 / (leftCount - endPositionLength + 1);\r\n      rightSt = 1 / (rightCount - endPositionLength + 1);\r\n      let a;\r\n      const halfEndPos = endPositionLength / 2;\r\n      for (i = halfEndPos + 1; i < endPositionLength + 1; i++) {\r\n        // lower left rounded end\r\n        a = CesiumMath.PI_OVER_TWO + theta * i;\r\n        st[stIndex++] = rightSt * (1 + Math.cos(a));\r\n        st[stIndex++] = 0.5 * (1 + Math.sin(a));\r\n      }\r\n      for (i = 1; i < rightCount - endPositionLength + 1; i++) {\r\n        // bottom edge\r\n        st[stIndex++] = i * rightSt;\r\n        st[stIndex++] = 0;\r\n      }\r\n      for (i = endPositionLength; i > halfEndPos; i--) {\r\n        // lower right rounded end\r\n        a = CesiumMath.PI_OVER_TWO - i * theta;\r\n        st[stIndex++] = 1 - rightSt * (1 + Math.cos(a));\r\n        st[stIndex++] = 0.5 * (1 + Math.sin(a));\r\n      }\r\n      for (i = halfEndPos; i > 0; i--) {\r\n        // upper right rounded end\r\n        a = CesiumMath.PI_OVER_TWO - theta * i;\r\n        st[stIndex++] = 1 - leftSt * (1 + Math.cos(a));\r\n        st[stIndex++] = 0.5 * (1 + Math.sin(a));\r\n      }\r\n      for (i = leftCount - endPositionLength; i > 0; i--) {\r\n        // top edge\r\n        st[stIndex++] = i * leftSt;\r\n        st[stIndex++] = 1;\r\n      }\r\n      for (i = 1; i < halfEndPos + 1; i++) {\r\n        // upper left rounded end\r\n        a = CesiumMath.PI_OVER_TWO + theta * i;\r\n        st[stIndex++] = leftSt * (1 + Math.cos(a));\r\n        st[stIndex++] = 0.5 * (1 + Math.sin(a));\r\n      }\r\n    } else {\r\n      leftCount /= 3;\r\n      rightCount /= 3;\r\n      leftSt = 1 / (leftCount - 1);\r\n      rightSt = 1 / (rightCount - 1);\r\n      for (i = 0; i < rightCount; i++) {\r\n        // bottom edge\r\n        st[stIndex++] = i * rightSt;\r\n        st[stIndex++] = 0;\r\n      }\r\n      for (i = leftCount; i > 0; i--) {\r\n        // top edge\r\n        st[stIndex++] = (i - 1) * leftSt;\r\n        st[stIndex++] = 1;\r\n      }\r\n    }\r\n\r\n    attributes.st = new GeometryAttribute({\r\n      componentDatatype: ComponentDatatype.FLOAT,\r\n      componentsPerAttribute: 2,\r\n      values: st,\r\n    });\r\n  }\r\n\r\n  if (vertexFormat.normal) {\r\n    attributes.normal = new GeometryAttribute({\r\n      componentDatatype: ComponentDatatype.FLOAT,\r\n      componentsPerAttribute: 3,\r\n      values: attr.normals,\r\n    });\r\n  }\r\n\r\n  if (vertexFormat.tangent) {\r\n    attributes.tangent = new GeometryAttribute({\r\n      componentDatatype: ComponentDatatype.FLOAT,\r\n      componentsPerAttribute: 3,\r\n      values: attr.tangents,\r\n    });\r\n  }\r\n\r\n  if (vertexFormat.bitangent) {\r\n    attributes.bitangent = new GeometryAttribute({\r\n      componentDatatype: ComponentDatatype.FLOAT,\r\n      componentsPerAttribute: 3,\r\n      values: attr.bitangents,\r\n    });\r\n  }\r\n\r\n  return {\r\n    attributes: attributes,\r\n    indices: indices,\r\n  };\r\n}\r\n\r\nfunction extrudedAttributes(attributes, vertexFormat) {\r\n  if (\r\n    !vertexFormat.normal &&\r\n    !vertexFormat.tangent &&\r\n    !vertexFormat.bitangent &&\r\n    !vertexFormat.st\r\n  ) {\r\n    return attributes;\r\n  }\r\n  const positions = attributes.position.values;\r\n  let topNormals;\r\n  let topBitangents;\r\n  if (vertexFormat.normal || vertexFormat.bitangent) {\r\n    topNormals = attributes.normal.values;\r\n    topBitangents = attributes.bitangent.values;\r\n  }\r\n  const size = attributes.position.values.length / 18;\r\n  const threeSize = size * 3;\r\n  const twoSize = size * 2;\r\n  const sixSize = threeSize * 2;\r\n  let i;\r\n  if (vertexFormat.normal || vertexFormat.bitangent || vertexFormat.tangent) {\r\n    const normals = vertexFormat.normal\r\n      ? new Float32Array(threeSize * 6)\r\n      : undefined;\r\n    const tangents = vertexFormat.tangent\r\n      ? new Float32Array(threeSize * 6)\r\n      : undefined;\r\n    const bitangents = vertexFormat.bitangent\r\n      ? new Float32Array(threeSize * 6)\r\n      : undefined;\r\n    let topPosition = cartesian1;\r\n    let bottomPosition = cartesian2;\r\n    let previousPosition = cartesian3;\r\n    let normal = cartesian4;\r\n    let tangent = cartesian5;\r\n    let bitangent = cartesian6;\r\n    let attrIndex = sixSize;\r\n    for (i = 0; i < threeSize; i += 3) {\r\n      const attrIndexOffset = attrIndex + sixSize;\r\n      topPosition = Cartesian3.fromArray(positions, i, topPosition);\r\n      bottomPosition = Cartesian3.fromArray(\r\n        positions,\r\n        i + threeSize,\r\n        bottomPosition\r\n      );\r\n      previousPosition = Cartesian3.fromArray(\r\n        positions,\r\n        (i + 3) % threeSize,\r\n        previousPosition\r\n      );\r\n      bottomPosition = Cartesian3.subtract(\r\n        bottomPosition,\r\n        topPosition,\r\n        bottomPosition\r\n      );\r\n      previousPosition = Cartesian3.subtract(\r\n        previousPosition,\r\n        topPosition,\r\n        previousPosition\r\n      );\r\n      normal = Cartesian3.normalize(\r\n        Cartesian3.cross(bottomPosition, previousPosition, normal),\r\n        normal\r\n      );\r\n      if (vertexFormat.normal) {\r\n        CorridorGeometryLibrary.addAttribute(normals, normal, attrIndexOffset);\r\n        CorridorGeometryLibrary.addAttribute(\r\n          normals,\r\n          normal,\r\n          attrIndexOffset + 3\r\n        );\r\n        CorridorGeometryLibrary.addAttribute(normals, normal, attrIndex);\r\n        CorridorGeometryLibrary.addAttribute(normals, normal, attrIndex + 3);\r\n      }\r\n      if (vertexFormat.tangent || vertexFormat.bitangent) {\r\n        bitangent = Cartesian3.fromArray(topNormals, i, bitangent);\r\n        if (vertexFormat.bitangent) {\r\n          CorridorGeometryLibrary.addAttribute(\r\n            bitangents,\r\n            bitangent,\r\n            attrIndexOffset\r\n          );\r\n          CorridorGeometryLibrary.addAttribute(\r\n            bitangents,\r\n            bitangent,\r\n            attrIndexOffset + 3\r\n          );\r\n          CorridorGeometryLibrary.addAttribute(\r\n            bitangents,\r\n            bitangent,\r\n            attrIndex\r\n          );\r\n          CorridorGeometryLibrary.addAttribute(\r\n            bitangents,\r\n            bitangent,\r\n            attrIndex + 3\r\n          );\r\n        }\r\n\r\n        if (vertexFormat.tangent) {\r\n          tangent = Cartesian3.normalize(\r\n            Cartesian3.cross(bitangent, normal, tangent),\r\n            tangent\r\n          );\r\n          CorridorGeometryLibrary.addAttribute(\r\n            tangents,\r\n            tangent,\r\n            attrIndexOffset\r\n          );\r\n          CorridorGeometryLibrary.addAttribute(\r\n            tangents,\r\n            tangent,\r\n            attrIndexOffset + 3\r\n          );\r\n          CorridorGeometryLibrary.addAttribute(tangents, tangent, attrIndex);\r\n          CorridorGeometryLibrary.addAttribute(\r\n            tangents,\r\n            tangent,\r\n            attrIndex + 3\r\n          );\r\n        }\r\n      }\r\n      attrIndex += 6;\r\n    }\r\n\r\n    if (vertexFormat.normal) {\r\n      normals.set(topNormals); //top\r\n      for (i = 0; i < threeSize; i += 3) {\r\n        //bottom normals\r\n        normals[i + threeSize] = -topNormals[i];\r\n        normals[i + threeSize + 1] = -topNormals[i + 1];\r\n        normals[i + threeSize + 2] = -topNormals[i + 2];\r\n      }\r\n      attributes.normal.values = normals;\r\n    } else {\r\n      attributes.normal = undefined;\r\n    }\r\n\r\n    if (vertexFormat.bitangent) {\r\n      bitangents.set(topBitangents); //top\r\n      bitangents.set(topBitangents, threeSize); //bottom\r\n      attributes.bitangent.values = bitangents;\r\n    } else {\r\n      attributes.bitangent = undefined;\r\n    }\r\n\r\n    if (vertexFormat.tangent) {\r\n      const topTangents = attributes.tangent.values;\r\n      tangents.set(topTangents); //top\r\n      tangents.set(topTangents, threeSize); //bottom\r\n      attributes.tangent.values = tangents;\r\n    }\r\n  }\r\n  if (vertexFormat.st) {\r\n    const topSt = attributes.st.values;\r\n    const st = new Float32Array(twoSize * 6);\r\n    st.set(topSt); //top\r\n    st.set(topSt, twoSize); //bottom\r\n    let index = twoSize * 2;\r\n\r\n    for (let j = 0; j < 2; j++) {\r\n      st[index++] = topSt[0];\r\n      st[index++] = topSt[1];\r\n      for (i = 2; i < twoSize; i += 2) {\r\n        const s = topSt[i];\r\n        const t = topSt[i + 1];\r\n        st[index++] = s;\r\n        st[index++] = t;\r\n        st[index++] = s;\r\n        st[index++] = t;\r\n      }\r\n      st[index++] = topSt[0];\r\n      st[index++] = topSt[1];\r\n    }\r\n    attributes.st.values = st;\r\n  }\r\n\r\n  return attributes;\r\n}\r\n\r\nfunction addWallPositions(positions, index, wallPositions) {\r\n  wallPositions[index++] = positions[0];\r\n  wallPositions[index++] = positions[1];\r\n  wallPositions[index++] = positions[2];\r\n  for (let i = 3; i < positions.length; i += 3) {\r\n    const x = positions[i];\r\n    const y = positions[i + 1];\r\n    const z = positions[i + 2];\r\n    wallPositions[index++] = x;\r\n    wallPositions[index++] = y;\r\n    wallPositions[index++] = z;\r\n    wallPositions[index++] = x;\r\n    wallPositions[index++] = y;\r\n    wallPositions[index++] = z;\r\n  }\r\n  wallPositions[index++] = positions[0];\r\n  wallPositions[index++] = positions[1];\r\n  wallPositions[index++] = positions[2];\r\n\r\n  return wallPositions;\r\n}\r\n\r\nfunction computePositionsExtruded(params, vertexFormat) {\r\n  const topVertexFormat = new VertexFormat({\r\n    position: vertexFormat.position,\r\n    normal:\r\n      vertexFormat.normal || vertexFormat.bitangent || params.shadowVolume,\r\n    tangent: vertexFormat.tangent,\r\n    bitangent: vertexFormat.normal || vertexFormat.bitangent,\r\n    st: vertexFormat.st,\r\n  });\r\n  const ellipsoid = params.ellipsoid;\r\n  const computedPositions = CorridorGeometryLibrary.computePositions(params);\r\n  const attr = combine(computedPositions, topVertexFormat, ellipsoid);\r\n  const height = params.height;\r\n  const extrudedHeight = params.extrudedHeight;\r\n  let attributes = attr.attributes;\r\n  const indices = attr.indices;\r\n  let positions = attributes.position.values;\r\n  let length = positions.length;\r\n  const newPositions = new Float64Array(length * 6);\r\n  let extrudedPositions = new Float64Array(length);\r\n  extrudedPositions.set(positions);\r\n  let wallPositions = new Float64Array(length * 4);\r\n\r\n  positions = PolygonPipeline.scaleToGeodeticHeight(\r\n    positions,\r\n    height,\r\n    ellipsoid\r\n  );\r\n  wallPositions = addWallPositions(positions, 0, wallPositions);\r\n  extrudedPositions = PolygonPipeline.scaleToGeodeticHeight(\r\n    extrudedPositions,\r\n    extrudedHeight,\r\n    ellipsoid\r\n  );\r\n  wallPositions = addWallPositions(\r\n    extrudedPositions,\r\n    length * 2,\r\n    wallPositions\r\n  );\r\n  newPositions.set(positions);\r\n  newPositions.set(extrudedPositions, length);\r\n  newPositions.set(wallPositions, length * 2);\r\n  attributes.position.values = newPositions;\r\n\r\n  attributes = extrudedAttributes(attributes, vertexFormat);\r\n  let i;\r\n  const size = length / 3;\r\n  if (params.shadowVolume) {\r\n    const topNormals = attributes.normal.values;\r\n    length = topNormals.length;\r\n\r\n    let extrudeNormals = new Float32Array(length * 6);\r\n    for (i = 0; i < length; i++) {\r\n      topNormals[i] = -topNormals[i];\r\n    }\r\n    //only get normals for bottom layer that's going to be pushed down\r\n    extrudeNormals.set(topNormals, length); //bottom face\r\n    extrudeNormals = addWallPositions(topNormals, length * 4, extrudeNormals); //bottom wall\r\n    attributes.extrudeDirection = new GeometryAttribute({\r\n      componentDatatype: ComponentDatatype.FLOAT,\r\n      componentsPerAttribute: 3,\r\n      values: extrudeNormals,\r\n    });\r\n    if (!vertexFormat.normal) {\r\n      attributes.normal = undefined;\r\n    }\r\n  }\r\n  if (defined(params.offsetAttribute)) {\r\n    let applyOffset = new Uint8Array(size * 6);\r\n    if (params.offsetAttribute === GeometryOffsetAttribute.TOP) {\r\n      applyOffset = arrayFill(applyOffset, 1, 0, size); // top face\r\n      applyOffset = arrayFill(applyOffset, 1, size * 2, size * 4); // top wall\r\n    } else {\r\n      const applyOffsetValue =\r\n        params.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\r\n      applyOffset = arrayFill(applyOffset, applyOffsetValue);\r\n    }\r\n    attributes.applyOffset = new GeometryAttribute({\r\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\r\n      componentsPerAttribute: 1,\r\n      values: applyOffset,\r\n    });\r\n  }\r\n\r\n  const iLength = indices.length;\r\n  const twoSize = size + size;\r\n  const newIndices = IndexDatatype.createTypedArray(\r\n    newPositions.length / 3,\r\n    iLength * 2 + twoSize * 3\r\n  );\r\n  newIndices.set(indices);\r\n  let index = iLength;\r\n  for (i = 0; i < iLength; i += 3) {\r\n    // bottom indices\r\n    const v0 = indices[i];\r\n    const v1 = indices[i + 1];\r\n    const v2 = indices[i + 2];\r\n    newIndices[index++] = v2 + size;\r\n    newIndices[index++] = v1 + size;\r\n    newIndices[index++] = v0 + size;\r\n  }\r\n\r\n  let UL, LL, UR, LR;\r\n\r\n  for (i = 0; i < twoSize; i += 2) {\r\n    //wall indices\r\n    UL = i + twoSize;\r\n    LL = UL + twoSize;\r\n    UR = UL + 1;\r\n    LR = LL + 1;\r\n    newIndices[index++] = UL;\r\n    newIndices[index++] = LL;\r\n    newIndices[index++] = UR;\r\n    newIndices[index++] = UR;\r\n    newIndices[index++] = LL;\r\n    newIndices[index++] = LR;\r\n  }\r\n\r\n  return {\r\n    attributes: attributes,\r\n    indices: newIndices,\r\n  };\r\n}\r\n\r\nconst scratchCartesian1 = new Cartesian3();\r\nconst scratchCartesian2 = new Cartesian3();\r\nconst scratchCartographic = new Cartographic();\r\n\r\nfunction computeOffsetPoints(\r\n  position1,\r\n  position2,\r\n  ellipsoid,\r\n  halfWidth,\r\n  min,\r\n  max\r\n) {\r\n  // Compute direction of offset the point\r\n  const direction = Cartesian3.subtract(\r\n    position2,\r\n    position1,\r\n    scratchCartesian1\r\n  );\r\n  Cartesian3.normalize(direction, direction);\r\n  const normal = ellipsoid.geodeticSurfaceNormal(position1, scratchCartesian2);\r\n  const offsetDirection = Cartesian3.cross(\r\n    direction,\r\n    normal,\r\n    scratchCartesian1\r\n  );\r\n  Cartesian3.multiplyByScalar(offsetDirection, halfWidth, offsetDirection);\r\n\r\n  let minLat = min.latitude;\r\n  let minLon = min.longitude;\r\n  let maxLat = max.latitude;\r\n  let maxLon = max.longitude;\r\n\r\n  // Compute 2 offset points\r\n  Cartesian3.add(position1, offsetDirection, scratchCartesian2);\r\n  ellipsoid.cartesianToCartographic(scratchCartesian2, scratchCartographic);\r\n\r\n  let lat = scratchCartographic.latitude;\r\n  let lon = scratchCartographic.longitude;\r\n  minLat = Math.min(minLat, lat);\r\n  minLon = Math.min(minLon, lon);\r\n  maxLat = Math.max(maxLat, lat);\r\n  maxLon = Math.max(maxLon, lon);\r\n\r\n  Cartesian3.subtract(position1, offsetDirection, scratchCartesian2);\r\n  ellipsoid.cartesianToCartographic(scratchCartesian2, scratchCartographic);\r\n\r\n  lat = scratchCartographic.latitude;\r\n  lon = scratchCartographic.longitude;\r\n  minLat = Math.min(minLat, lat);\r\n  minLon = Math.min(minLon, lon);\r\n  maxLat = Math.max(maxLat, lat);\r\n  maxLon = Math.max(maxLon, lon);\r\n\r\n  min.latitude = minLat;\r\n  min.longitude = minLon;\r\n  max.latitude = maxLat;\r\n  max.longitude = maxLon;\r\n}\r\n\r\nconst scratchCartesianOffset = new Cartesian3();\r\nconst scratchCartesianEnds = new Cartesian3();\r\nconst scratchCartographicMin = new Cartographic();\r\nconst scratchCartographicMax = new Cartographic();\r\n\r\nfunction computeRectangle(positions, ellipsoid, width, cornerType, result) {\r\n  positions = scaleToSurface(positions, ellipsoid);\r\n  const cleanPositions = arrayRemoveDuplicates(\r\n    positions,\r\n    Cartesian3.equalsEpsilon\r\n  );\r\n  const length = cleanPositions.length;\r\n  if (length < 2 || width <= 0) {\r\n    return new Rectangle();\r\n  }\r\n  const halfWidth = width * 0.5;\r\n\r\n  scratchCartographicMin.latitude = Number.POSITIVE_INFINITY;\r\n  scratchCartographicMin.longitude = Number.POSITIVE_INFINITY;\r\n  scratchCartographicMax.latitude = Number.NEGATIVE_INFINITY;\r\n  scratchCartographicMax.longitude = Number.NEGATIVE_INFINITY;\r\n\r\n  let lat, lon;\r\n  if (cornerType === CornerType.ROUNDED) {\r\n    // Compute start cap\r\n    const first = cleanPositions[0];\r\n    Cartesian3.subtract(first, cleanPositions[1], scratchCartesianOffset);\r\n    Cartesian3.normalize(scratchCartesianOffset, scratchCartesianOffset);\r\n    Cartesian3.multiplyByScalar(\r\n      scratchCartesianOffset,\r\n      halfWidth,\r\n      scratchCartesianOffset\r\n    );\r\n    Cartesian3.add(first, scratchCartesianOffset, scratchCartesianEnds);\r\n\r\n    ellipsoid.cartesianToCartographic(\r\n      scratchCartesianEnds,\r\n      scratchCartographic\r\n    );\r\n    lat = scratchCartographic.latitude;\r\n    lon = scratchCartographic.longitude;\r\n    scratchCartographicMin.latitude = Math.min(\r\n      scratchCartographicMin.latitude,\r\n      lat\r\n    );\r\n    scratchCartographicMin.longitude = Math.min(\r\n      scratchCartographicMin.longitude,\r\n      lon\r\n    );\r\n    scratchCartographicMax.latitude = Math.max(\r\n      scratchCartographicMax.latitude,\r\n      lat\r\n    );\r\n    scratchCartographicMax.longitude = Math.max(\r\n      scratchCartographicMax.longitude,\r\n      lon\r\n    );\r\n  }\r\n\r\n  // Compute the rest\r\n  for (let i = 0; i < length - 1; ++i) {\r\n    computeOffsetPoints(\r\n      cleanPositions[i],\r\n      cleanPositions[i + 1],\r\n      ellipsoid,\r\n      halfWidth,\r\n      scratchCartographicMin,\r\n      scratchCartographicMax\r\n    );\r\n  }\r\n\r\n  // Compute ending point\r\n  const last = cleanPositions[length - 1];\r\n  Cartesian3.subtract(last, cleanPositions[length - 2], scratchCartesianOffset);\r\n  Cartesian3.normalize(scratchCartesianOffset, scratchCartesianOffset);\r\n  Cartesian3.multiplyByScalar(\r\n    scratchCartesianOffset,\r\n    halfWidth,\r\n    scratchCartesianOffset\r\n  );\r\n  Cartesian3.add(last, scratchCartesianOffset, scratchCartesianEnds);\r\n  computeOffsetPoints(\r\n    last,\r\n    scratchCartesianEnds,\r\n    ellipsoid,\r\n    halfWidth,\r\n    scratchCartographicMin,\r\n    scratchCartographicMax\r\n  );\r\n\r\n  if (cornerType === CornerType.ROUNDED) {\r\n    // Compute end cap\r\n    ellipsoid.cartesianToCartographic(\r\n      scratchCartesianEnds,\r\n      scratchCartographic\r\n    );\r\n    lat = scratchCartographic.latitude;\r\n    lon = scratchCartographic.longitude;\r\n    scratchCartographicMin.latitude = Math.min(\r\n      scratchCartographicMin.latitude,\r\n      lat\r\n    );\r\n    scratchCartographicMin.longitude = Math.min(\r\n      scratchCartographicMin.longitude,\r\n      lon\r\n    );\r\n    scratchCartographicMax.latitude = Math.max(\r\n      scratchCartographicMax.latitude,\r\n      lat\r\n    );\r\n    scratchCartographicMax.longitude = Math.max(\r\n      scratchCartographicMax.longitude,\r\n      lon\r\n    );\r\n  }\r\n\r\n  const rectangle = defined(result) ? result : new Rectangle();\r\n  rectangle.north = scratchCartographicMax.latitude;\r\n  rectangle.south = scratchCartographicMin.latitude;\r\n  rectangle.east = scratchCartographicMax.longitude;\r\n  rectangle.west = scratchCartographicMin.longitude;\r\n\r\n  return rectangle;\r\n}\r\n\r\n/**\r\n * A description of a corridor. Corridor geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\r\n *\r\n * @alias CorridorGeometry\r\n * @constructor\r\n *\r\n * @param {Object} options Object with the following properties:\r\n * @param {Cartesian3[]} options.positions An array of positions that define the center of the corridor.\r\n * @param {Number} options.width The distance between the edges of the corridor in meters.\r\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\r\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\r\n * @param {Number} [options.height=0] The distance in meters between the ellipsoid surface and the positions.\r\n * @param {Number} [options.extrudedHeight] The distance in meters between the ellipsoid surface and the extruded face.\r\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\r\n * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.\r\n *\r\n * @see CorridorGeometry.createGeometry\r\n * @see Packable\r\n *\r\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Corridor.html|Cesium Sandcastle Corridor Demo}\r\n *\r\n * @example\r\n * const corridor = new Cesium.CorridorGeometry({\r\n *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,\r\n *   positions : Cesium.Cartesian3.fromDegreesArray([-72.0, 40.0, -70.0, 35.0]),\r\n *   width : 100000\r\n * });\r\n */\r\nfunction CorridorGeometry(options) {\r\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n  const positions = options.positions;\r\n  const width = options.width;\r\n\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"options.positions\", positions);\r\n  Check.defined(\"options.width\", width);\r\n  //>>includeEnd('debug');\r\n\r\n  const height = defaultValue(options.height, 0.0);\r\n  const extrudedHeight = defaultValue(options.extrudedHeight, height);\r\n\r\n  this._positions = positions;\r\n  this._ellipsoid = Ellipsoid.clone(\r\n    defaultValue(options.ellipsoid, Ellipsoid.WGS84)\r\n  );\r\n  this._vertexFormat = VertexFormat.clone(\r\n    defaultValue(options.vertexFormat, VertexFormat.DEFAULT)\r\n  );\r\n  this._width = width;\r\n  this._height = Math.max(height, extrudedHeight);\r\n  this._extrudedHeight = Math.min(height, extrudedHeight);\r\n  this._cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);\r\n  this._granularity = defaultValue(\r\n    options.granularity,\r\n    CesiumMath.RADIANS_PER_DEGREE\r\n  );\r\n  this._shadowVolume = defaultValue(options.shadowVolume, false);\r\n  this._workerName = \"createCorridorGeometry\";\r\n  this._offsetAttribute = options.offsetAttribute;\r\n  this._rectangle = undefined;\r\n\r\n  /**\r\n   * The number of elements used to pack the object into an array.\r\n   * @type {Number}\r\n   */\r\n  this.packedLength =\r\n    1 +\r\n    positions.length * Cartesian3.packedLength +\r\n    Ellipsoid.packedLength +\r\n    VertexFormat.packedLength +\r\n    7;\r\n}\r\n\r\n/**\r\n * Stores the provided instance into the provided array.\r\n *\r\n * @param {CorridorGeometry} value The value to pack.\r\n * @param {Number[]} array The array to pack into.\r\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n *\r\n * @returns {Number[]} The array that was packed into\r\n */\r\nCorridorGeometry.pack = function (value, array, startingIndex) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"value\", value);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  const positions = value._positions;\r\n  const length = positions.length;\r\n  array[startingIndex++] = length;\r\n\r\n  for (let i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\r\n    Cartesian3.pack(positions[i], array, startingIndex);\r\n  }\r\n\r\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\r\n  startingIndex += Ellipsoid.packedLength;\r\n\r\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\r\n  startingIndex += VertexFormat.packedLength;\r\n\r\n  array[startingIndex++] = value._width;\r\n  array[startingIndex++] = value._height;\r\n  array[startingIndex++] = value._extrudedHeight;\r\n  array[startingIndex++] = value._cornerType;\r\n  array[startingIndex++] = value._granularity;\r\n  array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;\r\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\r\n\r\n  return array;\r\n};\r\n\r\nconst scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\r\nconst scratchVertexFormat = new VertexFormat();\r\nconst scratchOptions = {\r\n  positions: undefined,\r\n  ellipsoid: scratchEllipsoid,\r\n  vertexFormat: scratchVertexFormat,\r\n  width: undefined,\r\n  height: undefined,\r\n  extrudedHeight: undefined,\r\n  cornerType: undefined,\r\n  granularity: undefined,\r\n  shadowVolume: undefined,\r\n  offsetAttribute: undefined,\r\n};\r\n\r\n/**\r\n * Retrieves an instance from a packed array.\r\n *\r\n * @param {Number[]} array The packed array.\r\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n * @param {CorridorGeometry} [result] The object into which to store the result.\r\n * @returns {CorridorGeometry} The modified result parameter or a new CorridorGeometry instance if one was not provided.\r\n */\r\nCorridorGeometry.unpack = function (array, startingIndex, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  const length = array[startingIndex++];\r\n  const positions = new Array(length);\r\n\r\n  for (let i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\r\n    positions[i] = Cartesian3.unpack(array, startingIndex);\r\n  }\r\n\r\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\r\n  startingIndex += Ellipsoid.packedLength;\r\n\r\n  const vertexFormat = VertexFormat.unpack(\r\n    array,\r\n    startingIndex,\r\n    scratchVertexFormat\r\n  );\r\n  startingIndex += VertexFormat.packedLength;\r\n\r\n  const width = array[startingIndex++];\r\n  const height = array[startingIndex++];\r\n  const extrudedHeight = array[startingIndex++];\r\n  const cornerType = array[startingIndex++];\r\n  const granularity = array[startingIndex++];\r\n  const shadowVolume = array[startingIndex++] === 1.0;\r\n  const offsetAttribute = array[startingIndex];\r\n\r\n  if (!defined(result)) {\r\n    scratchOptions.positions = positions;\r\n    scratchOptions.width = width;\r\n    scratchOptions.height = height;\r\n    scratchOptions.extrudedHeight = extrudedHeight;\r\n    scratchOptions.cornerType = cornerType;\r\n    scratchOptions.granularity = granularity;\r\n    scratchOptions.shadowVolume = shadowVolume;\r\n    scratchOptions.offsetAttribute =\r\n      offsetAttribute === -1 ? undefined : offsetAttribute;\r\n\r\n    return new CorridorGeometry(scratchOptions);\r\n  }\r\n\r\n  result._positions = positions;\r\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\r\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\r\n  result._width = width;\r\n  result._height = height;\r\n  result._extrudedHeight = extrudedHeight;\r\n  result._cornerType = cornerType;\r\n  result._granularity = granularity;\r\n  result._shadowVolume = shadowVolume;\r\n  result._offsetAttribute =\r\n    offsetAttribute === -1 ? undefined : offsetAttribute;\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the bounding rectangle given the provided options\r\n *\r\n * @param {Object} options Object with the following properties:\r\n * @param {Cartesian3[]} options.positions An array of positions that define the center of the corridor.\r\n * @param {Number} options.width The distance between the edges of the corridor in meters.\r\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\r\n * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.\r\n * @param {Rectangle} [result] An object in which to store the result.\r\n *\r\n * @returns {Rectangle} The result rectangle.\r\n */\r\nCorridorGeometry.computeRectangle = function (options, result) {\r\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n  const positions = options.positions;\r\n  const width = options.width;\r\n\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"options.positions\", positions);\r\n  Check.defined(\"options.width\", width);\r\n  //>>includeEnd('debug');\r\n\r\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\r\n  const cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);\r\n\r\n  return computeRectangle(positions, ellipsoid, width, cornerType, result);\r\n};\r\n\r\n/**\r\n * Computes the geometric representation of a corridor, including its vertices, indices, and a bounding sphere.\r\n *\r\n * @param {CorridorGeometry} corridorGeometry A description of the corridor.\r\n * @returns {Geometry|undefined} The computed vertices and indices.\r\n */\r\nCorridorGeometry.createGeometry = function (corridorGeometry) {\r\n  let positions = corridorGeometry._positions;\r\n  const width = corridorGeometry._width;\r\n  const ellipsoid = corridorGeometry._ellipsoid;\r\n\r\n  positions = scaleToSurface(positions, ellipsoid);\r\n  const cleanPositions = arrayRemoveDuplicates(\r\n    positions,\r\n    Cartesian3.equalsEpsilon\r\n  );\r\n\r\n  if (cleanPositions.length < 2 || width <= 0) {\r\n    return;\r\n  }\r\n\r\n  const height = corridorGeometry._height;\r\n  const extrudedHeight = corridorGeometry._extrudedHeight;\r\n  const extrude = !CesiumMath.equalsEpsilon(\r\n    height,\r\n    extrudedHeight,\r\n    0,\r\n    CesiumMath.EPSILON2\r\n  );\r\n\r\n  const vertexFormat = corridorGeometry._vertexFormat;\r\n  const params = {\r\n    ellipsoid: ellipsoid,\r\n    positions: cleanPositions,\r\n    width: width,\r\n    cornerType: corridorGeometry._cornerType,\r\n    granularity: corridorGeometry._granularity,\r\n    saveAttributes: true,\r\n  };\r\n  let attr;\r\n  if (extrude) {\r\n    params.height = height;\r\n    params.extrudedHeight = extrudedHeight;\r\n    params.shadowVolume = corridorGeometry._shadowVolume;\r\n    params.offsetAttribute = corridorGeometry._offsetAttribute;\r\n    attr = computePositionsExtruded(params, vertexFormat);\r\n  } else {\r\n    const computedPositions = CorridorGeometryLibrary.computePositions(params);\r\n    attr = combine(computedPositions, vertexFormat, ellipsoid);\r\n    attr.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(\r\n      attr.attributes.position.values,\r\n      height,\r\n      ellipsoid\r\n    );\r\n\r\n    if (defined(corridorGeometry._offsetAttribute)) {\r\n      const applyOffsetValue =\r\n        corridorGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\r\n          ? 0\r\n          : 1;\r\n      const length = attr.attributes.position.values.length;\r\n      const applyOffset = new Uint8Array(length / 3);\r\n      arrayFill(applyOffset, applyOffsetValue);\r\n      attr.attributes.applyOffset = new GeometryAttribute({\r\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\r\n        componentsPerAttribute: 1,\r\n        values: applyOffset,\r\n      });\r\n    }\r\n  }\r\n  const attributes = attr.attributes;\r\n  const boundingSphere = BoundingSphere.fromVertices(\r\n    attributes.position.values,\r\n    undefined,\r\n    3\r\n  );\r\n  if (!vertexFormat.position) {\r\n    attr.attributes.position.values = undefined;\r\n  }\r\n\r\n  return new Geometry({\r\n    attributes: attributes,\r\n    indices: attr.indices,\r\n    primitiveType: PrimitiveType.TRIANGLES,\r\n    boundingSphere: boundingSphere,\r\n    offsetAttribute: corridorGeometry._offsetAttribute,\r\n  });\r\n};\r\n\r\n/**\r\n * @private\r\n */\r\nCorridorGeometry.createShadowVolume = function (\r\n  corridorGeometry,\r\n  minHeightFunc,\r\n  maxHeightFunc\r\n) {\r\n  const granularity = corridorGeometry._granularity;\r\n  const ellipsoid = corridorGeometry._ellipsoid;\r\n\r\n  const minHeight = minHeightFunc(granularity, ellipsoid);\r\n  const maxHeight = maxHeightFunc(granularity, ellipsoid);\r\n\r\n  return new CorridorGeometry({\r\n    positions: corridorGeometry._positions,\r\n    width: corridorGeometry._width,\r\n    cornerType: corridorGeometry._cornerType,\r\n    ellipsoid: ellipsoid,\r\n    granularity: granularity,\r\n    extrudedHeight: minHeight,\r\n    height: maxHeight,\r\n    vertexFormat: VertexFormat.POSITION_ONLY,\r\n    shadowVolume: true,\r\n  });\r\n};\r\n\r\nObject.defineProperties(CorridorGeometry.prototype, {\r\n  /**\r\n   * @private\r\n   */\r\n  rectangle: {\r\n    get: function () {\r\n      if (!defined(this._rectangle)) {\r\n        this._rectangle = computeRectangle(\r\n          this._positions,\r\n          this._ellipsoid,\r\n          this._width,\r\n          this._cornerType\r\n        );\r\n      }\r\n      return this._rectangle;\r\n    },\r\n  },\r\n  /**\r\n   * For remapping texture coordinates when rendering CorridorGeometries as GroundPrimitives.\r\n   *\r\n   * Corridors don't support stRotation,\r\n   * so just return the corners of the original system.\r\n   * @private\r\n   */\r\n  textureCoordinateRotationPoints: {\r\n    get: function () {\r\n      return [0, 0, 0, 1, 1, 0];\r\n    },\r\n  },\r\n});\r\nexport default CorridorGeometry;\r\n","import CorridorGeometry from \"../Core/CorridorGeometry.js\";\r\nimport defined from \"../Core/defined.js\";\r\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\r\n\r\nfunction createCorridorGeometry(corridorGeometry, offset) {\r\n  if (defined(offset)) {\r\n    corridorGeometry = CorridorGeometry.unpack(corridorGeometry, offset);\r\n  }\r\n  corridorGeometry._ellipsoid = Ellipsoid.clone(corridorGeometry._ellipsoid);\r\n  return CorridorGeometry.createGeometry(corridorGeometry);\r\n}\r\nexport default createCorridorGeometry;\r\n"],"names":["cartesian1","Cartesian3","cartesian2","cartesian3","cartesian4","cartesian5","cartesian6","scratch1","scratch2","scaleToSurface","positions","ellipsoid","i","length","scaleToGeodeticSurface","addNormals","attr","normal","left","front","back","vertexFormat","normals","tangents","bitangents","forward","normalize","cross","CorridorGeometryLibrary","addAttribute","tangent","bitangent","combine","computedPositions","corners","endPositions","computedLefts","lefts","computedNormals","attributes","GeometryAttributes","corner","leftCount","rightCount","indicesLength","leftSide","leftPositions","defined","rightPositions","addEndPositions","endPositionLength","size","finalPositions","Float64Array","Float32Array","undefined","UL","LL","UR","LR","rightPos","leftPos","halfLength","indices","IndexDatatype","createTypedArray","index","firstEndPositions","fromArray","rightNormal","leftNormal","posIndex","compIndex","rightEdge","leftEdge","set","geodeticSurfaceNormal","add","j","l","r","pivot","start","outsidePoint","previousPoint","nextPoint","subtract","negate","splice","lastEndPositions","position","GeometryAttribute","componentDatatype","ComponentDatatype","DOUBLE","componentsPerAttribute","values","st","rightSt","leftSt","stIndex","theta","Math","PI","a","halfEndPos","CesiumMath","PI_OVER_TWO","cos","sin","FLOAT","addWallPositions","wallPositions","x","y","z","computePositionsExtruded","params","topVertexFormat","VertexFormat","shadowVolume","computePositions","height","extrudedHeight","newPositions","extrudedPositions","PolygonPipeline","scaleToGeodeticHeight","topNormals","topBitangents","threeSize","twoSize","sixSize","topPosition","bottomPosition","previousPosition","attrIndex","attrIndexOffset","topTangents","topSt","s","t","extrudedAttributes","extrudeNormals","extrudeDirection","offsetAttribute","applyOffset","Uint8Array","GeometryOffsetAttribute","TOP","arrayFill","applyOffsetValue","NONE","UNSIGNED_BYTE","iLength","newIndices","v0","v1","v2","scratchCartesian1","scratchCartesian2","scratchCartographic","Cartographic","computeOffsetPoints","position1","position2","halfWidth","min","max","direction","offsetDirection","multiplyByScalar","minLat","latitude","minLon","longitude","maxLat","maxLon","cartesianToCartographic","lat","lon","scratchCartesianOffset","scratchCartesianEnds","scratchCartographicMin","scratchCartographicMax","computeRectangle","width","cornerType","result","cleanPositions","arrayRemoveDuplicates","equalsEpsilon","Rectangle","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","CornerType","ROUNDED","first","last","rectangle","north","south","east","west","CorridorGeometry","options","defaultValue","EMPTY_OBJECT","Check","this","_positions","_ellipsoid","Ellipsoid","clone","WGS84","_vertexFormat","DEFAULT","_width","_height","_extrudedHeight","_cornerType","_granularity","granularity","RADIANS_PER_DEGREE","_shadowVolume","_workerName","_offsetAttribute","_rectangle","packedLength","pack","value","array","startingIndex","scratchEllipsoid","UNIT_SPHERE","scratchVertexFormat","scratchOptions","unpack","Array","createGeometry","corridorGeometry","extrude","EPSILON2","saveAttributes","boundingSphere","BoundingSphere","fromVertices","Geometry","primitiveType","PrimitiveType","TRIANGLES","createShadowVolume","minHeightFunc","maxHeightFunc","minHeight","maxHeight","POSITION_ONLY","Object","defineProperties","prototype","get","textureCoordinateRotationPoints","offset"],"mappings":"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"}