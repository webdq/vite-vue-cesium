define(["./defaultValue-69ee94f4","./Matrix2-fb98ca95","./GeometryOffsetAttribute-bae60293","./Transforms-f586e93e","./RuntimeError-ac440aa5","./ComponentDatatype-7ed489c0","./GeometryAttribute-c6fd2455","./GeometryAttributes-1b4134a9","./GeometryInstance-8059c913","./GeometryPipeline-0177166e","./IndexDatatype-b58b63e4","./PolygonPipeline-1b3c3695","./RectangleGeometryLibrary-97f11c89","./VertexFormat-c648f71f","./_commonjsHelpers-3aae1032-15991586","./combine-0259f56f","./WebGLConstants-f63312fc","./AttributeCompression-142fe884","./EncodedCartesian3-928e138a","./IntersectionTests-2d241d2b","./Plane-a09326f5","./EllipsoidRhumbLine-99a9f0c8"],(function(t,e,n,a,o,r,i,s,l,u,c,m,p,g,d,y,f,h,b,_,A,w){"use strict";const x=new e.Cartesian3,C=new e.Cartesian3,v=new e.Cartesian3,R=new e.Cartesian3,E=new e.Rectangle,F=new e.Cartesian2,G=new a.BoundingSphere,P=new a.BoundingSphere;function V(t,e){const n=new i.Geometry({attributes:new s.GeometryAttributes,primitiveType:i.PrimitiveType.TRIANGLES});return n.attributes.position=new i.GeometryAttribute({componentDatatype:r.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:e.positions}),t.normal&&(n.attributes.normal=new i.GeometryAttribute({componentDatatype:r.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:e.normals})),t.tangent&&(n.attributes.tangent=new i.GeometryAttribute({componentDatatype:r.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:e.tangents})),t.bitangent&&(n.attributes.bitangent=new i.GeometryAttribute({componentDatatype:r.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:e.bitangents})),n}const D=new e.Cartesian3,L=new e.Cartesian3;function M(t,n){const a=t._vertexFormat,o=t._ellipsoid,s=n.height,l=n.width,u=n.northCap,m=n.southCap;let g=0,d=s,y=s,f=0;u&&(g=1,y-=1,f+=1),m&&(d-=1,y-=1,f+=1),f+=l*y;const h=a.position?new Float64Array(3*f):void 0,b=a.st?new Float32Array(2*f):void 0;let _=0,A=0;const w=x,E=F;let G=Number.MAX_VALUE,P=Number.MAX_VALUE,D=-Number.MAX_VALUE,L=-Number.MAX_VALUE;for(let t=g;t<d;++t)for(let e=0;e<l;++e)p.RectangleGeometryLibrary.computePosition(n,o,a.st,t,e,w,E),h[_++]=w.x,h[_++]=w.y,h[_++]=w.z,a.st&&(b[A++]=E.x,b[A++]=E.y,G=Math.min(G,E.x),P=Math.min(P,E.y),D=Math.max(D,E.x),L=Math.max(L,E.y));if(u&&(p.RectangleGeometryLibrary.computePosition(n,o,a.st,0,0,w,E),h[_++]=w.x,h[_++]=w.y,h[_++]=w.z,a.st&&(b[A++]=E.x,b[A++]=E.y,G=E.x,P=E.y,D=E.x,L=E.y)),m&&(p.RectangleGeometryLibrary.computePosition(n,o,a.st,s-1,0,w,E),h[_++]=w.x,h[_++]=w.y,h[_]=w.z,a.st&&(b[A++]=E.x,b[A]=E.y,G=Math.min(G,E.x),P=Math.min(P,E.y),D=Math.max(D,E.x),L=Math.max(L,E.y))),a.st&&(G<0||P<0||D>1||L>1))for(let t=0;t<b.length;t+=2)b[t]=(b[t]-G)/(D-G),b[t+1]=(b[t+1]-P)/(L-P);const M=function(t,n,a,o){const r=t.length,i=n.normal?new Float32Array(r):void 0,s=n.tangent?new Float32Array(r):void 0,l=n.bitangent?new Float32Array(r):void 0;let u=0;const c=R,m=v;let p=C;if(n.normal||n.tangent||n.bitangent)for(let g=0;g<r;g+=3){const r=e.Cartesian3.fromArray(t,g,x),d=u+1,y=u+2;p=a.geodeticSurfaceNormal(r,p),(n.tangent||n.bitangent)&&(e.Cartesian3.cross(e.Cartesian3.UNIT_Z,p,m),e.Matrix3.multiplyByVector(o,m,m),e.Cartesian3.normalize(m,m),n.bitangent&&e.Cartesian3.normalize(e.Cartesian3.cross(p,m,c),c)),n.normal&&(i[u]=p.x,i[d]=p.y,i[y]=p.z),n.tangent&&(s[u]=m.x,s[d]=m.y,s[y]=m.z),n.bitangent&&(l[u]=c.x,l[d]=c.y,l[y]=c.z),u+=3}return V(n,{positions:t,normals:i,tangents:s,bitangents:l})}(h,a,o,n.tangentRotationMatrix);let O=6*(l-1)*(y-1);u&&(O+=3*(l-1)),m&&(O+=3*(l-1));const T=c.IndexDatatype.createTypedArray(f,O);let N,k=0,S=0;for(N=0;N<y-1;++N){for(let t=0;t<l-1;++t){const t=k,e=t+l,n=e+1,a=t+1;T[S++]=t,T[S++]=e,T[S++]=a,T[S++]=a,T[S++]=e,T[S++]=n,++k}++k}if(u||m){let t=f-1;const e=f-1;let n,a;if(u&&m&&(t=f-2),k=0,u)for(N=0;N<l-1;N++)n=k,a=n+1,T[S++]=t,T[S++]=n,T[S++]=a,++k;if(m)for(k=(y-1)*l,N=0;N<l-1;N++)n=k,a=n+1,T[S++]=n,T[S++]=e,T[S++]=a,++k}return M.indices=T,a.st&&(M.attributes.st=new i.GeometryAttribute({componentDatatype:r.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:b})),M}function O(t,e,n,a,o){return t[e++]=a[n],t[e++]=a[n+1],t[e++]=a[n+2],t[e++]=o[n],t[e++]=o[n+1],t[e]=o[n+2],t}function T(t,e,n,a){return t[e++]=a[n],t[e++]=a[n+1],t[e++]=a[n],t[e]=a[n+1],t}const N=new g.VertexFormat;function k(a,o){const s=a._shadowVolume,p=a._offsetAttribute,d=a._vertexFormat,y=a._extrudedHeight,f=a._surfaceHeight,h=a._ellipsoid,b=o.height,_=o.width;let A;if(s){const t=g.VertexFormat.clone(d,N);t.normal=!0,a._vertexFormat=t}const w=M(a,o);s&&(a._vertexFormat=d);let E=m.PolygonPipeline.scaleToGeodeticHeight(w.attributes.position.values,f,h,!1);E=new Float64Array(E);let F=E.length;const G=2*F,P=new Float64Array(G);P.set(E);const k=m.PolygonPipeline.scaleToGeodeticHeight(w.attributes.position.values,y,h);P.set(k,F),w.attributes.position.values=P;const S=d.normal?new Float32Array(G):void 0,I=d.tangent?new Float32Array(G):void 0,H=d.bitangent?new Float32Array(G):void 0,z=d.st?new Float32Array(G/3*2):void 0;let B,U,q;if(d.normal){for(U=w.attributes.normal.values,S.set(U),A=0;A<F;A++)U[A]=-U[A];S.set(U,F),w.attributes.normal.values=S}if(s){U=w.attributes.normal.values,d.normal||(w.attributes.normal=void 0);const t=new Float32Array(G);for(A=0;A<F;A++)U[A]=-U[A];t.set(U,F),w.attributes.extrudeDirection=new i.GeometryAttribute({componentDatatype:r.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:t})}const Y=t.defined(p);if(Y){const t=F/3*2;let e=new Uint8Array(t);p===n.GeometryOffsetAttribute.TOP?e=n.arrayFill(e,1,0,t/2):(q=p===n.GeometryOffsetAttribute.NONE?0:1,e=n.arrayFill(e,q)),w.attributes.applyOffset=new i.GeometryAttribute({componentDatatype:r.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:e})}if(d.tangent){const t=w.attributes.tangent.values;for(I.set(t),A=0;A<F;A++)t[A]=-t[A];I.set(t,F),w.attributes.tangent.values=I}if(d.bitangent){const t=w.attributes.bitangent.values;H.set(t),H.set(t,F),w.attributes.bitangent.values=H}d.st&&(B=w.attributes.st.values,z.set(B),z.set(B,F/3*2),w.attributes.st.values=z);const j=w.indices,X=j.length,Q=F/3,W=c.IndexDatatype.createTypedArray(G/3,2*X);for(W.set(j),A=0;A<X;A+=3)W[A+X]=j[A+2]+Q,W[A+1+X]=j[A+1]+Q,W[A+2+X]=j[A]+Q;w.indices=W;const J=o.northCap,Z=o.southCap;let K=b,$=2,tt=0,et=4,nt=4;J&&($-=1,K-=1,tt+=1,et-=2,nt-=1),Z&&($-=1,K-=1,tt+=1,et-=2,nt-=1),tt+=$*_+2*K-et;const at=2*(tt+nt);let ot=new Float64Array(3*at);const rt=s?new Float32Array(3*at):void 0;let it=Y?new Uint8Array(at):void 0,st=d.st?new Float32Array(2*at):void 0;const lt=p===n.GeometryOffsetAttribute.TOP;Y&&!lt&&(q=p===n.GeometryOffsetAttribute.ALL?1:0,it=n.arrayFill(it,q));let ut=0,ct=0,mt=0,pt=0;const gt=_*K;let dt;for(A=0;A<gt;A+=_)dt=3*A,ot=O(ot,ut,dt,E,k),ut+=6,d.st&&(st=T(st,ct,2*A,B),ct+=4),s&&(mt+=3,rt[mt++]=U[dt],rt[mt++]=U[dt+1],rt[mt++]=U[dt+2]),lt&&(it[pt++]=1,pt+=1);if(Z){const t=J?gt+1:gt;for(dt=3*t,A=0;A<2;A++)ot=O(ot,ut,dt,E,k),ut+=6,d.st&&(st=T(st,ct,2*t,B),ct+=4),s&&(mt+=3,rt[mt++]=U[dt],rt[mt++]=U[dt+1],rt[mt++]=U[dt+2]),lt&&(it[pt++]=1,pt+=1)}else for(A=gt-_;A<gt;A++)dt=3*A,ot=O(ot,ut,dt,E,k),ut+=6,d.st&&(st=T(st,ct,2*A,B),ct+=4),s&&(mt+=3,rt[mt++]=U[dt],rt[mt++]=U[dt+1],rt[mt++]=U[dt+2]),lt&&(it[pt++]=1,pt+=1);for(A=gt-1;A>0;A-=_)dt=3*A,ot=O(ot,ut,dt,E,k),ut+=6,d.st&&(st=T(st,ct,2*A,B),ct+=4),s&&(mt+=3,rt[mt++]=U[dt],rt[mt++]=U[dt+1],rt[mt++]=U[dt+2]),lt&&(it[pt++]=1,pt+=1);if(J){const t=gt;for(dt=3*t,A=0;A<2;A++)ot=O(ot,ut,dt,E,k),ut+=6,d.st&&(st=T(st,ct,2*t,B),ct+=4),s&&(mt+=3,rt[mt++]=U[dt],rt[mt++]=U[dt+1],rt[mt++]=U[dt+2]),lt&&(it[pt++]=1,pt+=1)}else for(A=_-1;A>=0;A--)dt=3*A,ot=O(ot,ut,dt,E,k),ut+=6,d.st&&(st=T(st,ct,2*A,B),ct+=4),s&&(mt+=3,rt[mt++]=U[dt],rt[mt++]=U[dt+1],rt[mt++]=U[dt+2]),lt&&(it[pt++]=1,pt+=1);let yt=function(t,n,a){const o=t.length,i=n.normal?new Float32Array(o):void 0,s=n.tangent?new Float32Array(o):void 0,l=n.bitangent?new Float32Array(o):void 0;let u=0,c=0,m=0,p=!0,g=R,d=v,y=C;if(n.normal||n.tangent||n.bitangent)for(let f=0;f<o;f+=6){const h=e.Cartesian3.fromArray(t,f,x),b=e.Cartesian3.fromArray(t,(f+6)%o,D);if(p){const n=e.Cartesian3.fromArray(t,(f+3)%o,L);e.Cartesian3.subtract(b,h,b),e.Cartesian3.subtract(n,h,n),y=e.Cartesian3.normalize(e.Cartesian3.cross(n,b,y),y),p=!1}e.Cartesian3.equalsEpsilon(b,h,r.CesiumMath.EPSILON10)&&(p=!0),(n.tangent||n.bitangent)&&(g=a.geodeticSurfaceNormal(h,g),n.tangent&&(d=e.Cartesian3.normalize(e.Cartesian3.cross(g,y,d),d))),n.normal&&(i[u++]=y.x,i[u++]=y.y,i[u++]=y.z,i[u++]=y.x,i[u++]=y.y,i[u++]=y.z),n.tangent&&(s[c++]=d.x,s[c++]=d.y,s[c++]=d.z,s[c++]=d.x,s[c++]=d.y,s[c++]=d.z),n.bitangent&&(l[m++]=g.x,l[m++]=g.y,l[m++]=g.z,l[m++]=g.x,l[m++]=g.y,l[m++]=g.z)}return V(n,{positions:t,normals:i,tangents:s,bitangents:l})}(ot,d,h);d.st&&(yt.attributes.st=new i.GeometryAttribute({componentDatatype:r.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:st})),s&&(yt.attributes.extrudeDirection=new i.GeometryAttribute({componentDatatype:r.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:rt})),Y&&(yt.attributes.applyOffset=new i.GeometryAttribute({componentDatatype:r.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:it}));const ft=c.IndexDatatype.createTypedArray(at,6*tt);let ht,bt,_t,At;F=ot.length/3;let wt=0;for(A=0;A<F-1;A+=2){ht=A,At=(ht+2)%F;const t=e.Cartesian3.fromArray(ot,3*ht,D),n=e.Cartesian3.fromArray(ot,3*At,L);e.Cartesian3.equalsEpsilon(t,n,r.CesiumMath.EPSILON10)||(bt=(ht+1)%F,_t=(bt+2)%F,ft[wt++]=ht,ft[wt++]=bt,ft[wt++]=At,ft[wt++]=At,ft[wt++]=bt,ft[wt++]=_t)}return yt.indices=ft,yt=u.GeometryPipeline.combineInstances([new l.GeometryInstance({geometry:w}),new l.GeometryInstance({geometry:yt})]),yt[0]}const S=[new e.Cartesian3,new e.Cartesian3,new e.Cartesian3,new e.Cartesian3],I=new e.Cartographic,H=new e.Cartographic;function z(t,n,a,o,r){if(0===a)return e.Rectangle.clone(t,r);const i=p.RectangleGeometryLibrary.computeOptions(t,n,a,0,E,I),s=i.height,l=i.width,u=S;return p.RectangleGeometryLibrary.computePosition(i,o,!1,0,0,u[0]),p.RectangleGeometryLibrary.computePosition(i,o,!1,0,l-1,u[1]),p.RectangleGeometryLibrary.computePosition(i,o,!1,s-1,0,u[2]),p.RectangleGeometryLibrary.computePosition(i,o,!1,s-1,l-1,u[3]),e.Rectangle.fromCartesianArray(u,o,r)}function B(n){const a=(n=t.defaultValue(n,t.defaultValue.EMPTY_OBJECT)).rectangle;if(o.Check.typeOf.object("rectangle",a),e.Rectangle.validate(a),a.north<a.south)throw new o.DeveloperError("options.rectangle.north must be greater than or equal to options.rectangle.south");const i=t.defaultValue(n.height,0),s=t.defaultValue(n.extrudedHeight,i);this._rectangle=e.Rectangle.clone(a),this._granularity=t.defaultValue(n.granularity,r.CesiumMath.RADIANS_PER_DEGREE),this._ellipsoid=e.Ellipsoid.clone(t.defaultValue(n.ellipsoid,e.Ellipsoid.WGS84)),this._surfaceHeight=Math.max(i,s),this._rotation=t.defaultValue(n.rotation,0),this._stRotation=t.defaultValue(n.stRotation,0),this._vertexFormat=g.VertexFormat.clone(t.defaultValue(n.vertexFormat,g.VertexFormat.DEFAULT)),this._extrudedHeight=Math.min(i,s),this._shadowVolume=t.defaultValue(n.shadowVolume,!1),this._workerName="createRectangleGeometry",this._offsetAttribute=n.offsetAttribute,this._rotatedRectangle=void 0,this._textureCoordinateRotationPoints=void 0}B.packedLength=e.Rectangle.packedLength+e.Ellipsoid.packedLength+g.VertexFormat.packedLength+7,B.pack=function(n,a,r){return o.Check.typeOf.object("value",n),o.Check.defined("array",a),r=t.defaultValue(r,0),e.Rectangle.pack(n._rectangle,a,r),r+=e.Rectangle.packedLength,e.Ellipsoid.pack(n._ellipsoid,a,r),r+=e.Ellipsoid.packedLength,g.VertexFormat.pack(n._vertexFormat,a,r),r+=g.VertexFormat.packedLength,a[r++]=n._granularity,a[r++]=n._surfaceHeight,a[r++]=n._rotation,a[r++]=n._stRotation,a[r++]=n._extrudedHeight,a[r++]=n._shadowVolume?1:0,a[r]=t.defaultValue(n._offsetAttribute,-1),a};const U=new e.Rectangle,q=e.Ellipsoid.clone(e.Ellipsoid.UNIT_SPHERE),Y={rectangle:U,ellipsoid:q,vertexFormat:N,granularity:void 0,height:void 0,rotation:void 0,stRotation:void 0,extrudedHeight:void 0,shadowVolume:void 0,offsetAttribute:void 0};B.unpack=function(n,a,r){o.Check.defined("array",n),a=t.defaultValue(a,0);const i=e.Rectangle.unpack(n,a,U);a+=e.Rectangle.packedLength;const s=e.Ellipsoid.unpack(n,a,q);a+=e.Ellipsoid.packedLength;const l=g.VertexFormat.unpack(n,a,N);a+=g.VertexFormat.packedLength;const u=n[a++],c=n[a++],m=n[a++],p=n[a++],d=n[a++],y=1===n[a++],f=n[a];return t.defined(r)?(r._rectangle=e.Rectangle.clone(i,r._rectangle),r._ellipsoid=e.Ellipsoid.clone(s,r._ellipsoid),r._vertexFormat=g.VertexFormat.clone(l,r._vertexFormat),r._granularity=u,r._surfaceHeight=c,r._rotation=m,r._stRotation=p,r._extrudedHeight=d,r._shadowVolume=y,r._offsetAttribute=-1===f?void 0:f,r):(Y.granularity=u,Y.height=c,Y.rotation=m,Y.stRotation=p,Y.extrudedHeight=d,Y.shadowVolume=y,Y.offsetAttribute=-1===f?void 0:f,new B(Y))},B.computeRectangle=function(n,a){const i=(n=t.defaultValue(n,t.defaultValue.EMPTY_OBJECT)).rectangle;if(o.Check.typeOf.object("rectangle",i),e.Rectangle.validate(i),i.north<i.south)throw new o.DeveloperError("options.rectangle.north must be greater than or equal to options.rectangle.south");const s=t.defaultValue(n.granularity,r.CesiumMath.RADIANS_PER_DEGREE),l=t.defaultValue(n.ellipsoid,e.Ellipsoid.WGS84);return z(i,s,t.defaultValue(n.rotation,0),l,a)};const j=new e.Matrix3,X=new a.Quaternion,Q=new e.Cartographic;B.createGeometry=function(o){if(r.CesiumMath.equalsEpsilon(o._rectangle.north,o._rectangle.south,r.CesiumMath.EPSILON10)||r.CesiumMath.equalsEpsilon(o._rectangle.east,o._rectangle.west,r.CesiumMath.EPSILON10))return;let s=o._rectangle;const l=o._ellipsoid,u=o._rotation,c=o._stRotation,g=o._vertexFormat,d=p.RectangleGeometryLibrary.computeOptions(s,o._granularity,u,c,E,I,H),y=j;if(0!==c||0!==u){const t=e.Rectangle.center(s,Q),n=l.geodeticSurfaceNormalCartographic(t,D);a.Quaternion.fromAxisAngle(n,-c,X),e.Matrix3.fromQuaternion(X,y)}else e.Matrix3.clone(e.Matrix3.IDENTITY,y);const f=o._surfaceHeight,h=o._extrudedHeight,b=!r.CesiumMath.equalsEpsilon(f,h,0,r.CesiumMath.EPSILON2);let _,A;if(d.lonScalar=1/o._rectangle.width,d.latScalar=1/o._rectangle.height,d.tangentRotationMatrix=y,s=o._rectangle,b){_=k(o,d);const t=a.BoundingSphere.fromRectangle3D(s,l,f,P),e=a.BoundingSphere.fromRectangle3D(s,l,h,G);A=a.BoundingSphere.union(t,e)}else{if(_=M(o,d),_.attributes.position.values=m.PolygonPipeline.scaleToGeodeticHeight(_.attributes.position.values,f,l,!1),t.defined(o._offsetAttribute)){const t=_.attributes.position.values.length,e=new Uint8Array(t/3),a=o._offsetAttribute===n.GeometryOffsetAttribute.NONE?0:1;n.arrayFill(e,a),_.attributes.applyOffset=new i.GeometryAttribute({componentDatatype:r.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:e})}A=a.BoundingSphere.fromRectangle3D(s,l,f)}return g.position||delete _.attributes.position,new i.Geometry({attributes:_.attributes,indices:_.indices,primitiveType:_.primitiveType,boundingSphere:A,offsetAttribute:o._offsetAttribute})},B.createShadowVolume=function(t,e,n){const a=t._granularity,o=t._ellipsoid,r=e(a,o),i=n(a,o);return new B({rectangle:t._rectangle,rotation:t._rotation,ellipsoid:o,stRotation:t._stRotation,granularity:a,extrudedHeight:i,height:r,vertexFormat:g.VertexFormat.POSITION_ONLY,shadowVolume:!0})};const W=new e.Rectangle,J=[new e.Cartesian2,new e.Cartesian2,new e.Cartesian2],Z=new e.Matrix2,K=new e.Cartographic;return Object.defineProperties(B.prototype,{rectangle:{get:function(){return t.defined(this._rotatedRectangle)||(this._rotatedRectangle=z(this._rectangle,this._granularity,this._rotation,this._ellipsoid)),this._rotatedRectangle}},textureCoordinateRotationPoints:{get:function(){return t.defined(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=function(t){if(0===t._stRotation)return[0,0,0,1,1,0];const n=e.Rectangle.clone(t._rectangle,W),a=t._granularity,o=t._ellipsoid,r=z(n,a,t._rotation-t._stRotation,o,W),i=J;i[0].x=r.west,i[0].y=r.south,i[1].x=r.west,i[1].y=r.north,i[2].x=r.east,i[2].y=r.south;const s=t.rectangle,l=e.Matrix2.fromRotation(t._stRotation,Z),u=e.Rectangle.center(s,K);for(let t=0;t<3;++t){const n=i[t];n.x-=u.longitude,n.y-=u.latitude,e.Matrix2.multiplyByVector(l,n,n),n.x+=u.longitude,n.y+=u.latitude,n.x=(n.x-s.west)/s.width,n.y=(n.y-s.south)/s.height}const c=i[0],m=i[1],p=i[2],g=new Array(6);return e.Cartesian2.pack(c,g),e.Cartesian2.pack(m,g,2),e.Cartesian2.pack(p,g,4),g}(this)),this._textureCoordinateRotationPoints}}}),function(n,a){return t.defined(a)&&(n=B.unpack(n,a)),n._ellipsoid=e.Ellipsoid.clone(n._ellipsoid),n._rectangle=e.Rectangle.clone(n._rectangle),B.createGeometry(n)}}));
//# sourceMappingURL=createRectangleGeometry.js.map
