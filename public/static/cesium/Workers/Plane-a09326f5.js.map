{"version":3,"file":"Plane-a09326f5.js","sources":["../../../../Source/Core/Plane.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\r\nimport Cartesian4 from \"./Cartesian4.js\";\r\nimport Check from \"./Check.js\";\r\nimport defined from \"./defined.js\";\r\nimport DeveloperError from \"./DeveloperError.js\";\r\nimport CesiumMath from \"./Math.js\";\r\nimport Matrix4 from \"./Matrix4.js\";\r\n\r\n/**\r\n * A plane in Hessian Normal Form defined by\r\n * <pre>\r\n * ax + by + cz + d = 0\r\n * </pre>\r\n * where (a, b, c) is the plane's <code>normal</code>, d is the signed\r\n * <code>distance</code> to the plane, and (x, y, z) is any point on\r\n * the plane.\r\n *\r\n * @alias Plane\r\n * @constructor\r\n *\r\n * @param {Cartesian3} normal The plane's normal (normalized).\r\n * @param {Number} distance The shortest distance from the origin to the plane.  The sign of\r\n * <code>distance</code> determines which side of the plane the origin\r\n * is on.  If <code>distance</code> is positive, the origin is in the half-space\r\n * in the direction of the normal; if negative, the origin is in the half-space\r\n * opposite to the normal; if zero, the plane passes through the origin.\r\n *\r\n * @example\r\n * // The plane x=0\r\n * const plane = new Cesium.Plane(Cesium.Cartesian3.UNIT_X, 0.0);\r\n *\r\n * @exception {DeveloperError} Normal must be normalized\r\n */\r\nfunction Plane(normal, distance) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"normal\", normal);\r\n  if (\r\n    !CesiumMath.equalsEpsilon(\r\n      Cartesian3.magnitude(normal),\r\n      1.0,\r\n      CesiumMath.EPSILON6\r\n    )\r\n  ) {\r\n    throw new DeveloperError(\"normal must be normalized.\");\r\n  }\r\n  Check.typeOf.number(\"distance\", distance);\r\n  //>>includeEnd('debug');\r\n\r\n  /**\r\n   * The plane's normal.\r\n   *\r\n   * @type {Cartesian3}\r\n   */\r\n  this.normal = Cartesian3.clone(normal);\r\n\r\n  /**\r\n   * The shortest distance from the origin to the plane.  The sign of\r\n   * <code>distance</code> determines which side of the plane the origin\r\n   * is on.  If <code>distance</code> is positive, the origin is in the half-space\r\n   * in the direction of the normal; if negative, the origin is in the half-space\r\n   * opposite to the normal; if zero, the plane passes through the origin.\r\n   *\r\n   * @type {Number}\r\n   */\r\n  this.distance = distance;\r\n}\r\n\r\n/**\r\n * Creates a plane from a normal and a point on the plane.\r\n *\r\n * @param {Cartesian3} point The point on the plane.\r\n * @param {Cartesian3} normal The plane's normal (normalized).\r\n * @param {Plane} [result] The object onto which to store the result.\r\n * @returns {Plane} A new plane instance or the modified result parameter.\r\n *\r\n * @example\r\n * const point = Cesium.Cartesian3.fromDegrees(-72.0, 40.0);\r\n * const normal = ellipsoid.geodeticSurfaceNormal(point);\r\n * const tangentPlane = Cesium.Plane.fromPointNormal(point, normal);\r\n *\r\n * @exception {DeveloperError} Normal must be normalized\r\n */\r\nPlane.fromPointNormal = function (point, normal, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"point\", point);\r\n  Check.typeOf.object(\"normal\", normal);\r\n  if (\r\n    !CesiumMath.equalsEpsilon(\r\n      Cartesian3.magnitude(normal),\r\n      1.0,\r\n      CesiumMath.EPSILON6\r\n    )\r\n  ) {\r\n    throw new DeveloperError(\"normal must be normalized.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const distance = -Cartesian3.dot(normal, point);\r\n\r\n  if (!defined(result)) {\r\n    return new Plane(normal, distance);\r\n  }\r\n\r\n  Cartesian3.clone(normal, result.normal);\r\n  result.distance = distance;\r\n  return result;\r\n};\r\n\r\nconst scratchNormal = new Cartesian3();\r\n/**\r\n * Creates a plane from the general equation\r\n *\r\n * @param {Cartesian4} coefficients The plane's normal (normalized).\r\n * @param {Plane} [result] The object onto which to store the result.\r\n * @returns {Plane} A new plane instance or the modified result parameter.\r\n *\r\n * @exception {DeveloperError} Normal must be normalized\r\n */\r\nPlane.fromCartesian4 = function (coefficients, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"coefficients\", coefficients);\r\n  //>>includeEnd('debug');\r\n\r\n  const normal = Cartesian3.fromCartesian4(coefficients, scratchNormal);\r\n  const distance = coefficients.w;\r\n\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (\r\n    !CesiumMath.equalsEpsilon(\r\n      Cartesian3.magnitude(normal),\r\n      1.0,\r\n      CesiumMath.EPSILON6\r\n    )\r\n  ) {\r\n    throw new DeveloperError(\"normal must be normalized.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    return new Plane(normal, distance);\r\n  }\r\n  Cartesian3.clone(normal, result.normal);\r\n  result.distance = distance;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the signed shortest distance of a point to a plane.\r\n * The sign of the distance determines which side of the plane the point\r\n * is on.  If the distance is positive, the point is in the half-space\r\n * in the direction of the normal; if negative, the point is in the half-space\r\n * opposite to the normal; if zero, the plane passes through the point.\r\n *\r\n * @param {Plane} plane The plane.\r\n * @param {Cartesian3} point The point.\r\n * @returns {Number} The signed shortest distance of the point to the plane.\r\n */\r\nPlane.getPointDistance = function (plane, point) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"plane\", plane);\r\n  Check.typeOf.object(\"point\", point);\r\n  //>>includeEnd('debug');\r\n\r\n  return Cartesian3.dot(plane.normal, point) + plane.distance;\r\n};\r\n\r\nconst scratchCartesian = new Cartesian3();\r\n/**\r\n * Projects a point onto the plane.\r\n * @param {Plane} plane The plane to project the point onto\r\n * @param {Cartesian3} point The point to project onto the plane\r\n * @param {Cartesian3} [result] The result point.  If undefined, a new Cartesian3 will be created.\r\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\r\n */\r\nPlane.projectPointOntoPlane = function (plane, point, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"plane\", plane);\r\n  Check.typeOf.object(\"point\", point);\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    result = new Cartesian3();\r\n  }\r\n\r\n  // projectedPoint = point - (normal.point + scale) * normal\r\n  const pointDistance = Plane.getPointDistance(plane, point);\r\n  const scaledNormal = Cartesian3.multiplyByScalar(\r\n    plane.normal,\r\n    pointDistance,\r\n    scratchCartesian\r\n  );\r\n\r\n  return Cartesian3.subtract(point, scaledNormal, result);\r\n};\r\n\r\nconst scratchInverseTranspose = new Matrix4();\r\nconst scratchPlaneCartesian4 = new Cartesian4();\r\nconst scratchTransformNormal = new Cartesian3();\r\n/**\r\n * Transforms the plane by the given transformation matrix.\r\n *\r\n * @param {Plane} plane The plane.\r\n * @param {Matrix4} transform The transformation matrix.\r\n * @param {Plane} [result] The object into which to store the result.\r\n * @returns {Plane} The plane transformed by the given transformation matrix.\r\n */\r\nPlane.transform = function (plane, transform, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"plane\", plane);\r\n  Check.typeOf.object(\"transform\", transform);\r\n  //>>includeEnd('debug');\r\n\r\n  const normal = plane.normal;\r\n  const distance = plane.distance;\r\n  const inverseTranspose = Matrix4.inverseTranspose(\r\n    transform,\r\n    scratchInverseTranspose\r\n  );\r\n  let planeAsCartesian4 = Cartesian4.fromElements(\r\n    normal.x,\r\n    normal.y,\r\n    normal.z,\r\n    distance,\r\n    scratchPlaneCartesian4\r\n  );\r\n  planeAsCartesian4 = Matrix4.multiplyByVector(\r\n    inverseTranspose,\r\n    planeAsCartesian4,\r\n    planeAsCartesian4\r\n  );\r\n\r\n  // Convert the transformed plane to Hessian Normal Form\r\n  const transformedNormal = Cartesian3.fromCartesian4(\r\n    planeAsCartesian4,\r\n    scratchTransformNormal\r\n  );\r\n\r\n  planeAsCartesian4 = Cartesian4.divideByScalar(\r\n    planeAsCartesian4,\r\n    Cartesian3.magnitude(transformedNormal),\r\n    planeAsCartesian4\r\n  );\r\n\r\n  return Plane.fromCartesian4(planeAsCartesian4, result);\r\n};\r\n\r\n/**\r\n * Duplicates a Plane instance.\r\n *\r\n * @param {Plane} plane The plane to duplicate.\r\n * @param {Plane} [result] The object onto which to store the result.\r\n * @returns {Plane} The modified result parameter or a new Plane instance if one was not provided.\r\n */\r\nPlane.clone = function (plane, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"plane\", plane);\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    return new Plane(plane.normal, plane.distance);\r\n  }\r\n\r\n  Cartesian3.clone(plane.normal, result.normal);\r\n  result.distance = plane.distance;\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Compares the provided Planes by normal and distance and returns\r\n * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n *\r\n * @param {Plane} left The first plane.\r\n * @param {Plane} right The second plane.\r\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\r\n */\r\nPlane.equals = function (left, right) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"left\", left);\r\n  Check.typeOf.object(\"right\", right);\r\n  //>>includeEnd('debug');\r\n\r\n  return (\r\n    left.distance === right.distance &&\r\n    Cartesian3.equals(left.normal, right.normal)\r\n  );\r\n};\r\n\r\n/**\r\n * A constant initialized to the XY plane passing through the origin, with normal in positive Z.\r\n *\r\n * @type {Plane}\r\n * @constant\r\n */\r\nPlane.ORIGIN_XY_PLANE = Object.freeze(new Plane(Cartesian3.UNIT_Z, 0.0));\r\n\r\n/**\r\n * A constant initialized to the YZ plane passing through the origin, with normal in positive X.\r\n *\r\n * @type {Plane}\r\n * @constant\r\n */\r\nPlane.ORIGIN_YZ_PLANE = Object.freeze(new Plane(Cartesian3.UNIT_X, 0.0));\r\n\r\n/**\r\n * A constant initialized to the ZX plane passing through the origin, with normal in positive Y.\r\n *\r\n * @type {Plane}\r\n * @constant\r\n */\r\nPlane.ORIGIN_ZX_PLANE = Object.freeze(new Plane(Cartesian3.UNIT_Y, 0.0));\r\nexport default Plane;\r\n"],"names":["Plane","normal","distance","Check","typeOf","object","CesiumMath","equalsEpsilon","Cartesian3","magnitude","EPSILON6","DeveloperError","number","this","clone","fromPointNormal","point","result","dot","defined","scratchNormal","fromCartesian4","coefficients","w","getPointDistance","plane","scratchCartesian","projectPointOntoPlane","pointDistance","scaledNormal","multiplyByScalar","subtract","scratchInverseTranspose","Matrix4","scratchPlaneCartesian4","Cartesian4","scratchTransformNormal","transform","inverseTranspose","planeAsCartesian4","fromElements","x","y","z","multiplyByVector","transformedNormal","divideByScalar","equals","left","right","ORIGIN_XY_PLANE","Object","freeze","UNIT_Z","ORIGIN_YZ_PLANE","UNIT_X","ORIGIN_ZX_PLANE","UNIT_Y"],"mappings":"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"}